import { createRequire as ny } from "node:module";
var uy = Object.create;
var {
  getPrototypeOf: ly,
  defineProperty: Qw,
  getOwnPropertyNames: py,
} = Object;
var iy = Object.prototype.hasOwnProperty;
var xE = (A, Q, B) => {
  B = A != null ? uy(ly(A)) : {};
  let I =
    Q || !A || !A.__esModule
      ? Qw(B, "default", { value: A, enumerable: !0 })
      : B;
  for (let E of py(A))
    if (!iy.call(I, E)) Qw(I, E, { get: () => A[E], enumerable: !0 });
  return I;
};
var Z = (A, Q) => () => (Q || A((Q = { exports: {} }).exports, Q), Q.exports);
var $ = ny(import.meta.url);
var qD = Z((Bw) => {
  Object.defineProperty(Bw, "__esModule", { value: !0 });
  Bw.toCommandProperties = Bw.toCommandValue = void 0;
  function ay(A) {
    if (A === null || A === void 0) return "";
    else if (typeof A === "string" || A instanceof String) return A;
    return JSON.stringify(A);
  }
  Bw.toCommandValue = ay;
  function oy(A) {
    if (!Object.keys(A).length) return {};
    return {
      title: A.title,
      file: A.file,
      line: A.startLine,
      endLine: A.endLine,
      col: A.startColumn,
      endColumn: A.endColumn,
    };
  }
  Bw.toCommandProperties = oy;
});
var Dw = Z((tB) => {
  var ry =
      (tB && tB.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            var E = Object.getOwnPropertyDescriptor(Q, B);
            if (
              !E ||
              ("get" in E ? !Q.__esModule : E.writable || E.configurable)
            )
              E = {
                enumerable: !0,
                get: function () {
                  return Q[B];
                },
              };
            Object.defineProperty(A, I, E);
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    ty =
      (tB && tB.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    ey =
      (tB && tB.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.prototype.hasOwnProperty.call(A, B))
              ry(Q, A, B);
        }
        return ty(Q, A), Q;
      };
  Object.defineProperty(tB, "__esModule", { value: !0 });
  tB.issue = tB.issueCommand = void 0;
  var AS = ey($("os")),
    Cw = qD();
  function gw(A, Q, B) {
    let I = new Fw(A, Q, B);
    process.stdout.write(I.toString() + AS.EOL);
  }
  tB.issueCommand = gw;
  function QS(A, Q = "") {
    gw(A, {}, Q);
  }
  tB.issue = QS;
  var Ew = "::";
  class Fw {
    constructor(A, Q, B) {
      if (!A) A = "missing.command";
      (this.command = A), (this.properties = Q), (this.message = B);
    }
    toString() {
      let A = Ew + this.command;
      if (this.properties && Object.keys(this.properties).length > 0) {
        A += " ";
        let Q = !0;
        for (let B in this.properties)
          if (this.properties.hasOwnProperty(B)) {
            let I = this.properties[B];
            if (I) {
              if (Q) Q = !1;
              else A += ",";
              A += `${B}=${IS(I)}`;
            }
          }
      }
      return (A += `${Ew}${BS(this.message)}`), A;
    }
  }
  function BS(A) {
    return (0, Cw.toCommandValue)(A)
      .replace(/%/g, "%25")
      .replace(/\r/g, "%0D")
      .replace(/\n/g, "%0A");
  }
  function IS(A) {
    return (0, Cw.toCommandValue)(A)
      .replace(/%/g, "%25")
      .replace(/\r/g, "%0D")
      .replace(/\n/g, "%0A")
      .replace(/:/g, "%3A")
      .replace(/,/g, "%2C");
  }
});
var Nw = Z((eB) => {
  var ES =
      (eB && eB.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            var E = Object.getOwnPropertyDescriptor(Q, B);
            if (
              !E ||
              ("get" in E ? !Q.__esModule : E.writable || E.configurable)
            )
              E = {
                enumerable: !0,
                get: function () {
                  return Q[B];
                },
              };
            Object.defineProperty(A, I, E);
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    CS =
      (eB && eB.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    OG =
      (eB && eB.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.prototype.hasOwnProperty.call(A, B))
              ES(Q, A, B);
        }
        return CS(Q, A), Q;
      };
  Object.defineProperty(eB, "__esModule", { value: !0 });
  eB.prepareKeyValueMessage = eB.issueFileCommand = void 0;
  var gS = OG($("crypto")),
    Yw = OG($("fs")),
    TG = OG($("os")),
    Jw = qD();
  function FS(A, Q) {
    let B = process.env[`GITHUB_${A}`];
    if (!B)
      throw Error(`Unable to find environment variable for file command ${A}`);
    if (!Yw.existsSync(B)) throw Error(`Missing file at path: ${B}`);
    Yw.appendFileSync(B, `${(0, Jw.toCommandValue)(Q)}${TG.EOL}`, {
      encoding: "utf8",
    });
  }
  eB.issueFileCommand = FS;
  function DS(A, Q) {
    let B = `ghadelimiter_${gS.randomUUID()}`,
      I = (0, Jw.toCommandValue)(Q);
    if (A.includes(B))
      throw Error(
        `Unexpected input: name should not contain the delimiter "${B}"`,
      );
    if (I.includes(B))
      throw Error(
        `Unexpected input: value should not contain the delimiter "${B}"`,
      );
    return `${A}<<${B}${TG.EOL}${I}${TG.EOL}${B}`;
  }
  eB.prepareKeyValueMessage = DS;
});
var Zw = Z((Uw) => {
  Object.defineProperty(Uw, "__esModule", { value: !0 });
  Uw.checkBypass = Uw.getProxyUrl = void 0;
  function YS(A) {
    let Q = A.protocol === "https:";
    if (Gw(A)) return;
    let B = (() => {
      if (Q) return process.env.https_proxy || process.env.HTTPS_PROXY;
      else return process.env.http_proxy || process.env.HTTP_PROXY;
    })();
    if (B)
      try {
        return new qG(B);
      } catch (I) {
        if (!B.startsWith("http://") && !B.startsWith("https://"))
          return new qG(`http://${B}`);
      }
    else return;
  }
  Uw.getProxyUrl = YS;
  function Gw(A) {
    if (!A.hostname) return !1;
    let Q = A.hostname;
    if (JS(Q)) return !0;
    let B = process.env.no_proxy || process.env.NO_PROXY || "";
    if (!B) return !1;
    let I;
    if (A.port) I = Number(A.port);
    else if (A.protocol === "http:") I = 80;
    else if (A.protocol === "https:") I = 443;
    let E = [A.hostname.toUpperCase()];
    if (typeof I === "number") E.push(`${E[0]}:${I}`);
    for (let C of B.split(",")
      .map((g) => g.trim().toUpperCase())
      .filter((g) => g))
      if (
        C === "*" ||
        E.some(
          (g) =>
            g === C ||
            g.endsWith(`.${C}`) ||
            (C.startsWith(".") && g.endsWith(`${C}`)),
        )
      )
        return !0;
    return !1;
  }
  Uw.checkBypass = Gw;
  function JS(A) {
    let Q = A.toLowerCase();
    return (
      Q === "localhost" ||
      Q.startsWith("127.") ||
      Q.startsWith("[::1]") ||
      Q.startsWith("[0:0:0:0:0:0:0:1]")
    );
  }
  class qG extends URL {
    constructor(A, Q) {
      super(A, Q);
      (this._decodedUsername = decodeURIComponent(super.username)),
        (this._decodedPassword = decodeURIComponent(super.password));
    }
    get username() {
      return this._decodedUsername;
    }
    get password() {
      return this._decodedPassword;
    }
  }
});
var Lw = Z((LS) => {
  var MVA = $("net"),
    GS = $("tls"),
    jG = $("http"),
    Xw = $("https"),
    US = $("events"),
    LVA = $("assert"),
    WS = $("util");
  LS.httpOverHttp = ZS;
  LS.httpsOverHttp = XS;
  LS.httpOverHttps = wS;
  LS.httpsOverHttps = MS;
  function ZS(A) {
    var Q = new IE(A);
    return (Q.request = jG.request), Q;
  }
  function XS(A) {
    var Q = new IE(A);
    return (
      (Q.request = jG.request), (Q.createSocket = ww), (Q.defaultPort = 443), Q
    );
  }
  function wS(A) {
    var Q = new IE(A);
    return (Q.request = Xw.request), Q;
  }
  function MS(A) {
    var Q = new IE(A);
    return (
      (Q.request = Xw.request), (Q.createSocket = ww), (Q.defaultPort = 443), Q
    );
  }
  function IE(A) {
    var Q = this;
    (Q.options = A || {}),
      (Q.proxyOptions = Q.options.proxy || {}),
      (Q.maxSockets = Q.options.maxSockets || jG.Agent.defaultMaxSockets),
      (Q.requests = []),
      (Q.sockets = []),
      Q.on("free", function (I, E, C, g) {
        var F = Mw(E, C, g);
        for (var D = 0, J = Q.requests.length; D < J; ++D) {
          var Y = Q.requests[D];
          if (Y.host === F.host && Y.port === F.port) {
            Q.requests.splice(D, 1), Y.request.onSocket(I);
            return;
          }
        }
        I.destroy(), Q.removeSocket(I);
      });
  }
  WS.inherits(IE, US.EventEmitter);
  IE.prototype.addRequest = function (Q, B, I, E) {
    var C = this,
      g = fG({ request: Q }, C.options, Mw(B, I, E));
    if (C.sockets.length >= this.maxSockets) {
      C.requests.push(g);
      return;
    }
    C.createSocket(g, function (F) {
      F.on("free", D), F.on("close", J), F.on("agentRemove", J), Q.onSocket(F);
      function D() {
        C.emit("free", F, g);
      }
      function J(Y) {
        C.removeSocket(F),
          F.removeListener("free", D),
          F.removeListener("close", J),
          F.removeListener("agentRemove", J);
      }
    });
  };
  IE.prototype.createSocket = function (Q, B) {
    var I = this,
      E = {};
    I.sockets.push(E);
    var C = fG({}, I.proxyOptions, {
      method: "CONNECT",
      path: Q.host + ":" + Q.port,
      agent: !1,
      headers: { host: Q.host + ":" + Q.port },
    });
    if (Q.localAddress) C.localAddress = Q.localAddress;
    if (C.proxyAuth)
      (C.headers = C.headers || {}),
        (C.headers["Proxy-Authorization"] =
          "Basic " + new Buffer(C.proxyAuth).toString("base64"));
    vE("making CONNECT request");
    var g = I.request(C);
    (g.useChunkedEncodingByDefault = !1),
      g.once("response", F),
      g.once("upgrade", D),
      g.once("connect", J),
      g.once("error", Y),
      g.end();
    function F(N) {
      N.upgrade = !0;
    }
    function D(N, W, X) {
      process.nextTick(function () {
        J(N, W, X);
      });
    }
    function J(N, W, X) {
      if (
        (g.removeAllListeners(), W.removeAllListeners(), N.statusCode !== 200)
      ) {
        vE(
          "tunneling socket could not be established, statusCode=%d",
          N.statusCode,
        ),
          W.destroy();
        var M = Error(
          "tunneling socket could not be established, statusCode=" +
            N.statusCode,
        );
        (M.code = "ECONNRESET"), Q.request.emit("error", M), I.removeSocket(E);
        return;
      }
      if (X.length > 0) {
        vE("got illegal response body from proxy"), W.destroy();
        var M = Error("got illegal response body from proxy");
        (M.code = "ECONNRESET"), Q.request.emit("error", M), I.removeSocket(E);
        return;
      }
      return (
        vE("tunneling connection has established"),
        (I.sockets[I.sockets.indexOf(E)] = W),
        B(W)
      );
    }
    function Y(N) {
      g.removeAllListeners(),
        vE(
          `tunneling socket could not be established, cause=%s
`,
          N.message,
          N.stack,
        );
      var W = Error(
        "tunneling socket could not be established, cause=" + N.message,
      );
      (W.code = "ECONNRESET"), Q.request.emit("error", W), I.removeSocket(E);
    }
  };
  IE.prototype.removeSocket = function (Q) {
    var B = this.sockets.indexOf(Q);
    if (B === -1) return;
    this.sockets.splice(B, 1);
    var I = this.requests.shift();
    if (I)
      this.createSocket(I, function (E) {
        I.request.onSocket(E);
      });
  };
  function ww(A, Q) {
    var B = this;
    IE.prototype.createSocket.call(B, A, function (I) {
      var E = A.request.getHeader("host"),
        C = fG({}, B.options, {
          socket: I,
          servername: E ? E.replace(/:.*$/, "") : A.host,
        }),
        g = GS.connect(0, C);
      (B.sockets[B.sockets.indexOf(I)] = g), Q(g);
    });
  }
  function Mw(A, Q, B) {
    if (typeof A === "string") return { host: A, port: Q, localAddress: B };
    return A;
  }
  function fG(A) {
    for (var Q = 1, B = arguments.length; Q < B; ++Q) {
      var I = arguments[Q];
      if (typeof I === "object") {
        var E = Object.keys(I);
        for (var C = 0, g = E.length; C < g; ++C) {
          var F = E[C];
          if (I[F] !== void 0) A[F] = I[F];
        }
      }
    }
    return A;
  }
  var vE;
  if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG))
    vE = function () {
      var A = Array.prototype.slice.call(arguments);
      if (typeof A[0] === "string") A[0] = "TUNNEL: " + A[0];
      else A.unshift("TUNNEL:");
      console.error.apply(console, A);
    };
  else vE = function () {};
  LS.debug = vE;
});
var aA = Z((VVA, Rw) => {
  Rw.exports = {
    kClose: Symbol("close"),
    kDestroy: Symbol("destroy"),
    kDispatch: Symbol("dispatch"),
    kUrl: Symbol("url"),
    kWriting: Symbol("writing"),
    kResuming: Symbol("resuming"),
    kQueue: Symbol("queue"),
    kConnect: Symbol("connect"),
    kConnecting: Symbol("connecting"),
    kHeadersList: Symbol("headers list"),
    kKeepAliveDefaultTimeout: Symbol("default keep alive timeout"),
    kKeepAliveMaxTimeout: Symbol("max keep alive timeout"),
    kKeepAliveTimeoutThreshold: Symbol("keep alive timeout threshold"),
    kKeepAliveTimeoutValue: Symbol("keep alive timeout"),
    kKeepAlive: Symbol("keep alive"),
    kHeadersTimeout: Symbol("headers timeout"),
    kBodyTimeout: Symbol("body timeout"),
    kServerName: Symbol("server name"),
    kLocalAddress: Symbol("local address"),
    kHost: Symbol("host"),
    kNoRef: Symbol("no ref"),
    kBodyUsed: Symbol("used"),
    kRunning: Symbol("running"),
    kBlocking: Symbol("blocking"),
    kPending: Symbol("pending"),
    kSize: Symbol("size"),
    kBusy: Symbol("busy"),
    kQueued: Symbol("queued"),
    kFree: Symbol("free"),
    kConnected: Symbol("connected"),
    kClosed: Symbol("closed"),
    kNeedDrain: Symbol("need drain"),
    kReset: Symbol("reset"),
    kDestroyed: Symbol.for("nodejs.stream.destroyed"),
    kMaxHeadersSize: Symbol("max headers size"),
    kRunningIdx: Symbol("running index"),
    kPendingIdx: Symbol("pending index"),
    kError: Symbol("error"),
    kClients: Symbol("clients"),
    kClient: Symbol("client"),
    kParser: Symbol("parser"),
    kOnDestroyed: Symbol("destroy callbacks"),
    kPipelining: Symbol("pipelining"),
    kSocket: Symbol("socket"),
    kHostHeader: Symbol("host header"),
    kConnector: Symbol("connector"),
    kStrictContentLength: Symbol("strict content length"),
    kMaxRedirections: Symbol("maxRedirections"),
    kMaxRequests: Symbol("maxRequestsPerClient"),
    kProxy: Symbol("proxy agent options"),
    kCounter: Symbol("socket request counter"),
    kInterceptors: Symbol("dispatch interceptors"),
    kMaxResponseSize: Symbol("max response size"),
    kHTTP2Session: Symbol("http2Session"),
    kHTTP2SessionState: Symbol("http2Session state"),
    kHTTP2BuildRequest: Symbol("http2 build request"),
    kHTTP1BuildRequest: Symbol("http1 build request"),
    kHTTP2CopyHeaders: Symbol("http2 copy headers"),
    kHTTPConnVersion: Symbol("http connection version"),
    kRetryHandlerDefaultRetry: Symbol("retry agent default retry"),
    kConstruct: Symbol("constructable"),
  };
});
var dA = Z(($VA, $w) => {
  class LQ extends Error {
    constructor(A) {
      super(A);
      (this.name = "UndiciError"), (this.code = "UND_ERR");
    }
  }
  class hG extends LQ {
    constructor(A) {
      super(A);
      Error.captureStackTrace(this, hG),
        (this.name = "ConnectTimeoutError"),
        (this.message = A || "Connect Timeout Error"),
        (this.code = "UND_ERR_CONNECT_TIMEOUT");
    }
  }
  class kG extends LQ {
    constructor(A) {
      super(A);
      Error.captureStackTrace(this, kG),
        (this.name = "HeadersTimeoutError"),
        (this.message = A || "Headers Timeout Error"),
        (this.code = "UND_ERR_HEADERS_TIMEOUT");
    }
  }
  class xG extends LQ {
    constructor(A) {
      super(A);
      Error.captureStackTrace(this, xG),
        (this.name = "HeadersOverflowError"),
        (this.message = A || "Headers Overflow Error"),
        (this.code = "UND_ERR_HEADERS_OVERFLOW");
    }
  }
  class vG extends LQ {
    constructor(A) {
      super(A);
      Error.captureStackTrace(this, vG),
        (this.name = "BodyTimeoutError"),
        (this.message = A || "Body Timeout Error"),
        (this.code = "UND_ERR_BODY_TIMEOUT");
    }
  }
  class PG extends LQ {
    constructor(A, Q, B, I) {
      super(A);
      Error.captureStackTrace(this, PG),
        (this.name = "ResponseStatusCodeError"),
        (this.message = A || "Response Status Code Error"),
        (this.code = "UND_ERR_RESPONSE_STATUS_CODE"),
        (this.body = I),
        (this.status = Q),
        (this.statusCode = Q),
        (this.headers = B);
    }
  }
  class _G extends LQ {
    constructor(A) {
      super(A);
      Error.captureStackTrace(this, _G),
        (this.name = "InvalidArgumentError"),
        (this.message = A || "Invalid Argument Error"),
        (this.code = "UND_ERR_INVALID_ARG");
    }
  }
  class yG extends LQ {
    constructor(A) {
      super(A);
      Error.captureStackTrace(this, yG),
        (this.name = "InvalidReturnValueError"),
        (this.message = A || "Invalid Return Value Error"),
        (this.code = "UND_ERR_INVALID_RETURN_VALUE");
    }
  }
  class SG extends LQ {
    constructor(A) {
      super(A);
      Error.captureStackTrace(this, SG),
        (this.name = "AbortError"),
        (this.message = A || "Request aborted"),
        (this.code = "UND_ERR_ABORTED");
    }
  }
  class bG extends LQ {
    constructor(A) {
      super(A);
      Error.captureStackTrace(this, bG),
        (this.name = "InformationalError"),
        (this.message = A || "Request information"),
        (this.code = "UND_ERR_INFO");
    }
  }
  class mG extends LQ {
    constructor(A) {
      super(A);
      Error.captureStackTrace(this, mG),
        (this.name = "RequestContentLengthMismatchError"),
        (this.message =
          A || "Request body length does not match content-length header"),
        (this.code = "UND_ERR_REQ_CONTENT_LENGTH_MISMATCH");
    }
  }
  class dG extends LQ {
    constructor(A) {
      super(A);
      Error.captureStackTrace(this, dG),
        (this.name = "ResponseContentLengthMismatchError"),
        (this.message =
          A || "Response body length does not match content-length header"),
        (this.code = "UND_ERR_RES_CONTENT_LENGTH_MISMATCH");
    }
  }
  class cG extends LQ {
    constructor(A) {
      super(A);
      Error.captureStackTrace(this, cG),
        (this.name = "ClientDestroyedError"),
        (this.message = A || "The client is destroyed"),
        (this.code = "UND_ERR_DESTROYED");
    }
  }
  class uG extends LQ {
    constructor(A) {
      super(A);
      Error.captureStackTrace(this, uG),
        (this.name = "ClientClosedError"),
        (this.message = A || "The client is closed"),
        (this.code = "UND_ERR_CLOSED");
    }
  }
  class lG extends LQ {
    constructor(A, Q) {
      super(A);
      Error.captureStackTrace(this, lG),
        (this.name = "SocketError"),
        (this.message = A || "Socket error"),
        (this.code = "UND_ERR_SOCKET"),
        (this.socket = Q);
    }
  }
  class jD extends LQ {
    constructor(A) {
      super(A);
      Error.captureStackTrace(this, jD),
        (this.name = "NotSupportedError"),
        (this.message = A || "Not supported error"),
        (this.code = "UND_ERR_NOT_SUPPORTED");
    }
  }
  class Vw extends LQ {
    constructor(A) {
      super(A);
      Error.captureStackTrace(this, jD),
        (this.name = "MissingUpstreamError"),
        (this.message = A || "No upstream has been added to the BalancedPool"),
        (this.code = "UND_ERR_BPL_MISSING_UPSTREAM");
    }
  }
  class pG extends Error {
    constructor(A, Q, B) {
      super(A);
      Error.captureStackTrace(this, pG),
        (this.name = "HTTPParserError"),
        (this.code = Q ? `HPE_${Q}` : void 0),
        (this.data = B ? B.toString() : void 0);
    }
  }
  class iG extends LQ {
    constructor(A) {
      super(A);
      Error.captureStackTrace(this, iG),
        (this.name = "ResponseExceededMaxSizeError"),
        (this.message = A || "Response content exceeded max size"),
        (this.code = "UND_ERR_RES_EXCEEDED_MAX_SIZE");
    }
  }
  class nG extends LQ {
    constructor(A, Q, { headers: B, data: I }) {
      super(A);
      Error.captureStackTrace(this, nG),
        (this.name = "RequestRetryError"),
        (this.message = A || "Request retry error"),
        (this.code = "UND_ERR_REQ_RETRY"),
        (this.statusCode = Q),
        (this.data = I),
        (this.headers = B);
    }
  }
  $w.exports = {
    HTTPParserError: pG,
    UndiciError: LQ,
    HeadersTimeoutError: kG,
    HeadersOverflowError: xG,
    BodyTimeoutError: vG,
    RequestContentLengthMismatchError: mG,
    ConnectTimeoutError: hG,
    ResponseStatusCodeError: PG,
    InvalidArgumentError: _G,
    InvalidReturnValueError: yG,
    RequestAbortedError: SG,
    ClientDestroyedError: cG,
    ClientClosedError: uG,
    InformationalError: bG,
    SocketError: lG,
    NotSupportedError: jD,
    ResponseContentLengthMismatchError: dG,
    BalancedPoolMissingUpstreamError: Vw,
    ResponseExceededMaxSizeError: iG,
    RequestRetryError: nG,
  };
});
var Kw = Z((HVA, Hw) => {
  var fD = {},
    aG = [
      "Accept",
      "Accept-Encoding",
      "Accept-Language",
      "Accept-Ranges",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Age",
      "Allow",
      "Alt-Svc",
      "Alt-Used",
      "Authorization",
      "Cache-Control",
      "Clear-Site-Data",
      "Connection",
      "Content-Disposition",
      "Content-Encoding",
      "Content-Language",
      "Content-Length",
      "Content-Location",
      "Content-Range",
      "Content-Security-Policy",
      "Content-Security-Policy-Report-Only",
      "Content-Type",
      "Cookie",
      "Cross-Origin-Embedder-Policy",
      "Cross-Origin-Opener-Policy",
      "Cross-Origin-Resource-Policy",
      "Date",
      "Device-Memory",
      "Downlink",
      "ECT",
      "ETag",
      "Expect",
      "Expect-CT",
      "Expires",
      "Forwarded",
      "From",
      "Host",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Range",
      "If-Unmodified-Since",
      "Keep-Alive",
      "Last-Modified",
      "Link",
      "Location",
      "Max-Forwards",
      "Origin",
      "Permissions-Policy",
      "Pragma",
      "Proxy-Authenticate",
      "Proxy-Authorization",
      "RTT",
      "Range",
      "Referer",
      "Referrer-Policy",
      "Refresh",
      "Retry-After",
      "Sec-WebSocket-Accept",
      "Sec-WebSocket-Extensions",
      "Sec-WebSocket-Key",
      "Sec-WebSocket-Protocol",
      "Sec-WebSocket-Version",
      "Server",
      "Server-Timing",
      "Service-Worker-Allowed",
      "Service-Worker-Navigation-Preload",
      "Set-Cookie",
      "SourceMap",
      "Strict-Transport-Security",
      "Supports-Loading-Mode",
      "TE",
      "Timing-Allow-Origin",
      "Trailer",
      "Transfer-Encoding",
      "Upgrade",
      "Upgrade-Insecure-Requests",
      "User-Agent",
      "Vary",
      "Via",
      "WWW-Authenticate",
      "X-Content-Type-Options",
      "X-DNS-Prefetch-Control",
      "X-Frame-Options",
      "X-Permitted-Cross-Domain-Policies",
      "X-Powered-By",
      "X-Requested-With",
      "X-XSS-Protection",
    ];
  for (let A = 0; A < aG.length; ++A) {
    let Q = aG[A],
      B = Q.toLowerCase();
    fD[Q] = fD[B] = B;
  }
  Object.setPrototypeOf(fD, null);
  Hw.exports = { wellknownHeaderNames: aG, headerNameLowerCasedRecord: fD };
});
var HA = Z((KVA, Pw) => {
  var qw = $("assert"),
    { kDestroyed: jw, kBodyUsed: zw } = aA(),
    { IncomingMessage: zS } = $("http"),
    G0 = $("stream"),
    TS = $("net"),
    { InvalidArgumentError: cQ } = dA(),
    { Blob: Tw } = $("buffer"),
    hD = $("util"),
    { stringify: OS } = $("querystring"),
    { headerNameLowerCasedRecord: qS } = Kw(),
    [oG, Ow] = process.versions.node.split(".").map((A) => Number(A));
  function jS() {}
  function sG(A) {
    return (
      A &&
      typeof A === "object" &&
      typeof A.pipe === "function" &&
      typeof A.on === "function"
    );
  }
  function fw(A) {
    return (
      (Tw && A instanceof Tw) ||
      (A &&
        typeof A === "object" &&
        (typeof A.stream === "function" ||
          typeof A.arrayBuffer === "function") &&
        /^(Blob|File)$/.test(A[Symbol.toStringTag]))
    );
  }
  function fS(A, Q) {
    if (A.includes("?") || A.includes("#"))
      throw Error(
        'Query params cannot be passed when url already contains "?" or "#".',
      );
    let B = OS(Q);
    if (B) A += "?" + B;
    return A;
  }
  function hw(A) {
    if (typeof A === "string") {
      if (((A = new URL(A)), !/^https?:/.test(A.origin || A.protocol)))
        throw new cQ(
          "Invalid URL protocol: the URL must start with `http:` or `https:`.",
        );
      return A;
    }
    if (!A || typeof A !== "object")
      throw new cQ("Invalid URL: The URL argument must be a non-null object.");
    if (!/^https?:/.test(A.origin || A.protocol))
      throw new cQ(
        "Invalid URL protocol: the URL must start with `http:` or `https:`.",
      );
    if (!(A instanceof URL)) {
      if (A.port != null && A.port !== "" && !Number.isFinite(parseInt(A.port)))
        throw new cQ(
          "Invalid URL: port must be a valid integer or a string representation of an integer.",
        );
      if (A.path != null && typeof A.path !== "string")
        throw new cQ(
          "Invalid URL path: the path must be a string or null/undefined.",
        );
      if (A.pathname != null && typeof A.pathname !== "string")
        throw new cQ(
          "Invalid URL pathname: the pathname must be a string or null/undefined.",
        );
      if (A.hostname != null && typeof A.hostname !== "string")
        throw new cQ(
          "Invalid URL hostname: the hostname must be a string or null/undefined.",
        );
      if (A.origin != null && typeof A.origin !== "string")
        throw new cQ(
          "Invalid URL origin: the origin must be a string or null/undefined.",
        );
      let Q = A.port != null ? A.port : A.protocol === "https:" ? 443 : 80,
        B = A.origin != null ? A.origin : `${A.protocol}//${A.hostname}:${Q}`,
        I = A.path != null ? A.path : `${A.pathname || ""}${A.search || ""}`;
      if (B.endsWith("/")) B = B.substring(0, B.length - 1);
      if (I && !I.startsWith("/")) I = `/${I}`;
      A = new URL(B + I);
    }
    return A;
  }
  function hS(A) {
    if (((A = hw(A)), A.pathname !== "/" || A.search || A.hash))
      throw new cQ("invalid url");
    return A;
  }
  function kS(A) {
    if (A[0] === "[") {
      let B = A.indexOf("]");
      return qw(B !== -1), A.substring(1, B);
    }
    let Q = A.indexOf(":");
    if (Q === -1) return A;
    return A.substring(0, Q);
  }
  function xS(A) {
    if (!A) return null;
    qw.strictEqual(typeof A, "string");
    let Q = kS(A);
    if (TS.isIP(Q)) return "";
    return Q;
  }
  function vS(A) {
    return JSON.parse(JSON.stringify(A));
  }
  function PS(A) {
    return A != null && typeof A[Symbol.asyncIterator] === "function";
  }
  function _S(A) {
    return (
      A != null &&
      (typeof A[Symbol.iterator] === "function" ||
        typeof A[Symbol.asyncIterator] === "function")
    );
  }
  function yS(A) {
    if (A == null) return 0;
    else if (sG(A)) {
      let Q = A._readableState;
      return Q &&
        Q.objectMode === !1 &&
        Q.ended === !0 &&
        Number.isFinite(Q.length)
        ? Q.length
        : null;
    } else if (fw(A)) return A.size != null ? A.size : null;
    else if (xw(A)) return A.byteLength;
    return null;
  }
  function rG(A) {
    return !A || !!(A.destroyed || A[jw]);
  }
  function kw(A) {
    let Q = A && A._readableState;
    return rG(A) && Q && !Q.endEmitted;
  }
  function SS(A, Q) {
    if (A == null || !sG(A) || rG(A)) return;
    if (typeof A.destroy === "function") {
      if (Object.getPrototypeOf(A).constructor === zS) A.socket = null;
      A.destroy(Q);
    } else if (Q)
      process.nextTick(
        (B, I) => {
          B.emit("error", I);
        },
        A,
        Q,
      );
    if (A.destroyed !== !0) A[jw] = !0;
  }
  var bS = /timeout=(\d+)/;
  function mS(A) {
    let Q = A.toString().match(bS);
    return Q ? parseInt(Q[1], 10) * 1000 : null;
  }
  function dS(A) {
    return qS[A] || A.toLowerCase();
  }
  function cS(A, Q = {}) {
    if (!Array.isArray(A)) return A;
    for (let B = 0; B < A.length; B += 2) {
      let I = A[B].toString().toLowerCase(),
        E = Q[I];
      if (!E)
        if (Array.isArray(A[B + 1]))
          Q[I] = A[B + 1].map((C) => C.toString("utf8"));
        else Q[I] = A[B + 1].toString("utf8");
      else {
        if (!Array.isArray(E)) (E = [E]), (Q[I] = E);
        E.push(A[B + 1].toString("utf8"));
      }
    }
    if ("content-length" in Q && "content-disposition" in Q)
      Q["content-disposition"] = Buffer.from(Q["content-disposition"]).toString(
        "latin1",
      );
    return Q;
  }
  function uS(A) {
    let Q = [],
      B = !1,
      I = -1;
    for (let E = 0; E < A.length; E += 2) {
      let C = A[E + 0].toString(),
        g = A[E + 1].toString("utf8");
      if (
        C.length === 14 &&
        (C === "content-length" || C.toLowerCase() === "content-length")
      )
        Q.push(C, g), (B = !0);
      else if (
        C.length === 19 &&
        (C === "content-disposition" ||
          C.toLowerCase() === "content-disposition")
      )
        I = Q.push(C, g) - 1;
      else Q.push(C, g);
    }
    if (B && I !== -1) Q[I] = Buffer.from(Q[I]).toString("latin1");
    return Q;
  }
  function xw(A) {
    return A instanceof Uint8Array || Buffer.isBuffer(A);
  }
  function lS(A, Q, B) {
    if (!A || typeof A !== "object") throw new cQ("handler must be an object");
    if (typeof A.onConnect !== "function")
      throw new cQ("invalid onConnect method");
    if (typeof A.onError !== "function") throw new cQ("invalid onError method");
    if (typeof A.onBodySent !== "function" && A.onBodySent !== void 0)
      throw new cQ("invalid onBodySent method");
    if (B || Q === "CONNECT") {
      if (typeof A.onUpgrade !== "function")
        throw new cQ("invalid onUpgrade method");
    } else {
      if (typeof A.onHeaders !== "function")
        throw new cQ("invalid onHeaders method");
      if (typeof A.onData !== "function") throw new cQ("invalid onData method");
      if (typeof A.onComplete !== "function")
        throw new cQ("invalid onComplete method");
    }
  }
  function pS(A) {
    return !!(
      A &&
      (G0.isDisturbed
        ? G0.isDisturbed(A) || A[zw]
        : A[zw] ||
          A.readableDidRead ||
          (A._readableState && A._readableState.dataEmitted) ||
          kw(A))
    );
  }
  function iS(A) {
    return !!(
      A &&
      (G0.isErrored ? G0.isErrored(A) : /state: 'errored'/.test(hD.inspect(A)))
    );
  }
  function nS(A) {
    return !!(
      A &&
      (G0.isReadable
        ? G0.isReadable(A)
        : /state: 'readable'/.test(hD.inspect(A)))
    );
  }
  function aS(A) {
    return {
      localAddress: A.localAddress,
      localPort: A.localPort,
      remoteAddress: A.remoteAddress,
      remotePort: A.remotePort,
      remoteFamily: A.remoteFamily,
      timeout: A.timeout,
      bytesWritten: A.bytesWritten,
      bytesRead: A.bytesRead,
    };
  }
  async function* oS(A) {
    for await (let Q of A) yield Buffer.isBuffer(Q) ? Q : Buffer.from(Q);
  }
  var bg;
  function sS(A) {
    if (!bg) bg = $("stream/web").ReadableStream;
    if (bg.from) return bg.from(oS(A));
    let Q;
    return new bg(
      {
        async start() {
          Q = A[Symbol.asyncIterator]();
        },
        async pull(B) {
          let { done: I, value: E } = await Q.next();
          if (I)
            queueMicrotask(() => {
              B.close();
            });
          else {
            let C = Buffer.isBuffer(E) ? E : Buffer.from(E);
            B.enqueue(new Uint8Array(C));
          }
          return B.desiredSize > 0;
        },
        async cancel(B) {
          await Q.return();
        },
      },
      0,
    );
  }
  function rS(A) {
    return (
      A &&
      typeof A === "object" &&
      typeof A.append === "function" &&
      typeof A.delete === "function" &&
      typeof A.get === "function" &&
      typeof A.getAll === "function" &&
      typeof A.has === "function" &&
      typeof A.set === "function" &&
      A[Symbol.toStringTag] === "FormData"
    );
  }
  function tS(A) {
    if (!A) return;
    if (typeof A.throwIfAborted === "function") A.throwIfAborted();
    else if (A.aborted) {
      let Q = Error("The operation was aborted");
      throw ((Q.name = "AbortError"), Q);
    }
  }
  function eS(A, Q) {
    if ("addEventListener" in A)
      return (
        A.addEventListener("abort", Q, { once: !0 }),
        () => A.removeEventListener("abort", Q)
      );
    return A.addListener("abort", Q), () => A.removeListener("abort", Q);
  }
  var Ab = !!String.prototype.toWellFormed;
  function Qb(A) {
    if (Ab) return `${A}`.toWellFormed();
    else if (hD.toUSVString) return hD.toUSVString(A);
    return `${A}`;
  }
  function Bb(A) {
    if (A == null || A === "") return { start: 0, end: null, size: null };
    let Q = A ? A.match(/^bytes (\d+)-(\d+)\/(\d+)?$/) : null;
    return Q
      ? {
          start: parseInt(Q[1]),
          end: Q[2] ? parseInt(Q[2]) : null,
          size: Q[3] ? parseInt(Q[3]) : null,
        }
      : null;
  }
  var vw = Object.create(null);
  vw.enumerable = !0;
  Pw.exports = {
    kEnumerableProperty: vw,
    nop: jS,
    isDisturbed: pS,
    isErrored: iS,
    isReadable: nS,
    toUSVString: Qb,
    isReadableAborted: kw,
    isBlobLike: fw,
    parseOrigin: hS,
    parseURL: hw,
    getServerName: xS,
    isStream: sG,
    isIterable: _S,
    isAsyncIterable: PS,
    isDestroyed: rG,
    headerNameToString: dS,
    parseRawHeaders: uS,
    parseHeaders: cS,
    parseKeepAliveTimeout: mS,
    destroy: SS,
    bodyLength: yS,
    deepClone: vS,
    ReadableStreamFrom: sS,
    isBuffer: xw,
    validateHandler: lS,
    getSocketInfo: aS,
    isFormDataLike: rS,
    buildURL: fS,
    throwIfAborted: tS,
    addAbortListener: eS,
    parseRangeHeader: Bb,
    nodeMajor: oG,
    nodeMinor: Ow,
    nodeHasAutoSelectFamily: oG > 18 || (oG === 18 && Ow >= 13),
    safeHTTPMethods: ["GET", "HEAD", "OPTIONS", "TRACE"],
  };
});
var Sw = Z((zVA, yw) => {
  var tG = Date.now(),
    PE,
    _E = [];
  function Ib() {
    tG = Date.now();
    let A = _E.length,
      Q = 0;
    while (Q < A) {
      let B = _E[Q];
      if (B.state === 0) B.state = tG + B.delay;
      else if (B.state > 0 && tG >= B.state)
        (B.state = -1), B.callback(B.opaque);
      if (B.state === -1) {
        if (((B.state = -2), Q !== A - 1)) _E[Q] = _E.pop();
        else _E.pop();
        A -= 1;
      } else Q += 1;
    }
    if (_E.length > 0) _w();
  }
  function _w() {
    if (PE && PE.refresh) PE.refresh();
    else if ((clearTimeout(PE), (PE = setTimeout(Ib, 1000)), PE.unref))
      PE.unref();
  }
  class eG {
    constructor(A, Q, B) {
      (this.callback = A),
        (this.delay = Q),
        (this.opaque = B),
        (this.state = -2),
        this.refresh();
    }
    refresh() {
      if (this.state === -2) {
        if ((_E.push(this), !PE || _E.length === 1)) _w();
      }
      this.state = 0;
    }
    clear() {
      this.state = -1;
    }
  }
  yw.exports = {
    setTimeout(A, Q, B) {
      return Q < 1000 ? setTimeout(A, Q, B) : new eG(A, Q, B);
    },
    clearTimeout(A) {
      if (A instanceof eG) A.clear();
      else clearTimeout(A);
    },
  };
});
var AU = Z((TVA, bw) => {
  var Eb = $("node:events").EventEmitter,
    Cb = $("node:util").inherits;
  function $C(A) {
    if (typeof A === "string") A = Buffer.from(A);
    if (!Buffer.isBuffer(A))
      throw TypeError("The needle has to be a String or a Buffer.");
    let Q = A.length;
    if (Q === 0) throw Error("The needle cannot be an empty String/Buffer.");
    if (Q > 256)
      throw Error("The needle cannot have a length bigger than 256.");
    (this.maxMatches = 1 / 0),
      (this.matches = 0),
      (this._occ = Array(256).fill(Q)),
      (this._lookbehind_size = 0),
      (this._needle = A),
      (this._bufpos = 0),
      (this._lookbehind = Buffer.alloc(Q));
    for (var B = 0; B < Q - 1; ++B) this._occ[A[B]] = Q - 1 - B;
  }
  Cb($C, Eb);
  $C.prototype.reset = function () {
    (this._lookbehind_size = 0), (this.matches = 0), (this._bufpos = 0);
  };
  $C.prototype.push = function (A, Q) {
    if (!Buffer.isBuffer(A)) A = Buffer.from(A, "binary");
    let B = A.length;
    this._bufpos = Q || 0;
    let I;
    while (I !== B && this.matches < this.maxMatches) I = this._sbmh_feed(A);
    return I;
  };
  $C.prototype._sbmh_feed = function (A) {
    let Q = A.length,
      B = this._needle,
      I = B.length,
      E = B[I - 1],
      C = -this._lookbehind_size,
      g;
    if (C < 0) {
      while (C < 0 && C <= Q - I) {
        if (
          ((g = this._sbmh_lookup_char(A, C + I - 1)),
          g === E && this._sbmh_memcmp(A, C, I - 1))
        )
          return (
            (this._lookbehind_size = 0),
            ++this.matches,
            this.emit("info", !0),
            (this._bufpos = C + I)
          );
        C += this._occ[g];
      }
      if (C < 0) while (C < 0 && !this._sbmh_memcmp(A, C, Q - C)) ++C;
      if (C >= 0)
        this.emit("info", !1, this._lookbehind, 0, this._lookbehind_size),
          (this._lookbehind_size = 0);
      else {
        let F = this._lookbehind_size + C;
        if (F > 0) this.emit("info", !1, this._lookbehind, 0, F);
        return (
          this._lookbehind.copy(
            this._lookbehind,
            0,
            F,
            this._lookbehind_size - F,
          ),
          (this._lookbehind_size -= F),
          A.copy(this._lookbehind, this._lookbehind_size),
          (this._lookbehind_size += Q),
          (this._bufpos = Q),
          Q
        );
      }
    }
    if (((C += (C >= 0) * this._bufpos), A.indexOf(B, C) !== -1)) {
      if (((C = A.indexOf(B, C)), ++this.matches, C > 0))
        this.emit("info", !0, A, this._bufpos, C);
      else this.emit("info", !0);
      return (this._bufpos = C + I);
    } else C = Q - I;
    while (
      C < Q &&
      (A[C] !== B[0] ||
        Buffer.compare(A.subarray(C, C + Q - C), B.subarray(0, Q - C)) !== 0)
    )
      ++C;
    if (C < Q)
      A.copy(this._lookbehind, 0, C, C + (Q - C)),
        (this._lookbehind_size = Q - C);
    if (C > 0) this.emit("info", !1, A, this._bufpos, C < Q ? C : Q);
    return (this._bufpos = Q), Q;
  };
  $C.prototype._sbmh_lookup_char = function (A, Q) {
    return Q < 0 ? this._lookbehind[this._lookbehind_size + Q] : A[Q];
  };
  $C.prototype._sbmh_memcmp = function (A, Q, B) {
    for (var I = 0; I < B; ++I)
      if (this._sbmh_lookup_char(A, Q + I) !== this._needle[I]) return !1;
    return !0;
  };
  bw.exports = $C;
});
var cw = Z((OVA, dw) => {
  var gb = $("node:util").inherits,
    mw = $("node:stream").Readable;
  function QU(A) {
    mw.call(this, A);
  }
  gb(QU, mw);
  QU.prototype._read = function (A) {};
  dw.exports = QU;
});
var kD = Z((qVA, uw) => {
  uw.exports = function (Q, B, I) {
    if (!Q || Q[B] === void 0 || Q[B] === null) return I;
    if (typeof Q[B] !== "number" || isNaN(Q[B]))
      throw TypeError("Limit " + B + " is not a valid number");
    return Q[B];
  };
});
var nw = Z((jVA, iw) => {
  var pw = $("node:events").EventEmitter,
    Fb = $("node:util").inherits,
    lw = kD(),
    Db = AU(),
    Yb = Buffer.from(`\r
\r
`),
    Jb = /\r\n/g,
    Nb = /^([^:]+):[ \t]?([\x00-\xFF]+)?$/;
  function U0(A) {
    pw.call(this), (A = A || {});
    let Q = this;
    (this.nread = 0),
      (this.maxed = !1),
      (this.npairs = 0),
      (this.maxHeaderPairs = lw(A, "maxHeaderPairs", 2000)),
      (this.maxHeaderSize = lw(A, "maxHeaderSize", 81920)),
      (this.buffer = ""),
      (this.header = {}),
      (this.finished = !1),
      (this.ss = new Db(Yb)),
      this.ss.on("info", function (B, I, E, C) {
        if (I && !Q.maxed) {
          if (Q.nread + C - E >= Q.maxHeaderSize)
            (C = Q.maxHeaderSize - Q.nread + E),
              (Q.nread = Q.maxHeaderSize),
              (Q.maxed = !0);
          else Q.nread += C - E;
          Q.buffer += I.toString("binary", E, C);
        }
        if (B) Q._finish();
      });
  }
  Fb(U0, pw);
  U0.prototype.push = function (A) {
    let Q = this.ss.push(A);
    if (this.finished) return Q;
  };
  U0.prototype.reset = function () {
    (this.finished = !1),
      (this.buffer = ""),
      (this.header = {}),
      this.ss.reset();
  };
  U0.prototype._finish = function () {
    if (this.buffer) this._parseHeader();
    this.ss.matches = this.ss.maxMatches;
    let A = this.header;
    (this.header = {}),
      (this.buffer = ""),
      (this.finished = !0),
      (this.nread = this.npairs = 0),
      (this.maxed = !1),
      this.emit("header", A);
  };
  U0.prototype._parseHeader = function () {
    if (this.npairs === this.maxHeaderPairs) return;
    let A = this.buffer.split(Jb),
      Q = A.length,
      B,
      I;
    for (var E = 0; E < Q; ++E) {
      if (A[E].length === 0) continue;
      if (A[E][0] === "\t" || A[E][0] === " ") {
        if (I) {
          this.header[I][this.header[I].length - 1] += A[E];
          continue;
        }
      }
      let C = A[E].indexOf(":");
      if (C === -1 || C === 0) return;
      if (
        ((B = Nb.exec(A[E])),
        (I = B[1].toLowerCase()),
        (this.header[I] = this.header[I] || []),
        this.header[I].push(B[2] || ""),
        ++this.npairs === this.maxHeaderPairs)
      )
        break;
    }
  };
  iw.exports = U0;
});
var IU = Z((fVA, ow) => {
  var BU = $("node:stream").Writable,
    Gb = $("node:util").inherits,
    Ub = AU(),
    aw = cw(),
    Wb = nw(),
    Zb = Buffer.from("-"),
    Xb = Buffer.from(`\r
`),
    wb = function () {};
  function VI(A) {
    if (!(this instanceof VI)) return new VI(A);
    if (
      (BU.call(this, A),
      !A || (!A.headerFirst && typeof A.boundary !== "string"))
    )
      throw TypeError("Boundary required");
    if (typeof A.boundary === "string") this.setBoundary(A.boundary);
    else this._bparser = void 0;
    (this._headerFirst = A.headerFirst),
      (this._dashes = 0),
      (this._parts = 0),
      (this._finished = !1),
      (this._realFinish = !1),
      (this._isPreamble = !0),
      (this._justMatched = !1),
      (this._firstWrite = !0),
      (this._inHeader = !0),
      (this._part = void 0),
      (this._cb = void 0),
      (this._ignoreData = !1),
      (this._partOpts = { highWaterMark: A.partHwm }),
      (this._pause = !1);
    let Q = this;
    (this._hparser = new Wb(A)),
      this._hparser.on("header", function (B) {
        (Q._inHeader = !1), Q._part.emit("header", B);
      });
  }
  Gb(VI, BU);
  VI.prototype.emit = function (A) {
    if (A === "finish" && !this._realFinish) {
      if (!this._finished) {
        let Q = this;
        process.nextTick(function () {
          if (
            (Q.emit("error", Error("Unexpected end of multipart data")),
            Q._part && !Q._ignoreData)
          ) {
            let B = Q._isPreamble ? "Preamble" : "Part";
            Q._part.emit(
              "error",
              Error(
                B + " terminated early due to unexpected end of multipart data",
              ),
            ),
              Q._part.push(null),
              process.nextTick(function () {
                (Q._realFinish = !0), Q.emit("finish"), (Q._realFinish = !1);
              });
            return;
          }
          (Q._realFinish = !0), Q.emit("finish"), (Q._realFinish = !1);
        });
      }
    } else BU.prototype.emit.apply(this, arguments);
  };
  VI.prototype._write = function (A, Q, B) {
    if (!this._hparser && !this._bparser) return B();
    if (this._headerFirst && this._isPreamble) {
      if (!this._part)
        if (
          ((this._part = new aw(this._partOpts)),
          this.listenerCount("preamble") !== 0)
        )
          this.emit("preamble", this._part);
        else this._ignore();
      let I = this._hparser.push(A);
      if (!this._inHeader && I !== void 0 && I < A.length) A = A.slice(I);
      else return B();
    }
    if (this._firstWrite) this._bparser.push(Xb), (this._firstWrite = !1);
    if ((this._bparser.push(A), this._pause)) this._cb = B;
    else B();
  };
  VI.prototype.reset = function () {
    (this._part = void 0), (this._bparser = void 0), (this._hparser = void 0);
  };
  VI.prototype.setBoundary = function (A) {
    let Q = this;
    (this._bparser = new Ub(
      `\r
--` + A,
    )),
      this._bparser.on("info", function (B, I, E, C) {
        Q._oninfo(B, I, E, C);
      });
  };
  VI.prototype._ignore = function () {
    if (this._part && !this._ignoreData)
      (this._ignoreData = !0), this._part.on("error", wb), this._part.resume();
  };
  VI.prototype._oninfo = function (A, Q, B, I) {
    let E,
      C = this,
      g = 0,
      F,
      D = !0;
    if (!this._part && this._justMatched && Q) {
      while (this._dashes < 2 && B + g < I)
        if (Q[B + g] === 45) ++g, ++this._dashes;
        else {
          if (this._dashes) E = Zb;
          this._dashes = 0;
          break;
        }
      if (this._dashes === 2) {
        if (B + g < I && this.listenerCount("trailer") !== 0)
          this.emit("trailer", Q.slice(B + g, I));
        if ((this.reset(), (this._finished = !0), C._parts === 0))
          (C._realFinish = !0), C.emit("finish"), (C._realFinish = !1);
      }
      if (this._dashes) return;
    }
    if (this._justMatched) this._justMatched = !1;
    if (!this._part) {
      if (
        ((this._part = new aw(this._partOpts)),
        (this._part._read = function (J) {
          C._unpause();
        }),
        this._isPreamble && this.listenerCount("preamble") !== 0)
      )
        this.emit("preamble", this._part);
      else if (this._isPreamble !== !0 && this.listenerCount("part") !== 0)
        this.emit("part", this._part);
      else this._ignore();
      if (!this._isPreamble) this._inHeader = !0;
    }
    if (Q && B < I && !this._ignoreData) {
      if (this._isPreamble || !this._inHeader) {
        if (E) D = this._part.push(E);
        if (((D = this._part.push(Q.slice(B, I))), !D)) this._pause = !0;
      } else if (!this._isPreamble && this._inHeader) {
        if (E) this._hparser.push(E);
        if (
          ((F = this._hparser.push(Q.slice(B, I))),
          !this._inHeader && F !== void 0 && F < I)
        )
          this._oninfo(!1, Q, B + F, I);
      }
    }
    if (A) {
      if ((this._hparser.reset(), this._isPreamble)) this._isPreamble = !1;
      else if (B !== I)
        ++this._parts,
          this._part.on("end", function () {
            if (--C._parts === 0)
              if (C._finished)
                (C._realFinish = !0), C.emit("finish"), (C._realFinish = !1);
              else C._unpause();
          });
      this._part.push(null),
        (this._part = void 0),
        (this._ignoreData = !1),
        (this._justMatched = !0),
        (this._dashes = 0);
    }
  };
  VI.prototype._unpause = function () {
    if (!this._pause) return;
    if (((this._pause = !1), this._cb)) {
      let A = this._cb;
      (this._cb = void 0), A();
    }
  };
  ow.exports = VI;
});
var xD = Z((EU, tw) => {
  var sw = new TextDecoder("utf-8"),
    rw = new Map([
      ["utf-8", sw],
      ["utf8", sw],
    ]);
  function Mb(A) {
    let Q;
    while (!0)
      switch (A) {
        case "utf-8":
        case "utf8":
          return mg.utf8;
        case "latin1":
        case "ascii":
        case "us-ascii":
        case "iso-8859-1":
        case "iso8859-1":
        case "iso88591":
        case "iso_8859-1":
        case "windows-1252":
        case "iso_8859-1:1987":
        case "cp1252":
        case "x-cp1252":
          return mg.latin1;
        case "utf16le":
        case "utf-16le":
        case "ucs2":
        case "ucs-2":
          return mg.utf16le;
        case "base64":
          return mg.base64;
        default:
          if (Q === void 0) {
            (Q = !0), (A = A.toLowerCase());
            continue;
          }
          return mg.other.bind(A);
      }
  }
  var mg = {
    utf8: (A, Q) => {
      if (A.length === 0) return "";
      if (typeof A === "string") A = Buffer.from(A, Q);
      return A.utf8Slice(0, A.length);
    },
    latin1: (A, Q) => {
      if (A.length === 0) return "";
      if (typeof A === "string") return A;
      return A.latin1Slice(0, A.length);
    },
    utf16le: (A, Q) => {
      if (A.length === 0) return "";
      if (typeof A === "string") A = Buffer.from(A, Q);
      return A.ucs2Slice(0, A.length);
    },
    base64: (A, Q) => {
      if (A.length === 0) return "";
      if (typeof A === "string") A = Buffer.from(A, Q);
      return A.base64Slice(0, A.length);
    },
    other: (A, Q) => {
      if (A.length === 0) return "";
      if (typeof A === "string") A = Buffer.from(A, Q);
      if (rw.has(EU.toString()))
        try {
          return rw.get(EU).decode(A);
        } catch {}
      return typeof A === "string" ? A : A.toString();
    },
  };
  function Lb(A, Q, B) {
    if (A) return Mb(B)(A, Q);
    return A;
  }
  tw.exports = Lb;
});
var gU = Z((hVA, I8) => {
  var vD = xD(),
    ew = /%[a-fA-F0-9][a-fA-F0-9]/g,
    Rb = {
      "%00": "\x00",
      "%01": "\x01",
      "%02": "\x02",
      "%03": "\x03",
      "%04": "\x04",
      "%05": "\x05",
      "%06": "\x06",
      "%07": "\x07",
      "%08": "\b",
      "%09": "\t",
      "%0a": `
`,
      "%0A": `
`,
      "%0b": "\v",
      "%0B": "\v",
      "%0c": "\f",
      "%0C": "\f",
      "%0d": "\r",
      "%0D": "\r",
      "%0e": "\x0E",
      "%0E": "\x0E",
      "%0f": "\x0F",
      "%0F": "\x0F",
      "%10": "\x10",
      "%11": "\x11",
      "%12": "\x12",
      "%13": "\x13",
      "%14": "\x14",
      "%15": "\x15",
      "%16": "\x16",
      "%17": "\x17",
      "%18": "\x18",
      "%19": "\x19",
      "%1a": "\x1A",
      "%1A": "\x1A",
      "%1b": "\x1B",
      "%1B": "\x1B",
      "%1c": "\x1C",
      "%1C": "\x1C",
      "%1d": "\x1D",
      "%1D": "\x1D",
      "%1e": "\x1E",
      "%1E": "\x1E",
      "%1f": "\x1F",
      "%1F": "\x1F",
      "%20": " ",
      "%21": "!",
      "%22": '"',
      "%23": "#",
      "%24": "$",
      "%25": "%",
      "%26": "&",
      "%27": "'",
      "%28": "(",
      "%29": ")",
      "%2a": "*",
      "%2A": "*",
      "%2b": "+",
      "%2B": "+",
      "%2c": ",",
      "%2C": ",",
      "%2d": "-",
      "%2D": "-",
      "%2e": ".",
      "%2E": ".",
      "%2f": "/",
      "%2F": "/",
      "%30": "0",
      "%31": "1",
      "%32": "2",
      "%33": "3",
      "%34": "4",
      "%35": "5",
      "%36": "6",
      "%37": "7",
      "%38": "8",
      "%39": "9",
      "%3a": ":",
      "%3A": ":",
      "%3b": ";",
      "%3B": ";",
      "%3c": "<",
      "%3C": "<",
      "%3d": "=",
      "%3D": "=",
      "%3e": ">",
      "%3E": ">",
      "%3f": "?",
      "%3F": "?",
      "%40": "@",
      "%41": "A",
      "%42": "B",
      "%43": "C",
      "%44": "D",
      "%45": "E",
      "%46": "F",
      "%47": "G",
      "%48": "H",
      "%49": "I",
      "%4a": "J",
      "%4A": "J",
      "%4b": "K",
      "%4B": "K",
      "%4c": "L",
      "%4C": "L",
      "%4d": "M",
      "%4D": "M",
      "%4e": "N",
      "%4E": "N",
      "%4f": "O",
      "%4F": "O",
      "%50": "P",
      "%51": "Q",
      "%52": "R",
      "%53": "S",
      "%54": "T",
      "%55": "U",
      "%56": "V",
      "%57": "W",
      "%58": "X",
      "%59": "Y",
      "%5a": "Z",
      "%5A": "Z",
      "%5b": "[",
      "%5B": "[",
      "%5c": "\\",
      "%5C": "\\",
      "%5d": "]",
      "%5D": "]",
      "%5e": "^",
      "%5E": "^",
      "%5f": "_",
      "%5F": "_",
      "%60": "`",
      "%61": "a",
      "%62": "b",
      "%63": "c",
      "%64": "d",
      "%65": "e",
      "%66": "f",
      "%67": "g",
      "%68": "h",
      "%69": "i",
      "%6a": "j",
      "%6A": "j",
      "%6b": "k",
      "%6B": "k",
      "%6c": "l",
      "%6C": "l",
      "%6d": "m",
      "%6D": "m",
      "%6e": "n",
      "%6E": "n",
      "%6f": "o",
      "%6F": "o",
      "%70": "p",
      "%71": "q",
      "%72": "r",
      "%73": "s",
      "%74": "t",
      "%75": "u",
      "%76": "v",
      "%77": "w",
      "%78": "x",
      "%79": "y",
      "%7a": "z",
      "%7A": "z",
      "%7b": "{",
      "%7B": "{",
      "%7c": "|",
      "%7C": "|",
      "%7d": "}",
      "%7D": "}",
      "%7e": "~",
      "%7E": "~",
      "%7f": "",
      "%7F": "",
      "%80": "",
      "%81": "",
      "%82": "",
      "%83": "",
      "%84": "",
      "%85": "",
      "%86": "",
      "%87": "",
      "%88": "",
      "%89": "",
      "%8a": "",
      "%8A": "",
      "%8b": "",
      "%8B": "",
      "%8c": "",
      "%8C": "",
      "%8d": "",
      "%8D": "",
      "%8e": "",
      "%8E": "",
      "%8f": "",
      "%8F": "",
      "%90": "",
      "%91": "",
      "%92": "",
      "%93": "",
      "%94": "",
      "%95": "",
      "%96": "",
      "%97": "",
      "%98": "",
      "%99": "",
      "%9a": "",
      "%9A": "",
      "%9b": "",
      "%9B": "",
      "%9c": "",
      "%9C": "",
      "%9d": "",
      "%9D": "",
      "%9e": "",
      "%9E": "",
      "%9f": "",
      "%9F": "",
      "%a0": " ",
      "%A0": " ",
      "%a1": "¡",
      "%A1": "¡",
      "%a2": "¢",
      "%A2": "¢",
      "%a3": "£",
      "%A3": "£",
      "%a4": "¤",
      "%A4": "¤",
      "%a5": "¥",
      "%A5": "¥",
      "%a6": "¦",
      "%A6": "¦",
      "%a7": "§",
      "%A7": "§",
      "%a8": "¨",
      "%A8": "¨",
      "%a9": "©",
      "%A9": "©",
      "%aa": "ª",
      "%Aa": "ª",
      "%aA": "ª",
      "%AA": "ª",
      "%ab": "«",
      "%Ab": "«",
      "%aB": "«",
      "%AB": "«",
      "%ac": "¬",
      "%Ac": "¬",
      "%aC": "¬",
      "%AC": "¬",
      "%ad": "­",
      "%Ad": "­",
      "%aD": "­",
      "%AD": "­",
      "%ae": "®",
      "%Ae": "®",
      "%aE": "®",
      "%AE": "®",
      "%af": "¯",
      "%Af": "¯",
      "%aF": "¯",
      "%AF": "¯",
      "%b0": "°",
      "%B0": "°",
      "%b1": "±",
      "%B1": "±",
      "%b2": "²",
      "%B2": "²",
      "%b3": "³",
      "%B3": "³",
      "%b4": "´",
      "%B4": "´",
      "%b5": "µ",
      "%B5": "µ",
      "%b6": "¶",
      "%B6": "¶",
      "%b7": "·",
      "%B7": "·",
      "%b8": "¸",
      "%B8": "¸",
      "%b9": "¹",
      "%B9": "¹",
      "%ba": "º",
      "%Ba": "º",
      "%bA": "º",
      "%BA": "º",
      "%bb": "»",
      "%Bb": "»",
      "%bB": "»",
      "%BB": "»",
      "%bc": "¼",
      "%Bc": "¼",
      "%bC": "¼",
      "%BC": "¼",
      "%bd": "½",
      "%Bd": "½",
      "%bD": "½",
      "%BD": "½",
      "%be": "¾",
      "%Be": "¾",
      "%bE": "¾",
      "%BE": "¾",
      "%bf": "¿",
      "%Bf": "¿",
      "%bF": "¿",
      "%BF": "¿",
      "%c0": "À",
      "%C0": "À",
      "%c1": "Á",
      "%C1": "Á",
      "%c2": "Â",
      "%C2": "Â",
      "%c3": "Ã",
      "%C3": "Ã",
      "%c4": "Ä",
      "%C4": "Ä",
      "%c5": "Å",
      "%C5": "Å",
      "%c6": "Æ",
      "%C6": "Æ",
      "%c7": "Ç",
      "%C7": "Ç",
      "%c8": "È",
      "%C8": "È",
      "%c9": "É",
      "%C9": "É",
      "%ca": "Ê",
      "%Ca": "Ê",
      "%cA": "Ê",
      "%CA": "Ê",
      "%cb": "Ë",
      "%Cb": "Ë",
      "%cB": "Ë",
      "%CB": "Ë",
      "%cc": "Ì",
      "%Cc": "Ì",
      "%cC": "Ì",
      "%CC": "Ì",
      "%cd": "Í",
      "%Cd": "Í",
      "%cD": "Í",
      "%CD": "Í",
      "%ce": "Î",
      "%Ce": "Î",
      "%cE": "Î",
      "%CE": "Î",
      "%cf": "Ï",
      "%Cf": "Ï",
      "%cF": "Ï",
      "%CF": "Ï",
      "%d0": "Ð",
      "%D0": "Ð",
      "%d1": "Ñ",
      "%D1": "Ñ",
      "%d2": "Ò",
      "%D2": "Ò",
      "%d3": "Ó",
      "%D3": "Ó",
      "%d4": "Ô",
      "%D4": "Ô",
      "%d5": "Õ",
      "%D5": "Õ",
      "%d6": "Ö",
      "%D6": "Ö",
      "%d7": "×",
      "%D7": "×",
      "%d8": "Ø",
      "%D8": "Ø",
      "%d9": "Ù",
      "%D9": "Ù",
      "%da": "Ú",
      "%Da": "Ú",
      "%dA": "Ú",
      "%DA": "Ú",
      "%db": "Û",
      "%Db": "Û",
      "%dB": "Û",
      "%DB": "Û",
      "%dc": "Ü",
      "%Dc": "Ü",
      "%dC": "Ü",
      "%DC": "Ü",
      "%dd": "Ý",
      "%Dd": "Ý",
      "%dD": "Ý",
      "%DD": "Ý",
      "%de": "Þ",
      "%De": "Þ",
      "%dE": "Þ",
      "%DE": "Þ",
      "%df": "ß",
      "%Df": "ß",
      "%dF": "ß",
      "%DF": "ß",
      "%e0": "à",
      "%E0": "à",
      "%e1": "á",
      "%E1": "á",
      "%e2": "â",
      "%E2": "â",
      "%e3": "ã",
      "%E3": "ã",
      "%e4": "ä",
      "%E4": "ä",
      "%e5": "å",
      "%E5": "å",
      "%e6": "æ",
      "%E6": "æ",
      "%e7": "ç",
      "%E7": "ç",
      "%e8": "è",
      "%E8": "è",
      "%e9": "é",
      "%E9": "é",
      "%ea": "ê",
      "%Ea": "ê",
      "%eA": "ê",
      "%EA": "ê",
      "%eb": "ë",
      "%Eb": "ë",
      "%eB": "ë",
      "%EB": "ë",
      "%ec": "ì",
      "%Ec": "ì",
      "%eC": "ì",
      "%EC": "ì",
      "%ed": "í",
      "%Ed": "í",
      "%eD": "í",
      "%ED": "í",
      "%ee": "î",
      "%Ee": "î",
      "%eE": "î",
      "%EE": "î",
      "%ef": "ï",
      "%Ef": "ï",
      "%eF": "ï",
      "%EF": "ï",
      "%f0": "ð",
      "%F0": "ð",
      "%f1": "ñ",
      "%F1": "ñ",
      "%f2": "ò",
      "%F2": "ò",
      "%f3": "ó",
      "%F3": "ó",
      "%f4": "ô",
      "%F4": "ô",
      "%f5": "õ",
      "%F5": "õ",
      "%f6": "ö",
      "%F6": "ö",
      "%f7": "÷",
      "%F7": "÷",
      "%f8": "ø",
      "%F8": "ø",
      "%f9": "ù",
      "%F9": "ù",
      "%fa": "ú",
      "%Fa": "ú",
      "%fA": "ú",
      "%FA": "ú",
      "%fb": "û",
      "%Fb": "û",
      "%fB": "û",
      "%FB": "û",
      "%fc": "ü",
      "%Fc": "ü",
      "%fC": "ü",
      "%FC": "ü",
      "%fd": "ý",
      "%Fd": "ý",
      "%fD": "ý",
      "%FD": "ý",
      "%fe": "þ",
      "%Fe": "þ",
      "%fE": "þ",
      "%FE": "þ",
      "%ff": "ÿ",
      "%Ff": "ÿ",
      "%fF": "ÿ",
      "%FF": "ÿ",
    };
  function A8(A) {
    return Rb[A];
  }
  var PD = 0,
    Q8 = 1,
    CU = 2,
    B8 = 3;
  function Vb(A) {
    let Q = [],
      B = PD,
      I = "",
      E = !1,
      C = !1,
      g = 0,
      F = "",
      D = A.length;
    for (var J = 0; J < D; ++J) {
      let Y = A[J];
      if (Y === "\\" && E)
        if (C) C = !1;
        else {
          C = !0;
          continue;
        }
      else if (Y === '"')
        if (!C) {
          if (E) (E = !1), (B = PD);
          else E = !0;
          continue;
        } else C = !1;
      else {
        if (C && E) F += "\\";
        if (((C = !1), (B === CU || B === B8) && Y === "'")) {
          if (B === CU) (B = B8), (I = F.substring(1));
          else B = Q8;
          F = "";
          continue;
        } else if (B === PD && (Y === "*" || Y === "=") && Q.length) {
          (B = Y === "*" ? CU : Q8), (Q[g] = [F, void 0]), (F = "");
          continue;
        } else if (!E && Y === ";") {
          if (((B = PD), I)) {
            if (F.length) F = vD(F.replace(ew, A8), "binary", I);
            I = "";
          } else if (F.length) F = vD(F, "binary", "utf8");
          if (Q[g] === void 0) Q[g] = F;
          else Q[g][1] = F;
          (F = ""), ++g;
          continue;
        } else if (!E && (Y === " " || Y === "\t")) continue;
      }
      F += Y;
    }
    if (I && F.length) F = vD(F.replace(ew, A8), "binary", I);
    else if (F) F = vD(F, "binary", "utf8");
    if (Q[g] === void 0) {
      if (F) Q[g] = F;
    } else Q[g][1] = F;
    return Q;
  }
  I8.exports = Vb;
});
var C8 = Z((kVA, E8) => {
  E8.exports = function (Q) {
    if (typeof Q !== "string") return "";
    for (var B = Q.length - 1; B >= 0; --B)
      switch (Q.charCodeAt(B)) {
        case 47:
        case 92:
          return (Q = Q.slice(B + 1)), Q === ".." || Q === "." ? "" : Q;
      }
    return Q === ".." || Q === "." ? "" : Q;
  };
});
var Y8 = Z((xVA, D8) => {
  var { Readable: F8 } = $("node:stream"),
    { inherits: $b } = $("node:util"),
    Hb = IU(),
    g8 = gU(),
    Kb = xD(),
    zb = C8(),
    HC = kD(),
    Tb = /^boundary$/i,
    Ob = /^form-data$/i,
    qb = /^charset$/i,
    jb = /^filename$/i,
    fb = /^name$/i;
  _D.detect = /^multipart\/form-data/i;
  function _D(A, Q) {
    let B,
      I,
      E = this,
      C,
      g = Q.limits,
      F =
        Q.isPartAFile ||
        ((LA, EA, RA) => EA === "application/octet-stream" || RA !== void 0),
      D = Q.parsedConType || [],
      J = Q.defCharset || "utf8",
      Y = Q.preservePath,
      N = { highWaterMark: Q.fileHwm };
    for (B = 0, I = D.length; B < I; ++B)
      if (Array.isArray(D[B]) && Tb.test(D[B][0])) {
        C = D[B][1];
        break;
      }
    function W() {
      if (t === 0 && DA && !A._done) (DA = !1), E.end();
    }
    if (typeof C !== "string") throw Error("Multipart: Boundary not found");
    let X = HC(g, "fieldSize", 1048576),
      M = HC(g, "fileSize", 1 / 0),
      L = HC(g, "files", 1 / 0),
      H = HC(g, "fields", 1 / 0),
      q = HC(g, "parts", 1 / 0),
      O = HC(g, "headerPairs", 2000),
      f = HC(g, "headerSize", 81920),
      S = 0,
      r = 0,
      t = 0,
      IA,
      zA,
      DA = !1;
    (this._needDrain = !1),
      (this._pause = !1),
      (this._cb = void 0),
      (this._nparts = 0),
      (this._boy = A);
    let MA = {
      boundary: C,
      maxHeaderPairs: O,
      maxHeaderSize: f,
      partHwm: N.highWaterMark,
      highWaterMark: Q.highWaterMark,
    };
    (this.parser = new Hb(MA)),
      this.parser
        .on("drain", function () {
          if (((E._needDrain = !1), E._cb && !E._pause)) {
            let LA = E._cb;
            (E._cb = void 0), LA();
          }
        })
        .on("part", function LA(EA) {
          if (++E._nparts > q)
            return (
              E.parser.removeListener("part", LA),
              E.parser.on("part", W0),
              (A.hitPartsLimit = !0),
              A.emit("partsLimit"),
              W0(EA)
            );
          if (zA) {
            let RA = zA;
            RA.emit("end"), RA.removeAllListeners("end");
          }
          EA.on("header", function (RA) {
            let CQ,
              ZB,
              jQ,
              QE,
              fE,
              LI,
              qI = 0;
            if (RA["content-type"]) {
              if (((jQ = g8(RA["content-type"][0])), jQ[0])) {
                CQ = jQ[0].toLowerCase();
                for (B = 0, I = jQ.length; B < I; ++B)
                  if (qb.test(jQ[B][0])) {
                    QE = jQ[B][1].toLowerCase();
                    break;
                  }
              }
            }
            if (CQ === void 0) CQ = "text/plain";
            if (QE === void 0) QE = J;
            if (RA["content-disposition"]) {
              if (((jQ = g8(RA["content-disposition"][0])), !Ob.test(jQ[0])))
                return W0(EA);
              for (B = 0, I = jQ.length; B < I; ++B)
                if (fb.test(jQ[B][0])) ZB = jQ[B][1];
                else if (jb.test(jQ[B][0])) {
                  if (((LI = jQ[B][1]), !Y)) LI = zb(LI);
                }
            } else return W0(EA);
            if (RA["content-transfer-encoding"])
              fE = RA["content-transfer-encoding"][0].toLowerCase();
            else fE = "7bit";
            let hE, BE;
            if (F(ZB, CQ, LI)) {
              if (S === L) {
                if (!A.hitFilesLimit)
                  (A.hitFilesLimit = !0), A.emit("filesLimit");
                return W0(EA);
              }
              if ((++S, A.listenerCount("file") === 0)) {
                E.parser._ignore();
                return;
              }
              ++t;
              let MQ = new FU(N);
              (IA = MQ),
                MQ.on("end", function () {
                  if ((--t, (E._pause = !1), W(), E._cb && !E._needDrain)) {
                    let sB = E._cb;
                    (E._cb = void 0), sB();
                  }
                }),
                (MQ._read = function (sB) {
                  if (!E._pause) return;
                  if (((E._pause = !1), E._cb && !E._needDrain)) {
                    let RI = E._cb;
                    (E._cb = void 0), RI();
                  }
                }),
                A.emit("file", ZB, MQ, LI, fE, CQ),
                (hE = function (sB) {
                  if ((qI += sB.length) > M) {
                    let RI = M - qI + sB.length;
                    if (RI > 0) MQ.push(sB.slice(0, RI));
                    (MQ.truncated = !0),
                      (MQ.bytesRead = M),
                      EA.removeAllListeners("data"),
                      MQ.emit("limit");
                    return;
                  } else if (!MQ.push(sB)) E._pause = !0;
                  MQ.bytesRead = qI;
                }),
                (BE = function () {
                  (IA = void 0), MQ.push(null);
                });
            } else {
              if (r === H) {
                if (!A.hitFieldsLimit)
                  (A.hitFieldsLimit = !0), A.emit("fieldsLimit");
                return W0(EA);
              }
              ++r, ++t;
              let MQ = "",
                sB = !1;
              (zA = EA),
                (hE = function (RI) {
                  if ((qI += RI.length) > X) {
                    let HG = X - (qI - RI.length);
                    (MQ += RI.toString("binary", 0, HG)),
                      (sB = !0),
                      EA.removeAllListeners("data");
                  } else MQ += RI.toString("binary");
                }),
                (BE = function () {
                  if (((zA = void 0), MQ.length)) MQ = Kb(MQ, "binary", QE);
                  A.emit("field", ZB, MQ, !1, sB, fE, CQ), --t, W();
                });
            }
            (EA._readableState.sync = !1), EA.on("data", hE), EA.on("end", BE);
          }).on("error", function (RA) {
            if (IA) IA.emit("error", RA);
          });
        })
        .on("error", function (LA) {
          A.emit("error", LA);
        })
        .on("finish", function () {
          (DA = !0), W();
        });
  }
  _D.prototype.write = function (A, Q) {
    let B = this.parser.write(A);
    if (B && !this._pause) Q();
    else (this._needDrain = !B), (this._cb = Q);
  };
  _D.prototype.end = function () {
    let A = this;
    if (A.parser.writable) A.parser.end();
    else if (!A._boy._done)
      process.nextTick(function () {
        (A._boy._done = !0), A._boy.emit("finish");
      });
  };
  function W0(A) {
    A.resume();
  }
  function FU(A) {
    F8.call(this, A), (this.bytesRead = 0), (this.truncated = !1);
  }
  $b(FU, F8);
  FU.prototype._read = function (A) {};
  D8.exports = _D;
});
var N8 = Z((vVA, J8) => {
  var hb = /\+/g,
    kb = [
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1,
      1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1,
      1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0,
    ];
  function DU() {
    this.buffer = void 0;
  }
  DU.prototype.write = function (A) {
    A = A.replace(hb, " ");
    let Q = "",
      B = 0,
      I = 0,
      E = A.length;
    for (; B < E; ++B)
      if (this.buffer !== void 0) {
        if (!kb[A.charCodeAt(B)])
          (Q += "%" + this.buffer), (this.buffer = void 0), --B;
        else if (((this.buffer += A[B]), ++I, this.buffer.length === 2))
          (Q += String.fromCharCode(parseInt(this.buffer, 16))),
            (this.buffer = void 0);
      } else if (A[B] === "%") {
        if (B > I) (Q += A.substring(I, B)), (I = B);
        (this.buffer = ""), ++I;
      }
    if (I < E && this.buffer === void 0) Q += A.substring(I);
    return Q;
  };
  DU.prototype.reset = function () {
    this.buffer = void 0;
  };
  J8.exports = DU;
});
var U8 = Z((PVA, G8) => {
  var xb = N8(),
    Z0 = xD(),
    YU = kD(),
    vb = /^charset$/i;
  yD.detect = /^application\/x-www-form-urlencoded/i;
  function yD(A, Q) {
    let { limits: B, parsedConType: I } = Q;
    (this.boy = A),
      (this.fieldSizeLimit = YU(B, "fieldSize", 1048576)),
      (this.fieldNameSizeLimit = YU(B, "fieldNameSize", 100)),
      (this.fieldsLimit = YU(B, "fields", 1 / 0));
    let E;
    for (var C = 0, g = I.length; C < g; ++C)
      if (Array.isArray(I[C]) && vb.test(I[C][0])) {
        E = I[C][1].toLowerCase();
        break;
      }
    if (E === void 0) E = Q.defCharset || "utf8";
    (this.decoder = new xb()),
      (this.charset = E),
      (this._fields = 0),
      (this._state = "key"),
      (this._checkingBytes = !0),
      (this._bytesKey = 0),
      (this._bytesVal = 0),
      (this._key = ""),
      (this._val = ""),
      (this._keyTrunc = !1),
      (this._valTrunc = !1),
      (this._hitLimit = !1);
  }
  yD.prototype.write = function (A, Q) {
    if (this._fields === this.fieldsLimit) {
      if (!this.boy.hitFieldsLimit)
        (this.boy.hitFieldsLimit = !0), this.boy.emit("fieldsLimit");
      return Q();
    }
    let B,
      I,
      E,
      C = 0,
      g = A.length;
    while (C < g)
      if (this._state === "key") {
        B = I = void 0;
        for (E = C; E < g; ++E) {
          if (!this._checkingBytes) ++C;
          if (A[E] === 61) {
            B = E;
            break;
          } else if (A[E] === 38) {
            I = E;
            break;
          }
          if (
            this._checkingBytes &&
            this._bytesKey === this.fieldNameSizeLimit
          ) {
            this._hitLimit = !0;
            break;
          } else if (this._checkingBytes) ++this._bytesKey;
        }
        if (B !== void 0) {
          if (B > C)
            this._key += this.decoder.write(A.toString("binary", C, B));
          (this._state = "val"),
            (this._hitLimit = !1),
            (this._checkingBytes = !0),
            (this._val = ""),
            (this._bytesVal = 0),
            (this._valTrunc = !1),
            this.decoder.reset(),
            (C = B + 1);
        } else if (I !== void 0) {
          ++this._fields;
          let F,
            D = this._keyTrunc;
          if (I > C)
            F = this._key += this.decoder.write(A.toString("binary", C, I));
          else F = this._key;
          if (
            ((this._hitLimit = !1),
            (this._checkingBytes = !0),
            (this._key = ""),
            (this._bytesKey = 0),
            (this._keyTrunc = !1),
            this.decoder.reset(),
            F.length)
          )
            this.boy.emit("field", Z0(F, "binary", this.charset), "", D, !1);
          if (((C = I + 1), this._fields === this.fieldsLimit)) return Q();
        } else if (this._hitLimit) {
          if (E > C)
            this._key += this.decoder.write(A.toString("binary", C, E));
          if (
            ((C = E),
            (this._bytesKey = this._key.length) === this.fieldNameSizeLimit)
          )
            (this._checkingBytes = !1), (this._keyTrunc = !0);
        } else {
          if (C < g) this._key += this.decoder.write(A.toString("binary", C));
          C = g;
        }
      } else {
        I = void 0;
        for (E = C; E < g; ++E) {
          if (!this._checkingBytes) ++C;
          if (A[E] === 38) {
            I = E;
            break;
          }
          if (this._checkingBytes && this._bytesVal === this.fieldSizeLimit) {
            this._hitLimit = !0;
            break;
          } else if (this._checkingBytes) ++this._bytesVal;
        }
        if (I !== void 0) {
          if ((++this._fields, I > C))
            this._val += this.decoder.write(A.toString("binary", C, I));
          if (
            (this.boy.emit(
              "field",
              Z0(this._key, "binary", this.charset),
              Z0(this._val, "binary", this.charset),
              this._keyTrunc,
              this._valTrunc,
            ),
            (this._state = "key"),
            (this._hitLimit = !1),
            (this._checkingBytes = !0),
            (this._key = ""),
            (this._bytesKey = 0),
            (this._keyTrunc = !1),
            this.decoder.reset(),
            (C = I + 1),
            this._fields === this.fieldsLimit)
          )
            return Q();
        } else if (this._hitLimit) {
          if (E > C)
            this._val += this.decoder.write(A.toString("binary", C, E));
          if (
            ((C = E),
            (this._val === "" && this.fieldSizeLimit === 0) ||
              (this._bytesVal = this._val.length) === this.fieldSizeLimit)
          )
            (this._checkingBytes = !1), (this._valTrunc = !0);
        } else {
          if (C < g) this._val += this.decoder.write(A.toString("binary", C));
          C = g;
        }
      }
    Q();
  };
  yD.prototype.end = function () {
    if (this.boy._done) return;
    if (this._state === "key" && this._key.length > 0)
      this.boy.emit(
        "field",
        Z0(this._key, "binary", this.charset),
        "",
        this._keyTrunc,
        !1,
      );
    else if (this._state === "val")
      this.boy.emit(
        "field",
        Z0(this._key, "binary", this.charset),
        Z0(this._val, "binary", this.charset),
        this._keyTrunc,
        this._valTrunc,
      );
    (this.boy._done = !0), this.boy.emit("finish");
  };
  G8.exports = yD;
});
var X8 = Z((_VA, dg) => {
  var JU = $("node:stream").Writable,
    { inherits: Pb } = $("node:util"),
    _b = IU(),
    W8 = Y8(),
    Z8 = U8(),
    yb = gU();
  function EE(A) {
    if (!(this instanceof EE)) return new EE(A);
    if (typeof A !== "object")
      throw TypeError("Busboy expected an options-Object.");
    if (typeof A.headers !== "object")
      throw TypeError(
        "Busboy expected an options-Object with headers-attribute.",
      );
    if (typeof A.headers["content-type"] !== "string")
      throw TypeError("Missing Content-Type-header.");
    let { headers: Q, ...B } = A;
    (this.opts = { autoDestroy: !1, ...B }),
      JU.call(this, this.opts),
      (this._done = !1),
      (this._parser = this.getParserByHeaders(Q)),
      (this._finished = !1);
  }
  Pb(EE, JU);
  EE.prototype.emit = function (A) {
    if (A === "finish") {
      if (!this._done) {
        this._parser?.end();
        return;
      } else if (this._finished) return;
      this._finished = !0;
    }
    JU.prototype.emit.apply(this, arguments);
  };
  EE.prototype.getParserByHeaders = function (A) {
    let Q = yb(A["content-type"]),
      B = {
        defCharset: this.opts.defCharset,
        fileHwm: this.opts.fileHwm,
        headers: A,
        highWaterMark: this.opts.highWaterMark,
        isPartAFile: this.opts.isPartAFile,
        limits: this.opts.limits,
        parsedConType: Q,
        preservePath: this.opts.preservePath,
      };
    if (W8.detect.test(Q[0])) return new W8(this, B);
    if (Z8.detect.test(Q[0])) return new Z8(this, B);
    throw Error("Unsupported Content-Type.");
  };
  EE.prototype._write = function (A, Q, B) {
    this._parser.write(A, B);
  };
  dg.exports = EE;
  dg.exports.default = EE;
  dg.exports.Busboy = EE;
  dg.exports.Dicer = _b;
});
var yE = Z((yVA, K8) => {
  var { MessageChannel: Sb, receiveMessageOnPort: bb } = $("worker_threads"),
    w8 = ["GET", "HEAD", "POST"],
    mb = new Set(w8),
    db = [101, 204, 205, 304],
    M8 = [301, 302, 303, 307, 308],
    cb = new Set(M8),
    L8 = [
      "1",
      "7",
      "9",
      "11",
      "13",
      "15",
      "17",
      "19",
      "20",
      "21",
      "22",
      "23",
      "25",
      "37",
      "42",
      "43",
      "53",
      "69",
      "77",
      "79",
      "87",
      "95",
      "101",
      "102",
      "103",
      "104",
      "109",
      "110",
      "111",
      "113",
      "115",
      "117",
      "119",
      "123",
      "135",
      "137",
      "139",
      "143",
      "161",
      "179",
      "389",
      "427",
      "465",
      "512",
      "513",
      "514",
      "515",
      "526",
      "530",
      "531",
      "532",
      "540",
      "548",
      "554",
      "556",
      "563",
      "587",
      "601",
      "636",
      "989",
      "990",
      "993",
      "995",
      "1719",
      "1720",
      "1723",
      "2049",
      "3659",
      "4045",
      "5060",
      "5061",
      "6000",
      "6566",
      "6665",
      "6666",
      "6667",
      "6668",
      "6669",
      "6697",
      "10080",
    ],
    ub = new Set(L8),
    R8 = [
      "",
      "no-referrer",
      "no-referrer-when-downgrade",
      "same-origin",
      "origin",
      "strict-origin",
      "origin-when-cross-origin",
      "strict-origin-when-cross-origin",
      "unsafe-url",
    ],
    lb = new Set(R8),
    pb = ["follow", "manual", "error"],
    V8 = ["GET", "HEAD", "OPTIONS", "TRACE"],
    ib = new Set(V8),
    nb = ["navigate", "same-origin", "no-cors", "cors"],
    ab = ["omit", "same-origin", "include"],
    ob = [
      "default",
      "no-store",
      "reload",
      "no-cache",
      "force-cache",
      "only-if-cached",
    ],
    sb = [
      "content-encoding",
      "content-language",
      "content-location",
      "content-type",
      "content-length",
    ],
    rb = ["half"],
    $8 = ["CONNECT", "TRACE", "TRACK"],
    tb = new Set($8),
    H8 = [
      "audio",
      "audioworklet",
      "font",
      "image",
      "manifest",
      "paintworklet",
      "script",
      "style",
      "track",
      "video",
      "xslt",
      "",
    ],
    eb = new Set(H8),
    Am =
      globalThis.DOMException ??
      (() => {
        try {
          atob("~");
        } catch (A) {
          return Object.getPrototypeOf(A).constructor;
        }
      })(),
    X0,
    Qm =
      globalThis.structuredClone ??
      function (Q, B = void 0) {
        if (arguments.length === 0) throw TypeError("missing argument");
        if (!X0) X0 = new Sb();
        return (
          X0.port1.unref(),
          X0.port2.unref(),
          X0.port1.postMessage(Q, B?.transfer),
          bb(X0.port2).message
        );
      };
  K8.exports = {
    DOMException: Am,
    structuredClone: Qm,
    subresource: H8,
    forbiddenMethods: $8,
    requestBodyHeader: sb,
    referrerPolicy: R8,
    requestRedirect: pb,
    requestMode: nb,
    requestCredentials: ab,
    requestCache: ob,
    redirectStatus: M8,
    corsSafeListedMethods: w8,
    nullBodyStatus: db,
    safeMethods: V8,
    badPorts: L8,
    requestDuplex: rb,
    subresourceSet: eb,
    badPortsSet: ub,
    redirectStatusSet: cb,
    corsSafeListedMethodsSet: mb,
    safeMethodsSet: ib,
    forbiddenMethodsSet: tb,
    referrerPolicySet: lb,
  };
});
var w0 = Z((SVA, z8) => {
  var NU = Symbol.for("undici.globalOrigin.1");
  function Bm() {
    return globalThis[NU];
  }
  function Im(A) {
    if (A === void 0) {
      Object.defineProperty(globalThis, NU, {
        value: void 0,
        writable: !0,
        enumerable: !1,
        configurable: !1,
      });
      return;
    }
    let Q = new URL(A);
    if (Q.protocol !== "http:" && Q.protocol !== "https:")
      throw TypeError(
        `Only http & https urls are allowed, received ${Q.protocol}`,
      );
    Object.defineProperty(globalThis, NU, {
      value: Q,
      writable: !0,
      enumerable: !1,
      configurable: !1,
    });
  }
  z8.exports = { getGlobalOrigin: Bm, setGlobalOrigin: Im };
});
var AI = Z((bVA, x8) => {
  var { redirectStatusSet: Em, referrerPolicySet: Cm, badPortsSet: gm } = yE(),
    { getGlobalOrigin: Fm } = w0(),
    { performance: Dm } = $("perf_hooks"),
    { isBlobLike: Ym, toUSVString: Jm, ReadableStreamFrom: Nm } = HA(),
    M0 = $("assert"),
    { isUint8Array: Gm } = $("util/types"),
    T8 = [],
    SD;
  try {
    SD = $("crypto");
    let A = ["sha256", "sha384", "sha512"];
    T8 = SD.getHashes().filter((Q) => A.includes(Q));
  } catch {}
  function O8(A) {
    let Q = A.urlList,
      B = Q.length;
    return B === 0 ? null : Q[B - 1].toString();
  }
  function Um(A, Q) {
    if (!Em.has(A.status)) return null;
    let B = A.headersList.get("location");
    if (B !== null && j8(B)) B = new URL(B, O8(A));
    if (B && !B.hash) B.hash = Q;
    return B;
  }
  function ug(A) {
    return A.urlList[A.urlList.length - 1];
  }
  function Wm(A) {
    let Q = ug(A);
    if (k8(Q) && gm.has(Q.port)) return "blocked";
    return "allowed";
  }
  function Zm(A) {
    return (
      A instanceof Error ||
      A?.constructor?.name === "Error" ||
      A?.constructor?.name === "DOMException"
    );
  }
  function Xm(A) {
    for (let Q = 0; Q < A.length; ++Q) {
      let B = A.charCodeAt(Q);
      if (!(B === 9 || (B >= 32 && B <= 126) || (B >= 128 && B <= 255)))
        return !1;
    }
    return !0;
  }
  function wm(A) {
    switch (A) {
      case 34:
      case 40:
      case 41:
      case 44:
      case 47:
      case 58:
      case 59:
      case 60:
      case 61:
      case 62:
      case 63:
      case 64:
      case 91:
      case 92:
      case 93:
      case 123:
      case 125:
        return !1;
      default:
        return A >= 33 && A <= 126;
    }
  }
  function q8(A) {
    if (A.length === 0) return !1;
    for (let Q = 0; Q < A.length; ++Q) if (!wm(A.charCodeAt(Q))) return !1;
    return !0;
  }
  function Mm(A) {
    return q8(A);
  }
  function j8(A) {
    if (
      A.startsWith("\t") ||
      A.startsWith(" ") ||
      A.endsWith("\t") ||
      A.endsWith(" ")
    )
      return !1;
    if (
      A.includes("\x00") ||
      A.includes("\r") ||
      A.includes(`
`)
    )
      return !1;
    return !0;
  }
  function Lm(A, Q) {
    let { headersList: B } = Q,
      I = (B.get("referrer-policy") ?? "").split(","),
      E = "";
    if (I.length > 0)
      for (let C = I.length; C !== 0; C--) {
        let g = I[C - 1].trim();
        if (Cm.has(g)) {
          E = g;
          break;
        }
      }
    if (E !== "") A.referrerPolicy = E;
  }
  function Rm() {
    return "allowed";
  }
  function Vm() {
    return "success";
  }
  function $m() {
    return "success";
  }
  function Hm(A) {
    let Q = null;
    (Q = A.mode), A.headersList.set("sec-fetch-mode", Q);
  }
  function Km(A) {
    let Q = A.origin;
    if (A.responseTainting === "cors" || A.mode === "websocket") {
      if (Q) A.headersList.append("origin", Q);
    } else if (A.method !== "GET" && A.method !== "HEAD") {
      switch (A.referrerPolicy) {
        case "no-referrer":
          Q = null;
          break;
        case "no-referrer-when-downgrade":
        case "strict-origin":
        case "strict-origin-when-cross-origin":
          if (A.origin && WU(A.origin) && !WU(ug(A))) Q = null;
          break;
        case "same-origin":
          if (!bD(A, ug(A))) Q = null;
          break;
        default:
      }
      if (Q) A.headersList.append("origin", Q);
    }
  }
  function zm(A) {
    return Dm.now();
  }
  function Tm(A) {
    return {
      startTime: A.startTime ?? 0,
      redirectStartTime: 0,
      redirectEndTime: 0,
      postRedirectStartTime: A.startTime ?? 0,
      finalServiceWorkerStartTime: 0,
      finalNetworkResponseStartTime: 0,
      finalNetworkRequestStartTime: 0,
      endTime: 0,
      encodedBodySize: 0,
      decodedBodySize: 0,
      finalConnectionTimingInfo: null,
    };
  }
  function Om() {
    return { referrerPolicy: "strict-origin-when-cross-origin" };
  }
  function qm(A) {
    return { referrerPolicy: A.referrerPolicy };
  }
  function jm(A) {
    let Q = A.referrerPolicy;
    M0(Q);
    let B = null;
    if (A.referrer === "client") {
      let F = Fm();
      if (!F || F.origin === "null") return "no-referrer";
      B = new URL(F);
    } else if (A.referrer instanceof URL) B = A.referrer;
    let I = GU(B),
      E = GU(B, !0);
    if (I.toString().length > 4096) I = E;
    let C = bD(A, I),
      g = cg(I) && !cg(A.url);
    switch (Q) {
      case "origin":
        return E != null ? E : GU(B, !0);
      case "unsafe-url":
        return I;
      case "same-origin":
        return C ? E : "no-referrer";
      case "origin-when-cross-origin":
        return C ? I : E;
      case "strict-origin-when-cross-origin": {
        let F = ug(A);
        if (bD(I, F)) return I;
        if (cg(I) && !cg(F)) return "no-referrer";
        return E;
      }
      case "strict-origin":
      case "no-referrer-when-downgrade":
      default:
        return g ? "no-referrer" : E;
    }
  }
  function GU(A, Q) {
    if (
      (M0(A instanceof URL),
      A.protocol === "file:" ||
        A.protocol === "about:" ||
        A.protocol === "blank:")
    )
      return "no-referrer";
    if (((A.username = ""), (A.password = ""), (A.hash = ""), Q))
      (A.pathname = ""), (A.search = "");
    return A;
  }
  function cg(A) {
    if (!(A instanceof URL)) return !1;
    if (A.href === "about:blank" || A.href === "about:srcdoc") return !0;
    if (A.protocol === "data:") return !0;
    if (A.protocol === "file:") return !0;
    return Q(A.origin);
    function Q(B) {
      if (B == null || B === "null") return !1;
      let I = new URL(B);
      if (I.protocol === "https:" || I.protocol === "wss:") return !0;
      if (
        /^127(?:\.[0-9]+){0,2}\.[0-9]+$|^\[(?:0*:)*?:?0*1\]$/.test(
          I.hostname,
        ) ||
        I.hostname === "localhost" ||
        I.hostname.includes("localhost.") ||
        I.hostname.endsWith(".localhost")
      )
        return !0;
      return !1;
    }
  }
  function fm(A, Q) {
    if (SD === void 0) return !0;
    let B = f8(Q);
    if (B === "no metadata") return !0;
    if (B.length === 0) return !0;
    let I = km(B),
      E = xm(B, I);
    for (let C of E) {
      let { algo: g, hash: F } = C,
        D = SD.createHash(g).update(A).digest("base64");
      if (D[D.length - 1] === "=")
        if (D[D.length - 2] === "=") D = D.slice(0, -2);
        else D = D.slice(0, -1);
      if (vm(D, F)) return !0;
    }
    return !1;
  }
  var hm =
    /(?<algo>sha256|sha384|sha512)-((?<hash>[A-Za-z0-9+/]+|[A-Za-z0-9_-]+)={0,2}(?:\s|$)( +[!-~]*)?)?/i;
  function f8(A) {
    let Q = [],
      B = !0;
    for (let I of A.split(" ")) {
      B = !1;
      let E = hm.exec(I);
      if (E === null || E.groups === void 0 || E.groups.algo === void 0)
        continue;
      let C = E.groups.algo.toLowerCase();
      if (T8.includes(C)) Q.push(E.groups);
    }
    if (B === !0) return "no metadata";
    return Q;
  }
  function km(A) {
    let Q = A[0].algo;
    if (Q[3] === "5") return Q;
    for (let B = 1; B < A.length; ++B) {
      let I = A[B];
      if (I.algo[3] === "5") {
        Q = "sha512";
        break;
      } else if (Q[3] === "3") continue;
      else if (I.algo[3] === "3") Q = "sha384";
    }
    return Q;
  }
  function xm(A, Q) {
    if (A.length === 1) return A;
    let B = 0;
    for (let I = 0; I < A.length; ++I) if (A[I].algo === Q) A[B++] = A[I];
    return (A.length = B), A;
  }
  function vm(A, Q) {
    if (A.length !== Q.length) return !1;
    for (let B = 0; B < A.length; ++B)
      if (A[B] !== Q[B]) {
        if ((A[B] === "+" && Q[B] === "-") || (A[B] === "/" && Q[B] === "_"))
          continue;
        return !1;
      }
    return !0;
  }
  function Pm(A) {}
  function bD(A, Q) {
    if (A.origin === Q.origin && A.origin === "null") return !0;
    if (
      A.protocol === Q.protocol &&
      A.hostname === Q.hostname &&
      A.port === Q.port
    )
      return !0;
    return !1;
  }
  function _m() {
    let A, Q;
    return {
      promise: new Promise((I, E) => {
        (A = I), (Q = E);
      }),
      resolve: A,
      reject: Q,
    };
  }
  function ym(A) {
    return A.controller.state === "aborted";
  }
  function Sm(A) {
    return (
      A.controller.state === "aborted" || A.controller.state === "terminated"
    );
  }
  var ZU = {
    delete: "DELETE",
    DELETE: "DELETE",
    get: "GET",
    GET: "GET",
    head: "HEAD",
    HEAD: "HEAD",
    options: "OPTIONS",
    OPTIONS: "OPTIONS",
    post: "POST",
    POST: "POST",
    put: "PUT",
    PUT: "PUT",
  };
  Object.setPrototypeOf(ZU, null);
  function bm(A) {
    return ZU[A.toLowerCase()] ?? A;
  }
  function mm(A) {
    let Q = JSON.stringify(A);
    if (Q === void 0) throw TypeError("Value is not JSON serializable");
    return M0(typeof Q === "string"), Q;
  }
  var dm = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
  function cm(A, Q, B) {
    let I = { index: 0, kind: B, target: A },
      E = {
        next() {
          if (Object.getPrototypeOf(this) !== E)
            throw TypeError(
              `'next' called on an object that does not implement interface ${Q} Iterator.`,
            );
          let { index: C, kind: g, target: F } = I,
            D = F(),
            J = D.length;
          if (C >= J) return { value: void 0, done: !0 };
          let Y = D[C];
          return (I.index = C + 1), um(Y, g);
        },
        [Symbol.toStringTag]: `${Q} Iterator`,
      };
    return Object.setPrototypeOf(E, dm), Object.setPrototypeOf({}, E);
  }
  function um(A, Q) {
    let B;
    switch (Q) {
      case "key": {
        B = A[0];
        break;
      }
      case "value": {
        B = A[1];
        break;
      }
      case "key+value": {
        B = A;
        break;
      }
    }
    return { value: B, done: !1 };
  }
  async function lm(A, Q, B) {
    let I = Q,
      E = B,
      C;
    try {
      C = A.stream.getReader();
    } catch (g) {
      E(g);
      return;
    }
    try {
      let g = await h8(C);
      I(g);
    } catch (g) {
      E(g);
    }
  }
  var UU = globalThis.ReadableStream;
  function pm(A) {
    if (!UU) UU = $("stream/web").ReadableStream;
    return (
      A instanceof UU ||
      (A[Symbol.toStringTag] === "ReadableStream" &&
        typeof A.tee === "function")
    );
  }
  var im = 65535;
  function nm(A) {
    if (A.length < im) return String.fromCharCode(...A);
    return A.reduce((Q, B) => Q + String.fromCharCode(B), "");
  }
  function am(A) {
    try {
      A.close();
    } catch (Q) {
      if (!Q.message.includes("Controller is already closed")) throw Q;
    }
  }
  function om(A) {
    for (let Q = 0; Q < A.length; Q++) M0(A.charCodeAt(Q) <= 255);
    return A;
  }
  async function h8(A) {
    let Q = [],
      B = 0;
    while (!0) {
      let { done: I, value: E } = await A.read();
      if (I) return Buffer.concat(Q, B);
      if (!Gm(E)) throw TypeError("Received non-Uint8Array chunk");
      Q.push(E), (B += E.length);
    }
  }
  function sm(A) {
    M0("protocol" in A);
    let Q = A.protocol;
    return Q === "about:" || Q === "blob:" || Q === "data:";
  }
  function WU(A) {
    if (typeof A === "string") return A.startsWith("https:");
    return A.protocol === "https:";
  }
  function k8(A) {
    M0("protocol" in A);
    let Q = A.protocol;
    return Q === "http:" || Q === "https:";
  }
  var rm =
    Object.hasOwn || ((A, Q) => Object.prototype.hasOwnProperty.call(A, Q));
  x8.exports = {
    isAborted: ym,
    isCancelled: Sm,
    createDeferredPromise: _m,
    ReadableStreamFrom: Nm,
    toUSVString: Jm,
    tryUpgradeRequestToAPotentiallyTrustworthyURL: Pm,
    coarsenedSharedCurrentTime: zm,
    determineRequestsReferrer: jm,
    makePolicyContainer: Om,
    clonePolicyContainer: qm,
    appendFetchMetadata: Hm,
    appendRequestOriginHeader: Km,
    TAOCheck: $m,
    corsCheck: Vm,
    crossOriginResourcePolicyCheck: Rm,
    createOpaqueTimingInfo: Tm,
    setRequestReferrerPolicyOnRedirect: Lm,
    isValidHTTPToken: q8,
    requestBadPort: Wm,
    requestCurrentURL: ug,
    responseURL: O8,
    responseLocationURL: Um,
    isBlobLike: Ym,
    isURLPotentiallyTrustworthy: cg,
    isValidReasonPhrase: Xm,
    sameOrigin: bD,
    normalizeMethod: bm,
    serializeJavascriptValueToJSONString: mm,
    makeIterator: cm,
    isValidHeaderName: Mm,
    isValidHeaderValue: j8,
    hasOwn: rm,
    isErrorLike: Zm,
    fullyReadBody: lm,
    bytesMatch: fm,
    isReadableStreamLike: pm,
    readableStreamClose: am,
    isomorphicEncode: om,
    isomorphicDecode: nm,
    urlIsLocal: sm,
    urlHasHttpsScheme: WU,
    urlIsHttpHttpsScheme: k8,
    readAllBytes: h8,
    normalizeMethodRecord: ZU,
    parseMetadata: f8,
  };
});
var CE = Z((mVA, v8) => {
  v8.exports = {
    kUrl: Symbol("url"),
    kHeaders: Symbol("headers"),
    kSignal: Symbol("signal"),
    kState: Symbol("state"),
    kGuard: Symbol("guard"),
    kRealm: Symbol("realm"),
  };
});
var EB = Z((dVA, _8) => {
  var { types: fI } = $("util"),
    { hasOwn: P8, toUSVString: tm } = AI(),
    m = {};
  m.converters = {};
  m.util = {};
  m.errors = {};
  m.errors.exception = function (A) {
    return TypeError(`${A.header}: ${A.message}`);
  };
  m.errors.conversionFailed = function (A) {
    let Q = A.types.length === 1 ? "" : " one of",
      B = `${A.argument} could not be converted to${Q}: ${A.types.join(", ")}.`;
    return m.errors.exception({ header: A.prefix, message: B });
  };
  m.errors.invalidArgument = function (A) {
    return m.errors.exception({
      header: A.prefix,
      message: `"${A.value}" is an invalid ${A.type}.`,
    });
  };
  m.brandCheck = function (A, Q, B = void 0) {
    if (B?.strict !== !1 && !(A instanceof Q))
      throw TypeError("Illegal invocation");
    else return A?.[Symbol.toStringTag] === Q.prototype[Symbol.toStringTag];
  };
  m.argumentLengthCheck = function ({ length: A }, Q, B) {
    if (A < Q)
      throw m.errors.exception({
        message: `${Q} argument${Q !== 1 ? "s" : ""} required, but${A ? " only" : ""} ${A} found.`,
        ...B,
      });
  };
  m.illegalConstructor = function () {
    throw m.errors.exception({
      header: "TypeError",
      message: "Illegal constructor",
    });
  };
  m.util.Type = function (A) {
    switch (typeof A) {
      case "undefined":
        return "Undefined";
      case "boolean":
        return "Boolean";
      case "string":
        return "String";
      case "symbol":
        return "Symbol";
      case "number":
        return "Number";
      case "bigint":
        return "BigInt";
      case "function":
      case "object": {
        if (A === null) return "Null";
        return "Object";
      }
    }
  };
  m.util.ConvertToInt = function (A, Q, B, I = {}) {
    let E, C;
    if (Q === 64)
      if (((E = Math.pow(2, 53) - 1), B === "unsigned")) C = 0;
      else C = Math.pow(-2, 53) + 1;
    else if (B === "unsigned") (C = 0), (E = Math.pow(2, Q) - 1);
    else (C = Math.pow(-2, Q) - 1), (E = Math.pow(2, Q - 1) - 1);
    let g = Number(A);
    if (g === 0) g = 0;
    if (I.enforceRange === !0) {
      if (
        Number.isNaN(g) ||
        g === Number.POSITIVE_INFINITY ||
        g === Number.NEGATIVE_INFINITY
      )
        throw m.errors.exception({
          header: "Integer conversion",
          message: `Could not convert ${A} to an integer.`,
        });
      if (((g = m.util.IntegerPart(g)), g < C || g > E))
        throw m.errors.exception({
          header: "Integer conversion",
          message: `Value must be between ${C}-${E}, got ${g}.`,
        });
      return g;
    }
    if (!Number.isNaN(g) && I.clamp === !0) {
      if (((g = Math.min(Math.max(g, C), E)), Math.floor(g) % 2 === 0))
        g = Math.floor(g);
      else g = Math.ceil(g);
      return g;
    }
    if (
      Number.isNaN(g) ||
      (g === 0 && Object.is(0, g)) ||
      g === Number.POSITIVE_INFINITY ||
      g === Number.NEGATIVE_INFINITY
    )
      return 0;
    if (
      ((g = m.util.IntegerPart(g)),
      (g = g % Math.pow(2, Q)),
      B === "signed" && g >= Math.pow(2, Q) - 1)
    )
      return g - Math.pow(2, Q);
    return g;
  };
  m.util.IntegerPart = function (A) {
    let Q = Math.floor(Math.abs(A));
    if (A < 0) return -1 * Q;
    return Q;
  };
  m.sequenceConverter = function (A) {
    return (Q) => {
      if (m.util.Type(Q) !== "Object")
        throw m.errors.exception({
          header: "Sequence",
          message: `Value of type ${m.util.Type(Q)} is not an Object.`,
        });
      let B = Q?.[Symbol.iterator]?.(),
        I = [];
      if (B === void 0 || typeof B.next !== "function")
        throw m.errors.exception({
          header: "Sequence",
          message: "Object is not an iterator.",
        });
      while (!0) {
        let { done: E, value: C } = B.next();
        if (E) break;
        I.push(A(C));
      }
      return I;
    };
  };
  m.recordConverter = function (A, Q) {
    return (B) => {
      if (m.util.Type(B) !== "Object")
        throw m.errors.exception({
          header: "Record",
          message: `Value of type ${m.util.Type(B)} is not an Object.`,
        });
      let I = {};
      if (!fI.isProxy(B)) {
        let C = Object.keys(B);
        for (let g of C) {
          let F = A(g),
            D = Q(B[g]);
          I[F] = D;
        }
        return I;
      }
      let E = Reflect.ownKeys(B);
      for (let C of E)
        if (Reflect.getOwnPropertyDescriptor(B, C)?.enumerable) {
          let F = A(C),
            D = Q(B[C]);
          I[F] = D;
        }
      return I;
    };
  };
  m.interfaceConverter = function (A) {
    return (Q, B = {}) => {
      if (B.strict !== !1 && !(Q instanceof A))
        throw m.errors.exception({
          header: A.name,
          message: `Expected ${Q} to be an instance of ${A.name}.`,
        });
      return Q;
    };
  };
  m.dictionaryConverter = function (A) {
    return (Q) => {
      let B = m.util.Type(Q),
        I = {};
      if (B === "Null" || B === "Undefined") return I;
      else if (B !== "Object")
        throw m.errors.exception({
          header: "Dictionary",
          message: `Expected ${Q} to be one of: Null, Undefined, Object.`,
        });
      for (let E of A) {
        let { key: C, defaultValue: g, required: F, converter: D } = E;
        if (F === !0) {
          if (!P8(Q, C))
            throw m.errors.exception({
              header: "Dictionary",
              message: `Missing required key "${C}".`,
            });
        }
        let J = Q[C],
          Y = P8(E, "defaultValue");
        if (Y && J !== null) J = J ?? g;
        if (F || Y || J !== void 0) {
          if (((J = D(J)), E.allowedValues && !E.allowedValues.includes(J)))
            throw m.errors.exception({
              header: "Dictionary",
              message: `${J} is not an accepted type. Expected one of ${E.allowedValues.join(", ")}.`,
            });
          I[C] = J;
        }
      }
      return I;
    };
  };
  m.nullableConverter = function (A) {
    return (Q) => {
      if (Q === null) return Q;
      return A(Q);
    };
  };
  m.converters.DOMString = function (A, Q = {}) {
    if (A === null && Q.legacyNullToEmptyString) return "";
    if (typeof A === "symbol")
      throw TypeError("Could not convert argument of type symbol to string.");
    return String(A);
  };
  m.converters.ByteString = function (A) {
    let Q = m.converters.DOMString(A);
    for (let B = 0; B < Q.length; B++)
      if (Q.charCodeAt(B) > 255)
        throw TypeError(
          `Cannot convert argument to a ByteString because the character at index ${B} has a value of ${Q.charCodeAt(B)} which is greater than 255.`,
        );
    return Q;
  };
  m.converters.USVString = tm;
  m.converters.boolean = function (A) {
    return Boolean(A);
  };
  m.converters.any = function (A) {
    return A;
  };
  m.converters["long long"] = function (A) {
    return m.util.ConvertToInt(A, 64, "signed");
  };
  m.converters["unsigned long long"] = function (A) {
    return m.util.ConvertToInt(A, 64, "unsigned");
  };
  m.converters["unsigned long"] = function (A) {
    return m.util.ConvertToInt(A, 32, "unsigned");
  };
  m.converters["unsigned short"] = function (A, Q) {
    return m.util.ConvertToInt(A, 16, "unsigned", Q);
  };
  m.converters.ArrayBuffer = function (A, Q = {}) {
    if (m.util.Type(A) !== "Object" || !fI.isAnyArrayBuffer(A))
      throw m.errors.conversionFailed({
        prefix: `${A}`,
        argument: `${A}`,
        types: ["ArrayBuffer"],
      });
    if (Q.allowShared === !1 && fI.isSharedArrayBuffer(A))
      throw m.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed.",
      });
    return A;
  };
  m.converters.TypedArray = function (A, Q, B = {}) {
    if (
      m.util.Type(A) !== "Object" ||
      !fI.isTypedArray(A) ||
      A.constructor.name !== Q.name
    )
      throw m.errors.conversionFailed({
        prefix: `${Q.name}`,
        argument: `${A}`,
        types: [Q.name],
      });
    if (B.allowShared === !1 && fI.isSharedArrayBuffer(A.buffer))
      throw m.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed.",
      });
    return A;
  };
  m.converters.DataView = function (A, Q = {}) {
    if (m.util.Type(A) !== "Object" || !fI.isDataView(A))
      throw m.errors.exception({
        header: "DataView",
        message: "Object is not a DataView.",
      });
    if (Q.allowShared === !1 && fI.isSharedArrayBuffer(A.buffer))
      throw m.errors.exception({
        header: "ArrayBuffer",
        message: "SharedArrayBuffer is not allowed.",
      });
    return A;
  };
  m.converters.BufferSource = function (A, Q = {}) {
    if (fI.isAnyArrayBuffer(A)) return m.converters.ArrayBuffer(A, Q);
    if (fI.isTypedArray(A)) return m.converters.TypedArray(A, A.constructor);
    if (fI.isDataView(A)) return m.converters.DataView(A, Q);
    throw TypeError(`Could not convert ${A} to a BufferSource.`);
  };
  m.converters["sequence<ByteString>"] = m.sequenceConverter(
    m.converters.ByteString,
  );
  m.converters["sequence<sequence<ByteString>>"] = m.sequenceConverter(
    m.converters["sequence<ByteString>"],
  );
  m.converters["record<ByteString, ByteString>"] = m.recordConverter(
    m.converters.ByteString,
    m.converters.ByteString,
  );
  _8.exports = { webidl: m };
});
var $I = Z((cVA, c8) => {
  var dD = $("assert"),
    { atob: em } = $("buffer"),
    { isomorphicDecode: Ad } = AI(),
    Qd = new TextEncoder(),
    mD = /^[!#$%&'*+-.^_|~A-Za-z0-9]+$/,
    Bd = /(\u000A|\u000D|\u0009|\u0020)/,
    Id = /[\u0009|\u0020-\u007E|\u0080-\u00FF]/;
  function Ed(A) {
    dD(A.protocol === "data:");
    let Q = b8(A, !0);
    Q = Q.slice(5);
    let B = { position: 0 },
      I = L0(",", Q, B),
      E = I.length;
    if (((I = Dd(I, !0, !0)), B.position >= Q.length)) return "failure";
    B.position++;
    let C = Q.slice(E + 1),
      g = m8(C);
    if (/;(\u0020){0,}base64$/i.test(I)) {
      let D = Ad(g);
      if (((g = gd(D)), g === "failure")) return "failure";
      (I = I.slice(0, -6)),
        (I = I.replace(/(\u0020)+$/, "")),
        (I = I.slice(0, -1));
    }
    if (I.startsWith(";")) I = "text/plain" + I;
    let F = wU(I);
    if (F === "failure") F = wU("text/plain;charset=US-ASCII");
    return { mimeType: F, body: g };
  }
  function b8(A, Q = !1) {
    if (!Q) return A.href;
    let B = A.href,
      I = A.hash.length;
    return I === 0 ? B : B.substring(0, B.length - I);
  }
  function cD(A, Q, B) {
    let I = "";
    while (B.position < Q.length && A(Q[B.position]))
      (I += Q[B.position]), B.position++;
    return I;
  }
  function L0(A, Q, B) {
    let I = Q.indexOf(A, B.position),
      E = B.position;
    if (I === -1) return (B.position = Q.length), Q.slice(E);
    return (B.position = I), Q.slice(E, B.position);
  }
  function m8(A) {
    let Q = Qd.encode(A);
    return Cd(Q);
  }
  function Cd(A) {
    let Q = [];
    for (let B = 0; B < A.length; B++) {
      let I = A[B];
      if (I !== 37) Q.push(I);
      else if (
        I === 37 &&
        !/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(A[B + 1], A[B + 2]))
      )
        Q.push(37);
      else {
        let E = String.fromCharCode(A[B + 1], A[B + 2]),
          C = Number.parseInt(E, 16);
        Q.push(C), (B += 2);
      }
    }
    return Uint8Array.from(Q);
  }
  function wU(A) {
    A = XU(A, !0, !0);
    let Q = { position: 0 },
      B = L0("/", A, Q);
    if (B.length === 0 || !mD.test(B)) return "failure";
    if (Q.position > A.length) return "failure";
    Q.position++;
    let I = L0(";", A, Q);
    if (((I = XU(I, !1, !0)), I.length === 0 || !mD.test(I))) return "failure";
    let E = B.toLowerCase(),
      C = I.toLowerCase(),
      g = { type: E, subtype: C, parameters: new Map(), essence: `${E}/${C}` };
    while (Q.position < A.length) {
      Q.position++, cD((J) => Bd.test(J), A, Q);
      let F = cD((J) => J !== ";" && J !== "=", A, Q);
      if (((F = F.toLowerCase()), Q.position < A.length)) {
        if (A[Q.position] === ";") continue;
        Q.position++;
      }
      if (Q.position > A.length) break;
      let D = null;
      if (A[Q.position] === '"') (D = d8(A, Q, !0)), L0(";", A, Q);
      else if (((D = L0(";", A, Q)), (D = XU(D, !1, !0)), D.length === 0))
        continue;
      if (
        F.length !== 0 &&
        mD.test(F) &&
        (D.length === 0 || Id.test(D)) &&
        !g.parameters.has(F)
      )
        g.parameters.set(F, D);
    }
    return g;
  }
  function gd(A) {
    if (
      ((A = A.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, "")),
      A.length % 4 === 0)
    )
      A = A.replace(/=?=$/, "");
    if (A.length % 4 === 1) return "failure";
    if (/[^+/0-9A-Za-z]/.test(A)) return "failure";
    let Q = em(A),
      B = new Uint8Array(Q.length);
    for (let I = 0; I < Q.length; I++) B[I] = Q.charCodeAt(I);
    return B;
  }
  function d8(A, Q, B) {
    let I = Q.position,
      E = "";
    dD(A[Q.position] === '"'), Q.position++;
    while (!0) {
      if (
        ((E += cD((g) => g !== '"' && g !== "\\", A, Q)),
        Q.position >= A.length)
      )
        break;
      let C = A[Q.position];
      if ((Q.position++, C === "\\")) {
        if (Q.position >= A.length) {
          E += "\\";
          break;
        }
        (E += A[Q.position]), Q.position++;
      } else {
        dD(C === '"');
        break;
      }
    }
    if (B) return E;
    return A.slice(I, Q.position);
  }
  function Fd(A) {
    dD(A !== "failure");
    let { parameters: Q, essence: B } = A,
      I = B;
    for (let [E, C] of Q.entries()) {
      if (((I += ";"), (I += E), (I += "="), !mD.test(C)))
        (C = C.replace(/(\\|")/g, "\\$1")), (C = '"' + C), (C += '"');
      I += C;
    }
    return I;
  }
  function y8(A) {
    return (
      A === "\r" ||
      A ===
        `
` ||
      A === "\t" ||
      A === " "
    );
  }
  function XU(A, Q = !0, B = !0) {
    let I = 0,
      E = A.length - 1;
    if (Q) for (; I < A.length && y8(A[I]); I++);
    if (B) for (; E > 0 && y8(A[E]); E--);
    return A.slice(I, E + 1);
  }
  function S8(A) {
    return (
      A === "\r" ||
      A ===
        `
` ||
      A === "\t" ||
      A === "\f" ||
      A === " "
    );
  }
  function Dd(A, Q = !0, B = !0) {
    let I = 0,
      E = A.length - 1;
    if (Q) for (; I < A.length && S8(A[I]); I++);
    if (B) for (; E > 0 && S8(A[E]); E--);
    return A.slice(I, E + 1);
  }
  c8.exports = {
    dataURLProcessor: Ed,
    URLSerializer: b8,
    collectASequenceOfCodePoints: cD,
    collectASequenceOfCodePointsFast: L0,
    stringPercentDecode: m8,
    parseMIMEType: wU,
    collectAnHTTPQuotedString: d8,
    serializeAMimeType: Fd,
  };
});
var uD = Z((uVA, n8) => {
  var { Blob: p8, File: u8 } = $("buffer"),
    { types: MU } = $("util"),
    { kState: PB } = CE(),
    { isBlobLike: i8 } = AI(),
    { webidl: OA } = EB(),
    { parseMIMEType: Yd, serializeAMimeType: Jd } = $I(),
    { kEnumerableProperty: l8 } = HA(),
    Nd = new TextEncoder();
  class KC extends p8 {
    constructor(A, Q, B = {}) {
      OA.argumentLengthCheck(arguments, 2, { header: "File constructor" }),
        (A = OA.converters["sequence<BlobPart>"](A)),
        (Q = OA.converters.USVString(Q)),
        (B = OA.converters.FilePropertyBag(B));
      let I = Q,
        E = B.type,
        C;
      A: {
        if (E) {
          if (((E = Yd(E)), E === "failure")) {
            E = "";
            break A;
          }
          E = Jd(E).toLowerCase();
        }
        C = B.lastModified;
      }
      super(Gd(A, B), { type: E });
      this[PB] = { name: I, lastModified: C, type: E };
    }
    get name() {
      return OA.brandCheck(this, KC), this[PB].name;
    }
    get lastModified() {
      return OA.brandCheck(this, KC), this[PB].lastModified;
    }
    get type() {
      return OA.brandCheck(this, KC), this[PB].type;
    }
  }
  class hI {
    constructor(A, Q, B = {}) {
      let I = Q,
        E = B.type,
        C = B.lastModified ?? Date.now();
      this[PB] = { blobLike: A, name: I, type: E, lastModified: C };
    }
    stream(...A) {
      return OA.brandCheck(this, hI), this[PB].blobLike.stream(...A);
    }
    arrayBuffer(...A) {
      return OA.brandCheck(this, hI), this[PB].blobLike.arrayBuffer(...A);
    }
    slice(...A) {
      return OA.brandCheck(this, hI), this[PB].blobLike.slice(...A);
    }
    text(...A) {
      return OA.brandCheck(this, hI), this[PB].blobLike.text(...A);
    }
    get size() {
      return OA.brandCheck(this, hI), this[PB].blobLike.size;
    }
    get type() {
      return OA.brandCheck(this, hI), this[PB].blobLike.type;
    }
    get name() {
      return OA.brandCheck(this, hI), this[PB].name;
    }
    get lastModified() {
      return OA.brandCheck(this, hI), this[PB].lastModified;
    }
    get [Symbol.toStringTag]() {
      return "File";
    }
  }
  Object.defineProperties(KC.prototype, {
    [Symbol.toStringTag]: { value: "File", configurable: !0 },
    name: l8,
    lastModified: l8,
  });
  OA.converters.Blob = OA.interfaceConverter(p8);
  OA.converters.BlobPart = function (A, Q) {
    if (OA.util.Type(A) === "Object") {
      if (i8(A)) return OA.converters.Blob(A, { strict: !1 });
      if (ArrayBuffer.isView(A) || MU.isAnyArrayBuffer(A))
        return OA.converters.BufferSource(A, Q);
    }
    return OA.converters.USVString(A, Q);
  };
  OA.converters["sequence<BlobPart>"] = OA.sequenceConverter(
    OA.converters.BlobPart,
  );
  OA.converters.FilePropertyBag = OA.dictionaryConverter([
    {
      key: "lastModified",
      converter: OA.converters["long long"],
      get defaultValue() {
        return Date.now();
      },
    },
    { key: "type", converter: OA.converters.DOMString, defaultValue: "" },
    {
      key: "endings",
      converter: (A) => {
        if (
          ((A = OA.converters.DOMString(A)),
          (A = A.toLowerCase()),
          A !== "native")
        )
          A = "transparent";
        return A;
      },
      defaultValue: "transparent",
    },
  ]);
  function Gd(A, Q) {
    let B = [];
    for (let I of A)
      if (typeof I === "string") {
        let E = I;
        if (Q.endings === "native") E = Ud(E);
        B.push(Nd.encode(E));
      } else if (MU.isAnyArrayBuffer(I) || MU.isTypedArray(I))
        if (!I.buffer) B.push(new Uint8Array(I));
        else B.push(new Uint8Array(I.buffer, I.byteOffset, I.byteLength));
      else if (i8(I)) B.push(I);
    return B;
  }
  function Ud(A) {
    let Q = `
`;
    if (process.platform === "win32")
      Q = `\r
`;
    return A.replace(/\r?\n/g, Q);
  }
  function Wd(A) {
    return (
      (u8 && A instanceof u8) ||
      A instanceof KC ||
      (A &&
        (typeof A.stream === "function" ||
          typeof A.arrayBuffer === "function") &&
        A[Symbol.toStringTag] === "File")
    );
  }
  n8.exports = { File: KC, FileLike: hI, isFileLike: Wd };
});
var pD = Z((lVA, t8) => {
  var { isBlobLike: lD, toUSVString: Zd, makeIterator: LU } = AI(),
    { kState: aQ } = CE(),
    { File: r8, FileLike: a8, isFileLike: Xd } = uD(),
    { webidl: _A } = EB(),
    { Blob: wd, File: RU } = $("buffer"),
    o8 = RU ?? r8;
  class CB {
    constructor(A) {
      if (A !== void 0)
        throw _A.errors.conversionFailed({
          prefix: "FormData constructor",
          argument: "Argument 1",
          types: ["undefined"],
        });
      this[aQ] = [];
    }
    append(A, Q, B = void 0) {
      if (
        (_A.brandCheck(this, CB),
        _A.argumentLengthCheck(arguments, 2, { header: "FormData.append" }),
        arguments.length === 3 && !lD(Q))
      )
        throw TypeError(
          "Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'",
        );
      (A = _A.converters.USVString(A)),
        (Q = lD(Q)
          ? _A.converters.Blob(Q, { strict: !1 })
          : _A.converters.USVString(Q)),
        (B = arguments.length === 3 ? _A.converters.USVString(B) : void 0);
      let I = s8(A, Q, B);
      this[aQ].push(I);
    }
    delete(A) {
      _A.brandCheck(this, CB),
        _A.argumentLengthCheck(arguments, 1, { header: "FormData.delete" }),
        (A = _A.converters.USVString(A)),
        (this[aQ] = this[aQ].filter((Q) => Q.name !== A));
    }
    get(A) {
      _A.brandCheck(this, CB),
        _A.argumentLengthCheck(arguments, 1, { header: "FormData.get" }),
        (A = _A.converters.USVString(A));
      let Q = this[aQ].findIndex((B) => B.name === A);
      if (Q === -1) return null;
      return this[aQ][Q].value;
    }
    getAll(A) {
      return (
        _A.brandCheck(this, CB),
        _A.argumentLengthCheck(arguments, 1, { header: "FormData.getAll" }),
        (A = _A.converters.USVString(A)),
        this[aQ].filter((Q) => Q.name === A).map((Q) => Q.value)
      );
    }
    has(A) {
      return (
        _A.brandCheck(this, CB),
        _A.argumentLengthCheck(arguments, 1, { header: "FormData.has" }),
        (A = _A.converters.USVString(A)),
        this[aQ].findIndex((Q) => Q.name === A) !== -1
      );
    }
    set(A, Q, B = void 0) {
      if (
        (_A.brandCheck(this, CB),
        _A.argumentLengthCheck(arguments, 2, { header: "FormData.set" }),
        arguments.length === 3 && !lD(Q))
      )
        throw TypeError(
          "Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'",
        );
      (A = _A.converters.USVString(A)),
        (Q = lD(Q)
          ? _A.converters.Blob(Q, { strict: !1 })
          : _A.converters.USVString(Q)),
        (B = arguments.length === 3 ? Zd(B) : void 0);
      let I = s8(A, Q, B),
        E = this[aQ].findIndex((C) => C.name === A);
      if (E !== -1)
        this[aQ] = [
          ...this[aQ].slice(0, E),
          I,
          ...this[aQ].slice(E + 1).filter((C) => C.name !== A),
        ];
      else this[aQ].push(I);
    }
    entries() {
      return (
        _A.brandCheck(this, CB),
        LU(
          () => this[aQ].map((A) => [A.name, A.value]),
          "FormData",
          "key+value",
        )
      );
    }
    keys() {
      return (
        _A.brandCheck(this, CB),
        LU(() => this[aQ].map((A) => [A.name, A.value]), "FormData", "key")
      );
    }
    values() {
      return (
        _A.brandCheck(this, CB),
        LU(() => this[aQ].map((A) => [A.name, A.value]), "FormData", "value")
      );
    }
    forEach(A, Q = globalThis) {
      if (
        (_A.brandCheck(this, CB),
        _A.argumentLengthCheck(arguments, 1, { header: "FormData.forEach" }),
        typeof A !== "function")
      )
        throw TypeError(
          "Failed to execute 'forEach' on 'FormData': parameter 1 is not of type 'Function'.",
        );
      for (let [B, I] of this) A.apply(Q, [I, B, this]);
    }
  }
  CB.prototype[Symbol.iterator] = CB.prototype.entries;
  Object.defineProperties(CB.prototype, {
    [Symbol.toStringTag]: { value: "FormData", configurable: !0 },
  });
  function s8(A, Q, B) {
    if (((A = Buffer.from(A).toString("utf8")), typeof Q === "string"))
      Q = Buffer.from(Q).toString("utf8");
    else {
      if (!Xd(Q))
        Q =
          Q instanceof wd
            ? new o8([Q], "blob", { type: Q.type })
            : new a8(Q, "blob", { type: Q.type });
      if (B !== void 0) {
        let I = { type: Q.type, lastModified: Q.lastModified };
        Q =
          (RU && Q instanceof RU) || Q instanceof r8
            ? new o8([Q], B, I)
            : new a8(Q, B, I);
      }
    }
    return { name: A, value: Q };
  }
  t8.exports = { FormData: CB };
});
var lg = Z((pVA, F2) => {
  var Md = X8(),
    R0 = HA(),
    {
      ReadableStreamFrom: Ld,
      isBlobLike: e8,
      isReadableStreamLike: Rd,
      readableStreamClose: Vd,
      createDeferredPromise: $d,
      fullyReadBody: Hd,
    } = AI(),
    { FormData: A2 } = pD(),
    { kState: FE } = CE(),
    { webidl: VU } = EB(),
    { DOMException: I2, structuredClone: Kd } = yE(),
    { Blob: zd, File: Td } = $("buffer"),
    { kBodyUsed: Od } = aA(),
    $U = $("assert"),
    { isErrored: qd } = HA(),
    { isUint8Array: E2, isArrayBuffer: jd } = $("util/types"),
    { File: fd } = uD(),
    { parseMIMEType: hd, serializeAMimeType: kd } = $I(),
    HU;
  try {
    let A = $("node:crypto");
    HU = (Q) => A.randomInt(0, Q);
  } catch {
    HU = (A) => Math.floor(Math.random(A));
  }
  var gE = globalThis.ReadableStream,
    Q2 = Td ?? fd,
    iD = new TextEncoder(),
    xd = new TextDecoder();
  function C2(A, Q = !1) {
    if (!gE) gE = $("stream/web").ReadableStream;
    let B = null;
    if (A instanceof gE) B = A;
    else if (e8(A)) B = A.stream();
    else
      B = new gE({
        async pull(D) {
          D.enqueue(typeof E === "string" ? iD.encode(E) : E),
            queueMicrotask(() => Vd(D));
        },
        start() {},
        type: void 0,
      });
    $U(Rd(B));
    let I = null,
      E = null,
      C = null,
      g = null;
    if (typeof A === "string") (E = A), (g = "text/plain;charset=UTF-8");
    else if (A instanceof URLSearchParams)
      (E = A.toString()),
        (g = "application/x-www-form-urlencoded;charset=UTF-8");
    else if (jd(A)) E = new Uint8Array(A.slice());
    else if (ArrayBuffer.isView(A))
      E = new Uint8Array(
        A.buffer.slice(A.byteOffset, A.byteOffset + A.byteLength),
      );
    else if (R0.isFormDataLike(A)) {
      let D = `----formdata-undici-0${`${HU(100000000000)}`.padStart(11, "0")}`,
        J = `--${D}\r
Content-Disposition: form-data`;
      /*! formdata-polyfill. MIT License. Jimmy Wärting <https://jimmy.warting.se/opensource> */ let Y =
          (H) =>
            H.replace(/\n/g, "%0A").replace(/\r/g, "%0D").replace(/"/g, "%22"),
        N = (H) =>
          H.replace(
            /\r?\n|\r/g,
            `\r
`,
          ),
        W = [],
        X = new Uint8Array([13, 10]);
      C = 0;
      let M = !1;
      for (let [H, q] of A)
        if (typeof q === "string") {
          let O = iD.encode(
            J +
              `; name="${Y(N(H))}"\r
\r
${N(q)}\r
`,
          );
          W.push(O), (C += O.byteLength);
        } else {
          let O = iD.encode(
            `${J}; name="${Y(N(H))}"` +
              (q.name ? `; filename="${Y(q.name)}"` : "") +
              `\r
Content-Type: ${q.type || "application/octet-stream"}\r
\r
`,
          );
          if ((W.push(O, q, X), typeof q.size === "number"))
            C += O.byteLength + q.size + X.byteLength;
          else M = !0;
        }
      let L = iD.encode(`--${D}--`);
      if ((W.push(L), (C += L.byteLength), M)) C = null;
      (E = A),
        (I = async function* () {
          for (let H of W)
            if (H.stream) yield* H.stream();
            else yield H;
        }),
        (g = "multipart/form-data; boundary=" + D);
    } else if (e8(A)) {
      if (((E = A), (C = A.size), A.type)) g = A.type;
    } else if (typeof A[Symbol.asyncIterator] === "function") {
      if (Q) throw TypeError("keepalive");
      if (R0.isDisturbed(A) || A.locked)
        throw TypeError(
          "Response body object should not be disturbed or locked",
        );
      B = A instanceof gE ? A : Ld(A);
    }
    if (typeof E === "string" || R0.isBuffer(E)) C = Buffer.byteLength(E);
    if (I != null) {
      let D;
      B = new gE({
        async start() {
          D = I(A)[Symbol.asyncIterator]();
        },
        async pull(J) {
          let { value: Y, done: N } = await D.next();
          if (N)
            queueMicrotask(() => {
              J.close();
            });
          else if (!qd(B)) J.enqueue(new Uint8Array(Y));
          return J.desiredSize > 0;
        },
        async cancel(J) {
          await D.return();
        },
        type: void 0,
      });
    }
    return [{ stream: B, source: E, length: C }, g];
  }
  function vd(A, Q = !1) {
    if (!gE) gE = $("stream/web").ReadableStream;
    if (A instanceof gE)
      $U(!R0.isDisturbed(A), "The body has already been consumed."),
        $U(!A.locked, "The stream is locked.");
    return C2(A, Q);
  }
  function Pd(A) {
    let [Q, B] = A.stream.tee(),
      I = Kd(B, { transfer: [B] }),
      [, E] = I.tee();
    return (A.stream = Q), { stream: E, length: A.length, source: A.source };
  }
  async function* B2(A) {
    if (A)
      if (E2(A)) yield A;
      else {
        let Q = A.stream;
        if (R0.isDisturbed(Q))
          throw TypeError("The body has already been consumed.");
        if (Q.locked) throw TypeError("The stream is locked.");
        (Q[Od] = !0), yield* Q;
      }
  }
  function KU(A) {
    if (A.aborted) throw new I2("The operation was aborted.", "AbortError");
  }
  function _d(A) {
    return {
      blob() {
        return nD(
          this,
          (B) => {
            let I = md(this);
            if (I === "failure") I = "";
            else if (I) I = kd(I);
            return new zd([B], { type: I });
          },
          A,
        );
      },
      arrayBuffer() {
        return nD(
          this,
          (B) => {
            return new Uint8Array(B).buffer;
          },
          A,
        );
      },
      text() {
        return nD(this, g2, A);
      },
      json() {
        return nD(this, bd, A);
      },
      async formData() {
        VU.brandCheck(this, A), KU(this[FE]);
        let B = this.headers.get("Content-Type");
        if (/multipart\/form-data/.test(B)) {
          let I = {};
          for (let [F, D] of this.headers) I[F.toLowerCase()] = D;
          let E = new A2(),
            C;
          try {
            C = new Md({ headers: I, preservePath: !0 });
          } catch (F) {
            throw new I2(`${F}`, "AbortError");
          }
          C.on("field", (F, D) => {
            E.append(F, D);
          }),
            C.on("file", (F, D, J, Y, N) => {
              let W = [];
              if (Y === "base64" || Y.toLowerCase() === "base64") {
                let X = "";
                D.on("data", (M) => {
                  X += M.toString().replace(/[\r\n]/gm, "");
                  let L = X.length - (X.length % 4);
                  W.push(Buffer.from(X.slice(0, L), "base64")),
                    (X = X.slice(L));
                }),
                  D.on("end", () => {
                    W.push(Buffer.from(X, "base64")),
                      E.append(F, new Q2(W, J, { type: N }));
                  });
              } else
                D.on("data", (X) => {
                  W.push(X);
                }),
                  D.on("end", () => {
                    E.append(F, new Q2(W, J, { type: N }));
                  });
            });
          let g = new Promise((F, D) => {
            C.on("finish", F), C.on("error", (J) => D(TypeError(J)));
          });
          if (this.body !== null)
            for await (let F of B2(this[FE].body)) C.write(F);
          return C.end(), await g, E;
        } else if (/application\/x-www-form-urlencoded/.test(B)) {
          let I;
          try {
            let C = "",
              g = new TextDecoder("utf-8", { ignoreBOM: !0 });
            for await (let F of B2(this[FE].body)) {
              if (!E2(F)) throw TypeError("Expected Uint8Array chunk");
              C += g.decode(F, { stream: !0 });
            }
            (C += g.decode()), (I = new URLSearchParams(C));
          } catch (C) {
            throw Object.assign(TypeError(), { cause: C });
          }
          let E = new A2();
          for (let [C, g] of I) E.append(C, g);
          return E;
        } else
          throw (
            (await Promise.resolve(),
            KU(this[FE]),
            VU.errors.exception({
              header: `${A.name}.formData`,
              message: "Could not parse content as FormData.",
            }))
          );
      },
    };
  }
  function yd(A) {
    Object.assign(A.prototype, _d(A));
  }
  async function nD(A, Q, B) {
    if ((VU.brandCheck(A, B), KU(A[FE]), Sd(A[FE].body)))
      throw TypeError("Body is unusable");
    let I = $d(),
      E = (g) => I.reject(g),
      C = (g) => {
        try {
          I.resolve(Q(g));
        } catch (F) {
          E(F);
        }
      };
    if (A[FE].body == null) return C(new Uint8Array()), I.promise;
    return await Hd(A[FE].body, C, E), I.promise;
  }
  function Sd(A) {
    return A != null && (A.stream.locked || R0.isDisturbed(A.stream));
  }
  function g2(A) {
    if (A.length === 0) return "";
    if (A[0] === 239 && A[1] === 187 && A[2] === 191) A = A.subarray(3);
    return xd.decode(A);
  }
  function bd(A) {
    return JSON.parse(g2(A));
  }
  function md(A) {
    let { headersList: Q } = A[FE],
      B = Q.get("content-type");
    if (B === null) return "failure";
    return hd(B);
  }
  F2.exports = {
    extractBody: C2,
    safelyExtractBody: vd,
    cloneBody: Pd,
    mixinBody: yd,
  };
});
var N2 = Z((iVA, J2) => {
  var { InvalidArgumentError: pA, NotSupportedError: dd } = dA(),
    DE = $("assert"),
    {
      kHTTP2BuildRequest: cd,
      kHTTP2CopyHeaders: ud,
      kHTTP1BuildRequest: ld,
    } = aA(),
    XB = HA(),
    D2 = /^[\^_`a-zA-Z\-0-9!#$%&'*+.|~]+$/,
    Y2 = /[^\t\x20-\x7e\x80-\xff]/,
    pd = /[^\u0021-\u00ff]/,
    HI = Symbol("handler"),
    RQ = {},
    zU;
  try {
    let A = $("diagnostics_channel");
    (RQ.create = A.channel("undici:request:create")),
      (RQ.bodySent = A.channel("undici:request:bodySent")),
      (RQ.headers = A.channel("undici:request:headers")),
      (RQ.trailers = A.channel("undici:request:trailers")),
      (RQ.error = A.channel("undici:request:error"));
  } catch {
    (RQ.create = { hasSubscribers: !1 }),
      (RQ.bodySent = { hasSubscribers: !1 }),
      (RQ.headers = { hasSubscribers: !1 }),
      (RQ.trailers = { hasSubscribers: !1 }),
      (RQ.error = { hasSubscribers: !1 });
  }
  class aD {
    constructor(
      A,
      {
        path: Q,
        method: B,
        body: I,
        headers: E,
        query: C,
        idempotent: g,
        blocking: F,
        upgrade: D,
        headersTimeout: J,
        bodyTimeout: Y,
        reset: N,
        throwOnError: W,
        expectContinue: X,
      },
      M,
    ) {
      if (typeof Q !== "string") throw new pA("path must be a string");
      else if (
        Q[0] !== "/" &&
        !(Q.startsWith("http://") || Q.startsWith("https://")) &&
        B !== "CONNECT"
      )
        throw new pA("path must be an absolute URL or start with a slash");
      else if (pd.exec(Q) !== null) throw new pA("invalid request path");
      if (typeof B !== "string") throw new pA("method must be a string");
      else if (D2.exec(B) === null) throw new pA("invalid request method");
      if (D && typeof D !== "string") throw new pA("upgrade must be a string");
      if (J != null && (!Number.isFinite(J) || J < 0))
        throw new pA("invalid headersTimeout");
      if (Y != null && (!Number.isFinite(Y) || Y < 0))
        throw new pA("invalid bodyTimeout");
      if (N != null && typeof N !== "boolean") throw new pA("invalid reset");
      if (X != null && typeof X !== "boolean")
        throw new pA("invalid expectContinue");
      if (
        ((this.headersTimeout = J),
        (this.bodyTimeout = Y),
        (this.throwOnError = W === !0),
        (this.method = B),
        (this.abort = null),
        I == null)
      )
        this.body = null;
      else if (XB.isStream(I)) {
        this.body = I;
        let L = this.body._readableState;
        if (!L || !L.autoDestroy)
          (this.endHandler = function () {
            XB.destroy(this);
          }),
            this.body.on("end", this.endHandler);
        (this.errorHandler = (H) => {
          if (this.abort) this.abort(H);
          else this.error = H;
        }),
          this.body.on("error", this.errorHandler);
      } else if (XB.isBuffer(I)) this.body = I.byteLength ? I : null;
      else if (ArrayBuffer.isView(I))
        this.body = I.buffer.byteLength
          ? Buffer.from(I.buffer, I.byteOffset, I.byteLength)
          : null;
      else if (I instanceof ArrayBuffer)
        this.body = I.byteLength ? Buffer.from(I) : null;
      else if (typeof I === "string")
        this.body = I.length ? Buffer.from(I) : null;
      else if (XB.isFormDataLike(I) || XB.isIterable(I) || XB.isBlobLike(I))
        this.body = I;
      else
        throw new pA(
          "body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable",
        );
      if (
        ((this.completed = !1),
        (this.aborted = !1),
        (this.upgrade = D || null),
        (this.path = C ? XB.buildURL(Q, C) : Q),
        (this.origin = A),
        (this.idempotent = g == null ? B === "HEAD" || B === "GET" : g),
        (this.blocking = F == null ? !1 : F),
        (this.reset = N == null ? null : N),
        (this.host = null),
        (this.contentLength = null),
        (this.contentType = null),
        (this.headers = ""),
        (this.expectContinue = X != null ? X : !1),
        Array.isArray(E))
      ) {
        if (E.length % 2 !== 0) throw new pA("headers array must be even");
        for (let L = 0; L < E.length; L += 2) pg(this, E[L], E[L + 1]);
      } else if (E && typeof E === "object") {
        let L = Object.keys(E);
        for (let H = 0; H < L.length; H++) {
          let q = L[H];
          pg(this, q, E[q]);
        }
      } else if (E != null)
        throw new pA("headers must be an object or an array");
      if (XB.isFormDataLike(this.body)) {
        if (XB.nodeMajor < 16 || (XB.nodeMajor === 16 && XB.nodeMinor < 8))
          throw new pA(
            "Form-Data bodies are only supported in node v16.8 and newer.",
          );
        if (!zU) zU = lg().extractBody;
        let [L, H] = zU(I);
        if (this.contentType == null)
          (this.contentType = H),
            (this.headers += `content-type: ${H}\r
`);
        (this.body = L.stream), (this.contentLength = L.length);
      } else if (XB.isBlobLike(I) && this.contentType == null && I.type)
        (this.contentType = I.type),
          (this.headers += `content-type: ${I.type}\r
`);
      if (
        (XB.validateHandler(M, B, D),
        (this.servername = XB.getServerName(this.host)),
        (this[HI] = M),
        RQ.create.hasSubscribers)
      )
        RQ.create.publish({ request: this });
    }
    onBodySent(A) {
      if (this[HI].onBodySent)
        try {
          return this[HI].onBodySent(A);
        } catch (Q) {
          this.abort(Q);
        }
    }
    onRequestSent() {
      if (RQ.bodySent.hasSubscribers) RQ.bodySent.publish({ request: this });
      if (this[HI].onRequestSent)
        try {
          return this[HI].onRequestSent();
        } catch (A) {
          this.abort(A);
        }
    }
    onConnect(A) {
      if ((DE(!this.aborted), DE(!this.completed), this.error)) A(this.error);
      else return (this.abort = A), this[HI].onConnect(A);
    }
    onHeaders(A, Q, B, I) {
      if ((DE(!this.aborted), DE(!this.completed), RQ.headers.hasSubscribers))
        RQ.headers.publish({
          request: this,
          response: { statusCode: A, headers: Q, statusText: I },
        });
      try {
        return this[HI].onHeaders(A, Q, B, I);
      } catch (E) {
        this.abort(E);
      }
    }
    onData(A) {
      DE(!this.aborted), DE(!this.completed);
      try {
        return this[HI].onData(A);
      } catch (Q) {
        return this.abort(Q), !1;
      }
    }
    onUpgrade(A, Q, B) {
      return (
        DE(!this.aborted), DE(!this.completed), this[HI].onUpgrade(A, Q, B)
      );
    }
    onComplete(A) {
      if (
        (this.onFinally(),
        DE(!this.aborted),
        (this.completed = !0),
        RQ.trailers.hasSubscribers)
      )
        RQ.trailers.publish({ request: this, trailers: A });
      try {
        return this[HI].onComplete(A);
      } catch (Q) {
        this.onError(Q);
      }
    }
    onError(A) {
      if ((this.onFinally(), RQ.error.hasSubscribers))
        RQ.error.publish({ request: this, error: A });
      if (this.aborted) return;
      return (this.aborted = !0), this[HI].onError(A);
    }
    onFinally() {
      if (this.errorHandler)
        this.body.off("error", this.errorHandler), (this.errorHandler = null);
      if (this.endHandler)
        this.body.off("end", this.endHandler), (this.endHandler = null);
    }
    addHeader(A, Q) {
      return pg(this, A, Q), this;
    }
    static [ld](A, Q, B) {
      return new aD(A, Q, B);
    }
    static [cd](A, Q, B) {
      let I = Q.headers;
      Q = { ...Q, headers: null };
      let E = new aD(A, Q, B);
      if (((E.headers = {}), Array.isArray(I))) {
        if (I.length % 2 !== 0) throw new pA("headers array must be even");
        for (let C = 0; C < I.length; C += 2) pg(E, I[C], I[C + 1], !0);
      } else if (I && typeof I === "object") {
        let C = Object.keys(I);
        for (let g = 0; g < C.length; g++) {
          let F = C[g];
          pg(E, F, I[F], !0);
        }
      } else if (I != null)
        throw new pA("headers must be an object or an array");
      return E;
    }
    static [ud](A) {
      let Q = A.split(`\r
`),
        B = {};
      for (let I of Q) {
        let [E, C] = I.split(": ");
        if (C == null || C.length === 0) continue;
        if (B[E]) B[E] += `,${C}`;
        else B[E] = C;
      }
      return B;
    }
  }
  function zC(A, Q, B) {
    if (Q && typeof Q === "object") throw new pA(`invalid ${A} header`);
    if (((Q = Q != null ? `${Q}` : ""), Y2.exec(Q) !== null))
      throw new pA(`invalid ${A} header`);
    return B
      ? Q
      : `${A}: ${Q}\r
`;
  }
  function pg(A, Q, B, I = !1) {
    if (B && typeof B === "object" && !Array.isArray(B))
      throw new pA(`invalid ${Q} header`);
    else if (B === void 0) return;
    if (A.host === null && Q.length === 4 && Q.toLowerCase() === "host") {
      if (Y2.exec(B) !== null) throw new pA(`invalid ${Q} header`);
      A.host = B;
    } else if (
      A.contentLength === null &&
      Q.length === 14 &&
      Q.toLowerCase() === "content-length"
    ) {
      if (
        ((A.contentLength = parseInt(B, 10)), !Number.isFinite(A.contentLength))
      )
        throw new pA("invalid content-length header");
    } else if (
      A.contentType === null &&
      Q.length === 12 &&
      Q.toLowerCase() === "content-type"
    )
      if (((A.contentType = B), I)) A.headers[Q] = zC(Q, B, I);
      else A.headers += zC(Q, B);
    else if (Q.length === 17 && Q.toLowerCase() === "transfer-encoding")
      throw new pA("invalid transfer-encoding header");
    else if (Q.length === 10 && Q.toLowerCase() === "connection") {
      let E = typeof B === "string" ? B.toLowerCase() : null;
      if (E !== "close" && E !== "keep-alive")
        throw new pA("invalid connection header");
      else if (E === "close") A.reset = !0;
    } else if (Q.length === 10 && Q.toLowerCase() === "keep-alive")
      throw new pA("invalid keep-alive header");
    else if (Q.length === 7 && Q.toLowerCase() === "upgrade")
      throw new pA("invalid upgrade header");
    else if (Q.length === 6 && Q.toLowerCase() === "expect")
      throw new dd("expect header not supported");
    else if (D2.exec(Q) === null) throw new pA("invalid header key");
    else if (Array.isArray(B))
      for (let E = 0; E < B.length; E++)
        if (I)
          if (A.headers[Q]) A.headers[Q] += `,${zC(Q, B[E], I)}`;
          else A.headers[Q] = zC(Q, B[E], I);
        else A.headers += zC(Q, B[E]);
    else if (I) A.headers[Q] = zC(Q, B, I);
    else A.headers += zC(Q, B);
  }
  J2.exports = aD;
});
var oD = Z((nVA, U2) => {
  var id = $("events");
  class G2 extends id {
    dispatch() {
      throw Error("not implemented");
    }
    close() {
      throw Error("not implemented");
    }
    destroy() {
      throw Error("not implemented");
    }
  }
  U2.exports = G2;
});
var ng = Z((aVA, Z2) => {
  var nd = oD(),
    {
      ClientDestroyedError: TU,
      ClientClosedError: ad,
      InvalidArgumentError: V0,
    } = dA(),
    { kDestroy: od, kClose: sd, kDispatch: OU, kInterceptors: TC } = aA(),
    $0 = Symbol("destroyed"),
    ig = Symbol("closed"),
    YE = Symbol("onDestroyed"),
    H0 = Symbol("onClosed"),
    sD = Symbol("Intercepted Dispatch");
  class W2 extends nd {
    constructor() {
      super();
      (this[$0] = !1), (this[YE] = null), (this[ig] = !1), (this[H0] = []);
    }
    get destroyed() {
      return this[$0];
    }
    get closed() {
      return this[ig];
    }
    get interceptors() {
      return this[TC];
    }
    set interceptors(A) {
      if (A) {
        for (let Q = A.length - 1; Q >= 0; Q--)
          if (typeof this[TC][Q] !== "function")
            throw new V0("interceptor must be an function");
      }
      this[TC] = A;
    }
    close(A) {
      if (A === void 0)
        return new Promise((B, I) => {
          this.close((E, C) => {
            return E ? I(E) : B(C);
          });
        });
      if (typeof A !== "function") throw new V0("invalid callback");
      if (this[$0]) {
        queueMicrotask(() => A(new TU(), null));
        return;
      }
      if (this[ig]) {
        if (this[H0]) this[H0].push(A);
        else queueMicrotask(() => A(null, null));
        return;
      }
      (this[ig] = !0), this[H0].push(A);
      let Q = () => {
        let B = this[H0];
        this[H0] = null;
        for (let I = 0; I < B.length; I++) B[I](null, null);
      };
      this[sd]()
        .then(() => this.destroy())
        .then(() => {
          queueMicrotask(Q);
        });
    }
    destroy(A, Q) {
      if (typeof A === "function") (Q = A), (A = null);
      if (Q === void 0)
        return new Promise((I, E) => {
          this.destroy(A, (C, g) => {
            return C ? E(C) : I(g);
          });
        });
      if (typeof Q !== "function") throw new V0("invalid callback");
      if (this[$0]) {
        if (this[YE]) this[YE].push(Q);
        else queueMicrotask(() => Q(null, null));
        return;
      }
      if (!A) A = new TU();
      (this[$0] = !0), (this[YE] = this[YE] || []), this[YE].push(Q);
      let B = () => {
        let I = this[YE];
        this[YE] = null;
        for (let E = 0; E < I.length; E++) I[E](null, null);
      };
      this[od](A).then(() => {
        queueMicrotask(B);
      });
    }
    [sD](A, Q) {
      if (!this[TC] || this[TC].length === 0)
        return (this[sD] = this[OU]), this[OU](A, Q);
      let B = this[OU].bind(this);
      for (let I = this[TC].length - 1; I >= 0; I--) B = this[TC][I](B);
      return (this[sD] = B), B(A, Q);
    }
    dispatch(A, Q) {
      if (!Q || typeof Q !== "object")
        throw new V0("handler must be an object");
      try {
        if (!A || typeof A !== "object")
          throw new V0("opts must be an object.");
        if (this[$0] || this[YE]) throw new TU();
        if (this[ig]) throw new ad();
        return this[sD](A, Q);
      } catch (B) {
        if (typeof Q.onError !== "function")
          throw new V0("invalid onError method");
        return Q.onError(B), !1;
      }
    }
  }
  Z2.exports = W2;
});
var ag = Z((oVA, M2) => {
  var rd = $("net"),
    X2 = $("assert"),
    w2 = HA(),
    { InvalidArgumentError: td, ConnectTimeoutError: ed } = dA(),
    qU,
    jU;
  if (global.FinalizationRegistry && !process.env.NODE_V8_COVERAGE)
    jU = class {
      constructor(Q) {
        (this._maxCachedSessions = Q),
          (this._sessionCache = new Map()),
          (this._sessionRegistry = new global.FinalizationRegistry((B) => {
            if (this._sessionCache.size < this._maxCachedSessions) return;
            let I = this._sessionCache.get(B);
            if (I !== void 0 && I.deref() === void 0)
              this._sessionCache.delete(B);
          }));
      }
      get(Q) {
        let B = this._sessionCache.get(Q);
        return B ? B.deref() : null;
      }
      set(Q, B) {
        if (this._maxCachedSessions === 0) return;
        this._sessionCache.set(Q, new WeakRef(B)),
          this._sessionRegistry.register(B, Q);
      }
    };
  else
    jU = class {
      constructor(Q) {
        (this._maxCachedSessions = Q), (this._sessionCache = new Map());
      }
      get(Q) {
        return this._sessionCache.get(Q);
      }
      set(Q, B) {
        if (this._maxCachedSessions === 0) return;
        if (this._sessionCache.size >= this._maxCachedSessions) {
          let { value: I } = this._sessionCache.keys().next();
          this._sessionCache.delete(I);
        }
        this._sessionCache.set(Q, B);
      }
    };
  function Ac({
    allowH2: A,
    maxCachedSessions: Q,
    socketPath: B,
    timeout: I,
    ...E
  }) {
    if (Q != null && (!Number.isInteger(Q) || Q < 0))
      throw new td("maxCachedSessions must be a positive integer or zero");
    let C = { path: B, ...E },
      g = new jU(Q == null ? 100 : Q);
    return (
      (I = I == null ? 1e4 : I),
      (A = A != null ? A : !1),
      function (
        {
          hostname: D,
          host: J,
          protocol: Y,
          port: N,
          servername: W,
          localAddress: X,
          httpSocket: M,
        },
        L,
      ) {
        let H;
        if (Y === "https:") {
          if (!qU) qU = $("tls");
          W = W || C.servername || w2.getServerName(J) || null;
          let O = W || D,
            f = g.get(O) || null;
          X2(O),
            (H = qU.connect({
              highWaterMark: 16384,
              ...C,
              servername: W,
              session: f,
              localAddress: X,
              ALPNProtocols: A ? ["http/1.1", "h2"] : ["http/1.1"],
              socket: M,
              port: N || 443,
              host: D,
            })),
            H.on("session", function (S) {
              g.set(O, S);
            });
        } else
          X2(!M, "httpSocket can only be sent on TLS update"),
            (H = rd.connect({
              highWaterMark: 65536,
              ...C,
              localAddress: X,
              port: N || 80,
              host: D,
            }));
        if (C.keepAlive == null || C.keepAlive) {
          let O =
            C.keepAliveInitialDelay === void 0
              ? 60000
              : C.keepAliveInitialDelay;
          H.setKeepAlive(!0, O);
        }
        let q = Qc(() => Bc(H), I);
        return (
          H.setNoDelay(!0)
            .once(Y === "https:" ? "secureConnect" : "connect", function () {
              if ((q(), L)) {
                let O = L;
                (L = null), O(null, this);
              }
            })
            .on("error", function (O) {
              if ((q(), L)) {
                let f = L;
                (L = null), f(O);
              }
            }),
          H
        );
      }
    );
  }
  function Qc(A, Q) {
    if (!Q) return () => {};
    let B = null,
      I = null,
      E = setTimeout(() => {
        B = setImmediate(() => {
          if (process.platform === "win32") I = setImmediate(() => A());
          else A();
        });
      }, Q);
    return () => {
      clearTimeout(E), clearImmediate(B), clearImmediate(I);
    };
  }
  function Bc(A) {
    w2.destroy(A, new ed());
  }
  M2.exports = Ac;
});
var V2 = Z((L2) => {
  Object.defineProperty(L2, "__esModule", { value: !0 });
  L2.enumToMap = void 0;
  function Ic(A) {
    let Q = {};
    return (
      Object.keys(A).forEach((B) => {
        let I = A[B];
        if (typeof I === "number") Q[B] = I;
      }),
      Q
    );
  }
  L2.enumToMap = Ic;
});
var S2 = Z((j2) => {
  Object.defineProperty(j2, "__esModule", { value: !0 });
  j2.SPECIAL_HEADERS =
    j2.HEADER_STATE =
    j2.MINOR =
    j2.MAJOR =
    j2.CONNECTION_TOKEN_CHARS =
    j2.HEADER_CHARS =
    j2.TOKEN =
    j2.STRICT_TOKEN =
    j2.HEX =
    j2.URL_CHAR =
    j2.STRICT_URL_CHAR =
    j2.USERINFO_CHARS =
    j2.MARK =
    j2.ALPHANUM =
    j2.NUM =
    j2.HEX_MAP =
    j2.NUM_MAP =
    j2.ALPHA =
    j2.FINISH =
    j2.H_METHOD_MAP =
    j2.METHOD_MAP =
    j2.METHODS_RTSP =
    j2.METHODS_ICE =
    j2.METHODS_HTTP =
    j2.METHODS =
    j2.LENIENT_FLAGS =
    j2.FLAGS =
    j2.TYPE =
    j2.ERROR =
      void 0;
  var Ec = V2(),
    Cc;
  (function (A) {
    (A[(A.OK = 0)] = "OK"),
      (A[(A.INTERNAL = 1)] = "INTERNAL"),
      (A[(A.STRICT = 2)] = "STRICT"),
      (A[(A.LF_EXPECTED = 3)] = "LF_EXPECTED"),
      (A[(A.UNEXPECTED_CONTENT_LENGTH = 4)] = "UNEXPECTED_CONTENT_LENGTH"),
      (A[(A.CLOSED_CONNECTION = 5)] = "CLOSED_CONNECTION"),
      (A[(A.INVALID_METHOD = 6)] = "INVALID_METHOD"),
      (A[(A.INVALID_URL = 7)] = "INVALID_URL"),
      (A[(A.INVALID_CONSTANT = 8)] = "INVALID_CONSTANT"),
      (A[(A.INVALID_VERSION = 9)] = "INVALID_VERSION"),
      (A[(A.INVALID_HEADER_TOKEN = 10)] = "INVALID_HEADER_TOKEN"),
      (A[(A.INVALID_CONTENT_LENGTH = 11)] = "INVALID_CONTENT_LENGTH"),
      (A[(A.INVALID_CHUNK_SIZE = 12)] = "INVALID_CHUNK_SIZE"),
      (A[(A.INVALID_STATUS = 13)] = "INVALID_STATUS"),
      (A[(A.INVALID_EOF_STATE = 14)] = "INVALID_EOF_STATE"),
      (A[(A.INVALID_TRANSFER_ENCODING = 15)] = "INVALID_TRANSFER_ENCODING"),
      (A[(A.CB_MESSAGE_BEGIN = 16)] = "CB_MESSAGE_BEGIN"),
      (A[(A.CB_HEADERS_COMPLETE = 17)] = "CB_HEADERS_COMPLETE"),
      (A[(A.CB_MESSAGE_COMPLETE = 18)] = "CB_MESSAGE_COMPLETE"),
      (A[(A.CB_CHUNK_HEADER = 19)] = "CB_CHUNK_HEADER"),
      (A[(A.CB_CHUNK_COMPLETE = 20)] = "CB_CHUNK_COMPLETE"),
      (A[(A.PAUSED = 21)] = "PAUSED"),
      (A[(A.PAUSED_UPGRADE = 22)] = "PAUSED_UPGRADE"),
      (A[(A.PAUSED_H2_UPGRADE = 23)] = "PAUSED_H2_UPGRADE"),
      (A[(A.USER = 24)] = "USER");
  })((Cc = j2.ERROR || (j2.ERROR = {})));
  var gc;
  (function (A) {
    (A[(A.BOTH = 0)] = "BOTH"),
      (A[(A.REQUEST = 1)] = "REQUEST"),
      (A[(A.RESPONSE = 2)] = "RESPONSE");
  })((gc = j2.TYPE || (j2.TYPE = {})));
  var Fc;
  (function (A) {
    (A[(A.CONNECTION_KEEP_ALIVE = 1)] = "CONNECTION_KEEP_ALIVE"),
      (A[(A.CONNECTION_CLOSE = 2)] = "CONNECTION_CLOSE"),
      (A[(A.CONNECTION_UPGRADE = 4)] = "CONNECTION_UPGRADE"),
      (A[(A.CHUNKED = 8)] = "CHUNKED"),
      (A[(A.UPGRADE = 16)] = "UPGRADE"),
      (A[(A.CONTENT_LENGTH = 32)] = "CONTENT_LENGTH"),
      (A[(A.SKIPBODY = 64)] = "SKIPBODY"),
      (A[(A.TRAILING = 128)] = "TRAILING"),
      (A[(A.TRANSFER_ENCODING = 512)] = "TRANSFER_ENCODING");
  })((Fc = j2.FLAGS || (j2.FLAGS = {})));
  var Dc;
  (function (A) {
    (A[(A.HEADERS = 1)] = "HEADERS"),
      (A[(A.CHUNKED_LENGTH = 2)] = "CHUNKED_LENGTH"),
      (A[(A.KEEP_ALIVE = 4)] = "KEEP_ALIVE");
  })((Dc = j2.LENIENT_FLAGS || (j2.LENIENT_FLAGS = {})));
  var e;
  (function (A) {
    (A[(A.DELETE = 0)] = "DELETE"),
      (A[(A.GET = 1)] = "GET"),
      (A[(A.HEAD = 2)] = "HEAD"),
      (A[(A.POST = 3)] = "POST"),
      (A[(A.PUT = 4)] = "PUT"),
      (A[(A.CONNECT = 5)] = "CONNECT"),
      (A[(A.OPTIONS = 6)] = "OPTIONS"),
      (A[(A.TRACE = 7)] = "TRACE"),
      (A[(A.COPY = 8)] = "COPY"),
      (A[(A.LOCK = 9)] = "LOCK"),
      (A[(A.MKCOL = 10)] = "MKCOL"),
      (A[(A.MOVE = 11)] = "MOVE"),
      (A[(A.PROPFIND = 12)] = "PROPFIND"),
      (A[(A.PROPPATCH = 13)] = "PROPPATCH"),
      (A[(A.SEARCH = 14)] = "SEARCH"),
      (A[(A.UNLOCK = 15)] = "UNLOCK"),
      (A[(A.BIND = 16)] = "BIND"),
      (A[(A.REBIND = 17)] = "REBIND"),
      (A[(A.UNBIND = 18)] = "UNBIND"),
      (A[(A.ACL = 19)] = "ACL"),
      (A[(A.REPORT = 20)] = "REPORT"),
      (A[(A.MKACTIVITY = 21)] = "MKACTIVITY"),
      (A[(A.CHECKOUT = 22)] = "CHECKOUT"),
      (A[(A.MERGE = 23)] = "MERGE"),
      (A[(A["M-SEARCH"] = 24)] = "M-SEARCH"),
      (A[(A.NOTIFY = 25)] = "NOTIFY"),
      (A[(A.SUBSCRIBE = 26)] = "SUBSCRIBE"),
      (A[(A.UNSUBSCRIBE = 27)] = "UNSUBSCRIBE"),
      (A[(A.PATCH = 28)] = "PATCH"),
      (A[(A.PURGE = 29)] = "PURGE"),
      (A[(A.MKCALENDAR = 30)] = "MKCALENDAR"),
      (A[(A.LINK = 31)] = "LINK"),
      (A[(A.UNLINK = 32)] = "UNLINK"),
      (A[(A.SOURCE = 33)] = "SOURCE"),
      (A[(A.PRI = 34)] = "PRI"),
      (A[(A.DESCRIBE = 35)] = "DESCRIBE"),
      (A[(A.ANNOUNCE = 36)] = "ANNOUNCE"),
      (A[(A.SETUP = 37)] = "SETUP"),
      (A[(A.PLAY = 38)] = "PLAY"),
      (A[(A.PAUSE = 39)] = "PAUSE"),
      (A[(A.TEARDOWN = 40)] = "TEARDOWN"),
      (A[(A.GET_PARAMETER = 41)] = "GET_PARAMETER"),
      (A[(A.SET_PARAMETER = 42)] = "SET_PARAMETER"),
      (A[(A.REDIRECT = 43)] = "REDIRECT"),
      (A[(A.RECORD = 44)] = "RECORD"),
      (A[(A.FLUSH = 45)] = "FLUSH");
  })((e = j2.METHODS || (j2.METHODS = {})));
  j2.METHODS_HTTP = [
    e.DELETE,
    e.GET,
    e.HEAD,
    e.POST,
    e.PUT,
    e.CONNECT,
    e.OPTIONS,
    e.TRACE,
    e.COPY,
    e.LOCK,
    e.MKCOL,
    e.MOVE,
    e.PROPFIND,
    e.PROPPATCH,
    e.SEARCH,
    e.UNLOCK,
    e.BIND,
    e.REBIND,
    e.UNBIND,
    e.ACL,
    e.REPORT,
    e.MKACTIVITY,
    e.CHECKOUT,
    e.MERGE,
    e["M-SEARCH"],
    e.NOTIFY,
    e.SUBSCRIBE,
    e.UNSUBSCRIBE,
    e.PATCH,
    e.PURGE,
    e.MKCALENDAR,
    e.LINK,
    e.UNLINK,
    e.PRI,
    e.SOURCE,
  ];
  j2.METHODS_ICE = [e.SOURCE];
  j2.METHODS_RTSP = [
    e.OPTIONS,
    e.DESCRIBE,
    e.ANNOUNCE,
    e.SETUP,
    e.PLAY,
    e.PAUSE,
    e.TEARDOWN,
    e.GET_PARAMETER,
    e.SET_PARAMETER,
    e.REDIRECT,
    e.RECORD,
    e.FLUSH,
    e.GET,
    e.POST,
  ];
  j2.METHOD_MAP = Ec.enumToMap(e);
  j2.H_METHOD_MAP = {};
  Object.keys(j2.METHOD_MAP).forEach((A) => {
    if (/^H/.test(A)) j2.H_METHOD_MAP[A] = j2.METHOD_MAP[A];
  });
  var Yc;
  (function (A) {
    (A[(A.SAFE = 0)] = "SAFE"),
      (A[(A.SAFE_WITH_CB = 1)] = "SAFE_WITH_CB"),
      (A[(A.UNSAFE = 2)] = "UNSAFE");
  })((Yc = j2.FINISH || (j2.FINISH = {})));
  j2.ALPHA = [];
  for (let A = 65; A <= 90; A++)
    j2.ALPHA.push(String.fromCharCode(A)),
      j2.ALPHA.push(String.fromCharCode(A + 32));
  j2.NUM_MAP = { 0: 0, 1: 1, 2: 2, 3: 3, 4: 4, 5: 5, 6: 6, 7: 7, 8: 8, 9: 9 };
  j2.HEX_MAP = {
    0: 0,
    1: 1,
    2: 2,
    3: 3,
    4: 4,
    5: 5,
    6: 6,
    7: 7,
    8: 8,
    9: 9,
    A: 10,
    B: 11,
    C: 12,
    D: 13,
    E: 14,
    F: 15,
    a: 10,
    b: 11,
    c: 12,
    d: 13,
    e: 14,
    f: 15,
  };
  j2.NUM = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9"];
  j2.ALPHANUM = j2.ALPHA.concat(j2.NUM);
  j2.MARK = ["-", "_", ".", "!", "~", "*", "'", "(", ")"];
  j2.USERINFO_CHARS = j2.ALPHANUM.concat(j2.MARK).concat([
    "%",
    ";",
    ":",
    "&",
    "=",
    "+",
    "$",
    ",",
  ]);
  j2.STRICT_URL_CHAR = [
    "!",
    '"',
    "$",
    "%",
    "&",
    "'",
    "(",
    ")",
    "*",
    "+",
    ",",
    "-",
    ".",
    "/",
    ":",
    ";",
    "<",
    "=",
    ">",
    "@",
    "[",
    "\\",
    "]",
    "^",
    "_",
    "`",
    "{",
    "|",
    "}",
    "~",
  ].concat(j2.ALPHANUM);
  j2.URL_CHAR = j2.STRICT_URL_CHAR.concat(["\t", "\f"]);
  for (let A = 128; A <= 255; A++) j2.URL_CHAR.push(A);
  j2.HEX = j2.NUM.concat([
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
  ]);
  j2.STRICT_TOKEN = [
    "!",
    "#",
    "$",
    "%",
    "&",
    "'",
    "*",
    "+",
    "-",
    ".",
    "^",
    "_",
    "`",
    "|",
    "~",
  ].concat(j2.ALPHANUM);
  j2.TOKEN = j2.STRICT_TOKEN.concat([" "]);
  j2.HEADER_CHARS = ["\t"];
  for (let A = 32; A <= 255; A++) if (A !== 127) j2.HEADER_CHARS.push(A);
  j2.CONNECTION_TOKEN_CHARS = j2.HEADER_CHARS.filter((A) => A !== 44);
  j2.MAJOR = j2.NUM_MAP;
  j2.MINOR = j2.MAJOR;
  var K0;
  (function (A) {
    (A[(A.GENERAL = 0)] = "GENERAL"),
      (A[(A.CONNECTION = 1)] = "CONNECTION"),
      (A[(A.CONTENT_LENGTH = 2)] = "CONTENT_LENGTH"),
      (A[(A.TRANSFER_ENCODING = 3)] = "TRANSFER_ENCODING"),
      (A[(A.UPGRADE = 4)] = "UPGRADE"),
      (A[(A.CONNECTION_KEEP_ALIVE = 5)] = "CONNECTION_KEEP_ALIVE"),
      (A[(A.CONNECTION_CLOSE = 6)] = "CONNECTION_CLOSE"),
      (A[(A.CONNECTION_UPGRADE = 7)] = "CONNECTION_UPGRADE"),
      (A[(A.TRANSFER_ENCODING_CHUNKED = 8)] = "TRANSFER_ENCODING_CHUNKED");
  })((K0 = j2.HEADER_STATE || (j2.HEADER_STATE = {})));
  j2.SPECIAL_HEADERS = {
    connection: K0.CONNECTION,
    "content-length": K0.CONTENT_LENGTH,
    "proxy-connection": K0.CONNECTION,
    "transfer-encoding": K0.TRANSFER_ENCODING,
    upgrade: K0.UPGRADE,
  };
});
var PU = Z((tVA, c2) => {
  var JE = HA(),
    { kBodyUsed: og } = aA(),
    vU = $("assert"),
    { InvalidArgumentError: Lc } = dA(),
    Rc = $("events"),
    Vc = [300, 301, 302, 303, 307, 308],
    b2 = Symbol("body");
  class xU {
    constructor(A) {
      (this[b2] = A), (this[og] = !1);
    }
    async *[Symbol.asyncIterator]() {
      vU(!this[og], "disturbed"), (this[og] = !0), yield* this[b2];
    }
  }
  class d2 {
    constructor(A, Q, B, I) {
      if (Q != null && (!Number.isInteger(Q) || Q < 0))
        throw new Lc("maxRedirections must be a positive number");
      if (
        (JE.validateHandler(I, B.method, B.upgrade),
        (this.dispatch = A),
        (this.location = null),
        (this.abort = null),
        (this.opts = { ...B, maxRedirections: 0 }),
        (this.maxRedirections = Q),
        (this.handler = I),
        (this.history = []),
        JE.isStream(this.opts.body))
      ) {
        if (JE.bodyLength(this.opts.body) === 0)
          this.opts.body.on("data", function () {
            vU(!1);
          });
        if (typeof this.opts.body.readableDidRead !== "boolean")
          (this.opts.body[og] = !1),
            Rc.prototype.on.call(this.opts.body, "data", function () {
              this[og] = !0;
            });
      } else if (this.opts.body && typeof this.opts.body.pipeTo === "function")
        this.opts.body = new xU(this.opts.body);
      else if (
        this.opts.body &&
        typeof this.opts.body !== "string" &&
        !ArrayBuffer.isView(this.opts.body) &&
        JE.isIterable(this.opts.body)
      )
        this.opts.body = new xU(this.opts.body);
    }
    onConnect(A) {
      (this.abort = A), this.handler.onConnect(A, { history: this.history });
    }
    onUpgrade(A, Q, B) {
      this.handler.onUpgrade(A, Q, B);
    }
    onError(A) {
      this.handler.onError(A);
    }
    onHeaders(A, Q, B, I) {
      if (
        ((this.location =
          this.history.length >= this.maxRedirections ||
          JE.isDisturbed(this.opts.body)
            ? null
            : $c(A, Q)),
        this.opts.origin)
      )
        this.history.push(new URL(this.opts.path, this.opts.origin));
      if (!this.location) return this.handler.onHeaders(A, Q, B, I);
      let {
          origin: E,
          pathname: C,
          search: g,
        } = JE.parseURL(
          new URL(
            this.location,
            this.opts.origin && new URL(this.opts.path, this.opts.origin),
          ),
        ),
        F = g ? `${C}${g}` : C;
      if (
        ((this.opts.headers = Hc(
          this.opts.headers,
          A === 303,
          this.opts.origin !== E,
        )),
        (this.opts.path = F),
        (this.opts.origin = E),
        (this.opts.maxRedirections = 0),
        (this.opts.query = null),
        A === 303 && this.opts.method !== "HEAD")
      )
        (this.opts.method = "GET"), (this.opts.body = null);
    }
    onData(A) {
      if (this.location);
      else return this.handler.onData(A);
    }
    onComplete(A) {
      if (this.location)
        (this.location = null),
          (this.abort = null),
          this.dispatch(this.opts, this);
      else this.handler.onComplete(A);
    }
    onBodySent(A) {
      if (this.handler.onBodySent) this.handler.onBodySent(A);
    }
  }
  function $c(A, Q) {
    if (Vc.indexOf(A) === -1) return null;
    for (let B = 0; B < Q.length; B += 2)
      if (Q[B].toString().toLowerCase() === "location") return Q[B + 1];
  }
  function m2(A, Q, B) {
    if (A.length === 4) return JE.headerNameToString(A) === "host";
    if (Q && JE.headerNameToString(A).startsWith("content-")) return !0;
    if (B && (A.length === 13 || A.length === 6 || A.length === 19)) {
      let I = JE.headerNameToString(A);
      return (
        I === "authorization" || I === "cookie" || I === "proxy-authorization"
      );
    }
    return !1;
  }
  function Hc(A, Q, B) {
    let I = [];
    if (Array.isArray(A)) {
      for (let E = 0; E < A.length; E += 2)
        if (!m2(A[E], Q, B)) I.push(A[E], A[E + 1]);
    } else if (A && typeof A === "object") {
      for (let E of Object.keys(A)) if (!m2(E, Q, B)) I.push(E, A[E]);
    } else vU(A == null, "headers must be an object or an array");
    return I;
  }
  c2.exports = d2;
});
var eD = Z((eVA, u2) => {
  var Kc = PU();
  function zc({ maxRedirections: A }) {
    return (Q) => {
      return function (I, E) {
        let { maxRedirections: C = A } = I;
        if (!C) return Q(I, E);
        let g = new Kc(Q, C, I, E);
        return (I = { ...I, maxRedirections: 0 }), Q(I, g);
      };
    };
  }
  u2.exports = zc;
});
var _U = Z((A3A, l2) => {
  l2.exports =
    "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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ADcDACAAQShqQgA3AwAgAEEgakIANwMAIABBEGpCADcDACAAQQhqQgA3AwAgAEHdATYCHEEAC3sBAX8CQCAAKAIMIgMNAAJAIAAoAgRFDQAgACABNgIECwJAIAAgASACEMSAgIAAIgMNACAAKAIMDwsgACADNgIcQQAhAyAAKAIEIgFFDQAgACABIAIgACgCCBGBgICAAAAiAUUNACAAIAI2AhQgACABNgIMIAEhAwsgAwvk8wEDDn8DfgR/I4CAgIAAQRBrIgMkgICAgAAgASEEIAEhBSABIQYgASEHIAEhCCABIQkgASEKIAEhCyABIQwgASENIAEhDiABIQ8CQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgACgCHCIQQX9qDt0B2gEB2QECAwQFBgcICQoLDA0O2AEPENcBERLWARMUFRYXGBkaG+AB3wEcHR7VAR8gISIjJCXUASYnKCkqKyzTAdIBLS7RAdABLzAxMjM0NTY3ODk6Ozw9Pj9AQUJDREVG2wFHSElKzwHOAUvNAUzMAU1OT1BRUlNUVVZXWFlaW1xdXl9gYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAC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FCAAIBA2AgxBACEQDLIBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxNCyAAQdMANgIcIAAgATYCFCAAIBA2AgxBACEQDLEBCyAAKAIEIRAgAEEANgIEAkAgACAQIAEQp4CAgAAiEA0AIAEhAQxRCyAAQeUANgIcIAAgATYCFCAAIBA2AgxBACEQDLABCyAAQQA2AhwgACABNgIUIABBxoqAgAA2AhAgAEEHNgIMQQAhEAyvAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHSADYCHCAAIAE2AhQgACAQNgIMQQAhEAyuAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMSQsgAEHTADYCHCAAIAE2AhQgACAQNgIMQQAhEAytAQsgACgCBCEQIABBADYCBAJAIAAgECABEKeAgIAAIhANACABIQEMTQsgAEHlADYCHCAAIAE2AhQgACAQNgIMQQAhEAysAQsgAEEANgIcIAAgATYCFCAAQdyIgIAANgIQIABBBzYCDEEAIRAMqwELIBBBP0cNASABQQFqIQELQQUhEAyQAQtBACEQIABBADYCHCAAIAE2AhQgAEH9koCAADYCECAAQQc2AgwMqAELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0gA2AhwgACABNgIUIAAgEDYCDEEAIRAMpwELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEILIABB0wA2AhwgACABNgIUIAAgEDYCDEEAIRAMpgELIAAoAgQhECAAQQA2AgQCQCAAIBAgARCngICAACIQDQAgASEBDEYLIABB5QA2AhwgACABNgIUIAAgEDYCDEEAIRAMpQELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0gA2AhwgACAUNgIUIAAgATYCDEEAIRAMpAELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDD8LIABB0wA2AhwgACAUNgIUIAAgATYCDEEAIRAMowELIAAoAgQhASAAQQA2AgQCQCAAIAEgFBCngICAACIBDQAgFCEBDEMLIABB5QA2AhwgACAU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YWdlX2JlZ2luYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlYCBjYWxsYmFjayBlcnJvcgBgb25fc3RhdHVzX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdmVyc2lvbl9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX3VybF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX21ldGhvZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lYCBjYWxsYmFjayBlcnJvcgBVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNlcnZlcgBJbnZhbGlkIGhlYWRlciB2YWx1ZSBjaGFyAEludmFsaWQgaGVhZGVyIGZpZWxkIGNoYXIAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl92ZXJzaW9uAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBIVFRQIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgdmFsdWUATWlzc2luZyBleHBlY3RlZCBMRiBhZnRlciBoZWFkZXIgdmFsdWUASW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIHF1b3RlIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGVkIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX3Jlc2V0IHBhdXNlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl92YWx1ZSBwYXVzZQBvbl9zdGF0dXNfY29tcGxldGUgcGF1c2UAb25fdmVyc2lvbl9jb21wbGV0ZSBwYXVzZQBvbl91cmxfY29tcGxldGUgcGF1c2UAb25fY2h1bmtfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX3ZhbHVlX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAb25fbWV0aG9kX2NvbXBsZXRlIHBhdXNlAG9uX2hlYWRlcl9maWVsZF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19leHRlbnNpb25fbmFtZSBwYXVzZQBVbmV4cGVjdGVkIHNwYWNlIGFmdGVyIHN0YXJ0IGxpbmUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fbmFtZQBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBleHRlbnNpb25zIG5hbWUAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9tZXRob2QARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAFNXSVRDSF9QUk9YWQBVU0VfUFJPWFkATUtBQ1RJVklUWQBVTlBST0NFU1NBQkxFX0VOVElUWQBDT1BZAE1PVkVEX1BFUk1BTkVOVExZAFRPT19FQVJMWQBOT1RJRlkARkFJTEVEX0RFUEVOREVOQ1kAQkFEX0dBVEVXQVkAUExBWQBQVVQAQ0hFQ0tPVVQAR0FURVdBWV9USU1FT1VUAFJFUVVFU1RfVElNRU9VVABORVRXT1JLX0NPTk5FQ1RfVElNRU9VVABDT05ORUNUSU9OX1RJTUVPVVQATE9HSU5fVElNRU9VVABORVRXT1JLX1JFQURfVElNRU9VVABQT1NUAE1JU0RJUkVDVEVEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9SRVFVRVNUAENMSUVOVF9DTE9TRURfTE9BRF9CQUxBTkNFRF9SRVFVRVNUAEJBRF9SRVFVRVNUAEhUVFBfUkVRVUVTVF9TRU5UX1RPX0hUVFBTX1BPUlQAUkVQT1JUAElNX0FfVEVBUE9UAFJFU0VUX0NPTlRFTlQATk9fQ09OVEVOVABQQVJUSUFMX0NPTlRFTlQASFBFX0lOVkFMSURfQ09OU1RBTlQASFBFX0NCX1JFU0VUAEdFVABIUEVfU1RSSUNUAENPTkZMSUNUAFRFTVBPUkFSWV9SRURJUkVDVABQRVJNQU5FTlRfUkVESVJFQ1QAQ09OTkVDVABNVUxUSV9TVEFUVVMASFBFX0lOVkFMSURfU1RBVFVTAFRPT19NQU5ZX1JFUVVFU1RTAEVBUkxZX0hJTlRTAFVOQVZBSUxBQkxFX0ZPUl9MRUdBTF9SRUFTT05TAE9QVElPTlMAU1dJVENISU5HX1BST1RPQ09MUwBWQVJJQU5UX0FMU09fTkVHT1RJQVRFUwBNVUxUSVBMRV9DSE9JQ0VTAElOVEVSTkFMX1NFUlZFUl9FUlJPUgBXRUJfU0VSVkVSX1VOS05PV05fRVJST1IAUkFJTEdVTl9FUlJPUgBJREVOVElUWV9QUk9WSURFUl9BVVRIRU5USUNBVElPTl9FUlJPUgBTU0xfQ0VSVElGSUNBVEVfRVJST1IASU5WQUxJRF9YX0ZPUldBUkRFRF9GT1IAU0VUX1BBUkFNRVRFUgBHRVRfUEFSQU1FVEVSAEhQRV9VU0VSAFNFRV9PVEhFUgBIUEVfQ0JfQ0hVTktfSEVBREVSAE1LQ0FMRU5EQVIAU0VUVVAAV0VCX1NFUlZFUl9JU19ET1dOAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIRVVSSVNUSUNfRVhQSVJBVElPTgBESVNDT05ORUNURURfT1BFUkFUSU9OAE5PTl9BVVRIT1JJVEFUSVZFX0lORk9STUFUSU9OAEhQRV9JTlZBTElEX1ZFUlNJT04ASFBFX0NCX01FU1NBR0VfQkVHSU4AU0lURV9JU19GUk9aRU4ASFBFX0lOVkFMSURfSEVBREVSX1RPS0VOAElOVkFMSURfVE9LRU4ARk9SQklEREVOAEVOSEFOQ0VfWU9VUl9DQUxNAEhQRV9JTlZBTElEX1VSTABCTE9DS0VEX0JZX1BBUkVOVEFMX0NPTlRST0wATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFX1VOT0ZGSUNJQUwASFBFX09LAFVOTElOSwBVTkxPQ0sAUFJJAFJFVFJZX1dJVEgASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAFVSSV9UT09fTE9ORwBQUk9DRVNTSU5HAE1JU0NFTExBTkVPVVNfUEVSU0lTVEVOVF9XQVJOSU5HAE1JU0NFTExBTkVPVVNfV0FSTklORwBIUEVfSU5WQUxJRF9UUkFOU0ZFUl9FTkNPRElORwBFeHBlY3RlZCBDUkxGAEhQRV9JTlZBTElEX0NIVU5LX1NJWkUATU9WRQBDT05USU5VRQBIUEVfQ0JfU1RBVFVTX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9WRVJTSU9OX0NPTVBMRVRFAEhQRV9DQl9VUkxfQ09NUExFVEUASFBFX0NCX0NIVU5LX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfVkFMVUVfQ09NUExFVEUASFBFX0NCX0NIVU5LX0VYVEVOU0lPTl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX05BTUVfQ09NUExFVEUASFBFX0NCX01FU1NBR0VfQ09NUExFVEUASFBFX0NCX01FVEhPRF9DT01QTEVURQBIUEVfQ0JfSEVBREVSX0ZJRUxEX0NPTVBMRVRFAERFTEVURQBIUEVfSU5WQUxJRF9FT0ZfU1RBVEUASU5WQUxJRF9TU0xfQ0VSVElGSUNBVEUAUEFVU0UATk9fUkVTUE9OU0UAVU5TVVBQT1JURURfTUVESUFfVFlQRQBHT05FAE5PVF9BQ0NFUFRBQkxFAFNFUlZJQ0VfVU5BVkFJTEFCTEUAUkFOR0VfTk9UX1NBVElTRklBQkxFAE9SSUdJTl9JU19VTlJFQUNIQUJMRQBSRVNQT05TRV9JU19TVEFMRQBQVVJHRQBNRVJHRQBSRVFVRVNUX0hFQURFUl9GSUVMRFNfVE9PX0xBUkdFAFJFUVVFU1RfSEVBREVSX1RPT19MQVJHRQBQQVlMT0FEX1RPT19MQVJHRQBJTlNVRkZJQ0lFTlRfU1RPUkFHRQBIUEVfUEFVU0VEX1VQR1JBREUASFBFX1BBVVNFRF9IMl9VUEdSQURFAFNPVVJDRQBBTk5PVU5DRQBUUkFDRQBIUEVfVU5FWFBFQ1RFRF9TUEFDRQBERVNDUklCRQBVTlNVQlNDUklCRQBSRUNPUkQASFBFX0lOVkFMSURfTUVUSE9EAE5PVF9GT1VORABQUk9QRklORABVTkJJTkQAUkVCSU5EAFVOQVVUSE9SSVpFRABNRVRIT0RfTk9UX0FMTE9XRUQASFRUUF9WRVJTSU9OX05PVF9TVVBQT1JURUQAQUxSRUFEWV9SRVBPUlRFRABBQ0NFUFRFRABOT1RfSU1QTEVNRU5URUQATE9PUF9ERVRFQ1RFRABIUEVfQ1JfRVhQRUNURUQASFBFX0xGX0VYUEVDVEVEAENSRUFURUQASU1fVVNFRABIUEVfUEFVU0VEAFRJTUVPVVRfT0NDVVJFRABQQVlNRU5UX1JFUVVJUkVEAFBSRUNPTkRJVElPTl9SRVFVSVJFRABQUk9YWV9BVVRIRU5USUNBVElPTl9SRVFVSVJFRABORVRXT1JLX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAExFTkdUSF9SRVFVSVJFRABTU0xfQ0VSVElGSUNBVEVfUkVRVUlSRUQAVVBHUkFERV9SRVFVSVJFRABQQUdFX0VYUElSRUQAUFJFQ09ORElUSU9OX0ZBSUxFRABFWFBFQ1RBVElPTl9GQUlMRUQAUkVWQUxJREFUSU9OX0ZBSUxFRABTU0xfSEFORFNIQUtFX0ZBSUxFRABMT0NLRUQAVFJBTlNGT1JNQVRJT05fQVBQTElFRABOT1RfTU9ESUZJRUQATk9UX0VYVEVOREVEAEJBTkRXSURUSF9MSU1JVF9FWENFRURFRABTSVRFX0lTX09WRVJMT0FERUQASEVBRABFeHBlY3RlZCBIVFRQLwAAXhMAACYTAAAwEAAA8BcAAJ0TAAAVEgAAORcAAPASAAAKEAAAdRIAAK0SAACCEwAATxQAAH8QAACgFQAAIxQAAIkSAACLFAAATRUAANQRAADPFAAAEBgAAMkWAADcFgAAwREAAOAXAAC7FAAAdBQAAHwVAADlFAAACBcAAB8QAABlFQAAoxQAACgVAAACFQAAmRUAACwQAACLGQAATw8AANQOAABqEAAAzhAAAAIXAACJDgAAbhMAABwTAABmFAAAVhcAAMETAADNEwAAbBMAAGgXAABmFwAAXxcAACITAADODwAAaQ4AANgOAABjFgAAyxMAAKoOAAAoFwAAJhcAAMUTAABdFgAA6BEAAGcTAABlEwAA8hYAAHMTAAAdFwAA+RYAAPMRAADPDgAAzhUAAAwSAACzEQAApREAAGEQAAAyFwAAuxMAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIDAgICAgIAAAICAAICAAICAgICAgICAgIABAAAAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAACAAICAgICAAACAgACAgACAgICAgICAgICAAMABAAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIAAgACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbG9zZWVlcC1hbGl2ZQAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQIBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBY2h1bmtlZAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEAAAEBAAEBAAEBAQEBAQEBAQEAAAAAAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABlY3Rpb25lbnQtbGVuZ3Rob25yb3h5LWNvbm5lY3Rpb24AAAAAAAAAAAAAAAAAAAByYW5zZmVyLWVuY29kaW5ncGdyYWRlDQoNCg0KU00NCg0KVFRQL0NFL1RTUC8AAAAAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEFAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAAAAQAAAgAAAAAAAAAAAAAAAAAAAAAAAAMEAAAEBAQEBAQEBAQEBAUEBAQEBAQEBAQEBAQABAAGBwQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAIAAAAAAgAAAAAAAAAAAAAAAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABOT1VOQ0VFQ0tPVVRORUNURVRFQ1JJQkVMVVNIRVRFQURTRUFSQ0hSR0VDVElWSVRZTEVOREFSVkVPVElGWVBUSU9OU0NIU0VBWVNUQVRDSEdFT1JESVJFQ1RPUlRSQ0hQQVJBTUVURVJVUkNFQlNDUklCRUFSRE9XTkFDRUlORE5LQ0tVQlNDUklCRUhUVFAvQURUUC8=";
});
var i2 = Z((Q3A, p2) => {
  p2.exports =
    "AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAA0ZFAwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAAGBgYGAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAwABBAUBcAESEgUDAQACBggBfwFBgNQECwfRBSIGbWVtb3J5AgALX2luaXRpYWxpemUACRlfX2luZGlyZWN0X2Z1bmN0aW9uX3RhYmxlAQALbGxodHRwX2luaXQAChhsbGh0dHBfc2hvdWxkX2tlZXBfYWxpdmUAQQxsbGh0dHBfYWxsb2MADAZtYWxsb2MARgtsbGh0dHBfZnJlZQANBGZyZWUASA9sbGh0dHBfZ2V0X3R5cGUADhVsbGh0dHBfZ2V0X2h0dHBfbWFqb3IADxVsbGh0dHBfZ2V0X2h0dHBfbWlub3IAEBFsbGh0dHBfZ2V0X21ldGhvZAARFmxsaHR0cF9nZXRfc3RhdHVzX2NvZGUAEhJsbGh0dHBfZ2V0X3VwZ3JhZGUAEwxsbGh0dHBfcmVzZXQAFA5sbGh0dHBfZXhlY3V0ZQAVFGxsaHR0cF9zZXR0aW5nc19pbml0ABYNbGxodHRwX2ZpbmlzaAAXDGxsaHR0cF9wYXVzZQAYDWxsaHR0cF9yZXN1bWUAGRtsbGh0dHBfcmVzdW1lX2FmdGVyX3VwZ3JhZGUAGhBsbGh0dHBfZ2V0X2Vycm5vABsXbGxodHRwX2dldF9lcnJvcl9yZWFzb24AHBdsbGh0dHBfc2V0X2Vycm9yX3JlYXNvbgAdFGxsaHR0cF9nZXRfZXJyb3JfcG9zAB4RbGxodHRwX2Vycm5vX25hbWUAHxJsbGh0dHBfbWV0aG9kX25hbWUAIBJs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IAH9CwMAIABBMGogAf0LAwAgAEEgaiAB/QsDACAAQd0BNgIcQQALewEBfwJAIAAoAgwiAw0AAkAgACgCBEUNACAAIAE2AgQLAkAgACABIAIQxICAgAAiAw0AIAAoAgwPCyAAIAM2AhxBACEDIAAoAgQiAUUNACAAIAEgAiAAKAIIEYGAgIAAACIBRQ0AIAAgAjYCFCAAIAE2AgwgASEDCyADC+TzAQMOfwN+BH8jgICAgABBEGsiAySAgICAACABIQQgASEFIAEhBiABIQcgASEIIAEhCSABIQogASELIAEhDCABIQ0gASEOIAEhDwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAAKAIcIhBBf2oO3QHaAQHZAQIDBAUGBwgJCgsMDQ7YAQ8Q1wEREtYBExQVFhcYGRob4AHfARwdHtUBHyAhIiMkJdQBJicoKSorLNMB0gEtLtEB0AEvMDEyMzQ1Njc4OTo7PD0+P0BBQkNERUbbAUdISUrPAc4BS80BTMwBTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEB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QAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIBAOxwEAAQID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YWNrIGVycm9yAGBvbl9jaHVua19leHRlbnNpb25fdmFsdWVgIGNhbGxiYWNrIGVycm9yAGBvbl9zdGF0dXNfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl92ZXJzaW9uX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fdXJsX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGVgIGNhbGxiYWNrIGVycm9yAGBvbl9tZXNzYWdlX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWV0aG9kX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfZXh0ZW5zaW9uX25hbWVgIGNhbGxiYWNrIGVycm9yAFVuZXhwZWN0ZWQgY2hhciBpbiB1cmwgc2VydmVyAEludmFsaWQgaGVhZGVyIHZhbHVlIGNoYXIASW52YWxpZCBoZWFkZXIgZmllbGQgY2hhcgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3ZlcnNpb24ASW52YWxpZCBtaW5vciB2ZXJzaW9uAEludmFsaWQgbWFqb3IgdmVyc2lvbgBFeHBlY3RlZCBzcGFjZSBhZnRlciB2ZXJzaW9uAEV4cGVjdGVkIENSTEYgYWZ0ZXIgdmVyc2lvbgBJbnZhbGlkIEhUVFAgdmVyc2lvbgBJbnZhbGlkIGhlYWRlciB0b2tlbgBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX3VybABJbnZhbGlkIGNoYXJhY3RlcnMgaW4gdXJsAFVuZXhwZWN0ZWQgc3RhcnQgY2hhciBpbiB1cmwARG91YmxlIEAgaW4gdXJsAEVtcHR5IENvbnRlbnQtTGVuZ3RoAEludmFsaWQgY2hhcmFjdGVyIGluIENvbnRlbnQtTGVuZ3RoAER1cGxpY2F0ZSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXIgaW4gdXJsIHBhdGgAQ29udGVudC1MZW5ndGggY2FuJ3QgYmUgcHJlc2VudCB3aXRoIFRyYW5zZmVyLUVuY29kaW5nAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHNpemUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfdmFsdWUAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9jaHVua19leHRlbnNpb25fdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyB2YWx1ZQBNaXNzaW5nIGV4cGVjdGVkIExGIGFmdGVyIGhlYWRlciB2YWx1ZQBJbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AgaGVhZGVyIHZhbHVlAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgcXVvdGUgdmFsdWUASW52YWxpZCBjaGFyYWN0ZXIgaW4gY2h1bmsgZXh0ZW5zaW9ucyBxdW90ZWQgdmFsdWUAUGF1c2VkIGJ5IG9uX2hlYWRlcnNfY29tcGxldGUASW52YWxpZCBFT0Ygc3RhdGUAb25fcmVzZXQgcGF1c2UAb25fY2h1bmtfaGVhZGVyIHBhdXNlAG9uX21lc3NhZ2VfYmVnaW4gcGF1c2UAb25fY2h1bmtfZXh0ZW5zaW9uX3ZhbHVlIHBhdXNlAG9uX3N0YXR1c19jb21wbGV0ZSBwYXVzZQBvbl92ZXJzaW9uX2NvbXBsZXRlIHBhdXNlAG9uX3VybF9jb21wbGV0ZSBwYXVzZQBvbl9jaHVua19jb21wbGV0ZSBwYXVzZQBvbl9oZWFkZXJfdmFsdWVfY29tcGxldGUgcGF1c2UAb25fbWVzc2FnZV9jb21wbGV0ZSBwYXVzZQBvbl9tZXRob2RfY29tcGxldGUgcGF1c2UAb25faGVhZGVyX2ZpZWxkX2NvbXBsZXRlIHBhdXNlAG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lIHBhdXNlAFVuZXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgc3RhcnQgbGluZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX2NodW5rX2V4dGVuc2lvbl9uYW1lAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIGV4dGVuc2lvbnMgbmFtZQBQYXVzZSBvbiBDT05ORUNUL1VwZ3JhZGUAUGF1c2Ugb24gUFJJL1VwZ3JhZGUARXhwZWN0ZWQgSFRUUC8yIENvbm5lY3Rpb24gUHJlZmFjZQBTcGFuIGNhbGxiYWNrIGVycm9yIGluIG9uX21ldGhvZABFeHBlY3RlZCBzcGFjZSBhZnRlciBtZXRob2QAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9oZWFkZXJfZmllbGQAUGF1c2VkAEludmFsaWQgd29yZCBlbmNvdW50ZXJlZABJbnZhbGlkIG1ldGhvZCBlbmNvdW50ZXJlZABVbmV4cGVjdGVkIGNoYXIgaW4gdXJsIHNjaGVtYQBSZXF1ZXN0IGhhcyBpbnZhbGlkIGBUcmFuc2Zlci1FbmNvZGluZ2AAU1dJVENIX1BST1hZAFVTRV9QUk9YWQBNS0FDVElWSVRZAFVOUFJPQ0VTU0FCTEVfRU5USVRZAENPUFkATU9WRURfUEVSTUFORU5UTFkAVE9PX0VBUkxZAE5PVElGWQBGQUlMRURfREVQRU5ERU5DWQBCQURfR0FURVdBWQBQTEFZAFBVVABDSEVDS09VVABHQVRFV0FZX1RJTUVPVVQAUkVRVUVTVF9USU1FT1VUAE5FVFdPUktfQ09OTkVDVF9USU1FT1VUAENPTk5FQ1RJT05fVElNRU9VVABMT0dJTl9USU1FT1VUAE5FVFdPUktfUkVBRF9USU1FT1VUAFBPU1QATUlTRElSRUNURURfUkVRVUVTVABDTElFTlRfQ0xPU0VEX1JFUVVFU1QAQ0xJRU5UX0NMT1NFRF9MT0FEX0JBTEFOQ0VEX1JFUVVFU1QAQkFEX1JFUVVFU1QASFRUUF9SRVFVRVNUX1NFTlRfVE9fSFRUUFNfUE9SVABSRVBPUlQASU1fQV9URUFQT1QAUkVTRVRfQ09OVEVOVABOT19DT05URU5UAFBBUlRJQUxfQ09OVEVOVABIUEVfSU5WQUxJRF9DT05TVEFOVABIUEVfQ0JfUkVTRVQAR0VUAEhQRV9TVFJJQ1QAQ09ORkxJQ1QAVEVNUE9SQVJZX1JFRElSRUNUAFBFUk1BTkVOVF9SRURJUkVDVABDT05ORUNUAE1VTFRJX1NUQVRVUwBIUEVfSU5WQUxJRF9TVEFUVVMAVE9PX01BTllfUkVRVUVTVFMARUFSTFlfSElOVFMAVU5BVkFJTEFCTEVfRk9SX0xFR0FMX1JFQVNPTlMAT1BUSU9OUwBTV0lUQ0hJTkdfUFJPVE9DT0xTAFZBUklBTlRfQUxTT19ORUdPVElBVEVTAE1VTFRJUExFX0NIT0lDRVMASU5URVJOQUxfU0VSVkVSX0VSUk9SAFdFQl9TRVJWRVJfVU5LTk9XTl9FUlJPUgBSQUlMR1VOX0VSUk9SAElERU5USVRZX1BST1ZJREVSX0FVVEhFTlRJQ0FUSU9OX0VSUk9SAFNTTF9DRVJUSUZJQ0FURV9FUlJPUgBJTlZBTElEX1hfRk9SV0FSREVEX0ZPUgBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIAU0VFX09USEVSAEhQRV9DQl9DSFVOS19IRUFERVIATUtDQUxFTkRBUgBTRVRVUABXRUJfU0VSVkVSX0lTX0RPV04AVEVBUkRPV04ASFBFX0NMT1NFRF9DT05ORUNUSU9OAEhFVVJJU1RJQ19FWFBJUkFUSU9OAERJU0NPTk5FQ1RFRF9PUEVSQVRJT04ATk9OX0FVVEhPUklUQVRJVkVfSU5GT1JNQVRJT04ASFBFX0lOVkFMSURfVkVSU0lPTgBIUEVfQ0JfTUVTU0FHRV9CRUdJTgBTSVRFX0lTX0ZST1pFTgBIUEVfSU5WQUxJRF9IRUFERVJfVE9LRU4ASU5WQUxJRF9UT0tFTgBGT1JCSURERU4ARU5IQU5DRV9ZT1VSX0NBTE0ASFBFX0lOVkFMSURfVVJMAEJMT0NLRURfQllfUEFSRU5UQUxfQ09OVFJPTABNS0NPTABBQ0wASFBFX0lOVEVSTkFMAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0VfVU5PRkZJQ0lBTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkAUkVUUllfV0lUSABIUEVfSU5WQUxJRF9DT05URU5UX0xFTkdUSABIUEVfVU5FWFBFQ1RFRF9DT05URU5UX0xFTkdUSABGTFVTSABQUk9QUEFUQ0gATS1TRUFSQ0gAVVJJX1RPT19MT05HAFBST0NFU1NJTkcATUlTQ0VMTEFORU9VU19QRVJTSVNURU5UX1dBUk5JTkcATUlTQ0VMTEFORU9VU19XQVJOSU5HAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAENPTlRJTlVFAEhQRV9DQl9TVEFUVVNfQ09NUExFVEUASFBFX0NCX0hFQURFUlNfQ09NUExFVEUASFBFX0NCX1ZFUlNJT05fQ09NUExFVEUASFBFX0NCX1VSTF9DT01QTEVURQBIUEVfQ0JfQ0hVTktfQ09NUExFVEUASFBFX0NCX0hFQURFUl9WQUxVRV9DT01QTEVURQBIUEVfQ0JfQ0hVTktfRVhURU5TSU9OX1ZBTFVFX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19FWFRFTlNJT05fTkFNRV9DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBIUEVfQ0JfTUVUSE9EX0NPTVBMRVRFAEhQRV9DQl9IRUFERVJfRklFTERfQ09NUExFVEUAREVMRVRFAEhQRV9JTlZBTElEX0VPRl9TVEFURQBJTlZBTElEX1NTTF9DRVJUSUZJQ0FURQBQQVVTRQBOT19SRVNQT05TRQBVTlNVUFBPUlRFRF9NRURJQV9UWVBFAEdPTkUATk9UX0FDQ0VQVEFCTEUAU0VSVklDRV9VTkFWQUlMQUJMRQBSQU5HRV9OT1RfU0FUSVNGSUFCTEUAT1JJR0lOX0lTX1VOUkVBQ0hBQkxFAFJFU1BPTlNFX0lTX1NUQUxFAFBVUkdFAE1FUkdFAFJFUVVFU1RfSEVBREVSX0ZJRUxEU19UT09fTEFSR0UAUkVRVUVTVF9IRUFERVJfVE9PX0xBUkdFAFBBWUxPQURfVE9PX0xBUkdFAElOU1VGRklDSUVOVF9TVE9SQUdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAEhQRV9VTkVYUEVDVEVEX1NQQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QATk9UX0ZPVU5EAFBST1BGSU5EAFVOQklORABSRUJJTkQAVU5BVVRIT1JJWkVEAE1FVEhPRF9OT1RfQUxMT1dFRABIVFRQX1ZFUlNJT05fTk9UX1NVUFBPUlRFRABBTFJFQURZX1JFUE9SVEVEAEFDQ0VQVEVEAE5PVF9JTVBMRU1FTlRFRABMT09QX0RFVEVDVEVEAEhQRV9DUl9FWFBFQ1RFRABIUEVfTEZfRVhQRUNURUQAQ1JFQVRFRABJTV9VU0VEAEhQRV9QQVVTRUQAVElNRU9VVF9PQ0NVUkVEAFBBWU1FTlRfUkVRVUlSRUQAUFJFQ09ORElUSU9OX1JFUVVJUkVEAFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEAE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQATEVOR1RIX1JFUVVJUkVEAFNTTF9DRVJUSUZJQ0FURV9SRVFVSVJFRABVUEdSQURFX1JFUVVJUkVEAFBBR0VfRVhQSVJFRABQUkVDT05ESVRJT05fRkFJTEVEAEVYUEVDVEFUSU9OX0ZBSUxFRABSRVZBTElEQVRJT05fRkFJTEVEAFNTTF9IQU5EU0hBS0VfRkFJTEVEAExPQ0tFRABUUkFOU0ZPUk1BVElPTl9BUFBMSUVEAE5PVF9NT0RJRklFRABOT1RfRVhURU5ERUQAQkFORFdJRFRIX0xJTUlUX0VYQ0VFREVEAFNJVEVfSVNfT1ZFUkxPQURFRABIRUFEAEV4cGVjdGVkIEhUVFAvAABeEwAAJhMAADAQAADwFwAAnRMAABUSAAA5FwAA8BIAAAoQAAB1EgAArRIAAIITAABPFAAAfxAAAKAVAAAjFAAAiRIAAIsUAABNFQAA1BEAAM8UAAAQGAAAyRYAANwWAADBEQAA4BcAALsUAAB0FAAAfBUAAOUUAAAIFwAAHxAAAGUVAACjFAAAKBUAAAIVAACZFQAALBAAAIsZAABPDwAA1A4AAGoQAADOEAAAAhcAAIkOAABuEwAAHBMAAGYUAABWFwAAwRMAAM0TAABsEwAAaBcAAGYXAABfFwAAIhMAAM4PAABpDgAA2A4AAGMWAADLEwAAqg4AACgXAAAmFwAAxRMAAF0WAADoEQAAZxMAAGUTAADyFgAAcxMAAB0XAAD5FgAA8xEAAM8OAADOFQAADBIAALMRAAClEQAAYRAAADIXAAC7EwAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAgMCAgICAgAAAgIAAgIAAgICAgICAgICAgAEAAAAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgAAAAICAgICAgICAgICAgICAgICAgICAgICAgICAgICAAIAAgAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAIAAgICAgIAAAICAAICAAICAgICAgICAgIAAwAEAAAAAgICAgICAgICAgICAgICAgICAgICAgICAgIAAAACAgICAgICAgICAgICAgICAgICAgICAgICAgICAgACAAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABsb3NlZWVwLWFsaXZlAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQEBAQEBAQEBAQEBAgEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQFjaHVua2VkAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQAAAQEAAQEAAQEBAQEBAQEBAQAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAGVjdGlvbmVudC1sZW5ndGhvbnJveHktY29ubmVjdGlvbgAAAAAAAAAAAAAAAAAAAHJhbnNmZXItZW5jb2RpbmdwZ3JhZGUNCg0KDQpTTQ0KDQpUVFAvQ0UvVFNQLwAAAAAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAgABAwAAAAAAAAAAAAAAAAAAAAAAAAQBAQUBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAABAAACAAAAAAAAAAAAAAAAAAAAAAAAAwQAAAQEBAQEBAQEBAQEBQQEBAQEBAQEBAQEBAAEAAYHBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAEAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAgAAAAACAAAAAAAAAAAAAAAAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAE5PVU5DRUVDS09VVE5FQ1RFVEVDUklCRUxVU0hFVEVBRFNFQVJDSFJHRUNUSVZJVFlMRU5EQVJWRU9USUZZUFRJT05TQ0hTRUFZU1RBVENIR0VPUkRJUkVDVE9SVFJDSFBBUkFNRVRFUlVSQ0VCU0NSSUJFQVJET1dOQUNFSU5ETktDS1VCU0NSSUJFSFRUUC9BRFRQLw==";
});
var BF = Z((B3A, U5) => {
  var u = $("assert"),
    o2 = $("net"),
    Tc = $("http"),
    { pipeline: Oc } = $("stream"),
    s = HA(),
    yU = Sw(),
    bU = N2(),
    qc = ng(),
    {
      RequestContentLengthMismatchError: NE,
      ResponseContentLengthMismatchError: jc,
      InvalidArgumentError: XQ,
      RequestAbortedError: pU,
      HeadersTimeoutError: fc,
      HeadersOverflowError: hc,
      SocketError: T0,
      InformationalError: PI,
      BodyTimeoutError: kc,
      HTTPParserError: xc,
      ResponseExceededMaxSizeError: vc,
      ClientDestroyedError: Pc,
    } = dA(),
    _c = ag(),
    {
      kUrl: uQ,
      kReset: gB,
      kServerName: SE,
      kClient: _I,
      kBusy: mU,
      kParser: YQ,
      kConnect: yc,
      kBlocking: O0,
      kResuming: OC,
      kRunning: gQ,
      kPending: jC,
      kSize: qC,
      kWriting: GE,
      kQueue: oA,
      kConnected: Sc,
      kConnecting: z0,
      kNeedDrain: mE,
      kNoRef: sg,
      kKeepAliveDefaultTimeout: dU,
      kHostHeader: s2,
      kPendingIdx: _B,
      kRunningIdx: sA,
      kError: lQ,
      kPipelining: dE,
      kSocket: JQ,
      kKeepAliveTimeoutValue: eg,
      kMaxHeadersSize: BY,
      kKeepAliveMaxTimeout: r2,
      kKeepAliveTimeoutThreshold: t2,
      kHeadersTimeout: e2,
      kBodyTimeout: A5,
      kStrictContentLength: AF,
      kConnector: rg,
      kMaxRedirections: bc,
      kMaxRequests: QF,
      kCounter: Q5,
      kClose: mc,
      kDestroy: dc,
      kDispatch: cc,
      kInterceptors: uc,
      kLocalAddress: tg,
      kMaxResponseSize: B5,
      kHTTPConnVersion: yI,
      kHost: I5,
      kHTTP2Session: yB,
      kHTTP2SessionState: EY,
      kHTTP2BuildRequest: lc,
      kHTTP2CopyHeaders: pc,
      kHTTP1BuildRequest: ic,
    } = aA(),
    CY;
  try {
    CY = $("http2");
  } catch {
    CY = { constants: {} };
  }
  var {
      constants: {
        HTTP2_HEADER_AUTHORITY: nc,
        HTTP2_HEADER_METHOD: ac,
        HTTP2_HEADER_PATH: oc,
        HTTP2_HEADER_SCHEME: sc,
        HTTP2_HEADER_CONTENT_LENGTH: rc,
        HTTP2_HEADER_EXPECT: tc,
        HTTP2_HEADER_STATUS: ec,
      },
    } = CY,
    n2 = !1,
    AY = Buffer[Symbol.species],
    bE = Symbol("kClosedResolve"),
    oQ = {};
  try {
    let A = $("diagnostics_channel");
    (oQ.sendHeaders = A.channel("undici:client:sendHeaders")),
      (oQ.beforeConnect = A.channel("undici:client:beforeConnect")),
      (oQ.connectError = A.channel("undici:client:connectError")),
      (oQ.connected = A.channel("undici:client:connected"));
  } catch {
    (oQ.sendHeaders = { hasSubscribers: !1 }),
      (oQ.beforeConnect = { hasSubscribers: !1 }),
      (oQ.connectError = { hasSubscribers: !1 }),
      (oQ.connected = { hasSubscribers: !1 });
  }
  class E5 extends qc {
    constructor(
      A,
      {
        interceptors: Q,
        maxHeaderSize: B,
        headersTimeout: I,
        socketTimeout: E,
        requestTimeout: C,
        connectTimeout: g,
        bodyTimeout: F,
        idleTimeout: D,
        keepAlive: J,
        keepAliveTimeout: Y,
        maxKeepAliveTimeout: N,
        keepAliveMaxTimeout: W,
        keepAliveTimeoutThreshold: X,
        socketPath: M,
        pipelining: L,
        tls: H,
        strictContentLength: q,
        maxCachedSessions: O,
        maxRedirections: f,
        connect: S,
        maxRequestsPerClient: r,
        localAddress: t,
        maxResponseSize: IA,
        autoSelectFamily: zA,
        autoSelectFamilyAttemptTimeout: DA,
        allowH2: MA,
        maxConcurrentStreams: LA,
      } = {},
    ) {
      super();
      if (J !== void 0)
        throw new XQ("unsupported keepAlive, use pipelining=0 instead");
      if (E !== void 0)
        throw new XQ(
          "unsupported socketTimeout, use headersTimeout & bodyTimeout instead",
        );
      if (C !== void 0)
        throw new XQ(
          "unsupported requestTimeout, use headersTimeout & bodyTimeout instead",
        );
      if (D !== void 0)
        throw new XQ("unsupported idleTimeout, use keepAliveTimeout instead");
      if (N !== void 0)
        throw new XQ(
          "unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead",
        );
      if (B != null && !Number.isFinite(B))
        throw new XQ("invalid maxHeaderSize");
      if (M != null && typeof M !== "string")
        throw new XQ("invalid socketPath");
      if (g != null && (!Number.isFinite(g) || g < 0))
        throw new XQ("invalid connectTimeout");
      if (Y != null && (!Number.isFinite(Y) || Y <= 0))
        throw new XQ("invalid keepAliveTimeout");
      if (W != null && (!Number.isFinite(W) || W <= 0))
        throw new XQ("invalid keepAliveMaxTimeout");
      if (X != null && !Number.isFinite(X))
        throw new XQ("invalid keepAliveTimeoutThreshold");
      if (I != null && (!Number.isInteger(I) || I < 0))
        throw new XQ("headersTimeout must be a positive integer or zero");
      if (F != null && (!Number.isInteger(F) || F < 0))
        throw new XQ("bodyTimeout must be a positive integer or zero");
      if (S != null && typeof S !== "function" && typeof S !== "object")
        throw new XQ("connect must be a function or an object");
      if (f != null && (!Number.isInteger(f) || f < 0))
        throw new XQ("maxRedirections must be a positive number");
      if (r != null && (!Number.isInteger(r) || r < 0))
        throw new XQ("maxRequestsPerClient must be a positive number");
      if (t != null && (typeof t !== "string" || o2.isIP(t) === 0))
        throw new XQ("localAddress must be valid string IP address");
      if (IA != null && (!Number.isInteger(IA) || IA < -1))
        throw new XQ("maxResponseSize must be a positive number");
      if (DA != null && (!Number.isInteger(DA) || DA < -1))
        throw new XQ(
          "autoSelectFamilyAttemptTimeout must be a positive number",
        );
      if (MA != null && typeof MA !== "boolean")
        throw new XQ("allowH2 must be a valid boolean value");
      if (LA != null && (typeof LA !== "number" || LA < 1))
        throw new XQ(
          "maxConcurrentStreams must be a possitive integer, greater than 0",
        );
      if (typeof S !== "function")
        S = _c({
          ...H,
          maxCachedSessions: O,
          allowH2: MA,
          socketPath: M,
          timeout: g,
          ...(s.nodeHasAutoSelectFamily && zA
            ? { autoSelectFamily: zA, autoSelectFamilyAttemptTimeout: DA }
            : void 0),
          ...S,
        });
      (this[uc] =
        Q && Q.Client && Array.isArray(Q.Client)
          ? Q.Client
          : [Eu({ maxRedirections: f })]),
        (this[uQ] = s.parseOrigin(A)),
        (this[rg] = S),
        (this[JQ] = null),
        (this[dE] = L != null ? L : 1),
        (this[BY] = B || Tc.maxHeaderSize),
        (this[dU] = Y == null ? 4000 : Y),
        (this[r2] = W == null ? 600000 : W),
        (this[t2] = X == null ? 1000 : X),
        (this[eg] = this[dU]),
        (this[SE] = null),
        (this[tg] = t != null ? t : null),
        (this[OC] = 0),
        (this[mE] = 0),
        (this[s2] =
          `host: ${this[uQ].hostname}${this[uQ].port ? `:${this[uQ].port}` : ""}\r
`),
        (this[A5] = F != null ? F : 300000),
        (this[e2] = I != null ? I : 300000),
        (this[AF] = q == null ? !0 : q),
        (this[bc] = f),
        (this[QF] = r),
        (this[bE] = null),
        (this[B5] = IA > -1 ? IA : -1),
        (this[yI] = "h1"),
        (this[yB] = null),
        (this[EY] = !MA
          ? null
          : { openStreams: 0, maxConcurrentStreams: LA != null ? LA : 100 }),
        (this[I5] =
          `${this[uQ].hostname}${this[uQ].port ? `:${this[uQ].port}` : ""}`),
        (this[oA] = []),
        (this[sA] = 0),
        (this[_B] = 0);
    }
    get pipelining() {
      return this[dE];
    }
    set pipelining(A) {
      (this[dE] = A), SB(this, !0);
    }
    get [jC]() {
      return this[oA].length - this[_B];
    }
    get [gQ]() {
      return this[_B] - this[sA];
    }
    get [qC]() {
      return this[oA].length - this[sA];
    }
    get [Sc]() {
      return !!this[JQ] && !this[z0] && !this[JQ].destroyed;
    }
    get [mU]() {
      let A = this[JQ];
      return (
        (A && (A[gB] || A[GE] || A[O0])) ||
        this[qC] >= (this[dE] || 1) ||
        this[jC] > 0
      );
    }
    [yc](A) {
      Y5(this), this.once("connect", A);
    }
    [cc](A, Q) {
      let B = A.origin || this[uQ].origin,
        I = this[yI] === "h2" ? bU[lc](B, A, Q) : bU[ic](B, A, Q);
      if ((this[oA].push(I), this[OC]));
      else if (s.bodyLength(I.body) == null && s.isIterable(I.body))
        (this[OC] = 1), process.nextTick(SB, this);
      else SB(this, !0);
      if (this[OC] && this[mE] !== 2 && this[mU]) this[mE] = 2;
      return this[mE] < 2;
    }
    async [mc]() {
      return new Promise((A) => {
        if (!this[qC]) A(null);
        else this[bE] = A;
      });
    }
    async [dc](A) {
      return new Promise((Q) => {
        let B = this[oA].splice(this[_B]);
        for (let E = 0; E < B.length; E++) {
          let C = B[E];
          FB(this, C, A);
        }
        let I = () => {
          if (this[bE]) this[bE](), (this[bE] = null);
          Q();
        };
        if (this[yB] != null)
          s.destroy(this[yB], A), (this[yB] = null), (this[EY] = null);
        if (!this[JQ]) queueMicrotask(I);
        else s.destroy(this[JQ].on("close", I), A);
        SB(this);
      });
    }
  }
  function Au(A) {
    u(A.code !== "ERR_TLS_CERT_ALTNAME_INVALID"),
      (this[JQ][lQ] = A),
      FY(this[_I], A);
  }
  function Qu(A, Q, B) {
    let I = new PI(`HTTP/2: "frameError" received - type ${A}, code ${Q}`);
    if (B === 0) (this[JQ][lQ] = I), FY(this[_I], I);
  }
  function Bu() {
    s.destroy(this, new T0("other side closed")),
      s.destroy(this[JQ], new T0("other side closed"));
  }
  function Iu(A) {
    let Q = this[_I],
      B = new PI(`HTTP/2: "GOAWAY" frame received with code ${A}`);
    if (((Q[JQ] = null), (Q[yB] = null), Q.destroyed)) {
      u(this[jC] === 0);
      let I = Q[oA].splice(Q[sA]);
      for (let E = 0; E < I.length; E++) {
        let C = I[E];
        FB(this, C, B);
      }
    } else if (Q[gQ] > 0) {
      let I = Q[oA][Q[sA]];
      (Q[oA][Q[sA]++] = null), FB(Q, I, B);
    }
    (Q[_B] = Q[sA]), u(Q[gQ] === 0), Q.emit("disconnect", Q[uQ], [Q], B), SB(Q);
  }
  var kI = S2(),
    Eu = eD(),
    Cu = Buffer.alloc(0);
  async function gu() {
    let A = process.env.JEST_WORKER_ID ? _U() : void 0,
      Q;
    try {
      Q = await WebAssembly.compile(Buffer.from(i2(), "base64"));
    } catch (B) {
      Q = await WebAssembly.compile(Buffer.from(A || _U(), "base64"));
    }
    return await WebAssembly.instantiate(Q, {
      env: {
        wasm_on_url: (B, I, E) => {
          return 0;
        },
        wasm_on_status: (B, I, E) => {
          u.strictEqual(fQ.ptr, B);
          let C = I - vI + xI.byteOffset;
          return fQ.onStatus(new AY(xI.buffer, C, E)) || 0;
        },
        wasm_on_message_begin: (B) => {
          return u.strictEqual(fQ.ptr, B), fQ.onMessageBegin() || 0;
        },
        wasm_on_header_field: (B, I, E) => {
          u.strictEqual(fQ.ptr, B);
          let C = I - vI + xI.byteOffset;
          return fQ.onHeaderField(new AY(xI.buffer, C, E)) || 0;
        },
        wasm_on_header_value: (B, I, E) => {
          u.strictEqual(fQ.ptr, B);
          let C = I - vI + xI.byteOffset;
          return fQ.onHeaderValue(new AY(xI.buffer, C, E)) || 0;
        },
        wasm_on_headers_complete: (B, I, E, C) => {
          return (
            u.strictEqual(fQ.ptr, B),
            fQ.onHeadersComplete(I, Boolean(E), Boolean(C)) || 0
          );
        },
        wasm_on_body: (B, I, E) => {
          u.strictEqual(fQ.ptr, B);
          let C = I - vI + xI.byteOffset;
          return fQ.onBody(new AY(xI.buffer, C, E)) || 0;
        },
        wasm_on_message_complete: (B) => {
          return u.strictEqual(fQ.ptr, B), fQ.onMessageComplete() || 0;
        },
      },
    });
  }
  var SU = null,
    cU = gu();
  cU.catch();
  var fQ = null,
    xI = null,
    QY = 0,
    vI = null,
    q0 = 1,
    IY = 2,
    uU = 3;
  class C5 {
    constructor(A, Q, { exports: B }) {
      u(Number.isFinite(A[BY]) && A[BY] > 0),
        (this.llhttp = B),
        (this.ptr = this.llhttp.llhttp_alloc(kI.TYPE.RESPONSE)),
        (this.client = A),
        (this.socket = Q),
        (this.timeout = null),
        (this.timeoutValue = null),
        (this.timeoutType = null),
        (this.statusCode = null),
        (this.statusText = ""),
        (this.upgrade = !1),
        (this.headers = []),
        (this.headersSize = 0),
        (this.headersMaxSize = A[BY]),
        (this.shouldKeepAlive = !1),
        (this.paused = !1),
        (this.resume = this.resume.bind(this)),
        (this.bytesRead = 0),
        (this.keepAlive = ""),
        (this.contentLength = ""),
        (this.connection = ""),
        (this.maxResponseSize = A[B5]);
    }
    setTimeout(A, Q) {
      if (((this.timeoutType = Q), A !== this.timeoutValue)) {
        if ((yU.clearTimeout(this.timeout), A)) {
          if (((this.timeout = yU.setTimeout(Fu, A, this)), this.timeout.unref))
            this.timeout.unref();
        } else this.timeout = null;
        this.timeoutValue = A;
      } else if (this.timeout) {
        if (this.timeout.refresh) this.timeout.refresh();
      }
    }
    resume() {
      if (this.socket.destroyed || !this.paused) return;
      if (
        (u(this.ptr != null),
        u(fQ == null),
        this.llhttp.llhttp_resume(this.ptr),
        u(this.timeoutType === IY),
        this.timeout)
      ) {
        if (this.timeout.refresh) this.timeout.refresh();
      }
      (this.paused = !1),
        this.execute(this.socket.read() || Cu),
        this.readMore();
    }
    readMore() {
      while (!this.paused && this.ptr) {
        let A = this.socket.read();
        if (A === null) break;
        this.execute(A);
      }
    }
    execute(A) {
      u(this.ptr != null), u(fQ == null), u(!this.paused);
      let { socket: Q, llhttp: B } = this;
      if (A.length > QY) {
        if (vI) B.free(vI);
        (QY = Math.ceil(A.length / 4096) * 4096), (vI = B.malloc(QY));
      }
      new Uint8Array(B.memory.buffer, vI, QY).set(A);
      try {
        let I;
        try {
          (xI = A), (fQ = this), (I = B.llhttp_execute(this.ptr, vI, A.length));
        } catch (C) {
          throw C;
        } finally {
          (fQ = null), (xI = null);
        }
        let E = B.llhttp_get_error_pos(this.ptr) - vI;
        if (I === kI.ERROR.PAUSED_UPGRADE) this.onUpgrade(A.slice(E));
        else if (I === kI.ERROR.PAUSED)
          (this.paused = !0), Q.unshift(A.slice(E));
        else if (I !== kI.ERROR.OK) {
          let C = B.llhttp_get_error_reason(this.ptr),
            g = "";
          if (C) {
            let F = new Uint8Array(B.memory.buffer, C).indexOf(0);
            g =
              "Response does not match the HTTP/1.1 protocol (" +
              Buffer.from(B.memory.buffer, C, F).toString() +
              ")";
          }
          throw new xc(g, kI.ERROR[I], A.slice(E));
        }
      } catch (I) {
        s.destroy(Q, I);
      }
    }
    destroy() {
      u(this.ptr != null),
        u(fQ == null),
        this.llhttp.llhttp_free(this.ptr),
        (this.ptr = null),
        yU.clearTimeout(this.timeout),
        (this.timeout = null),
        (this.timeoutValue = null),
        (this.timeoutType = null),
        (this.paused = !1);
    }
    onStatus(A) {
      this.statusText = A.toString();
    }
    onMessageBegin() {
      let { socket: A, client: Q } = this;
      if (A.destroyed) return -1;
      if (!Q[oA][Q[sA]]) return -1;
    }
    onHeaderField(A) {
      let Q = this.headers.length;
      if ((Q & 1) === 0) this.headers.push(A);
      else this.headers[Q - 1] = Buffer.concat([this.headers[Q - 1], A]);
      this.trackHeader(A.length);
    }
    onHeaderValue(A) {
      let Q = this.headers.length;
      if ((Q & 1) === 1) this.headers.push(A), (Q += 1);
      else this.headers[Q - 1] = Buffer.concat([this.headers[Q - 1], A]);
      let B = this.headers[Q - 2];
      if (B.length === 10 && B.toString().toLowerCase() === "keep-alive")
        this.keepAlive += A.toString();
      else if (B.length === 10 && B.toString().toLowerCase() === "connection")
        this.connection += A.toString();
      else if (
        B.length === 14 &&
        B.toString().toLowerCase() === "content-length"
      )
        this.contentLength += A.toString();
      this.trackHeader(A.length);
    }
    trackHeader(A) {
      if (((this.headersSize += A), this.headersSize >= this.headersMaxSize))
        s.destroy(this.socket, new hc());
    }
    onUpgrade(A) {
      let {
        upgrade: Q,
        client: B,
        socket: I,
        headers: E,
        statusCode: C,
      } = this;
      u(Q);
      let g = B[oA][B[sA]];
      u(g),
        u(!I.destroyed),
        u(I === B[JQ]),
        u(!this.paused),
        u(g.upgrade || g.method === "CONNECT"),
        (this.statusCode = null),
        (this.statusText = ""),
        (this.shouldKeepAlive = null),
        u(this.headers.length % 2 === 0),
        (this.headers = []),
        (this.headersSize = 0),
        I.unshift(A),
        I[YQ].destroy(),
        (I[YQ] = null),
        (I[_I] = null),
        (I[lQ] = null),
        I.removeListener("error", F5)
          .removeListener("readable", g5)
          .removeListener("end", D5)
          .removeListener("close", lU),
        (B[JQ] = null),
        (B[oA][B[sA]++] = null),
        B.emit("disconnect", B[uQ], [B], new PI("upgrade"));
      try {
        g.onUpgrade(C, E, I);
      } catch (F) {
        s.destroy(I, F);
      }
      SB(B);
    }
    onHeadersComplete(A, Q, B) {
      let { client: I, socket: E, headers: C, statusText: g } = this;
      if (E.destroyed) return -1;
      let F = I[oA][I[sA]];
      if (!F) return -1;
      if ((u(!this.upgrade), u(this.statusCode < 200), A === 100))
        return s.destroy(E, new T0("bad response", s.getSocketInfo(E))), -1;
      if (Q && !F.upgrade)
        return s.destroy(E, new T0("bad upgrade", s.getSocketInfo(E))), -1;
      if (
        (u.strictEqual(this.timeoutType, q0),
        (this.statusCode = A),
        (this.shouldKeepAlive =
          B ||
          (F.method === "HEAD" &&
            !E[gB] &&
            this.connection.toLowerCase() === "keep-alive")),
        this.statusCode >= 200)
      ) {
        let J = F.bodyTimeout != null ? F.bodyTimeout : I[A5];
        this.setTimeout(J, IY);
      } else if (this.timeout) {
        if (this.timeout.refresh) this.timeout.refresh();
      }
      if (F.method === "CONNECT") return u(I[gQ] === 1), (this.upgrade = !0), 2;
      if (Q) return u(I[gQ] === 1), (this.upgrade = !0), 2;
      if (
        (u(this.headers.length % 2 === 0),
        (this.headers = []),
        (this.headersSize = 0),
        this.shouldKeepAlive && I[dE])
      ) {
        let J = this.keepAlive ? s.parseKeepAliveTimeout(this.keepAlive) : null;
        if (J != null) {
          let Y = Math.min(J - I[t2], I[r2]);
          if (Y <= 0) E[gB] = !0;
          else I[eg] = Y;
        } else I[eg] = I[dU];
      } else E[gB] = !0;
      let D = F.onHeaders(A, C, this.resume, g) === !1;
      if (F.aborted) return -1;
      if (F.method === "HEAD") return 1;
      if (A < 200) return 1;
      if (E[O0]) (E[O0] = !1), SB(I);
      return D ? kI.ERROR.PAUSED : 0;
    }
    onBody(A) {
      let { client: Q, socket: B, statusCode: I, maxResponseSize: E } = this;
      if (B.destroyed) return -1;
      let C = Q[oA][Q[sA]];
      if ((u(C), u.strictEqual(this.timeoutType, IY), this.timeout)) {
        if (this.timeout.refresh) this.timeout.refresh();
      }
      if ((u(I >= 200), E > -1 && this.bytesRead + A.length > E))
        return s.destroy(B, new vc()), -1;
      if (((this.bytesRead += A.length), C.onData(A) === !1))
        return kI.ERROR.PAUSED;
    }
    onMessageComplete() {
      let {
        client: A,
        socket: Q,
        statusCode: B,
        upgrade: I,
        headers: E,
        contentLength: C,
        bytesRead: g,
        shouldKeepAlive: F,
      } = this;
      if (Q.destroyed && (!B || F)) return -1;
      if (I) return;
      let D = A[oA][A[sA]];
      if (
        (u(D),
        u(B >= 100),
        (this.statusCode = null),
        (this.statusText = ""),
        (this.bytesRead = 0),
        (this.contentLength = ""),
        (this.keepAlive = ""),
        (this.connection = ""),
        u(this.headers.length % 2 === 0),
        (this.headers = []),
        (this.headersSize = 0),
        B < 200)
      )
        return;
      if (D.method !== "HEAD" && C && g !== parseInt(C, 10))
        return s.destroy(Q, new jc()), -1;
      if ((D.onComplete(E), (A[oA][A[sA]++] = null), Q[GE]))
        return (
          u.strictEqual(A[gQ], 0),
          s.destroy(Q, new PI("reset")),
          kI.ERROR.PAUSED
        );
      else if (!F) return s.destroy(Q, new PI("reset")), kI.ERROR.PAUSED;
      else if (Q[gB] && A[gQ] === 0)
        return s.destroy(Q, new PI("reset")), kI.ERROR.PAUSED;
      else if (A[dE] === 1) setImmediate(SB, A);
      else SB(A);
    }
  }
  function Fu(A) {
    let { socket: Q, timeoutType: B, client: I } = A;
    if (B === q0) {
      if (!Q[GE] || Q.writableNeedDrain || I[gQ] > 1)
        u(!A.paused, "cannot be paused while waiting for headers"),
          s.destroy(Q, new fc());
    } else if (B === IY) {
      if (!A.paused) s.destroy(Q, new kc());
    } else if (B === uU)
      u(I[gQ] === 0 && I[eg]), s.destroy(Q, new PI("socket idle timeout"));
  }
  function g5() {
    let { [YQ]: A } = this;
    if (A) A.readMore();
  }
  function F5(A) {
    let { [_I]: Q, [YQ]: B } = this;
    if ((u(A.code !== "ERR_TLS_CERT_ALTNAME_INVALID"), Q[yI] !== "h2")) {
      if (A.code === "ECONNRESET" && B.statusCode && !B.shouldKeepAlive) {
        B.onMessageComplete();
        return;
      }
    }
    (this[lQ] = A), FY(this[_I], A);
  }
  function FY(A, Q) {
    if (
      A[gQ] === 0 &&
      Q.code !== "UND_ERR_INFO" &&
      Q.code !== "UND_ERR_SOCKET"
    ) {
      u(A[_B] === A[sA]);
      let B = A[oA].splice(A[sA]);
      for (let I = 0; I < B.length; I++) {
        let E = B[I];
        FB(A, E, Q);
      }
      u(A[qC] === 0);
    }
  }
  function D5() {
    let { [YQ]: A, [_I]: Q } = this;
    if (Q[yI] !== "h2") {
      if (A.statusCode && !A.shouldKeepAlive) {
        A.onMessageComplete();
        return;
      }
    }
    s.destroy(this, new T0("other side closed", s.getSocketInfo(this)));
  }
  function lU() {
    let { [_I]: A, [YQ]: Q } = this;
    if (A[yI] === "h1" && Q) {
      if (!this[lQ] && Q.statusCode && !Q.shouldKeepAlive)
        Q.onMessageComplete();
      this[YQ].destroy(), (this[YQ] = null);
    }
    let B = this[lQ] || new T0("closed", s.getSocketInfo(this));
    if (((A[JQ] = null), A.destroyed)) {
      u(A[jC] === 0);
      let I = A[oA].splice(A[sA]);
      for (let E = 0; E < I.length; E++) {
        let C = I[E];
        FB(A, C, B);
      }
    } else if (A[gQ] > 0 && B.code !== "UND_ERR_INFO") {
      let I = A[oA][A[sA]];
      (A[oA][A[sA]++] = null), FB(A, I, B);
    }
    (A[_B] = A[sA]), u(A[gQ] === 0), A.emit("disconnect", A[uQ], [A], B), SB(A);
  }
  async function Y5(A) {
    u(!A[z0]), u(!A[JQ]);
    let { host: Q, hostname: B, protocol: I, port: E } = A[uQ];
    if (B[0] === "[") {
      let C = B.indexOf("]");
      u(C !== -1);
      let g = B.substring(1, C);
      u(o2.isIP(g)), (B = g);
    }
    if (((A[z0] = !0), oQ.beforeConnect.hasSubscribers))
      oQ.beforeConnect.publish({
        connectParams: {
          host: Q,
          hostname: B,
          protocol: I,
          port: E,
          servername: A[SE],
          localAddress: A[tg],
        },
        connector: A[rg],
      });
    try {
      let C = await new Promise((F, D) => {
        A[rg](
          {
            host: Q,
            hostname: B,
            protocol: I,
            port: E,
            servername: A[SE],
            localAddress: A[tg],
          },
          (J, Y) => {
            if (J) D(J);
            else F(Y);
          },
        );
      });
      if (A.destroyed) {
        s.destroy(
          C.on("error", () => {}),
          new Pc(),
        );
        return;
      }
      if (((A[z0] = !1), u(C), C.alpnProtocol === "h2")) {
        if (!n2)
          (n2 = !0),
            process.emitWarning(
              "H2 support is experimental, expect them to change at any time.",
              { code: "UNDICI-H2" },
            );
        let F = CY.connect(A[uQ], {
          createConnection: () => C,
          peerMaxConcurrentStreams: A[EY].maxConcurrentStreams,
        });
        (A[yI] = "h2"),
          (F[_I] = A),
          (F[JQ] = C),
          F.on("error", Au),
          F.on("frameError", Qu),
          F.on("end", Bu),
          F.on("goaway", Iu),
          F.on("close", lU),
          F.unref(),
          (A[yB] = F),
          (C[yB] = F);
      } else {
        if (!SU) (SU = await cU), (cU = null);
        (C[sg] = !1),
          (C[GE] = !1),
          (C[gB] = !1),
          (C[O0] = !1),
          (C[YQ] = new C5(A, C, SU));
      }
      if (
        ((C[Q5] = 0),
        (C[QF] = A[QF]),
        (C[_I] = A),
        (C[lQ] = null),
        C.on("error", F5).on("readable", g5).on("end", D5).on("close", lU),
        (A[JQ] = C),
        oQ.connected.hasSubscribers)
      )
        oQ.connected.publish({
          connectParams: {
            host: Q,
            hostname: B,
            protocol: I,
            port: E,
            servername: A[SE],
            localAddress: A[tg],
          },
          connector: A[rg],
          socket: C,
        });
      A.emit("connect", A[uQ], [A]);
    } catch (C) {
      if (A.destroyed) return;
      if (((A[z0] = !1), oQ.connectError.hasSubscribers))
        oQ.connectError.publish({
          connectParams: {
            host: Q,
            hostname: B,
            protocol: I,
            port: E,
            servername: A[SE],
            localAddress: A[tg],
          },
          connector: A[rg],
          error: C,
        });
      if (C.code === "ERR_TLS_CERT_ALTNAME_INVALID") {
        u(A[gQ] === 0);
        while (A[jC] > 0 && A[oA][A[_B]].servername === A[SE]) {
          let g = A[oA][A[_B]++];
          FB(A, g, C);
        }
      } else FY(A, C);
      A.emit("connectionError", A[uQ], [A], C);
    }
    SB(A);
  }
  function a2(A) {
    (A[mE] = 0), A.emit("drain", A[uQ], [A]);
  }
  function SB(A, Q) {
    if (A[OC] === 2) return;
    if (((A[OC] = 2), Du(A, Q), (A[OC] = 0), A[sA] > 256))
      A[oA].splice(0, A[sA]), (A[_B] -= A[sA]), (A[sA] = 0);
  }
  function Du(A, Q) {
    while (!0) {
      if (A.destroyed) {
        u(A[jC] === 0);
        return;
      }
      if (A[bE] && !A[qC]) {
        A[bE](), (A[bE] = null);
        return;
      }
      let B = A[JQ];
      if (B && !B.destroyed && B.alpnProtocol !== "h2") {
        if (A[qC] === 0) {
          if (!B[sg] && B.unref) B.unref(), (B[sg] = !0);
        } else if (B[sg] && B.ref) B.ref(), (B[sg] = !1);
        if (A[qC] === 0) {
          if (B[YQ].timeoutType !== uU) B[YQ].setTimeout(A[eg], uU);
        } else if (A[gQ] > 0 && B[YQ].statusCode < 200) {
          if (B[YQ].timeoutType !== q0) {
            let E = A[oA][A[sA]],
              C = E.headersTimeout != null ? E.headersTimeout : A[e2];
            B[YQ].setTimeout(C, q0);
          }
        }
      }
      if (A[mU]) A[mE] = 2;
      else if (A[mE] === 2) {
        if (Q) (A[mE] = 1), process.nextTick(a2, A);
        else a2(A);
        continue;
      }
      if (A[jC] === 0) return;
      if (A[gQ] >= (A[dE] || 1)) return;
      let I = A[oA][A[_B]];
      if (A[uQ].protocol === "https:" && A[SE] !== I.servername) {
        if (A[gQ] > 0) return;
        if (((A[SE] = I.servername), B && B.servername !== I.servername)) {
          s.destroy(B, new PI("servername changed"));
          return;
        }
      }
      if (A[z0]) return;
      if (!B && !A[yB]) {
        Y5(A);
        return;
      }
      if (B.destroyed || B[GE] || B[gB] || B[O0]) return;
      if (A[gQ] > 0 && !I.idempotent) return;
      if (A[gQ] > 0 && (I.upgrade || I.method === "CONNECT")) return;
      if (
        A[gQ] > 0 &&
        s.bodyLength(I.body) !== 0 &&
        (s.isStream(I.body) || s.isAsyncIterable(I.body))
      )
        return;
      if (!I.aborted && Yu(A, I)) A[_B]++;
      else A[oA].splice(A[_B], 1);
    }
  }
  function J5(A) {
    return (
      A !== "GET" &&
      A !== "HEAD" &&
      A !== "OPTIONS" &&
      A !== "TRACE" &&
      A !== "CONNECT"
    );
  }
  function Yu(A, Q) {
    if (A[yI] === "h2") {
      Ju(A, A[yB], Q);
      return;
    }
    let {
        body: B,
        method: I,
        path: E,
        host: C,
        upgrade: g,
        headers: F,
        blocking: D,
        reset: J,
      } = Q,
      Y = I === "PUT" || I === "POST" || I === "PATCH";
    if (B && typeof B.read === "function") B.read(0);
    let N = s.bodyLength(B),
      W = N;
    if (W === null) W = Q.contentLength;
    if (W === 0 && !Y) W = null;
    if (J5(I) && W > 0 && Q.contentLength !== null && Q.contentLength !== W) {
      if (A[AF]) return FB(A, Q, new NE()), !1;
      process.emitWarning(new NE());
    }
    let X = A[JQ];
    try {
      Q.onConnect((L) => {
        if (Q.aborted || Q.completed) return;
        FB(A, Q, L || new pU()), s.destroy(X, new PI("aborted"));
      });
    } catch (L) {
      FB(A, Q, L);
    }
    if (Q.aborted) return !1;
    if (I === "HEAD") X[gB] = !0;
    if (g || I === "CONNECT") X[gB] = !0;
    if (J != null) X[gB] = J;
    if (A[QF] && X[Q5]++ >= A[QF]) X[gB] = !0;
    if (D) X[O0] = !0;
    let M = `${I} ${E} HTTP/1.1\r
`;
    if (typeof C === "string")
      M += `host: ${C}\r
`;
    else M += A[s2];
    if (g)
      M += `connection: upgrade\r
upgrade: ${g}\r
`;
    else if (A[dE] && !X[gB])
      M += `connection: keep-alive\r
`;
    else
      M += `connection: close\r
`;
    if (F) M += F;
    if (oQ.sendHeaders.hasSubscribers)
      oQ.sendHeaders.publish({ request: Q, headers: M, socket: X });
    if (!B || N === 0) {
      if (W === 0)
        X.write(
          `${M}content-length: 0\r
\r
`,
          "latin1",
        );
      else
        u(W === null, "no body must not have content length"),
          X.write(
            `${M}\r
`,
            "latin1",
          );
      Q.onRequestSent();
    } else if (s.isBuffer(B)) {
      if (
        (u(W === B.byteLength, "buffer body must have content length"),
        X.cork(),
        X.write(
          `${M}content-length: ${W}\r
\r
`,
          "latin1",
        ),
        X.write(B),
        X.uncork(),
        Q.onBodySent(B),
        Q.onRequestSent(),
        !Y)
      )
        X[gB] = !0;
    } else if (s.isBlobLike(B))
      if (typeof B.stream === "function")
        gY({
          body: B.stream(),
          client: A,
          request: Q,
          socket: X,
          contentLength: W,
          header: M,
          expectsPayload: Y,
        });
      else
        G5({
          body: B,
          client: A,
          request: Q,
          socket: X,
          contentLength: W,
          header: M,
          expectsPayload: Y,
        });
    else if (s.isStream(B))
      N5({
        body: B,
        client: A,
        request: Q,
        socket: X,
        contentLength: W,
        header: M,
        expectsPayload: Y,
      });
    else if (s.isIterable(B))
      gY({
        body: B,
        client: A,
        request: Q,
        socket: X,
        contentLength: W,
        header: M,
        expectsPayload: Y,
      });
    else u(!1);
    return !0;
  }
  function Ju(A, Q, B) {
    let {
        body: I,
        method: E,
        path: C,
        host: g,
        upgrade: F,
        expectContinue: D,
        signal: J,
        headers: Y,
      } = B,
      N;
    if (typeof Y === "string") N = bU[pc](Y.trim());
    else N = Y;
    if (F) return FB(A, B, Error("Upgrade not supported for H2")), !1;
    try {
      B.onConnect((O) => {
        if (B.aborted || B.completed) return;
        FB(A, B, O || new pU());
      });
    } catch (O) {
      FB(A, B, O);
    }
    if (B.aborted) return !1;
    let W,
      X = A[EY];
    if (((N[nc] = g || A[I5]), (N[ac] = E), E === "CONNECT")) {
      if (
        (Q.ref(),
        (W = Q.request(N, { endStream: !1, signal: J })),
        W.id && !W.pending)
      )
        B.onUpgrade(null, null, W), ++X.openStreams;
      else
        W.once("ready", () => {
          B.onUpgrade(null, null, W), ++X.openStreams;
        });
      return (
        W.once("close", () => {
          if (((X.openStreams -= 1), X.openStreams === 0)) Q.unref();
        }),
        !0
      );
    }
    (N[oc] = C), (N[sc] = "https");
    let M = E === "PUT" || E === "POST" || E === "PATCH";
    if (I && typeof I.read === "function") I.read(0);
    let L = s.bodyLength(I);
    if (L == null) L = B.contentLength;
    if (L === 0 || !M) L = null;
    if (J5(E) && L > 0 && B.contentLength != null && B.contentLength !== L) {
      if (A[AF]) return FB(A, B, new NE()), !1;
      process.emitWarning(new NE());
    }
    if (L != null)
      u(I, "no body must not have content length"), (N[rc] = `${L}`);
    Q.ref();
    let H = E === "GET" || E === "HEAD";
    if (D)
      (N[tc] = "100-continue"),
        (W = Q.request(N, { endStream: H, signal: J })),
        W.once("continue", q);
    else (W = Q.request(N, { endStream: H, signal: J })), q();
    return (
      ++X.openStreams,
      W.once("response", (O) => {
        let { [ec]: f, ...S } = O;
        if (B.onHeaders(Number(f), S, W.resume.bind(W), "") === !1) W.pause();
      }),
      W.once("end", () => {
        B.onComplete([]);
      }),
      W.on("data", (O) => {
        if (B.onData(O) === !1) W.pause();
      }),
      W.once("close", () => {
        if (((X.openStreams -= 1), X.openStreams === 0)) Q.unref();
      }),
      W.once("error", function (O) {
        if (A[yB] && !A[yB].destroyed && !this.closed && !this.destroyed)
          (X.streams -= 1), s.destroy(W, O);
      }),
      W.once("frameError", (O, f) => {
        let S = new PI(`HTTP/2: "frameError" received - type ${O}, code ${f}`);
        if (
          (FB(A, B, S),
          A[yB] && !A[yB].destroyed && !this.closed && !this.destroyed)
        )
          (X.streams -= 1), s.destroy(W, S);
      }),
      !0
    );
    function q() {
      if (!I) B.onRequestSent();
      else if (s.isBuffer(I))
        u(L === I.byteLength, "buffer body must have content length"),
          W.cork(),
          W.write(I),
          W.uncork(),
          W.end(),
          B.onBodySent(I),
          B.onRequestSent();
      else if (s.isBlobLike(I))
        if (typeof I.stream === "function")
          gY({
            client: A,
            request: B,
            contentLength: L,
            h2stream: W,
            expectsPayload: M,
            body: I.stream(),
            socket: A[JQ],
            header: "",
          });
        else
          G5({
            body: I,
            client: A,
            request: B,
            contentLength: L,
            expectsPayload: M,
            h2stream: W,
            header: "",
            socket: A[JQ],
          });
      else if (s.isStream(I))
        N5({
          body: I,
          client: A,
          request: B,
          contentLength: L,
          expectsPayload: M,
          socket: A[JQ],
          h2stream: W,
          header: "",
        });
      else if (s.isIterable(I))
        gY({
          body: I,
          client: A,
          request: B,
          contentLength: L,
          expectsPayload: M,
          header: "",
          h2stream: W,
          socket: A[JQ],
        });
      else u(!1);
    }
  }
  function N5({
    h2stream: A,
    body: Q,
    client: B,
    request: I,
    socket: E,
    contentLength: C,
    header: g,
    expectsPayload: F,
  }) {
    if (
      (u(C !== 0 || B[gQ] === 0, "stream body cannot be pipelined"),
      B[yI] === "h2")
    ) {
      let L = function (H) {
          I.onBodySent(H);
        },
        M = Oc(Q, A, (H) => {
          if (H) s.destroy(Q, H), s.destroy(A, H);
          else I.onRequestSent();
        });
      M.on("data", L),
        M.once("end", () => {
          M.removeListener("data", L), s.destroy(M);
        });
      return;
    }
    let D = !1,
      J = new iU({
        socket: E,
        request: I,
        contentLength: C,
        client: B,
        expectsPayload: F,
        header: g,
      }),
      Y = function (M) {
        if (D) return;
        try {
          if (!J.write(M) && this.pause) this.pause();
        } catch (L) {
          s.destroy(this, L);
        }
      },
      N = function () {
        if (D) return;
        if (Q.resume) Q.resume();
      },
      W = function () {
        if (D) return;
        let M = new pU();
        queueMicrotask(() => X(M));
      },
      X = function (M) {
        if (D) return;
        if (
          ((D = !0),
          u(E.destroyed || (E[GE] && B[gQ] <= 1)),
          E.off("drain", N).off("error", X),
          Q.removeListener("data", Y)
            .removeListener("end", X)
            .removeListener("error", X)
            .removeListener("close", W),
          !M)
        )
          try {
            J.end();
          } catch (L) {
            M = L;
          }
        if (
          (J.destroy(M),
          M && (M.code !== "UND_ERR_INFO" || M.message !== "reset"))
        )
          s.destroy(Q, M);
        else s.destroy(Q);
      };
    if ((Q.on("data", Y).on("end", X).on("error", X).on("close", W), Q.resume))
      Q.resume();
    E.on("drain", N).on("error", X);
  }
  async function G5({
    h2stream: A,
    body: Q,
    client: B,
    request: I,
    socket: E,
    contentLength: C,
    header: g,
    expectsPayload: F,
  }) {
    u(C === Q.size, "blob body must have content length");
    let D = B[yI] === "h2";
    try {
      if (C != null && C !== Q.size) throw new NE();
      let J = Buffer.from(await Q.arrayBuffer());
      if (D) A.cork(), A.write(J), A.uncork();
      else
        E.cork(),
          E.write(
            `${g}content-length: ${C}\r
\r
`,
            "latin1",
          ),
          E.write(J),
          E.uncork();
      if ((I.onBodySent(J), I.onRequestSent(), !F)) E[gB] = !0;
      SB(B);
    } catch (J) {
      s.destroy(D ? A : E, J);
    }
  }
  async function gY({
    h2stream: A,
    body: Q,
    client: B,
    request: I,
    socket: E,
    contentLength: C,
    header: g,
    expectsPayload: F,
  }) {
    u(C !== 0 || B[gQ] === 0, "iterator body cannot be pipelined");
    let D = null;
    function J() {
      if (D) {
        let W = D;
        (D = null), W();
      }
    }
    let Y = () =>
      new Promise((W, X) => {
        if ((u(D === null), E[lQ])) X(E[lQ]);
        else D = W;
      });
    if (B[yI] === "h2") {
      A.on("close", J).on("drain", J);
      try {
        for await (let W of Q) {
          if (E[lQ]) throw E[lQ];
          let X = A.write(W);
          if ((I.onBodySent(W), !X)) await Y();
        }
      } catch (W) {
        A.destroy(W);
      } finally {
        I.onRequestSent(), A.end(), A.off("close", J).off("drain", J);
      }
      return;
    }
    E.on("close", J).on("drain", J);
    let N = new iU({
      socket: E,
      request: I,
      contentLength: C,
      client: B,
      expectsPayload: F,
      header: g,
    });
    try {
      for await (let W of Q) {
        if (E[lQ]) throw E[lQ];
        if (!N.write(W)) await Y();
      }
      N.end();
    } catch (W) {
      N.destroy(W);
    } finally {
      E.off("close", J).off("drain", J);
    }
  }
  class iU {
    constructor({
      socket: A,
      request: Q,
      contentLength: B,
      client: I,
      expectsPayload: E,
      header: C,
    }) {
      (this.socket = A),
        (this.request = Q),
        (this.contentLength = B),
        (this.client = I),
        (this.bytesWritten = 0),
        (this.expectsPayload = E),
        (this.header = C),
        (A[GE] = !0);
    }
    write(A) {
      let {
        socket: Q,
        request: B,
        contentLength: I,
        client: E,
        bytesWritten: C,
        expectsPayload: g,
        header: F,
      } = this;
      if (Q[lQ]) throw Q[lQ];
      if (Q.destroyed) return !1;
      let D = Buffer.byteLength(A);
      if (!D) return !0;
      if (I !== null && C + D > I) {
        if (E[AF]) throw new NE();
        process.emitWarning(new NE());
      }
      if ((Q.cork(), C === 0)) {
        if (!g) Q[gB] = !0;
        if (I === null)
          Q.write(
            `${F}transfer-encoding: chunked\r
`,
            "latin1",
          );
        else
          Q.write(
            `${F}content-length: ${I}\r
\r
`,
            "latin1",
          );
      }
      if (I === null)
        Q.write(
          `\r
${D.toString(16)}\r
`,
          "latin1",
        );
      this.bytesWritten += D;
      let J = Q.write(A);
      if ((Q.uncork(), B.onBodySent(A), !J)) {
        if (Q[YQ].timeout && Q[YQ].timeoutType === q0) {
          if (Q[YQ].timeout.refresh) Q[YQ].timeout.refresh();
        }
      }
      return J;
    }
    end() {
      let {
        socket: A,
        contentLength: Q,
        client: B,
        bytesWritten: I,
        expectsPayload: E,
        header: C,
        request: g,
      } = this;
      if ((g.onRequestSent(), (A[GE] = !1), A[lQ])) throw A[lQ];
      if (A.destroyed) return;
      if (I === 0)
        if (E)
          A.write(
            `${C}content-length: 0\r
\r
`,
            "latin1",
          );
        else
          A.write(
            `${C}\r
`,
            "latin1",
          );
      else if (Q === null)
        A.write(
          `\r
0\r
\r
`,
          "latin1",
        );
      if (Q !== null && I !== Q)
        if (B[AF]) throw new NE();
        else process.emitWarning(new NE());
      if (A[YQ].timeout && A[YQ].timeoutType === q0) {
        if (A[YQ].timeout.refresh) A[YQ].timeout.refresh();
      }
      SB(B);
    }
    destroy(A) {
      let { socket: Q, client: B } = this;
      if (((Q[GE] = !1), A))
        u(B[gQ] <= 1, "pipeline should only contain this request"),
          s.destroy(Q, A);
    }
  }
  function FB(A, Q, B) {
    try {
      Q.onError(B), u(Q.aborted);
    } catch (I) {
      A.emit("error", I);
    }
  }
  U5.exports = E5;
});
var Z5 = Z((I3A, W5) => {
  class nU {
    constructor() {
      (this.bottom = 0),
        (this.top = 0),
        (this.list = Array(2048)),
        (this.next = null);
    }
    isEmpty() {
      return this.top === this.bottom;
    }
    isFull() {
      return ((this.top + 1) & 2047) === this.bottom;
    }
    push(A) {
      (this.list[this.top] = A), (this.top = (this.top + 1) & 2047);
    }
    shift() {
      let A = this.list[this.bottom];
      if (A === void 0) return null;
      return (
        (this.list[this.bottom] = void 0),
        (this.bottom = (this.bottom + 1) & 2047),
        A
      );
    }
  }
  W5.exports = class {
    constructor() {
      this.head = this.tail = new nU();
    }
    isEmpty() {
      return this.head.isEmpty();
    }
    push(Q) {
      if (this.head.isFull()) this.head = this.head.next = new nU();
      this.head.push(Q);
    }
    shift() {
      let Q = this.tail,
        B = Q.shift();
      if (Q.isEmpty() && Q.next !== null) this.tail = Q.next;
      return B;
    }
  };
});
var M5 = Z((E3A, w5) => {
  var {
      kFree: Nu,
      kConnected: Gu,
      kPending: Uu,
      kQueued: Wu,
      kRunning: Zu,
      kSize: Xu,
    } = aA(),
    fC = Symbol("pool");
  class X5 {
    constructor(A) {
      this[fC] = A;
    }
    get connected() {
      return this[fC][Gu];
    }
    get free() {
      return this[fC][Nu];
    }
    get pending() {
      return this[fC][Uu];
    }
    get queued() {
      return this[fC][Wu];
    }
    get running() {
      return this[fC][Zu];
    }
    get size() {
      return this[fC][Xu];
    }
  }
  w5.exports = X5;
});
var tU = Z((C3A, j5) => {
  var wu = ng(),
    Mu = Z5(),
    {
      kConnected: aU,
      kSize: L5,
      kRunning: R5,
      kPending: V5,
      kQueued: IF,
      kBusy: Lu,
      kFree: Ru,
      kUrl: Vu,
      kClose: $u,
      kDestroy: Hu,
      kDispatch: Ku,
    } = aA(),
    zu = M5(),
    wB = Symbol("clients"),
    DB = Symbol("needDrain"),
    EF = Symbol("queue"),
    oU = Symbol("closed resolve"),
    sU = Symbol("onDrain"),
    $5 = Symbol("onConnect"),
    H5 = Symbol("onDisconnect"),
    K5 = Symbol("onConnectionError"),
    rU = Symbol("get dispatcher"),
    T5 = Symbol("add client"),
    O5 = Symbol("remove client"),
    z5 = Symbol("stats");
  class q5 extends wu {
    constructor() {
      super();
      (this[EF] = new Mu()), (this[wB] = []), (this[IF] = 0);
      let A = this;
      (this[sU] = function (B, I) {
        let E = A[EF],
          C = !1;
        while (!C) {
          let g = E.shift();
          if (!g) break;
          A[IF]--, (C = !this.dispatch(g.opts, g.handler));
        }
        if (((this[DB] = C), !this[DB] && A[DB]))
          (A[DB] = !1), A.emit("drain", B, [A, ...I]);
        if (A[oU] && E.isEmpty())
          Promise.all(A[wB].map((g) => g.close())).then(A[oU]);
      }),
        (this[$5] = (Q, B) => {
          A.emit("connect", Q, [A, ...B]);
        }),
        (this[H5] = (Q, B, I) => {
          A.emit("disconnect", Q, [A, ...B], I);
        }),
        (this[K5] = (Q, B, I) => {
          A.emit("connectionError", Q, [A, ...B], I);
        }),
        (this[z5] = new zu(this));
    }
    get [Lu]() {
      return this[DB];
    }
    get [aU]() {
      return this[wB].filter((A) => A[aU]).length;
    }
    get [Ru]() {
      return this[wB].filter((A) => A[aU] && !A[DB]).length;
    }
    get [V5]() {
      let A = this[IF];
      for (let { [V5]: Q } of this[wB]) A += Q;
      return A;
    }
    get [R5]() {
      let A = 0;
      for (let { [R5]: Q } of this[wB]) A += Q;
      return A;
    }
    get [L5]() {
      let A = this[IF];
      for (let { [L5]: Q } of this[wB]) A += Q;
      return A;
    }
    get stats() {
      return this[z5];
    }
    async [$u]() {
      if (this[EF].isEmpty())
        return Promise.all(this[wB].map((A) => A.close()));
      else
        return new Promise((A) => {
          this[oU] = A;
        });
    }
    async [Hu](A) {
      while (!0) {
        let Q = this[EF].shift();
        if (!Q) break;
        Q.handler.onError(A);
      }
      return Promise.all(this[wB].map((Q) => Q.destroy(A)));
    }
    [Ku](A, Q) {
      let B = this[rU]();
      if (!B)
        (this[DB] = !0), this[EF].push({ opts: A, handler: Q }), this[IF]++;
      else if (!B.dispatch(A, Q)) (B[DB] = !0), (this[DB] = !this[rU]());
      return !this[DB];
    }
    [T5](A) {
      if (
        (A.on("drain", this[sU])
          .on("connect", this[$5])
          .on("disconnect", this[H5])
          .on("connectionError", this[K5]),
        this[wB].push(A),
        this[DB])
      )
        process.nextTick(() => {
          if (this[DB]) this[sU](A[Vu], [this, A]);
        });
      return this;
    }
    [O5](A) {
      A.close(() => {
        let Q = this[wB].indexOf(A);
        if (Q !== -1) this[wB].splice(Q, 1);
      }),
        (this[DB] = this[wB].some(
          (Q) => !Q[DB] && Q.closed !== !0 && Q.destroyed !== !0,
        ));
    }
  }
  j5.exports = {
    PoolBase: q5,
    kClients: wB,
    kNeedDrain: DB,
    kAddClient: T5,
    kRemoveClient: O5,
    kGetDispatcher: rU,
  };
});
var j0 = Z((g3A, x5) => {
  var {
      PoolBase: Tu,
      kClients: DY,
      kNeedDrain: Ou,
      kAddClient: qu,
      kGetDispatcher: ju,
    } = tU(),
    fu = BF(),
    { InvalidArgumentError: eU } = dA(),
    AW = HA(),
    { kUrl: f5, kInterceptors: hu } = aA(),
    ku = ag(),
    QW = Symbol("options"),
    BW = Symbol("connections"),
    h5 = Symbol("factory");
  function xu(A, Q) {
    return new fu(A, Q);
  }
  class k5 extends Tu {
    constructor(
      A,
      {
        connections: Q,
        factory: B = xu,
        connect: I,
        connectTimeout: E,
        tls: C,
        maxCachedSessions: g,
        socketPath: F,
        autoSelectFamily: D,
        autoSelectFamilyAttemptTimeout: J,
        allowH2: Y,
        ...N
      } = {},
    ) {
      super();
      if (Q != null && (!Number.isFinite(Q) || Q < 0))
        throw new eU("invalid connections");
      if (typeof B !== "function") throw new eU("factory must be a function.");
      if (I != null && typeof I !== "function" && typeof I !== "object")
        throw new eU("connect must be a function or an object");
      if (typeof I !== "function")
        I = ku({
          ...C,
          maxCachedSessions: g,
          allowH2: Y,
          socketPath: F,
          timeout: E,
          ...(AW.nodeHasAutoSelectFamily && D
            ? { autoSelectFamily: D, autoSelectFamilyAttemptTimeout: J }
            : void 0),
          ...I,
        });
      (this[hu] =
        N.interceptors &&
        N.interceptors.Pool &&
        Array.isArray(N.interceptors.Pool)
          ? N.interceptors.Pool
          : []),
        (this[BW] = Q || null),
        (this[f5] = AW.parseOrigin(A)),
        (this[QW] = { ...AW.deepClone(N), connect: I, allowH2: Y }),
        (this[QW].interceptors = N.interceptors
          ? { ...N.interceptors }
          : void 0),
        (this[h5] = B),
        this.on("connectionError", (W, X, M) => {
          for (let L of X) {
            let H = this[DY].indexOf(L);
            if (H !== -1) this[DY].splice(H, 1);
          }
        });
    }
    [ju]() {
      let A = this[DY].find((Q) => !Q[Ou]);
      if (A) return A;
      if (!this[BW] || this[DY].length < this[BW])
        (A = this[h5](this[f5], this[QW])), this[qu](A);
      return A;
    }
  }
  x5.exports = k5;
});
var m5 = Z((F3A, b5) => {
  var { BalancedPoolMissingUpstreamError: vu, InvalidArgumentError: Pu } = dA(),
    {
      PoolBase: _u,
      kClients: YB,
      kNeedDrain: CF,
      kAddClient: yu,
      kRemoveClient: Su,
      kGetDispatcher: bu,
    } = tU(),
    mu = j0(),
    { kUrl: IW, kInterceptors: du } = aA(),
    { parseOrigin: v5 } = HA(),
    P5 = Symbol("factory"),
    YY = Symbol("options"),
    _5 = Symbol("kGreatestCommonDivisor"),
    hC = Symbol("kCurrentWeight"),
    kC = Symbol("kIndex"),
    QI = Symbol("kWeight"),
    JY = Symbol("kMaxWeightPerServer"),
    NY = Symbol("kErrorPenalty");
  function y5(A, Q) {
    if (Q === 0) return A;
    return y5(Q, A % Q);
  }
  function cu(A, Q) {
    return new mu(A, Q);
  }
  class S5 extends _u {
    constructor(A = [], { factory: Q = cu, ...B } = {}) {
      super();
      if (
        ((this[YY] = B),
        (this[kC] = -1),
        (this[hC] = 0),
        (this[JY] = this[YY].maxWeightPerServer || 100),
        (this[NY] = this[YY].errorPenalty || 15),
        !Array.isArray(A))
      )
        A = [A];
      if (typeof Q !== "function") throw new Pu("factory must be a function.");
      (this[du] =
        B.interceptors &&
        B.interceptors.BalancedPool &&
        Array.isArray(B.interceptors.BalancedPool)
          ? B.interceptors.BalancedPool
          : []),
        (this[P5] = Q);
      for (let I of A) this.addUpstream(I);
      this._updateBalancedPoolStats();
    }
    addUpstream(A) {
      let Q = v5(A).origin;
      if (
        this[YB].find(
          (I) => I[IW].origin === Q && I.closed !== !0 && I.destroyed !== !0,
        )
      )
        return this;
      let B = this[P5](Q, Object.assign({}, this[YY]));
      this[yu](B),
        B.on("connect", () => {
          B[QI] = Math.min(this[JY], B[QI] + this[NY]);
        }),
        B.on("connectionError", () => {
          (B[QI] = Math.max(1, B[QI] - this[NY])),
            this._updateBalancedPoolStats();
        }),
        B.on("disconnect", (...I) => {
          let E = I[2];
          if (E && E.code === "UND_ERR_SOCKET")
            (B[QI] = Math.max(1, B[QI] - this[NY])),
              this._updateBalancedPoolStats();
        });
      for (let I of this[YB]) I[QI] = this[JY];
      return this._updateBalancedPoolStats(), this;
    }
    _updateBalancedPoolStats() {
      this[_5] = this[YB].map((A) => A[QI]).reduce(y5, 0);
    }
    removeUpstream(A) {
      let Q = v5(A).origin,
        B = this[YB].find(
          (I) => I[IW].origin === Q && I.closed !== !0 && I.destroyed !== !0,
        );
      if (B) this[Su](B);
      return this;
    }
    get upstreams() {
      return this[YB].filter((A) => A.closed !== !0 && A.destroyed !== !0).map(
        (A) => A[IW].origin,
      );
    }
    [bu]() {
      if (this[YB].length === 0) throw new vu();
      if (
        !this[YB].find((E) => !E[CF] && E.closed !== !0 && E.destroyed !== !0)
      )
        return;
      if (this[YB].map((E) => E[CF]).reduce((E, C) => E && C, !0)) return;
      let B = 0,
        I = this[YB].findIndex((E) => !E[CF]);
      while (B++ < this[YB].length) {
        this[kC] = (this[kC] + 1) % this[YB].length;
        let E = this[YB][this[kC]];
        if (E[QI] > this[YB][I][QI] && !E[CF]) I = this[kC];
        if (this[kC] === 0) {
          if (((this[hC] = this[hC] - this[_5]), this[hC] <= 0))
            this[hC] = this[JY];
        }
        if (E[QI] >= this[hC] && !E[CF]) return E;
      }
      return (this[hC] = this[YB][I][QI]), (this[kC] = I), this[YB][I];
    }
  }
  b5.exports = S5;
});
var gW = Z((D3A, u5) => {
  var { kConnected: d5, kSize: c5 } = aA();
  class EW {
    constructor(A) {
      this.value = A;
    }
    deref() {
      return this.value[d5] === 0 && this.value[c5] === 0 ? void 0 : this.value;
    }
  }
  class CW {
    constructor(A) {
      this.finalizer = A;
    }
    register(A, Q) {
      if (A.on)
        A.on("disconnect", () => {
          if (A[d5] === 0 && A[c5] === 0) this.finalizer(Q);
        });
    }
  }
  u5.exports = function () {
    if (process.env.NODE_V8_COVERAGE)
      return { WeakRef: EW, FinalizationRegistry: CW };
    return {
      WeakRef: global.WeakRef || EW,
      FinalizationRegistry: global.FinalizationRegistry || CW,
    };
  };
});
var gF = Z((Y3A, t5) => {
  var { InvalidArgumentError: GY } = dA(),
    {
      kClients: cE,
      kRunning: l5,
      kClose: uu,
      kDestroy: lu,
      kDispatch: pu,
      kInterceptors: iu,
    } = aA(),
    nu = ng(),
    au = j0(),
    ou = BF(),
    su = HA(),
    ru = eD(),
    { WeakRef: tu, FinalizationRegistry: eu } = gW()(),
    p5 = Symbol("onConnect"),
    i5 = Symbol("onDisconnect"),
    n5 = Symbol("onConnectionError"),
    Al = Symbol("maxRedirections"),
    a5 = Symbol("onDrain"),
    o5 = Symbol("factory"),
    s5 = Symbol("finalizer"),
    FW = Symbol("options");
  function Ql(A, Q) {
    return Q && Q.connections === 1 ? new ou(A, Q) : new au(A, Q);
  }
  class r5 extends nu {
    constructor({
      factory: A = Ql,
      maxRedirections: Q = 0,
      connect: B,
      ...I
    } = {}) {
      super();
      if (typeof A !== "function") throw new GY("factory must be a function.");
      if (B != null && typeof B !== "function" && typeof B !== "object")
        throw new GY("connect must be a function or an object");
      if (!Number.isInteger(Q) || Q < 0)
        throw new GY("maxRedirections must be a positive number");
      if (B && typeof B !== "function") B = { ...B };
      (this[iu] =
        I.interceptors &&
        I.interceptors.Agent &&
        Array.isArray(I.interceptors.Agent)
          ? I.interceptors.Agent
          : [ru({ maxRedirections: Q })]),
        (this[FW] = { ...su.deepClone(I), connect: B }),
        (this[FW].interceptors = I.interceptors
          ? { ...I.interceptors }
          : void 0),
        (this[Al] = Q),
        (this[o5] = A),
        (this[cE] = new Map()),
        (this[s5] = new eu((C) => {
          let g = this[cE].get(C);
          if (g !== void 0 && g.deref() === void 0) this[cE].delete(C);
        }));
      let E = this;
      (this[a5] = (C, g) => {
        E.emit("drain", C, [E, ...g]);
      }),
        (this[p5] = (C, g) => {
          E.emit("connect", C, [E, ...g]);
        }),
        (this[i5] = (C, g, F) => {
          E.emit("disconnect", C, [E, ...g], F);
        }),
        (this[n5] = (C, g, F) => {
          E.emit("connectionError", C, [E, ...g], F);
        });
    }
    get [l5]() {
      let A = 0;
      for (let Q of this[cE].values()) {
        let B = Q.deref();
        if (B) A += B[l5];
      }
      return A;
    }
    [pu](A, Q) {
      let B;
      if (A.origin && (typeof A.origin === "string" || A.origin instanceof URL))
        B = String(A.origin);
      else throw new GY("opts.origin must be a non-empty string or URL.");
      let I = this[cE].get(B),
        E = I ? I.deref() : null;
      if (!E)
        (E = this[o5](A.origin, this[FW])
          .on("drain", this[a5])
          .on("connect", this[p5])
          .on("disconnect", this[i5])
          .on("connectionError", this[n5])),
          this[cE].set(B, new tu(E)),
          this[s5].register(E, B);
      return E.dispatch(A, Q);
    }
    async [uu]() {
      let A = [];
      for (let Q of this[cE].values()) {
        let B = Q.deref();
        if (B) A.push(B.close());
      }
      await Promise.all(A);
    }
    async [lu](A) {
      let Q = [];
      for (let B of this[cE].values()) {
        let I = B.deref();
        if (I) Q.push(I.destroy(A));
      }
      await Promise.all(Q);
    }
  }
  t5.exports = r5;
});
var FM = Z((J3A, gM) => {
  var BM = $("assert"),
    { Readable: Bl } = $("stream"),
    {
      RequestAbortedError: IM,
      NotSupportedError: Il,
      InvalidArgumentError: El,
    } = dA(),
    ZY = HA(),
    { ReadableStreamFrom: Cl, toUSVString: gl } = HA(),
    DW,
    bB = Symbol("kConsume"),
    UY = Symbol("kReading"),
    uE = Symbol("kBody"),
    e5 = Symbol("abort"),
    EM = Symbol("kContentType"),
    AM = () => {};
  gM.exports = class extends Bl {
    constructor({
      resume: Q,
      abort: B,
      contentType: I = "",
      highWaterMark: E = 65536,
    }) {
      super({ autoDestroy: !0, read: Q, highWaterMark: E });
      (this._readableState.dataEmitted = !1),
        (this[e5] = B),
        (this[bB] = null),
        (this[uE] = null),
        (this[EM] = I),
        (this[UY] = !1);
    }
    destroy(Q) {
      if (this.destroyed) return this;
      if (!Q && !this._readableState.endEmitted) Q = new IM();
      if (Q) this[e5]();
      return super.destroy(Q);
    }
    emit(Q, ...B) {
      if (Q === "data") this._readableState.dataEmitted = !0;
      else if (Q === "error") this._readableState.errorEmitted = !0;
      return super.emit(Q, ...B);
    }
    on(Q, ...B) {
      if (Q === "data" || Q === "readable") this[UY] = !0;
      return super.on(Q, ...B);
    }
    addListener(Q, ...B) {
      return this.on(Q, ...B);
    }
    off(Q, ...B) {
      let I = super.off(Q, ...B);
      if (Q === "data" || Q === "readable")
        this[UY] =
          this.listenerCount("data") > 0 || this.listenerCount("readable") > 0;
      return I;
    }
    removeListener(Q, ...B) {
      return this.off(Q, ...B);
    }
    push(Q) {
      if (this[bB] && Q !== null && this.readableLength === 0)
        return CM(this[bB], Q), this[UY] ? super.push(Q) : !0;
      return super.push(Q);
    }
    async text() {
      return WY(this, "text");
    }
    async json() {
      return WY(this, "json");
    }
    async blob() {
      return WY(this, "blob");
    }
    async arrayBuffer() {
      return WY(this, "arrayBuffer");
    }
    async formData() {
      throw new Il();
    }
    get bodyUsed() {
      return ZY.isDisturbed(this);
    }
    get body() {
      if (!this[uE]) {
        if (((this[uE] = Cl(this)), this[bB]))
          this[uE].getReader(), BM(this[uE].locked);
      }
      return this[uE];
    }
    dump(Q) {
      let B = Q && Number.isFinite(Q.limit) ? Q.limit : 262144,
        I = Q && Q.signal;
      if (I)
        try {
          if (typeof I !== "object" || !("aborted" in I))
            throw new El("signal must be an AbortSignal");
          ZY.throwIfAborted(I);
        } catch (E) {
          return Promise.reject(E);
        }
      if (this.closed) return Promise.resolve(null);
      return new Promise((E, C) => {
        let g = I
          ? ZY.addAbortListener(I, () => {
              this.destroy();
            })
          : AM;
        this.on("close", function () {
          if ((g(), I && I.aborted))
            C(
              I.reason ||
                Object.assign(Error("The operation was aborted"), {
                  name: "AbortError",
                }),
            );
          else E(null);
        })
          .on("error", AM)
          .on("data", function (F) {
            if (((B -= F.length), B <= 0)) this.destroy();
          })
          .resume();
      });
    }
  };
  function Fl(A) {
    return (A[uE] && A[uE].locked === !0) || A[bB];
  }
  function Dl(A) {
    return ZY.isDisturbed(A) || Fl(A);
  }
  async function WY(A, Q) {
    if (Dl(A)) throw TypeError("unusable");
    return (
      BM(!A[bB]),
      new Promise((B, I) => {
        (A[bB] = {
          type: Q,
          stream: A,
          resolve: B,
          reject: I,
          length: 0,
          body: [],
        }),
          A.on("error", function (E) {
            YW(this[bB], E);
          }).on("close", function () {
            if (this[bB].body !== null) YW(this[bB], new IM());
          }),
          process.nextTick(Yl, A[bB]);
      })
    );
  }
  function Yl(A) {
    if (A.body === null) return;
    let { _readableState: Q } = A.stream;
    for (let B of Q.buffer) CM(A, B);
    if (Q.endEmitted) QM(this[bB]);
    else
      A.stream.on("end", function () {
        QM(this[bB]);
      });
    A.stream.resume();
    while (A.stream.read() != null);
  }
  function QM(A) {
    let { type: Q, body: B, resolve: I, stream: E, length: C } = A;
    try {
      if (Q === "text") I(gl(Buffer.concat(B)));
      else if (Q === "json") I(JSON.parse(Buffer.concat(B)));
      else if (Q === "arrayBuffer") {
        let g = new Uint8Array(C),
          F = 0;
        for (let D of B) g.set(D, F), (F += D.byteLength);
        I(g.buffer);
      } else if (Q === "blob") {
        if (!DW) DW = $("buffer").Blob;
        I(new DW(B, { type: E[EM] }));
      }
      YW(A);
    } catch (g) {
      E.destroy(g);
    }
  }
  function CM(A, Q) {
    (A.length += Q.length), A.body.push(Q);
  }
  function YW(A, Q) {
    if (A.body === null) return;
    if (Q) A.reject(Q);
    else A.resolve();
    (A.type = null),
      (A.stream = null),
      (A.resolve = null),
      (A.reject = null),
      (A.length = 0),
      (A.body = null);
  }
});
var JW = Z((N3A, YM) => {
  var Jl = $("assert"),
    { ResponseStatusCodeError: XY } = dA(),
    { toUSVString: DM } = HA();
  async function Nl({
    callback: A,
    body: Q,
    contentType: B,
    statusCode: I,
    statusMessage: E,
    headers: C,
  }) {
    Jl(Q);
    let g = [],
      F = 0;
    for await (let D of Q)
      if ((g.push(D), (F += D.length), F > 131072)) {
        g = null;
        break;
      }
    if (I === 204 || !B || !g) {
      process.nextTick(
        A,
        new XY(`Response status code ${I}${E ? `: ${E}` : ""}`, I, C),
      );
      return;
    }
    try {
      if (B.startsWith("application/json")) {
        let D = JSON.parse(DM(Buffer.concat(g)));
        process.nextTick(
          A,
          new XY(`Response status code ${I}${E ? `: ${E}` : ""}`, I, C, D),
        );
        return;
      }
      if (B.startsWith("text/")) {
        let D = DM(Buffer.concat(g));
        process.nextTick(
          A,
          new XY(`Response status code ${I}${E ? `: ${E}` : ""}`, I, C, D),
        );
        return;
      }
    } catch (D) {}
    process.nextTick(
      A,
      new XY(`Response status code ${I}${E ? `: ${E}` : ""}`, I, C),
    );
  }
  YM.exports = { getResolveErrorBodyCallback: Nl };
});
var h0 = Z((G3A, NM) => {
  var { addAbortListener: Gl } = HA(),
    { RequestAbortedError: Ul } = dA(),
    f0 = Symbol("kListener"),
    lE = Symbol("kSignal");
  function JM(A) {
    if (A.abort) A.abort();
    else A.onError(new Ul());
  }
  function Wl(A, Q) {
    if (((A[lE] = null), (A[f0] = null), !Q)) return;
    if (Q.aborted) {
      JM(A);
      return;
    }
    (A[lE] = Q),
      (A[f0] = () => {
        JM(A);
      }),
      Gl(A[lE], A[f0]);
  }
  function Zl(A) {
    if (!A[lE]) return;
    if ("removeEventListener" in A[lE])
      A[lE].removeEventListener("abort", A[f0]);
    else A[lE].removeListener("abort", A[f0]);
    (A[lE] = null), (A[f0] = null);
  }
  NM.exports = { addSignal: Wl, removeSignal: Zl };
});
var WM = Z((U3A, GW) => {
  var Xl = FM(),
    { InvalidArgumentError: k0, RequestAbortedError: wl } = dA(),
    SI = HA(),
    { getResolveErrorBodyCallback: Ml } = JW(),
    { AsyncResource: Ll } = $("async_hooks"),
    { addSignal: Rl, removeSignal: GM } = h0();
  class NW extends Ll {
    constructor(A, Q) {
      if (!A || typeof A !== "object") throw new k0("invalid opts");
      let {
        signal: B,
        method: I,
        opaque: E,
        body: C,
        onInfo: g,
        responseHeaders: F,
        throwOnError: D,
        highWaterMark: J,
      } = A;
      try {
        if (typeof Q !== "function") throw new k0("invalid callback");
        if (J && (typeof J !== "number" || J < 0))
          throw new k0("invalid highWaterMark");
        if (
          B &&
          typeof B.on !== "function" &&
          typeof B.addEventListener !== "function"
        )
          throw new k0("signal must be an EventEmitter or EventTarget");
        if (I === "CONNECT") throw new k0("invalid method");
        if (g && typeof g !== "function")
          throw new k0("invalid onInfo callback");
        super("UNDICI_REQUEST");
      } catch (Y) {
        if (SI.isStream(C)) SI.destroy(C.on("error", SI.nop), Y);
        throw Y;
      }
      if (
        ((this.responseHeaders = F || null),
        (this.opaque = E || null),
        (this.callback = Q),
        (this.res = null),
        (this.abort = null),
        (this.body = C),
        (this.trailers = {}),
        (this.context = null),
        (this.onInfo = g || null),
        (this.throwOnError = D),
        (this.highWaterMark = J),
        SI.isStream(C))
      )
        C.on("error", (Y) => {
          this.onError(Y);
        });
      Rl(this, B);
    }
    onConnect(A, Q) {
      if (!this.callback) throw new wl();
      (this.abort = A), (this.context = Q);
    }
    onHeaders(A, Q, B, I) {
      let {
          callback: E,
          opaque: C,
          abort: g,
          context: F,
          responseHeaders: D,
          highWaterMark: J,
        } = this,
        Y = D === "raw" ? SI.parseRawHeaders(Q) : SI.parseHeaders(Q);
      if (A < 200) {
        if (this.onInfo) this.onInfo({ statusCode: A, headers: Y });
        return;
      }
      let W = (D === "raw" ? SI.parseHeaders(Q) : Y)["content-type"],
        X = new Xl({ resume: B, abort: g, contentType: W, highWaterMark: J });
      if (((this.callback = null), (this.res = X), E !== null))
        if (this.throwOnError && A >= 400)
          this.runInAsyncScope(Ml, null, {
            callback: E,
            body: X,
            contentType: W,
            statusCode: A,
            statusMessage: I,
            headers: Y,
          });
        else
          this.runInAsyncScope(E, null, null, {
            statusCode: A,
            headers: Y,
            trailers: this.trailers,
            opaque: C,
            body: X,
            context: F,
          });
    }
    onData(A) {
      let { res: Q } = this;
      return Q.push(A);
    }
    onComplete(A) {
      let { res: Q } = this;
      GM(this), SI.parseHeaders(A, this.trailers), Q.push(null);
    }
    onError(A) {
      let { res: Q, callback: B, body: I, opaque: E } = this;
      if ((GM(this), B))
        (this.callback = null),
          queueMicrotask(() => {
            this.runInAsyncScope(B, null, A, { opaque: E });
          });
      if (Q)
        (this.res = null),
          queueMicrotask(() => {
            SI.destroy(Q, A);
          });
      if (I) (this.body = null), SI.destroy(I, A);
    }
  }
  function UM(A, Q) {
    if (Q === void 0)
      return new Promise((B, I) => {
        UM.call(this, A, (E, C) => {
          return E ? I(E) : B(C);
        });
      });
    try {
      this.dispatch(A, new NW(A, Q));
    } catch (B) {
      if (typeof Q !== "function") throw B;
      let I = A && A.opaque;
      queueMicrotask(() => Q(B, { opaque: I }));
    }
  }
  GW.exports = UM;
  GW.exports.RequestHandler = NW;
});
var LM = Z((W3A, MM) => {
  var { finished: Vl, PassThrough: $l } = $("stream"),
    {
      InvalidArgumentError: x0,
      InvalidReturnValueError: Hl,
      RequestAbortedError: Kl,
    } = dA(),
    KI = HA(),
    { getResolveErrorBodyCallback: zl } = JW(),
    { AsyncResource: Tl } = $("async_hooks"),
    { addSignal: Ol, removeSignal: ZM } = h0();
  class XM extends Tl {
    constructor(A, Q, B) {
      if (!A || typeof A !== "object") throw new x0("invalid opts");
      let {
        signal: I,
        method: E,
        opaque: C,
        body: g,
        onInfo: F,
        responseHeaders: D,
        throwOnError: J,
      } = A;
      try {
        if (typeof B !== "function") throw new x0("invalid callback");
        if (typeof Q !== "function") throw new x0("invalid factory");
        if (
          I &&
          typeof I.on !== "function" &&
          typeof I.addEventListener !== "function"
        )
          throw new x0("signal must be an EventEmitter or EventTarget");
        if (E === "CONNECT") throw new x0("invalid method");
        if (F && typeof F !== "function")
          throw new x0("invalid onInfo callback");
        super("UNDICI_STREAM");
      } catch (Y) {
        if (KI.isStream(g)) KI.destroy(g.on("error", KI.nop), Y);
        throw Y;
      }
      if (
        ((this.responseHeaders = D || null),
        (this.opaque = C || null),
        (this.factory = Q),
        (this.callback = B),
        (this.res = null),
        (this.abort = null),
        (this.context = null),
        (this.trailers = null),
        (this.body = g),
        (this.onInfo = F || null),
        (this.throwOnError = J || !1),
        KI.isStream(g))
      )
        g.on("error", (Y) => {
          this.onError(Y);
        });
      Ol(this, I);
    }
    onConnect(A, Q) {
      if (!this.callback) throw new Kl();
      (this.abort = A), (this.context = Q);
    }
    onHeaders(A, Q, B, I) {
      let {
          factory: E,
          opaque: C,
          context: g,
          callback: F,
          responseHeaders: D,
        } = this,
        J = D === "raw" ? KI.parseRawHeaders(Q) : KI.parseHeaders(Q);
      if (A < 200) {
        if (this.onInfo) this.onInfo({ statusCode: A, headers: J });
        return;
      }
      this.factory = null;
      let Y;
      if (this.throwOnError && A >= 400) {
        let X = (D === "raw" ? KI.parseHeaders(Q) : J)["content-type"];
        (Y = new $l()),
          (this.callback = null),
          this.runInAsyncScope(zl, null, {
            callback: F,
            body: Y,
            contentType: X,
            statusCode: A,
            statusMessage: I,
            headers: J,
          });
      } else {
        if (E === null) return;
        if (
          ((Y = this.runInAsyncScope(E, null, {
            statusCode: A,
            headers: J,
            opaque: C,
            context: g,
          })),
          !Y ||
            typeof Y.write !== "function" ||
            typeof Y.end !== "function" ||
            typeof Y.on !== "function")
        )
          throw new Hl("expected Writable");
        Vl(Y, { readable: !1 }, (W) => {
          let { callback: X, res: M, opaque: L, trailers: H, abort: q } = this;
          if (((this.res = null), W || !M.readable)) KI.destroy(M, W);
          if (
            ((this.callback = null),
            this.runInAsyncScope(X, null, W || null, {
              opaque: L,
              trailers: H,
            }),
            W)
          )
            q();
        });
      }
      return (
        Y.on("drain", B),
        (this.res = Y),
        (Y.writableNeedDrain !== void 0
          ? Y.writableNeedDrain
          : Y._writableState && Y._writableState.needDrain) !== !0
      );
    }
    onData(A) {
      let { res: Q } = this;
      return Q ? Q.write(A) : !0;
    }
    onComplete(A) {
      let { res: Q } = this;
      if ((ZM(this), !Q)) return;
      (this.trailers = KI.parseHeaders(A)), Q.end();
    }
    onError(A) {
      let { res: Q, callback: B, opaque: I, body: E } = this;
      if ((ZM(this), (this.factory = null), Q))
        (this.res = null), KI.destroy(Q, A);
      else if (B)
        (this.callback = null),
          queueMicrotask(() => {
            this.runInAsyncScope(B, null, A, { opaque: I });
          });
      if (E) (this.body = null), KI.destroy(E, A);
    }
  }
  function wM(A, Q, B) {
    if (B === void 0)
      return new Promise((I, E) => {
        wM.call(this, A, Q, (C, g) => {
          return C ? E(C) : I(g);
        });
      });
    try {
      this.dispatch(A, new XM(A, Q, B));
    } catch (I) {
      if (typeof B !== "function") throw I;
      let E = A && A.opaque;
      queueMicrotask(() => B(I, { opaque: E }));
    }
  }
  MM.exports = wM;
});
var zM = Z((Z3A, KM) => {
  var { Readable: RM, Duplex: ql, PassThrough: jl } = $("stream"),
    {
      InvalidArgumentError: FF,
      InvalidReturnValueError: fl,
      RequestAbortedError: wY,
    } = dA(),
    BI = HA(),
    { AsyncResource: hl } = $("async_hooks"),
    { addSignal: kl, removeSignal: xl } = h0(),
    vl = $("assert"),
    v0 = Symbol("resume");
  class VM extends RM {
    constructor() {
      super({ autoDestroy: !0 });
      this[v0] = null;
    }
    _read() {
      let { [v0]: A } = this;
      if (A) (this[v0] = null), A();
    }
    _destroy(A, Q) {
      this._read(), Q(A);
    }
  }
  class $M extends RM {
    constructor(A) {
      super({ autoDestroy: !0 });
      this[v0] = A;
    }
    _read() {
      this[v0]();
    }
    _destroy(A, Q) {
      if (!A && !this._readableState.endEmitted) A = new wY();
      Q(A);
    }
  }
  class HM extends hl {
    constructor(A, Q) {
      if (!A || typeof A !== "object") throw new FF("invalid opts");
      if (typeof Q !== "function") throw new FF("invalid handler");
      let {
        signal: B,
        method: I,
        opaque: E,
        onInfo: C,
        responseHeaders: g,
      } = A;
      if (
        B &&
        typeof B.on !== "function" &&
        typeof B.addEventListener !== "function"
      )
        throw new FF("signal must be an EventEmitter or EventTarget");
      if (I === "CONNECT") throw new FF("invalid method");
      if (C && typeof C !== "function") throw new FF("invalid onInfo callback");
      super("UNDICI_PIPELINE");
      (this.opaque = E || null),
        (this.responseHeaders = g || null),
        (this.handler = Q),
        (this.abort = null),
        (this.context = null),
        (this.onInfo = C || null),
        (this.req = new VM().on("error", BI.nop)),
        (this.ret = new ql({
          readableObjectMode: A.objectMode,
          autoDestroy: !0,
          read: () => {
            let { body: F } = this;
            if (F && F.resume) F.resume();
          },
          write: (F, D, J) => {
            let { req: Y } = this;
            if (Y.push(F, D) || Y._readableState.destroyed) J();
            else Y[v0] = J;
          },
          destroy: (F, D) => {
            let { body: J, req: Y, res: N, ret: W, abort: X } = this;
            if (!F && !W._readableState.endEmitted) F = new wY();
            if (X && F) X();
            BI.destroy(J, F),
              BI.destroy(Y, F),
              BI.destroy(N, F),
              xl(this),
              D(F);
          },
        }).on("prefinish", () => {
          let { req: F } = this;
          F.push(null);
        })),
        (this.res = null),
        kl(this, B);
    }
    onConnect(A, Q) {
      let { ret: B, res: I } = this;
      if ((vl(!I, "pipeline cannot be retried"), B.destroyed)) throw new wY();
      (this.abort = A), (this.context = Q);
    }
    onHeaders(A, Q, B) {
      let { opaque: I, handler: E, context: C } = this;
      if (A < 200) {
        if (this.onInfo) {
          let F =
            this.responseHeaders === "raw"
              ? BI.parseRawHeaders(Q)
              : BI.parseHeaders(Q);
          this.onInfo({ statusCode: A, headers: F });
        }
        return;
      }
      this.res = new $M(B);
      let g;
      try {
        this.handler = null;
        let F =
          this.responseHeaders === "raw"
            ? BI.parseRawHeaders(Q)
            : BI.parseHeaders(Q);
        g = this.runInAsyncScope(E, null, {
          statusCode: A,
          headers: F,
          opaque: I,
          body: this.res,
          context: C,
        });
      } catch (F) {
        throw (this.res.on("error", BI.nop), F);
      }
      if (!g || typeof g.on !== "function") throw new fl("expected Readable");
      g
        .on("data", (F) => {
          let { ret: D, body: J } = this;
          if (!D.push(F) && J.pause) J.pause();
        })
        .on("error", (F) => {
          let { ret: D } = this;
          BI.destroy(D, F);
        })
        .on("end", () => {
          let { ret: F } = this;
          F.push(null);
        })
        .on("close", () => {
          let { ret: F } = this;
          if (!F._readableState.ended) BI.destroy(F, new wY());
        }),
        (this.body = g);
    }
    onData(A) {
      let { res: Q } = this;
      return Q.push(A);
    }
    onComplete(A) {
      let { res: Q } = this;
      Q.push(null);
    }
    onError(A) {
      let { ret: Q } = this;
      (this.handler = null), BI.destroy(Q, A);
    }
  }
  function Pl(A, Q) {
    try {
      let B = new HM(A, Q);
      return this.dispatch({ ...A, body: B.req }, B), B.ret;
    } catch (B) {
      return new jl().destroy(B);
    }
  }
  KM.exports = Pl;
});
var hM = Z((X3A, fM) => {
  var {
      InvalidArgumentError: UW,
      RequestAbortedError: _l,
      SocketError: yl,
    } = dA(),
    { AsyncResource: Sl } = $("async_hooks"),
    TM = HA(),
    { addSignal: bl, removeSignal: OM } = h0(),
    ml = $("assert");
  class qM extends Sl {
    constructor(A, Q) {
      if (!A || typeof A !== "object") throw new UW("invalid opts");
      if (typeof Q !== "function") throw new UW("invalid callback");
      let { signal: B, opaque: I, responseHeaders: E } = A;
      if (
        B &&
        typeof B.on !== "function" &&
        typeof B.addEventListener !== "function"
      )
        throw new UW("signal must be an EventEmitter or EventTarget");
      super("UNDICI_UPGRADE");
      (this.responseHeaders = E || null),
        (this.opaque = I || null),
        (this.callback = Q),
        (this.abort = null),
        (this.context = null),
        bl(this, B);
    }
    onConnect(A, Q) {
      if (!this.callback) throw new _l();
      (this.abort = A), (this.context = null);
    }
    onHeaders() {
      throw new yl("bad upgrade", null);
    }
    onUpgrade(A, Q, B) {
      let { callback: I, opaque: E, context: C } = this;
      ml.strictEqual(A, 101), OM(this), (this.callback = null);
      let g =
        this.responseHeaders === "raw"
          ? TM.parseRawHeaders(Q)
          : TM.parseHeaders(Q);
      this.runInAsyncScope(I, null, null, {
        headers: g,
        socket: B,
        opaque: E,
        context: C,
      });
    }
    onError(A) {
      let { callback: Q, opaque: B } = this;
      if ((OM(this), Q))
        (this.callback = null),
          queueMicrotask(() => {
            this.runInAsyncScope(Q, null, A, { opaque: B });
          });
    }
  }
  function jM(A, Q) {
    if (Q === void 0)
      return new Promise((B, I) => {
        jM.call(this, A, (E, C) => {
          return E ? I(E) : B(C);
        });
      });
    try {
      let B = new qM(A, Q);
      this.dispatch(
        { ...A, method: A.method || "GET", upgrade: A.protocol || "Websocket" },
        B,
      );
    } catch (B) {
      if (typeof Q !== "function") throw B;
      let I = A && A.opaque;
      queueMicrotask(() => Q(B, { opaque: I }));
    }
  }
  fM.exports = jM;
});
var yM = Z((w3A, _M) => {
  var { AsyncResource: dl } = $("async_hooks"),
    {
      InvalidArgumentError: WW,
      RequestAbortedError: cl,
      SocketError: ul,
    } = dA(),
    kM = HA(),
    { addSignal: ll, removeSignal: xM } = h0();
  class vM extends dl {
    constructor(A, Q) {
      if (!A || typeof A !== "object") throw new WW("invalid opts");
      if (typeof Q !== "function") throw new WW("invalid callback");
      let { signal: B, opaque: I, responseHeaders: E } = A;
      if (
        B &&
        typeof B.on !== "function" &&
        typeof B.addEventListener !== "function"
      )
        throw new WW("signal must be an EventEmitter or EventTarget");
      super("UNDICI_CONNECT");
      (this.opaque = I || null),
        (this.responseHeaders = E || null),
        (this.callback = Q),
        (this.abort = null),
        ll(this, B);
    }
    onConnect(A, Q) {
      if (!this.callback) throw new cl();
      (this.abort = A), (this.context = Q);
    }
    onHeaders() {
      throw new ul("bad connect", null);
    }
    onUpgrade(A, Q, B) {
      let { callback: I, opaque: E, context: C } = this;
      xM(this), (this.callback = null);
      let g = Q;
      if (g != null)
        g =
          this.responseHeaders === "raw"
            ? kM.parseRawHeaders(Q)
            : kM.parseHeaders(Q);
      this.runInAsyncScope(I, null, null, {
        statusCode: A,
        headers: g,
        socket: B,
        opaque: E,
        context: C,
      });
    }
    onError(A) {
      let { callback: Q, opaque: B } = this;
      if ((xM(this), Q))
        (this.callback = null),
          queueMicrotask(() => {
            this.runInAsyncScope(Q, null, A, { opaque: B });
          });
    }
  }
  function PM(A, Q) {
    if (Q === void 0)
      return new Promise((B, I) => {
        PM.call(this, A, (E, C) => {
          return E ? I(E) : B(C);
        });
      });
    try {
      let B = new vM(A, Q);
      this.dispatch({ ...A, method: "CONNECT" }, B);
    } catch (B) {
      if (typeof Q !== "function") throw B;
      let I = A && A.opaque;
      queueMicrotask(() => Q(B, { opaque: I }));
    }
  }
  _M.exports = PM;
});
var SM = Z((pl, P0) => {
  pl.request = WM();
  pl.stream = LM();
  pl.pipeline = zM();
  pl.upgrade = hM();
  pl.connect = yM();
});
var XW = Z((M3A, bM) => {
  var { UndiciError: rl } = dA();
  class ZW extends rl {
    constructor(A) {
      super(A);
      Error.captureStackTrace(this, ZW),
        (this.name = "MockNotMatchedError"),
        (this.message =
          A || "The request does not match any registered mock dispatches"),
        (this.code = "UND_MOCK_ERR_MOCK_NOT_MATCHED");
    }
  }
  bM.exports = { MockNotMatchedError: ZW };
});
var _0 = Z((L3A, mM) => {
  mM.exports = {
    kAgent: Symbol("agent"),
    kOptions: Symbol("options"),
    kFactory: Symbol("factory"),
    kDispatches: Symbol("dispatches"),
    kDispatchKey: Symbol("dispatch key"),
    kDefaultHeaders: Symbol("default headers"),
    kDefaultTrailers: Symbol("default trailers"),
    kContentLength: Symbol("content length"),
    kMockAgent: Symbol("mock agent"),
    kMockAgentSet: Symbol("mock agent set"),
    kMockAgentGet: Symbol("mock agent get"),
    kMockDispatch: Symbol("mock dispatch"),
    kClose: Symbol("close"),
    kOriginalClose: Symbol("original agent close"),
    kOrigin: Symbol("origin"),
    kIsMockActive: Symbol("is mock active"),
    kNetConnect: Symbol("net connect"),
    kGetNetConnect: Symbol("get net connect"),
    kConnected: Symbol("connected"),
  };
});
var DF = Z((R3A, tM) => {
  var { MockNotMatchedError: xC } = XW(),
    {
      kDispatches: MY,
      kMockAgent: tl,
      kOriginalDispatch: el,
      kOrigin: Ap,
      kGetNetConnect: Qp,
    } = _0(),
    { buildURL: Bp, nop: Ip } = HA(),
    { STATUS_CODES: Ep } = $("http"),
    {
      types: { isPromise: Cp },
    } = $("util");
  function UE(A, Q) {
    if (typeof A === "string") return A === Q;
    if (A instanceof RegExp) return A.test(Q);
    if (typeof A === "function") return A(Q) === !0;
    return !1;
  }
  function cM(A) {
    return Object.fromEntries(
      Object.entries(A).map(([Q, B]) => {
        return [Q.toLocaleLowerCase(), B];
      }),
    );
  }
  function uM(A, Q) {
    if (Array.isArray(A)) {
      for (let B = 0; B < A.length; B += 2)
        if (A[B].toLocaleLowerCase() === Q.toLocaleLowerCase()) return A[B + 1];
      return;
    } else if (typeof A.get === "function") return A.get(Q);
    else return cM(A)[Q.toLocaleLowerCase()];
  }
  function lM(A) {
    let Q = A.slice(),
      B = [];
    for (let I = 0; I < Q.length; I += 2) B.push([Q[I], Q[I + 1]]);
    return Object.fromEntries(B);
  }
  function pM(A, Q) {
    if (typeof A.headers === "function") {
      if (Array.isArray(Q)) Q = lM(Q);
      return A.headers(Q ? cM(Q) : {});
    }
    if (typeof A.headers > "u") return !0;
    if (typeof Q !== "object" || typeof A.headers !== "object") return !1;
    for (let [B, I] of Object.entries(A.headers)) {
      let E = uM(Q, B);
      if (!UE(I, E)) return !1;
    }
    return !0;
  }
  function dM(A) {
    if (typeof A !== "string") return A;
    let Q = A.split("?");
    if (Q.length !== 2) return A;
    let B = new URLSearchParams(Q.pop());
    return B.sort(), [...Q, B.toString()].join("?");
  }
  function gp(A, { path: Q, method: B, body: I, headers: E }) {
    let C = UE(A.path, Q),
      g = UE(A.method, B),
      F = typeof A.body < "u" ? UE(A.body, I) : !0,
      D = pM(A, E);
    return C && g && F && D;
  }
  function iM(A) {
    if (Buffer.isBuffer(A)) return A;
    else if (typeof A === "object") return JSON.stringify(A);
    else return A.toString();
  }
  function nM(A, Q) {
    let B = Q.query ? Bp(Q.path, Q.query) : Q.path,
      I = typeof B === "string" ? dM(B) : B,
      E = A.filter(({ consumed: C }) => !C).filter(({ path: C }) =>
        UE(dM(C), I),
      );
    if (E.length === 0)
      throw new xC(`Mock dispatch not matched for path '${I}'`);
    if (((E = E.filter(({ method: C }) => UE(C, Q.method))), E.length === 0))
      throw new xC(`Mock dispatch not matched for method '${Q.method}'`);
    if (
      ((E = E.filter(({ body: C }) => (typeof C < "u" ? UE(C, Q.body) : !0))),
      E.length === 0)
    )
      throw new xC(`Mock dispatch not matched for body '${Q.body}'`);
    if (((E = E.filter((C) => pM(C, Q.headers))), E.length === 0))
      throw new xC(
        `Mock dispatch not matched for headers '${typeof Q.headers === "object" ? JSON.stringify(Q.headers) : Q.headers}'`,
      );
    return E[0];
  }
  function Fp(A, Q, B) {
    let I = { timesInvoked: 0, times: 1, persist: !1, consumed: !1 },
      E = typeof B === "function" ? { callback: B } : { ...B },
      C = { ...I, ...Q, pending: !0, data: { error: null, ...E } };
    return A.push(C), C;
  }
  function wW(A, Q) {
    let B = A.findIndex((I) => {
      if (!I.consumed) return !1;
      return gp(I, Q);
    });
    if (B !== -1) A.splice(B, 1);
  }
  function aM(A) {
    let { path: Q, method: B, body: I, headers: E, query: C } = A;
    return { path: Q, method: B, body: I, headers: E, query: C };
  }
  function MW(A) {
    return Object.entries(A).reduce(
      (Q, [B, I]) => [
        ...Q,
        Buffer.from(`${B}`),
        Array.isArray(I)
          ? I.map((E) => Buffer.from(`${E}`))
          : Buffer.from(`${I}`),
      ],
      [],
    );
  }
  function oM(A) {
    return Ep[A] || "unknown";
  }
  async function Dp(A) {
    let Q = [];
    for await (let B of A) Q.push(B);
    return Buffer.concat(Q).toString("utf8");
  }
  function sM(A, Q) {
    let B = aM(A),
      I = nM(this[MY], B);
    if ((I.timesInvoked++, I.data.callback))
      I.data = { ...I.data, ...I.data.callback(A) };
    let {
        data: { statusCode: E, data: C, headers: g, trailers: F, error: D },
        delay: J,
        persist: Y,
      } = I,
      { timesInvoked: N, times: W } = I;
    if (((I.consumed = !Y && N >= W), (I.pending = N < W), D !== null))
      return wW(this[MY], B), Q.onError(D), !0;
    if (typeof J === "number" && J > 0)
      setTimeout(() => {
        X(this[MY]);
      }, J);
    else X(this[MY]);
    function X(L, H = C) {
      let q = Array.isArray(A.headers) ? lM(A.headers) : A.headers,
        O = typeof H === "function" ? H({ ...A, headers: q }) : H;
      if (Cp(O)) {
        O.then((t) => X(L, t));
        return;
      }
      let f = iM(O),
        S = MW(g),
        r = MW(F);
      (Q.abort = Ip),
        Q.onHeaders(E, S, M, oM(E)),
        Q.onData(Buffer.from(f)),
        Q.onComplete(r),
        wW(L, B);
    }
    function M() {}
    return !0;
  }
  function Yp() {
    let A = this[tl],
      Q = this[Ap],
      B = this[el];
    return function (E, C) {
      if (A.isMockActive)
        try {
          sM.call(this, E, C);
        } catch (g) {
          if (g instanceof xC) {
            let F = A[Qp]();
            if (F === !1)
              throw new xC(
                `${g.message}: subsequent request to origin ${Q} was not allowed (net.connect disabled)`,
              );
            if (rM(F, Q)) B.call(this, E, C);
            else
              throw new xC(
                `${g.message}: subsequent request to origin ${Q} was not allowed (net.connect is not enabled for this origin)`,
              );
          } else throw g;
        }
      else B.call(this, E, C);
    };
  }
  function rM(A, Q) {
    let B = new URL(Q);
    if (A === !0) return !0;
    else if (Array.isArray(A) && A.some((I) => UE(I, B.host))) return !0;
    return !1;
  }
  function Jp(A) {
    if (A) {
      let { agent: Q, ...B } = A;
      return B;
    }
  }
  tM.exports = {
    getResponseData: iM,
    getMockDispatch: nM,
    addMockDispatch: Fp,
    deleteMockDispatch: wW,
    buildKey: aM,
    generateKeyValues: MW,
    matchValue: UE,
    getResponse: Dp,
    getStatusText: oM,
    mockDispatch: sM,
    buildMockDispatch: Yp,
    checkNetConnect: rM,
    buildMockOptions: Jp,
    getHeaderByName: uM,
  };
});
var KW = Z((Wp, HW) => {
  var { getResponseData: Np, buildKey: Gp, addMockDispatch: LW } = DF(),
    {
      kDispatches: LY,
      kDispatchKey: RY,
      kDefaultHeaders: RW,
      kDefaultTrailers: VW,
      kContentLength: $W,
      kMockDispatch: VY,
    } = _0(),
    { InvalidArgumentError: zI } = dA(),
    { buildURL: Up } = HA();
  class YF {
    constructor(A) {
      this[VY] = A;
    }
    delay(A) {
      if (typeof A !== "number" || !Number.isInteger(A) || A <= 0)
        throw new zI("waitInMs must be a valid integer > 0");
      return (this[VY].delay = A), this;
    }
    persist() {
      return (this[VY].persist = !0), this;
    }
    times(A) {
      if (typeof A !== "number" || !Number.isInteger(A) || A <= 0)
        throw new zI("repeatTimes must be a valid integer > 0");
      return (this[VY].times = A), this;
    }
  }
  class eM {
    constructor(A, Q) {
      if (typeof A !== "object") throw new zI("opts must be an object");
      if (typeof A.path > "u") throw new zI("opts.path must be defined");
      if (typeof A.method > "u") A.method = "GET";
      if (typeof A.path === "string")
        if (A.query) A.path = Up(A.path, A.query);
        else {
          let B = new URL(A.path, "data://");
          A.path = B.pathname + B.search;
        }
      if (typeof A.method === "string") A.method = A.method.toUpperCase();
      (this[RY] = Gp(A)),
        (this[LY] = Q),
        (this[RW] = {}),
        (this[VW] = {}),
        (this[$W] = !1);
    }
    createMockScopeDispatchData(A, Q, B = {}) {
      let I = Np(Q),
        E = this[$W] ? { "content-length": I.length } : {},
        C = { ...this[RW], ...E, ...B.headers },
        g = { ...this[VW], ...B.trailers };
      return { statusCode: A, data: Q, headers: C, trailers: g };
    }
    validateReplyParameters(A, Q, B) {
      if (typeof A > "u") throw new zI("statusCode must be defined");
      if (typeof Q > "u") throw new zI("data must be defined");
      if (typeof B !== "object")
        throw new zI("responseOptions must be an object");
    }
    reply(A) {
      if (typeof A === "function") {
        let g = (D) => {
            let J = A(D);
            if (typeof J !== "object")
              throw new zI("reply options callback must return an object");
            let { statusCode: Y, data: N = "", responseOptions: W = {} } = J;
            return (
              this.validateReplyParameters(Y, N, W),
              { ...this.createMockScopeDispatchData(Y, N, W) }
            );
          },
          F = LW(this[LY], this[RY], g);
        return new YF(F);
      }
      let [Q, B = "", I = {}] = [...arguments];
      this.validateReplyParameters(Q, B, I);
      let E = this.createMockScopeDispatchData(Q, B, I),
        C = LW(this[LY], this[RY], E);
      return new YF(C);
    }
    replyWithError(A) {
      if (typeof A > "u") throw new zI("error must be defined");
      let Q = LW(this[LY], this[RY], { error: A });
      return new YF(Q);
    }
    defaultReplyHeaders(A) {
      if (typeof A > "u") throw new zI("headers must be defined");
      return (this[RW] = A), this;
    }
    defaultReplyTrailers(A) {
      if (typeof A > "u") throw new zI("trailers must be defined");
      return (this[VW] = A), this;
    }
    replyContentLength() {
      return (this[$W] = !0), this;
    }
  }
  Wp.MockInterceptor = eM;
  Wp.MockScope = YF;
});
var TW = Z((V3A, FL) => {
  var { promisify: wp } = $("util"),
    Mp = BF(),
    { buildMockDispatch: Lp } = DF(),
    {
      kDispatches: AL,
      kMockAgent: QL,
      kClose: BL,
      kOriginalClose: IL,
      kOrigin: EL,
      kOriginalDispatch: Rp,
      kConnected: zW,
    } = _0(),
    { MockInterceptor: Vp } = KW(),
    CL = aA(),
    { InvalidArgumentError: $p } = dA();
  class gL extends Mp {
    constructor(A, Q) {
      super(A, Q);
      if (!Q || !Q.agent || typeof Q.agent.dispatch !== "function")
        throw new $p("Argument opts.agent must implement Agent");
      (this[QL] = Q.agent),
        (this[EL] = A),
        (this[AL] = []),
        (this[zW] = 1),
        (this[Rp] = this.dispatch),
        (this[IL] = this.close.bind(this)),
        (this.dispatch = Lp.call(this)),
        (this.close = this[BL]);
    }
    get [CL.kConnected]() {
      return this[zW];
    }
    intercept(A) {
      return new Vp(A, this[AL]);
    }
    async [BL]() {
      await wp(this[IL])(),
        (this[zW] = 0),
        this[QL][CL.kClients].delete(this[EL]);
    }
  }
  FL.exports = gL;
});
var qW = Z(($3A, ZL) => {
  var { promisify: Hp } = $("util"),
    Kp = j0(),
    { buildMockDispatch: zp } = DF(),
    {
      kDispatches: DL,
      kMockAgent: YL,
      kClose: JL,
      kOriginalClose: NL,
      kOrigin: GL,
      kOriginalDispatch: Tp,
      kConnected: OW,
    } = _0(),
    { MockInterceptor: Op } = KW(),
    UL = aA(),
    { InvalidArgumentError: qp } = dA();
  class WL extends Kp {
    constructor(A, Q) {
      super(A, Q);
      if (!Q || !Q.agent || typeof Q.agent.dispatch !== "function")
        throw new qp("Argument opts.agent must implement Agent");
      (this[YL] = Q.agent),
        (this[GL] = A),
        (this[DL] = []),
        (this[OW] = 1),
        (this[Tp] = this.dispatch),
        (this[NL] = this.close.bind(this)),
        (this.dispatch = zp.call(this)),
        (this.close = this[JL]);
    }
    get [UL.kConnected]() {
      return this[OW];
    }
    intercept(A) {
      return new Op(A, this[DL]);
    }
    async [JL]() {
      await Hp(this[NL])(),
        (this[OW] = 0),
        this[YL][UL.kClients].delete(this[GL]);
    }
  }
  ZL.exports = WL;
});
var wL = Z((H3A, XL) => {
  var jp = { pronoun: "it", is: "is", was: "was", this: "this" },
    fp = { pronoun: "they", is: "are", was: "were", this: "these" };
  XL.exports = class {
    constructor(Q, B) {
      (this.singular = Q), (this.plural = B);
    }
    pluralize(Q) {
      let B = Q === 1,
        I = B ? jp : fp,
        E = B ? this.singular : this.plural;
      return { ...I, count: Q, noun: E };
    }
  };
});
var LL = Z((K3A, ML) => {
  var { Transform: hp } = $("stream"),
    { Console: kp } = $("console");
  ML.exports = class {
    constructor({ disableColors: Q } = {}) {
      (this.transform = new hp({
        transform(B, I, E) {
          E(null, B);
        },
      })),
        (this.logger = new kp({
          stdout: this.transform,
          inspectOptions: { colors: !Q && !process.env.CI },
        }));
    }
    format(Q) {
      let B = Q.map(
        ({
          method: I,
          path: E,
          data: { statusCode: C },
          persist: g,
          times: F,
          timesInvoked: D,
          origin: J,
        }) => ({
          Method: I,
          Origin: J,
          Path: E,
          "Status code": C,
          Persistent: g ? "✅" : "❌",
          Invocations: D,
          Remaining: g ? 1 / 0 : F - D,
        }),
      );
      return this.logger.table(B), this.transform.read().toString();
    }
  };
});
var zL = Z((z3A, KL) => {
  var { kClients: vC } = aA(),
    xp = gF(),
    {
      kAgent: jW,
      kMockAgentSet: $Y,
      kMockAgentGet: RL,
      kDispatches: fW,
      kIsMockActive: HY,
      kNetConnect: PC,
      kGetNetConnect: vp,
      kOptions: KY,
      kFactory: zY,
    } = _0(),
    Pp = TW(),
    _p = qW(),
    { matchValue: yp, buildMockOptions: Sp } = DF(),
    { InvalidArgumentError: VL, UndiciError: bp } = dA(),
    mp = oD(),
    dp = wL(),
    cp = LL();
  class $L {
    constructor(A) {
      this.value = A;
    }
    deref() {
      return this.value;
    }
  }
  class HL extends mp {
    constructor(A) {
      super(A);
      if (
        ((this[PC] = !0),
        (this[HY] = !0),
        A && A.agent && typeof A.agent.dispatch !== "function")
      )
        throw new VL("Argument opts.agent must implement Agent");
      let Q = A && A.agent ? A.agent : new xp(A);
      (this[jW] = Q), (this[vC] = Q[vC]), (this[KY] = Sp(A));
    }
    get(A) {
      let Q = this[RL](A);
      if (!Q) (Q = this[zY](A)), this[$Y](A, Q);
      return Q;
    }
    dispatch(A, Q) {
      return this.get(A.origin), this[jW].dispatch(A, Q);
    }
    async close() {
      await this[jW].close(), this[vC].clear();
    }
    deactivate() {
      this[HY] = !1;
    }
    activate() {
      this[HY] = !0;
    }
    enableNetConnect(A) {
      if (
        typeof A === "string" ||
        typeof A === "function" ||
        A instanceof RegExp
      )
        if (Array.isArray(this[PC])) this[PC].push(A);
        else this[PC] = [A];
      else if (typeof A > "u") this[PC] = !0;
      else
        throw new VL(
          "Unsupported matcher. Must be one of String|Function|RegExp.",
        );
    }
    disableNetConnect() {
      this[PC] = !1;
    }
    get isMockActive() {
      return this[HY];
    }
    [$Y](A, Q) {
      this[vC].set(A, new $L(Q));
    }
    [zY](A) {
      let Q = Object.assign({ agent: this }, this[KY]);
      return this[KY] && this[KY].connections === 1
        ? new Pp(A, Q)
        : new _p(A, Q);
    }
    [RL](A) {
      let Q = this[vC].get(A);
      if (Q) return Q.deref();
      if (typeof A !== "string") {
        let B = this[zY]("http://localhost:9999");
        return this[$Y](A, B), B;
      }
      for (let [B, I] of Array.from(this[vC])) {
        let E = I.deref();
        if (E && typeof B !== "string" && yp(B, A)) {
          let C = this[zY](A);
          return this[$Y](A, C), (C[fW] = E[fW]), C;
        }
      }
    }
    [vp]() {
      return this[PC];
    }
    pendingInterceptors() {
      let A = this[vC];
      return Array.from(A.entries())
        .flatMap(([Q, B]) => B.deref()[fW].map((I) => ({ ...I, origin: Q })))
        .filter(({ pending: Q }) => Q);
    }
    assertNoPendingInterceptors({
      pendingInterceptorsFormatter: A = new cp(),
    } = {}) {
      let Q = this.pendingInterceptors();
      if (Q.length === 0) return;
      let B = new dp("interceptor", "interceptors").pluralize(Q.length);
      throw new bp(
        `
${B.count} ${B.noun} ${B.is} pending:

${A.format(Q)}
`.trim(),
      );
    }
  }
  KL.exports = HL;
});
var kL = Z((T3A, hL) => {
  var { kProxy: up, kClose: lp, kDestroy: pp, kInterceptors: ip } = aA(),
    { URL: TL } = $("url"),
    OL = gF(),
    np = j0(),
    ap = ng(),
    { InvalidArgumentError: GF, RequestAbortedError: op } = dA(),
    qL = ag(),
    JF = Symbol("proxy agent"),
    TY = Symbol("proxy client"),
    NF = Symbol("proxy headers"),
    hW = Symbol("request tls settings"),
    sp = Symbol("proxy tls settings"),
    jL = Symbol("connect endpoint function");
  function rp(A) {
    return A === "https:" ? 443 : 80;
  }
  function tp(A) {
    if (typeof A === "string") A = { uri: A };
    if (!A || !A.uri) throw new GF("Proxy opts.uri is mandatory");
    return { uri: A.uri, protocol: A.protocol || "https" };
  }
  function ep(A, Q) {
    return new np(A, Q);
  }
  class fL extends ap {
    constructor(A) {
      super(A);
      if (
        ((this[up] = tp(A)),
        (this[JF] = new OL(A)),
        (this[ip] =
          A.interceptors &&
          A.interceptors.ProxyAgent &&
          Array.isArray(A.interceptors.ProxyAgent)
            ? A.interceptors.ProxyAgent
            : []),
        typeof A === "string")
      )
        A = { uri: A };
      if (!A || !A.uri) throw new GF("Proxy opts.uri is mandatory");
      let { clientFactory: Q = ep } = A;
      if (typeof Q !== "function")
        throw new GF("Proxy opts.clientFactory must be a function.");
      (this[hW] = A.requestTls),
        (this[sp] = A.proxyTls),
        (this[NF] = A.headers || {});
      let B = new TL(A.uri),
        { origin: I, port: E, host: C, username: g, password: F } = B;
      if (A.auth && A.token)
        throw new GF("opts.auth cannot be used in combination with opts.token");
      else if (A.auth) this[NF]["proxy-authorization"] = `Basic ${A.auth}`;
      else if (A.token) this[NF]["proxy-authorization"] = A.token;
      else if (g && F)
        this[NF]["proxy-authorization"] =
          `Basic ${Buffer.from(`${decodeURIComponent(g)}:${decodeURIComponent(F)}`).toString("base64")}`;
      let D = qL({ ...A.proxyTls });
      (this[jL] = qL({ ...A.requestTls })),
        (this[TY] = Q(B, { connect: D })),
        (this[JF] = new OL({
          ...A,
          connect: async (J, Y) => {
            let N = J.host;
            if (!J.port) N += `:${rp(J.protocol)}`;
            try {
              let { socket: W, statusCode: X } = await this[TY].connect({
                origin: I,
                port: E,
                path: N,
                signal: J.signal,
                headers: { ...this[NF], host: C },
              });
              if (X !== 200)
                W.on("error", () => {}).destroy(),
                  Y(
                    new op(`Proxy response (${X}) !== 200 when HTTP Tunneling`),
                  );
              if (J.protocol !== "https:") {
                Y(null, W);
                return;
              }
              let M;
              if (this[hW]) M = this[hW].servername;
              else M = J.servername;
              this[jL]({ ...J, servername: M, httpSocket: W }, Y);
            } catch (W) {
              Y(W);
            }
          },
        }));
    }
    dispatch(A, Q) {
      let { host: B } = new TL(A.origin),
        I = Ai(A.headers);
      return Qi(I), this[JF].dispatch({ ...A, headers: { ...I, host: B } }, Q);
    }
    async [lp]() {
      await this[JF].close(), await this[TY].close();
    }
    async [pp]() {
      await this[JF].destroy(), await this[TY].destroy();
    }
  }
  function Ai(A) {
    if (Array.isArray(A)) {
      let Q = {};
      for (let B = 0; B < A.length; B += 2) Q[A[B]] = A[B + 1];
      return Q;
    }
    return A;
  }
  function Qi(A) {
    if (
      A &&
      Object.keys(A).find((B) => B.toLowerCase() === "proxy-authorization")
    )
      throw new GF(
        "Proxy-Authorization should be sent in ProxyAgent constructor",
      );
  }
  hL.exports = fL;
});
var yL = Z((O3A, _L) => {
  var _C = $("assert"),
    { kRetryHandlerDefaultRetry: xL } = aA(),
    { RequestRetryError: OY } = dA(),
    { isDisturbed: vL, parseHeaders: Bi, parseRangeHeader: PL } = HA();
  function Ii(A) {
    let Q = Date.now();
    return new Date(A).getTime() - Q;
  }
  class kW {
    constructor(A, Q) {
      let { retryOptions: B, ...I } = A,
        {
          retry: E,
          maxRetries: C,
          maxTimeout: g,
          minTimeout: F,
          timeoutFactor: D,
          methods: J,
          errorCodes: Y,
          retryAfter: N,
          statusCodes: W,
        } = B ?? {};
      (this.dispatch = Q.dispatch),
        (this.handler = Q.handler),
        (this.opts = I),
        (this.abort = null),
        (this.aborted = !1),
        (this.retryOpts = {
          retry: E ?? kW[xL],
          retryAfter: N ?? !0,
          maxTimeout: g ?? 30000,
          timeout: F ?? 500,
          timeoutFactor: D ?? 2,
          maxRetries: C ?? 5,
          methods: J ?? ["GET", "HEAD", "OPTIONS", "PUT", "DELETE", "TRACE"],
          statusCodes: W ?? [500, 502, 503, 504, 429],
          errorCodes: Y ?? [
            "ECONNRESET",
            "ECONNREFUSED",
            "ENOTFOUND",
            "ENETDOWN",
            "ENETUNREACH",
            "EHOSTDOWN",
            "EHOSTUNREACH",
            "EPIPE",
          ],
        }),
        (this.retryCount = 0),
        (this.start = 0),
        (this.end = null),
        (this.etag = null),
        (this.resume = null),
        this.handler.onConnect((X) => {
          if (((this.aborted = !0), this.abort)) this.abort(X);
          else this.reason = X;
        });
    }
    onRequestSent() {
      if (this.handler.onRequestSent) this.handler.onRequestSent();
    }
    onUpgrade(A, Q, B) {
      if (this.handler.onUpgrade) this.handler.onUpgrade(A, Q, B);
    }
    onConnect(A) {
      if (this.aborted) A(this.reason);
      else this.abort = A;
    }
    onBodySent(A) {
      if (this.handler.onBodySent) return this.handler.onBodySent(A);
    }
    static [xL](A, { state: Q, opts: B }, I) {
      let { statusCode: E, code: C, headers: g } = A,
        { method: F, retryOptions: D } = B,
        {
          maxRetries: J,
          timeout: Y,
          maxTimeout: N,
          timeoutFactor: W,
          statusCodes: X,
          errorCodes: M,
          methods: L,
        } = D,
        { counter: H, currentTimeout: q } = Q;
      if (
        ((q = q != null && q > 0 ? q : Y),
        C &&
          C !== "UND_ERR_REQ_RETRY" &&
          C !== "UND_ERR_SOCKET" &&
          !M.includes(C))
      ) {
        I(A);
        return;
      }
      if (Array.isArray(L) && !L.includes(F)) {
        I(A);
        return;
      }
      if (E != null && Array.isArray(X) && !X.includes(E)) {
        I(A);
        return;
      }
      if (H > J) {
        I(A);
        return;
      }
      let O = g != null && g["retry-after"];
      if (O) (O = Number(O)), (O = isNaN(O) ? Ii(O) : O * 1000);
      let f = O > 0 ? Math.min(O, N) : Math.min(q * W ** H, N);
      (Q.currentTimeout = f), setTimeout(() => I(null), f);
    }
    onHeaders(A, Q, B, I) {
      let E = Bi(Q);
      if (((this.retryCount += 1), A >= 300))
        return (
          this.abort(
            new OY("Request failed", A, { headers: E, count: this.retryCount }),
          ),
          !1
        );
      if (this.resume != null) {
        if (((this.resume = null), A !== 206)) return !0;
        let g = PL(E["content-range"]);
        if (!g)
          return (
            this.abort(
              new OY("Content-Range mismatch", A, {
                headers: E,
                count: this.retryCount,
              }),
            ),
            !1
          );
        if (this.etag != null && this.etag !== E.etag)
          return (
            this.abort(
              new OY("ETag mismatch", A, {
                headers: E,
                count: this.retryCount,
              }),
            ),
            !1
          );
        let { start: F, size: D, end: J = D } = g;
        return (
          _C(this.start === F, "content-range mismatch"),
          _C(this.end == null || this.end === J, "content-range mismatch"),
          (this.resume = B),
          !0
        );
      }
      if (this.end == null) {
        if (A === 206) {
          let g = PL(E["content-range"]);
          if (g == null) return this.handler.onHeaders(A, Q, B, I);
          let { start: F, size: D, end: J = D } = g;
          _C(
            F != null && Number.isFinite(F) && this.start !== F,
            "content-range mismatch",
          ),
            _C(Number.isFinite(F)),
            _C(
              J != null && Number.isFinite(J) && this.end !== J,
              "invalid content-length",
            ),
            (this.start = F),
            (this.end = J);
        }
        if (this.end == null) {
          let g = E["content-length"];
          this.end = g != null ? Number(g) : null;
        }
        return (
          _C(Number.isFinite(this.start)),
          _C(
            this.end == null || Number.isFinite(this.end),
            "invalid content-length",
          ),
          (this.resume = B),
          (this.etag = E.etag != null ? E.etag : null),
          this.handler.onHeaders(A, Q, B, I)
        );
      }
      let C = new OY("Request failed", A, {
        headers: E,
        count: this.retryCount,
      });
      return this.abort(C), !1;
    }
    onData(A) {
      return (this.start += A.length), this.handler.onData(A);
    }
    onComplete(A) {
      return (this.retryCount = 0), this.handler.onComplete(A);
    }
    onError(A) {
      if (this.aborted || vL(this.opts.body)) return this.handler.onError(A);
      this.retryOpts.retry(
        A,
        {
          state: {
            counter: this.retryCount++,
            currentTimeout: this.retryAfter,
          },
          opts: { retryOptions: this.retryOpts, ...this.opts },
        },
        Q.bind(this),
      );
      function Q(B) {
        if (B != null || this.aborted || vL(this.opts.body))
          return this.handler.onError(B);
        if (this.start !== 0)
          this.opts = {
            ...this.opts,
            headers: {
              ...this.opts.headers,
              range: `bytes=${this.start}-${this.end ?? ""}`,
            },
          };
        try {
          this.dispatch(this.opts, this);
        } catch (I) {
          this.handler.onError(I);
        }
      }
    }
  }
  _L.exports = kW;
});
var y0 = Z((q3A, dL) => {
  var SL = Symbol.for("undici.globalDispatcher.1"),
    { InvalidArgumentError: Ei } = dA(),
    Ci = gF();
  if (mL() === void 0) bL(new Ci());
  function bL(A) {
    if (!A || typeof A.dispatch !== "function")
      throw new Ei("Argument agent must implement Agent");
    Object.defineProperty(globalThis, SL, {
      value: A,
      writable: !0,
      enumerable: !1,
      configurable: !1,
    });
  }
  function mL() {
    return globalThis[SL];
  }
  dL.exports = { setGlobalDispatcher: bL, getGlobalDispatcher: mL };
});
var uL = Z((j3A, cL) => {
  cL.exports = class {
    constructor(Q) {
      this.handler = Q;
    }
    onConnect(...Q) {
      return this.handler.onConnect(...Q);
    }
    onError(...Q) {
      return this.handler.onError(...Q);
    }
    onUpgrade(...Q) {
      return this.handler.onUpgrade(...Q);
    }
    onHeaders(...Q) {
      return this.handler.onHeaders(...Q);
    }
    onData(...Q) {
      return this.handler.onData(...Q);
    }
    onComplete(...Q) {
      return this.handler.onComplete(...Q);
    }
    onBodySent(...Q) {
      return this.handler.onBodySent(...Q);
    }
  };
});
var yC = Z((f3A, aL) => {
  var { kHeadersList: LB, kConstruct: gi } = aA(),
    { kGuard: mI } = CE(),
    { kEnumerableProperty: bI } = HA(),
    { makeIterator: S0, isValidHeaderName: UF, isValidHeaderValue: pL } = AI(),
    Fi = $("util"),
    { webidl: UA } = EB(),
    Di = $("assert"),
    MB = Symbol("headers map"),
    pQ = Symbol("headers map sorted");
  function lL(A) {
    return A === 10 || A === 13 || A === 9 || A === 32;
  }
  function iL(A) {
    let Q = 0,
      B = A.length;
    while (B > Q && lL(A.charCodeAt(B - 1))) --B;
    while (B > Q && lL(A.charCodeAt(Q))) ++Q;
    return Q === 0 && B === A.length ? A : A.substring(Q, B);
  }
  function nL(A, Q) {
    if (Array.isArray(Q))
      for (let B = 0; B < Q.length; ++B) {
        let I = Q[B];
        if (I.length !== 2)
          throw UA.errors.exception({
            header: "Headers constructor",
            message: `expected name/value pair to be length 2, found ${I.length}.`,
          });
        xW(A, I[0], I[1]);
      }
    else if (typeof Q === "object" && Q !== null) {
      let B = Object.keys(Q);
      for (let I = 0; I < B.length; ++I) xW(A, B[I], Q[B[I]]);
    } else
      throw UA.errors.conversionFailed({
        prefix: "Headers constructor",
        argument: "Argument 1",
        types: [
          "sequence<sequence<ByteString>>",
          "record<ByteString, ByteString>",
        ],
      });
  }
  function xW(A, Q, B) {
    if (((B = iL(B)), !UF(Q)))
      throw UA.errors.invalidArgument({
        prefix: "Headers.append",
        value: Q,
        type: "header name",
      });
    else if (!pL(B))
      throw UA.errors.invalidArgument({
        prefix: "Headers.append",
        value: B,
        type: "header value",
      });
    if (A[mI] === "immutable") throw TypeError("immutable");
    else if (A[mI] === "request-no-cors");
    return A[LB].append(Q, B);
  }
  class qY {
    cookies = null;
    constructor(A) {
      if (A instanceof qY)
        (this[MB] = new Map(A[MB])),
          (this[pQ] = A[pQ]),
          (this.cookies = A.cookies === null ? null : [...A.cookies]);
      else (this[MB] = new Map(A)), (this[pQ] = null);
    }
    contains(A) {
      return (A = A.toLowerCase()), this[MB].has(A);
    }
    clear() {
      this[MB].clear(), (this[pQ] = null), (this.cookies = null);
    }
    append(A, Q) {
      this[pQ] = null;
      let B = A.toLowerCase(),
        I = this[MB].get(B);
      if (I) {
        let E = B === "cookie" ? "; " : ", ";
        this[MB].set(B, { name: I.name, value: `${I.value}${E}${Q}` });
      } else this[MB].set(B, { name: A, value: Q });
      if (B === "set-cookie") (this.cookies ??= []), this.cookies.push(Q);
    }
    set(A, Q) {
      this[pQ] = null;
      let B = A.toLowerCase();
      if (B === "set-cookie") this.cookies = [Q];
      this[MB].set(B, { name: A, value: Q });
    }
    delete(A) {
      if (((this[pQ] = null), (A = A.toLowerCase()), A === "set-cookie"))
        this.cookies = null;
      this[MB].delete(A);
    }
    get(A) {
      let Q = this[MB].get(A.toLowerCase());
      return Q === void 0 ? null : Q.value;
    }
    *[Symbol.iterator]() {
      for (let [A, { value: Q }] of this[MB]) yield [A, Q];
    }
    get entries() {
      let A = {};
      if (this[MB].size)
        for (let { name: Q, value: B } of this[MB].values()) A[Q] = B;
      return A;
    }
  }
  class sQ {
    constructor(A = void 0) {
      if (A === gi) return;
      if (((this[LB] = new qY()), (this[mI] = "none"), A !== void 0))
        (A = UA.converters.HeadersInit(A)), nL(this, A);
    }
    append(A, Q) {
      return (
        UA.brandCheck(this, sQ),
        UA.argumentLengthCheck(arguments, 2, { header: "Headers.append" }),
        (A = UA.converters.ByteString(A)),
        (Q = UA.converters.ByteString(Q)),
        xW(this, A, Q)
      );
    }
    delete(A) {
      if (
        (UA.brandCheck(this, sQ),
        UA.argumentLengthCheck(arguments, 1, { header: "Headers.delete" }),
        (A = UA.converters.ByteString(A)),
        !UF(A))
      )
        throw UA.errors.invalidArgument({
          prefix: "Headers.delete",
          value: A,
          type: "header name",
        });
      if (this[mI] === "immutable") throw TypeError("immutable");
      else if (this[mI] === "request-no-cors");
      if (!this[LB].contains(A)) return;
      this[LB].delete(A);
    }
    get(A) {
      if (
        (UA.brandCheck(this, sQ),
        UA.argumentLengthCheck(arguments, 1, { header: "Headers.get" }),
        (A = UA.converters.ByteString(A)),
        !UF(A))
      )
        throw UA.errors.invalidArgument({
          prefix: "Headers.get",
          value: A,
          type: "header name",
        });
      return this[LB].get(A);
    }
    has(A) {
      if (
        (UA.brandCheck(this, sQ),
        UA.argumentLengthCheck(arguments, 1, { header: "Headers.has" }),
        (A = UA.converters.ByteString(A)),
        !UF(A))
      )
        throw UA.errors.invalidArgument({
          prefix: "Headers.has",
          value: A,
          type: "header name",
        });
      return this[LB].contains(A);
    }
    set(A, Q) {
      if (
        (UA.brandCheck(this, sQ),
        UA.argumentLengthCheck(arguments, 2, { header: "Headers.set" }),
        (A = UA.converters.ByteString(A)),
        (Q = UA.converters.ByteString(Q)),
        (Q = iL(Q)),
        !UF(A))
      )
        throw UA.errors.invalidArgument({
          prefix: "Headers.set",
          value: A,
          type: "header name",
        });
      else if (!pL(Q))
        throw UA.errors.invalidArgument({
          prefix: "Headers.set",
          value: Q,
          type: "header value",
        });
      if (this[mI] === "immutable") throw TypeError("immutable");
      else if (this[mI] === "request-no-cors");
      this[LB].set(A, Q);
    }
    getSetCookie() {
      UA.brandCheck(this, sQ);
      let A = this[LB].cookies;
      if (A) return [...A];
      return [];
    }
    get [pQ]() {
      if (this[LB][pQ]) return this[LB][pQ];
      let A = [],
        Q = [...this[LB]].sort((I, E) => (I[0] < E[0] ? -1 : 1)),
        B = this[LB].cookies;
      for (let I = 0; I < Q.length; ++I) {
        let [E, C] = Q[I];
        if (E === "set-cookie")
          for (let g = 0; g < B.length; ++g) A.push([E, B[g]]);
        else Di(C !== null), A.push([E, C]);
      }
      return (this[LB][pQ] = A), A;
    }
    keys() {
      if ((UA.brandCheck(this, sQ), this[mI] === "immutable")) {
        let A = this[pQ];
        return S0(() => A, "Headers", "key");
      }
      return S0(() => [...this[pQ].values()], "Headers", "key");
    }
    values() {
      if ((UA.brandCheck(this, sQ), this[mI] === "immutable")) {
        let A = this[pQ];
        return S0(() => A, "Headers", "value");
      }
      return S0(() => [...this[pQ].values()], "Headers", "value");
    }
    entries() {
      if ((UA.brandCheck(this, sQ), this[mI] === "immutable")) {
        let A = this[pQ];
        return S0(() => A, "Headers", "key+value");
      }
      return S0(() => [...this[pQ].values()], "Headers", "key+value");
    }
    forEach(A, Q = globalThis) {
      if (
        (UA.brandCheck(this, sQ),
        UA.argumentLengthCheck(arguments, 1, { header: "Headers.forEach" }),
        typeof A !== "function")
      )
        throw TypeError(
          "Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'.",
        );
      for (let [B, I] of this) A.apply(Q, [I, B, this]);
    }
    [Symbol.for("nodejs.util.inspect.custom")]() {
      return UA.brandCheck(this, sQ), this[LB];
    }
  }
  sQ.prototype[Symbol.iterator] = sQ.prototype.entries;
  Object.defineProperties(sQ.prototype, {
    append: bI,
    delete: bI,
    get: bI,
    has: bI,
    set: bI,
    getSetCookie: bI,
    keys: bI,
    values: bI,
    entries: bI,
    forEach: bI,
    [Symbol.iterator]: { enumerable: !1 },
    [Symbol.toStringTag]: { value: "Headers", configurable: !0 },
    [Fi.inspect.custom]: { enumerable: !1 },
  });
  UA.converters.HeadersInit = function (A) {
    if (UA.util.Type(A) === "Object") {
      if (A[Symbol.iterator])
        return UA.converters["sequence<sequence<ByteString>>"](A);
      return UA.converters["record<ByteString, ByteString>"](A);
    }
    throw UA.errors.conversionFailed({
      prefix: "Headers constructor",
      argument: "Argument 1",
      types: [
        "sequence<sequence<ByteString>>",
        "record<ByteString, ByteString>",
      ],
    });
  };
  aL.exports = { fill: nL, Headers: sQ, HeadersList: qY };
});
var kY = Z((h3A, B6) => {
  var { Headers: Yi, HeadersList: oL, fill: Ji } = yC(),
    { extractBody: sL, cloneBody: Ni, mixinBody: Gi } = lg(),
    _W = HA(),
    { kEnumerableProperty: dB } = _W,
    {
      isValidReasonPhrase: Ui,
      isCancelled: Wi,
      isAborted: Zi,
      isBlobLike: Xi,
      serializeJavascriptValueToJSONString: wi,
      isErrorLike: Mi,
      isomorphicEncode: Li,
    } = AI(),
    { redirectStatusSet: Ri, nullBodyStatus: Vi, DOMException: rL } = yE(),
    { kState: QQ, kHeaders: vQ, kGuard: b0, kRealm: mB } = CE(),
    { webidl: NA } = EB(),
    { FormData: $i } = pD(),
    { getGlobalOrigin: Hi } = w0(),
    { URLSerializer: tL } = $I(),
    { kHeadersList: vW, kConstruct: Ki } = aA(),
    yW = $("assert"),
    { types: PW } = $("util"),
    A6 = globalThis.ReadableStream || $("stream/web").ReadableStream,
    zi = new TextEncoder("utf-8");
  class hQ {
    static error() {
      let A = { settingsObject: {} },
        Q = new hQ();
      return (
        (Q[QQ] = fY()),
        (Q[mB] = A),
        (Q[vQ][vW] = Q[QQ].headersList),
        (Q[vQ][b0] = "immutable"),
        (Q[vQ][mB] = A),
        Q
      );
    }
    static json(A, Q = {}) {
      if (
        (NA.argumentLengthCheck(arguments, 1, { header: "Response.json" }),
        Q !== null)
      )
        Q = NA.converters.ResponseInit(Q);
      let B = zi.encode(wi(A)),
        I = sL(B),
        E = { settingsObject: {} },
        C = new hQ();
      return (
        (C[mB] = E),
        (C[vQ][b0] = "response"),
        (C[vQ][mB] = E),
        eL(C, Q, { body: I[0], type: "application/json" }),
        C
      );
    }
    static redirect(A, Q = 302) {
      let B = { settingsObject: {} };
      NA.argumentLengthCheck(arguments, 1, { header: "Response.redirect" }),
        (A = NA.converters.USVString(A)),
        (Q = NA.converters["unsigned short"](Q));
      let I;
      try {
        I = new URL(A, Hi());
      } catch (g) {
        throw Object.assign(TypeError("Failed to parse URL from " + A), {
          cause: g,
        });
      }
      if (!Ri.has(Q)) throw RangeError("Invalid status code " + Q);
      let E = new hQ();
      (E[mB] = B),
        (E[vQ][b0] = "immutable"),
        (E[vQ][mB] = B),
        (E[QQ].status = Q);
      let C = Li(tL(I));
      return E[QQ].headersList.append("location", C), E;
    }
    constructor(A = null, Q = {}) {
      if (A !== null) A = NA.converters.BodyInit(A);
      (Q = NA.converters.ResponseInit(Q)),
        (this[mB] = { settingsObject: {} }),
        (this[QQ] = hY({})),
        (this[vQ] = new Yi(Ki)),
        (this[vQ][b0] = "response"),
        (this[vQ][vW] = this[QQ].headersList),
        (this[vQ][mB] = this[mB]);
      let B = null;
      if (A != null) {
        let [I, E] = sL(A);
        B = { body: I, type: E };
      }
      eL(this, Q, B);
    }
    get type() {
      return NA.brandCheck(this, hQ), this[QQ].type;
    }
    get url() {
      NA.brandCheck(this, hQ);
      let A = this[QQ].urlList,
        Q = A[A.length - 1] ?? null;
      if (Q === null) return "";
      return tL(Q, !0);
    }
    get redirected() {
      return NA.brandCheck(this, hQ), this[QQ].urlList.length > 1;
    }
    get status() {
      return NA.brandCheck(this, hQ), this[QQ].status;
    }
    get ok() {
      return (
        NA.brandCheck(this, hQ),
        this[QQ].status >= 200 && this[QQ].status <= 299
      );
    }
    get statusText() {
      return NA.brandCheck(this, hQ), this[QQ].statusText;
    }
    get headers() {
      return NA.brandCheck(this, hQ), this[vQ];
    }
    get body() {
      return (
        NA.brandCheck(this, hQ), this[QQ].body ? this[QQ].body.stream : null
      );
    }
    get bodyUsed() {
      return (
        NA.brandCheck(this, hQ),
        !!this[QQ].body && _W.isDisturbed(this[QQ].body.stream)
      );
    }
    clone() {
      if (
        (NA.brandCheck(this, hQ),
        this.bodyUsed || (this.body && this.body.locked))
      )
        throw NA.errors.exception({
          header: "Response.clone",
          message: "Body has already been consumed.",
        });
      let A = SW(this[QQ]),
        Q = new hQ();
      return (
        (Q[QQ] = A),
        (Q[mB] = this[mB]),
        (Q[vQ][vW] = A.headersList),
        (Q[vQ][b0] = this[vQ][b0]),
        (Q[vQ][mB] = this[vQ][mB]),
        Q
      );
    }
  }
  Gi(hQ);
  Object.defineProperties(hQ.prototype, {
    type: dB,
    url: dB,
    status: dB,
    ok: dB,
    redirected: dB,
    statusText: dB,
    headers: dB,
    clone: dB,
    body: dB,
    bodyUsed: dB,
    [Symbol.toStringTag]: { value: "Response", configurable: !0 },
  });
  Object.defineProperties(hQ, { json: dB, redirect: dB, error: dB });
  function SW(A) {
    if (A.internalResponse) return Q6(SW(A.internalResponse), A.type);
    let Q = hY({ ...A, body: null });
    if (A.body != null) Q.body = Ni(A.body);
    return Q;
  }
  function hY(A) {
    return {
      aborted: !1,
      rangeRequested: !1,
      timingAllowPassed: !1,
      requestIncludesCredentials: !1,
      type: "default",
      status: 200,
      timingInfo: null,
      cacheState: "",
      statusText: "",
      ...A,
      headersList: A.headersList ? new oL(A.headersList) : new oL(),
      urlList: A.urlList ? [...A.urlList] : [],
    };
  }
  function fY(A) {
    let Q = Mi(A);
    return hY({
      type: "error",
      status: 0,
      error: Q ? A : Error(A ? String(A) : A),
      aborted: A && A.name === "AbortError",
    });
  }
  function jY(A, Q) {
    return (
      (Q = { internalResponse: A, ...Q }),
      new Proxy(A, {
        get(B, I) {
          return I in Q ? Q[I] : B[I];
        },
        set(B, I, E) {
          return yW(!(I in Q)), (B[I] = E), !0;
        },
      })
    );
  }
  function Q6(A, Q) {
    if (Q === "basic")
      return jY(A, { type: "basic", headersList: A.headersList });
    else if (Q === "cors")
      return jY(A, { type: "cors", headersList: A.headersList });
    else if (Q === "opaque")
      return jY(A, {
        type: "opaque",
        urlList: Object.freeze([]),
        status: 0,
        statusText: "",
        body: null,
      });
    else if (Q === "opaqueredirect")
      return jY(A, {
        type: "opaqueredirect",
        status: 0,
        statusText: "",
        headersList: [],
        body: null,
      });
    else yW(!1);
  }
  function Ti(A, Q = null) {
    return (
      yW(Wi(A)),
      Zi(A)
        ? fY(
            Object.assign(new rL("The operation was aborted.", "AbortError"), {
              cause: Q,
            }),
          )
        : fY(Object.assign(new rL("Request was cancelled."), { cause: Q }))
    );
  }
  function eL(A, Q, B) {
    if (Q.status !== null && (Q.status < 200 || Q.status > 599))
      throw RangeError(
        'init["status"] must be in the range of 200 to 599, inclusive.',
      );
    if ("statusText" in Q && Q.statusText != null) {
      if (!Ui(String(Q.statusText))) throw TypeError("Invalid statusText");
    }
    if ("status" in Q && Q.status != null) A[QQ].status = Q.status;
    if ("statusText" in Q && Q.statusText != null)
      A[QQ].statusText = Q.statusText;
    if ("headers" in Q && Q.headers != null) Ji(A[vQ], Q.headers);
    if (B) {
      if (Vi.includes(A.status))
        throw NA.errors.exception({
          header: "Response constructor",
          message: "Invalid response status code " + A.status,
        });
      if (
        ((A[QQ].body = B.body),
        B.type != null && !A[QQ].headersList.contains("Content-Type"))
      )
        A[QQ].headersList.append("content-type", B.type);
    }
  }
  NA.converters.ReadableStream = NA.interfaceConverter(A6);
  NA.converters.FormData = NA.interfaceConverter($i);
  NA.converters.URLSearchParams = NA.interfaceConverter(URLSearchParams);
  NA.converters.XMLHttpRequestBodyInit = function (A) {
    if (typeof A === "string") return NA.converters.USVString(A);
    if (Xi(A)) return NA.converters.Blob(A, { strict: !1 });
    if (PW.isArrayBuffer(A) || PW.isTypedArray(A) || PW.isDataView(A))
      return NA.converters.BufferSource(A);
    if (_W.isFormDataLike(A)) return NA.converters.FormData(A, { strict: !1 });
    if (A instanceof URLSearchParams) return NA.converters.URLSearchParams(A);
    return NA.converters.DOMString(A);
  };
  NA.converters.BodyInit = function (A) {
    if (A instanceof A6) return NA.converters.ReadableStream(A);
    if (A?.[Symbol.asyncIterator]) return A;
    return NA.converters.XMLHttpRequestBodyInit(A);
  };
  NA.converters.ResponseInit = NA.dictionaryConverter([
    {
      key: "status",
      converter: NA.converters["unsigned short"],
      defaultValue: 200,
    },
    {
      key: "statusText",
      converter: NA.converters.ByteString,
      defaultValue: "",
    },
    { key: "headers", converter: NA.converters.HeadersInit },
  ]);
  B6.exports = {
    makeNetworkError: fY,
    makeResponse: hY,
    makeAppropriateNetworkError: Ti,
    filterResponse: Q6,
    Response: hQ,
    cloneResponse: SW,
  };
});
var XF = Z((k3A, D6) => {
  var { extractBody: Oi, mixinBody: qi, cloneBody: ji } = lg(),
    { Headers: I6, fill: fi, HeadersList: _Y } = yC(),
    { FinalizationRegistry: hi } = gW()(),
    ZF = HA(),
    {
      isValidHTTPToken: ki,
      sameOrigin: E6,
      normalizeMethod: xi,
      makePolicyContainer: vi,
      normalizeMethodRecord: Pi,
    } = AI(),
    {
      forbiddenMethodsSet: _i,
      corsSafeListedMethodsSet: yi,
      referrerPolicy: Si,
      requestRedirect: bi,
      requestMode: mi,
      requestCredentials: di,
      requestCache: ci,
      requestDuplex: ui,
    } = yE(),
    { kEnumerableProperty: VQ } = ZF,
    { kHeaders: rQ, kSignal: WF, kState: rA, kGuard: xY, kRealm: cB } = CE(),
    { webidl: CA } = EB(),
    { getGlobalOrigin: li } = w0(),
    { URLSerializer: pi } = $I(),
    { kHeadersList: vY, kConstruct: PY } = aA(),
    ii = $("assert"),
    {
      getMaxListeners: C6,
      setMaxListeners: g6,
      getEventListeners: ni,
      defaultMaxListeners: F6,
    } = $("events"),
    bW = globalThis.TransformStream,
    ai = Symbol("abortController"),
    oi = new hi(({ signal: A, abort: Q }) => {
      A.removeEventListener("abort", Q);
    });
  class cA {
    constructor(A, Q = {}) {
      if (A === PY) return;
      CA.argumentLengthCheck(arguments, 1, { header: "Request constructor" }),
        (A = CA.converters.RequestInfo(A)),
        (Q = CA.converters.RequestInit(Q)),
        (this[cB] = {
          settingsObject: {
            baseUrl: li(),
            get origin() {
              return this.baseUrl?.origin;
            },
            policyContainer: vi(),
          },
        });
      let B = null,
        I = null,
        E = this[cB].settingsObject.baseUrl,
        C = null;
      if (typeof A === "string") {
        let L;
        try {
          L = new URL(A, E);
        } catch (H) {
          throw TypeError("Failed to parse URL from " + A, { cause: H });
        }
        if (L.username || L.password)
          throw TypeError(
            "Request cannot be constructed from a URL that includes credentials: " +
              A,
          );
        (B = yY({ urlList: [L] })), (I = "cors");
      } else ii(A instanceof cA), (B = A[rA]), (C = A[WF]);
      let g = this[cB].settingsObject.origin,
        F = "client";
      if (
        B.window?.constructor?.name === "EnvironmentSettingsObject" &&
        E6(B.window, g)
      )
        F = B.window;
      if (Q.window != null)
        throw TypeError(`'window' option '${F}' must be null`);
      if ("window" in Q) F = "no-window";
      B = yY({
        method: B.method,
        headersList: B.headersList,
        unsafeRequest: B.unsafeRequest,
        client: this[cB].settingsObject,
        window: F,
        priority: B.priority,
        origin: B.origin,
        referrer: B.referrer,
        referrerPolicy: B.referrerPolicy,
        mode: B.mode,
        credentials: B.credentials,
        cache: B.cache,
        redirect: B.redirect,
        integrity: B.integrity,
        keepalive: B.keepalive,
        reloadNavigation: B.reloadNavigation,
        historyNavigation: B.historyNavigation,
        urlList: [...B.urlList],
      });
      let D = Object.keys(Q).length !== 0;
      if (D) {
        if (B.mode === "navigate") B.mode = "same-origin";
        (B.reloadNavigation = !1),
          (B.historyNavigation = !1),
          (B.origin = "client"),
          (B.referrer = "client"),
          (B.referrerPolicy = ""),
          (B.url = B.urlList[B.urlList.length - 1]),
          (B.urlList = [B.url]);
      }
      if (Q.referrer !== void 0) {
        let L = Q.referrer;
        if (L === "") B.referrer = "no-referrer";
        else {
          let H;
          try {
            H = new URL(L, E);
          } catch (q) {
            throw TypeError(`Referrer "${L}" is not a valid URL.`, {
              cause: q,
            });
          }
          if (
            (H.protocol === "about:" && H.hostname === "client") ||
            (g && !E6(H, this[cB].settingsObject.baseUrl))
          )
            B.referrer = "client";
          else B.referrer = H;
        }
      }
      if (Q.referrerPolicy !== void 0) B.referrerPolicy = Q.referrerPolicy;
      let J;
      if (Q.mode !== void 0) J = Q.mode;
      else J = I;
      if (J === "navigate")
        throw CA.errors.exception({
          header: "Request constructor",
          message: "invalid request mode navigate.",
        });
      if (J != null) B.mode = J;
      if (Q.credentials !== void 0) B.credentials = Q.credentials;
      if (Q.cache !== void 0) B.cache = Q.cache;
      if (B.cache === "only-if-cached" && B.mode !== "same-origin")
        throw TypeError(
          "'only-if-cached' can be set only with 'same-origin' mode",
        );
      if (Q.redirect !== void 0) B.redirect = Q.redirect;
      if (Q.integrity != null) B.integrity = String(Q.integrity);
      if (Q.keepalive !== void 0) B.keepalive = Boolean(Q.keepalive);
      if (Q.method !== void 0) {
        let L = Q.method;
        if (!ki(L)) throw TypeError(`'${L}' is not a valid HTTP method.`);
        if (_i.has(L.toUpperCase()))
          throw TypeError(`'${L}' HTTP method is unsupported.`);
        (L = Pi[L] ?? xi(L)), (B.method = L);
      }
      if (Q.signal !== void 0) C = Q.signal;
      this[rA] = B;
      let Y = new AbortController();
      if (((this[WF] = Y.signal), (this[WF][cB] = this[cB]), C != null)) {
        if (
          !C ||
          typeof C.aborted !== "boolean" ||
          typeof C.addEventListener !== "function"
        )
          throw TypeError(
            "Failed to construct 'Request': member signal is not of type AbortSignal.",
          );
        if (C.aborted) Y.abort(C.reason);
        else {
          this[ai] = Y;
          let L = new WeakRef(Y),
            H = function () {
              let q = L.deref();
              if (q !== void 0) q.abort(this.reason);
            };
          try {
            if (typeof C6 === "function" && C6(C) === F6) g6(100, C);
            else if (ni(C, "abort").length >= F6) g6(100, C);
          } catch {}
          ZF.addAbortListener(C, H), oi.register(Y, { signal: C, abort: H });
        }
      }
      if (
        ((this[rQ] = new I6(PY)),
        (this[rQ][vY] = B.headersList),
        (this[rQ][xY] = "request"),
        (this[rQ][cB] = this[cB]),
        J === "no-cors")
      ) {
        if (!yi.has(B.method))
          throw TypeError(`'${B.method} is unsupported in no-cors mode.`);
        this[rQ][xY] = "request-no-cors";
      }
      if (D) {
        let L = this[rQ][vY],
          H = Q.headers !== void 0 ? Q.headers : new _Y(L);
        if ((L.clear(), H instanceof _Y)) {
          for (let [q, O] of H) L.append(q, O);
          L.cookies = H.cookies;
        } else fi(this[rQ], H);
      }
      let N = A instanceof cA ? A[rA].body : null;
      if (
        (Q.body != null || N != null) &&
        (B.method === "GET" || B.method === "HEAD")
      )
        throw TypeError("Request with GET/HEAD method cannot have body.");
      let W = null;
      if (Q.body != null) {
        let [L, H] = Oi(Q.body, B.keepalive);
        if (((W = L), H && !this[rQ][vY].contains("content-type")))
          this[rQ].append("content-type", H);
      }
      let X = W ?? N;
      if (X != null && X.source == null) {
        if (W != null && Q.duplex == null)
          throw TypeError(
            "RequestInit: duplex option is required when sending a body.",
          );
        if (B.mode !== "same-origin" && B.mode !== "cors")
          throw TypeError(
            'If request is made from ReadableStream, mode should be "same-origin" or "cors"',
          );
        B.useCORSPreflightFlag = !0;
      }
      let M = X;
      if (W == null && N != null) {
        if (ZF.isDisturbed(N.stream) || N.stream.locked)
          throw TypeError(
            "Cannot construct a Request with a Request object that has already been used.",
          );
        if (!bW) bW = $("stream/web").TransformStream;
        let L = new bW();
        N.stream.pipeThrough(L),
          (M = { source: N.source, length: N.length, stream: L.readable });
      }
      this[rA].body = M;
    }
    get method() {
      return CA.brandCheck(this, cA), this[rA].method;
    }
    get url() {
      return CA.brandCheck(this, cA), pi(this[rA].url);
    }
    get headers() {
      return CA.brandCheck(this, cA), this[rQ];
    }
    get destination() {
      return CA.brandCheck(this, cA), this[rA].destination;
    }
    get referrer() {
      if ((CA.brandCheck(this, cA), this[rA].referrer === "no-referrer"))
        return "";
      if (this[rA].referrer === "client") return "about:client";
      return this[rA].referrer.toString();
    }
    get referrerPolicy() {
      return CA.brandCheck(this, cA), this[rA].referrerPolicy;
    }
    get mode() {
      return CA.brandCheck(this, cA), this[rA].mode;
    }
    get credentials() {
      return this[rA].credentials;
    }
    get cache() {
      return CA.brandCheck(this, cA), this[rA].cache;
    }
    get redirect() {
      return CA.brandCheck(this, cA), this[rA].redirect;
    }
    get integrity() {
      return CA.brandCheck(this, cA), this[rA].integrity;
    }
    get keepalive() {
      return CA.brandCheck(this, cA), this[rA].keepalive;
    }
    get isReloadNavigation() {
      return CA.brandCheck(this, cA), this[rA].reloadNavigation;
    }
    get isHistoryNavigation() {
      return CA.brandCheck(this, cA), this[rA].historyNavigation;
    }
    get signal() {
      return CA.brandCheck(this, cA), this[WF];
    }
    get body() {
      return (
        CA.brandCheck(this, cA), this[rA].body ? this[rA].body.stream : null
      );
    }
    get bodyUsed() {
      return (
        CA.brandCheck(this, cA),
        !!this[rA].body && ZF.isDisturbed(this[rA].body.stream)
      );
    }
    get duplex() {
      return CA.brandCheck(this, cA), "half";
    }
    clone() {
      if ((CA.brandCheck(this, cA), this.bodyUsed || this.body?.locked))
        throw TypeError("unusable");
      let A = si(this[rA]),
        Q = new cA(PY);
      (Q[rA] = A),
        (Q[cB] = this[cB]),
        (Q[rQ] = new I6(PY)),
        (Q[rQ][vY] = A.headersList),
        (Q[rQ][xY] = this[rQ][xY]),
        (Q[rQ][cB] = this[rQ][cB]);
      let B = new AbortController();
      if (this.signal.aborted) B.abort(this.signal.reason);
      else
        ZF.addAbortListener(this.signal, () => {
          B.abort(this.signal.reason);
        });
      return (Q[WF] = B.signal), Q;
    }
  }
  qi(cA);
  function yY(A) {
    let Q = {
      method: "GET",
      localURLsOnly: !1,
      unsafeRequest: !1,
      body: null,
      client: null,
      reservedClient: null,
      replacesClientId: "",
      window: "client",
      keepalive: !1,
      serviceWorkers: "all",
      initiator: "",
      destination: "",
      priority: null,
      origin: "client",
      policyContainer: "client",
      referrer: "client",
      referrerPolicy: "",
      mode: "no-cors",
      useCORSPreflightFlag: !1,
      credentials: "same-origin",
      useCredentials: !1,
      cache: "default",
      redirect: "follow",
      integrity: "",
      cryptoGraphicsNonceMetadata: "",
      parserMetadata: "",
      reloadNavigation: !1,
      historyNavigation: !1,
      userActivation: !1,
      taintedOrigin: !1,
      redirectCount: 0,
      responseTainting: "basic",
      preventNoCacheCacheControlHeaderModification: !1,
      done: !1,
      timingAllowFailed: !1,
      ...A,
      headersList: A.headersList ? new _Y(A.headersList) : new _Y(),
    };
    return (Q.url = Q.urlList[0]), Q;
  }
  function si(A) {
    let Q = yY({ ...A, body: null });
    if (A.body != null) Q.body = ji(A.body);
    return Q;
  }
  Object.defineProperties(cA.prototype, {
    method: VQ,
    url: VQ,
    headers: VQ,
    redirect: VQ,
    clone: VQ,
    signal: VQ,
    duplex: VQ,
    destination: VQ,
    body: VQ,
    bodyUsed: VQ,
    isHistoryNavigation: VQ,
    isReloadNavigation: VQ,
    keepalive: VQ,
    integrity: VQ,
    cache: VQ,
    credentials: VQ,
    attribute: VQ,
    referrerPolicy: VQ,
    referrer: VQ,
    mode: VQ,
    [Symbol.toStringTag]: { value: "Request", configurable: !0 },
  });
  CA.converters.Request = CA.interfaceConverter(cA);
  CA.converters.RequestInfo = function (A) {
    if (typeof A === "string") return CA.converters.USVString(A);
    if (A instanceof cA) return CA.converters.Request(A);
    return CA.converters.USVString(A);
  };
  CA.converters.AbortSignal = CA.interfaceConverter(AbortSignal);
  CA.converters.RequestInit = CA.dictionaryConverter([
    { key: "method", converter: CA.converters.ByteString },
    { key: "headers", converter: CA.converters.HeadersInit },
    { key: "body", converter: CA.nullableConverter(CA.converters.BodyInit) },
    { key: "referrer", converter: CA.converters.USVString },
    {
      key: "referrerPolicy",
      converter: CA.converters.DOMString,
      allowedValues: Si,
    },
    { key: "mode", converter: CA.converters.DOMString, allowedValues: mi },
    {
      key: "credentials",
      converter: CA.converters.DOMString,
      allowedValues: di,
    },
    { key: "cache", converter: CA.converters.DOMString, allowedValues: ci },
    { key: "redirect", converter: CA.converters.DOMString, allowedValues: bi },
    { key: "integrity", converter: CA.converters.DOMString },
    { key: "keepalive", converter: CA.converters.boolean },
    {
      key: "signal",
      converter: CA.nullableConverter((A) =>
        CA.converters.AbortSignal(A, { strict: !1 }),
      ),
    },
    { key: "window", converter: CA.converters.any },
    { key: "duplex", converter: CA.converters.DOMString, allowedValues: ui },
  ]);
  D6.exports = { Request: cA, makeRequest: yY };
});
var uY = Z((x3A, $6) => {
  var {
      Response: ri,
      makeNetworkError: uA,
      makeAppropriateNetworkError: SY,
      filterResponse: mW,
      makeResponse: bY,
    } = kY(),
    { Headers: Y6 } = yC(),
    { Request: ti, makeRequest: ei } = XF(),
    wF = $("zlib"),
    {
      bytesMatch: An,
      makePolicyContainer: Qn,
      clonePolicyContainer: Bn,
      requestBadPort: In,
      TAOCheck: En,
      appendRequestOriginHeader: Cn,
      responseLocationURL: gn,
      requestCurrentURL: dI,
      setRequestReferrerPolicyOnRedirect: Fn,
      tryUpgradeRequestToAPotentiallyTrustworthyURL: Dn,
      createOpaqueTimingInfo: oW,
      appendFetchMetadata: Yn,
      corsCheck: Jn,
      crossOriginResourcePolicyCheck: Nn,
      determineRequestsReferrer: Gn,
      coarsenedSharedCurrentTime: sW,
      createDeferredPromise: Un,
      isBlobLike: Wn,
      sameOrigin: iW,
      isCancelled: d0,
      isAborted: J6,
      isErrorLike: Zn,
      fullyReadBody: W6,
      readableStreamClose: Xn,
      isomorphicEncode: nW,
      urlIsLocal: wn,
      urlIsHttpHttpsScheme: rW,
      urlHasHttpsScheme: Mn,
    } = AI(),
    { kState: aW, kHeaders: dW, kGuard: Ln, kRealm: N6 } = CE(),
    c0 = $("assert"),
    { safelyExtractBody: mY } = lg(),
    {
      redirectStatusSet: Z6,
      nullBodyStatus: X6,
      safeMethodsSet: Rn,
      requestBodyHeader: Vn,
      subresourceSet: $n,
      DOMException: dY,
    } = yE(),
    { kHeadersList: m0 } = aA(),
    Hn = $("events"),
    { Readable: Kn, pipeline: zn } = $("stream"),
    {
      addAbortListener: Tn,
      isErrored: On,
      isReadable: cY,
      nodeMajor: G6,
      nodeMinor: qn,
    } = HA(),
    { dataURLProcessor: jn, serializeAMimeType: fn } = $I(),
    { TransformStream: hn } = $("stream/web"),
    { getGlobalDispatcher: kn } = y0(),
    { webidl: xn } = EB(),
    { STATUS_CODES: vn } = $("http"),
    Pn = ["GET", "HEAD"],
    cW,
    uW = globalThis.ReadableStream;
  class tW extends Hn {
    constructor(A) {
      super();
      (this.dispatcher = A),
        (this.connection = null),
        (this.dump = !1),
        (this.state = "ongoing"),
        this.setMaxListeners(21);
    }
    terminate(A) {
      if (this.state !== "ongoing") return;
      (this.state = "terminated"),
        this.connection?.destroy(A),
        this.emit("terminated", A);
    }
    abort(A) {
      if (this.state !== "ongoing") return;
      if (((this.state = "aborted"), !A))
        A = new dY("The operation was aborted.", "AbortError");
      (this.serializedAbortReason = A),
        this.connection?.destroy(A),
        this.emit("terminated", A);
    }
  }
  function _n(A, Q = {}) {
    xn.argumentLengthCheck(arguments, 1, { header: "globalThis.fetch" });
    let B = Un(),
      I;
    try {
      I = new ti(A, Q);
    } catch (W) {
      return B.reject(W), B.promise;
    }
    let E = I[aW];
    if (I.signal.aborted) return lW(B, E, null, I.signal.reason), B.promise;
    if (E.client.globalObject?.constructor?.name === "ServiceWorkerGlobalScope")
      E.serviceWorkers = "none";
    let g = null,
      F = null,
      D = !1,
      J = null;
    return (
      Tn(I.signal, () => {
        (D = !0),
          c0(J != null),
          J.abort(I.signal.reason),
          lW(B, E, g, I.signal.reason);
      }),
      (J = M6({
        request: E,
        processResponseEndOfBody: (W) => w6(W, "fetch"),
        processResponse: (W) => {
          if (D) return Promise.resolve();
          if (W.aborted)
            return lW(B, E, g, J.serializedAbortReason), Promise.resolve();
          if (W.type === "error")
            return (
              B.reject(
                Object.assign(TypeError("fetch failed"), { cause: W.error }),
              ),
              Promise.resolve()
            );
          (g = new ri()),
            (g[aW] = W),
            (g[N6] = F),
            (g[dW][m0] = W.headersList),
            (g[dW][Ln] = "immutable"),
            (g[dW][N6] = F),
            B.resolve(g);
        },
        dispatcher: Q.dispatcher ?? kn(),
      })),
      B.promise
    );
  }
  function w6(A, Q = "other") {
    if (A.type === "error" && A.aborted) return;
    if (!A.urlList?.length) return;
    let B = A.urlList[0],
      I = A.timingInfo,
      E = A.cacheState;
    if (!rW(B)) return;
    if (I === null) return;
    if (!A.timingAllowPassed) (I = oW({ startTime: I.startTime })), (E = "");
    (I.endTime = sW()), (A.timingInfo = I), yn(I, B, Q, globalThis, E);
  }
  function yn(A, Q, B, I, E) {
    if (G6 > 18 || (G6 === 18 && qn >= 2))
      performance.markResourceTiming(A, Q.href, B, I, E);
  }
  function lW(A, Q, B, I) {
    if (!I) I = new dY("The operation was aborted.", "AbortError");
    if ((A.reject(I), Q.body != null && cY(Q.body?.stream)))
      Q.body.stream.cancel(I).catch((C) => {
        if (C.code === "ERR_INVALID_STATE") return;
        throw C;
      });
    if (B == null) return;
    let E = B[aW];
    if (E.body != null && cY(E.body?.stream))
      E.body.stream.cancel(I).catch((C) => {
        if (C.code === "ERR_INVALID_STATE") return;
        throw C;
      });
  }
  function M6({
    request: A,
    processRequestBodyChunkLength: Q,
    processRequestEndOfBody: B,
    processResponse: I,
    processResponseEndOfBody: E,
    processResponseConsumeBody: C,
    useParallelQueue: g = !1,
    dispatcher: F,
  }) {
    let D = null,
      J = !1;
    if (A.client != null)
      (D = A.client.globalObject), (J = A.client.crossOriginIsolatedCapability);
    let Y = sW(J),
      N = oW({ startTime: Y }),
      W = {
        controller: new tW(F),
        request: A,
        timingInfo: N,
        processRequestBodyChunkLength: Q,
        processRequestEndOfBody: B,
        processResponse: I,
        processResponseConsumeBody: C,
        processResponseEndOfBody: E,
        taskDestination: D,
        crossOriginIsolatedCapability: J,
      };
    if ((c0(!A.body || A.body.stream), A.window === "client"))
      A.window =
        A.client?.globalObject?.constructor?.name === "Window"
          ? A.client
          : "no-window";
    if (A.origin === "client") A.origin = A.client?.origin;
    if (A.policyContainer === "client")
      if (A.client != null) A.policyContainer = Bn(A.client.policyContainer);
      else A.policyContainer = Qn();
    if (!A.headersList.contains("accept"))
      A.headersList.append("accept", "*/*");
    if (!A.headersList.contains("accept-language"))
      A.headersList.append("accept-language", "*");
    if (A.priority === null);
    if ($n.has(A.destination));
    return (
      L6(W).catch((X) => {
        W.controller.terminate(X);
      }),
      W.controller
    );
  }
  async function L6(A, Q = !1) {
    let B = A.request,
      I = null;
    if (B.localURLsOnly && !wn(dI(B))) I = uA("local URLs only");
    if ((Dn(B), In(B) === "blocked")) I = uA("bad port");
    if (B.referrerPolicy === "")
      B.referrerPolicy = B.policyContainer.referrerPolicy;
    if (B.referrer !== "no-referrer") B.referrer = Gn(B);
    if (I === null)
      I = await (async () => {
        let C = dI(B);
        if (
          (iW(C, B.url) && B.responseTainting === "basic") ||
          C.protocol === "data:" ||
          B.mode === "navigate" ||
          B.mode === "websocket"
        )
          return (B.responseTainting = "basic"), await U6(A);
        if (B.mode === "same-origin")
          return uA('request mode cannot be "same-origin"');
        if (B.mode === "no-cors") {
          if (B.redirect !== "follow")
            return uA('redirect mode cannot be "follow" for "no-cors" request');
          return (B.responseTainting = "opaque"), await U6(A);
        }
        if (!rW(dI(B))) return uA("URL scheme must be a HTTP(S) scheme");
        return (B.responseTainting = "cors"), await R6(A);
      })();
    if (Q) return I;
    if (I.status !== 0 && !I.internalResponse) {
      if (B.responseTainting === "cors");
      if (B.responseTainting === "basic") I = mW(I, "basic");
      else if (B.responseTainting === "cors") I = mW(I, "cors");
      else if (B.responseTainting === "opaque") I = mW(I, "opaque");
      else c0(!1);
    }
    let E = I.status === 0 ? I : I.internalResponse;
    if (E.urlList.length === 0) E.urlList.push(...B.urlList);
    if (!B.timingAllowFailed) I.timingAllowPassed = !0;
    if (
      I.type === "opaque" &&
      E.status === 206 &&
      E.rangeRequested &&
      !B.headers.contains("range")
    )
      I = E = uA();
    if (
      I.status !== 0 &&
      (B.method === "HEAD" || B.method === "CONNECT" || X6.includes(E.status))
    )
      (E.body = null), (A.controller.dump = !0);
    if (B.integrity) {
      let C = (F) => pW(A, uA(F));
      if (B.responseTainting === "opaque" || I.body == null) {
        C(I.error);
        return;
      }
      let g = (F) => {
        if (!An(F, B.integrity)) {
          C("integrity mismatch");
          return;
        }
        (I.body = mY(F)[0]), pW(A, I);
      };
      await W6(I.body, g, C);
    } else pW(A, I);
  }
  function U6(A) {
    if (d0(A) && A.request.redirectCount === 0) return Promise.resolve(SY(A));
    let { request: Q } = A,
      { protocol: B } = dI(Q);
    switch (B) {
      case "about:":
        return Promise.resolve(uA("about scheme is not supported"));
      case "blob:": {
        if (!cW) cW = $("buffer").resolveObjectURL;
        let I = dI(Q);
        if (I.search.length !== 0)
          return Promise.resolve(
            uA("NetworkError when attempting to fetch resource."),
          );
        let E = cW(I.toString());
        if (Q.method !== "GET" || !Wn(E))
          return Promise.resolve(uA("invalid method"));
        let C = mY(E),
          g = C[0],
          F = nW(`${g.length}`),
          D = C[1] ?? "",
          J = bY({
            statusText: "OK",
            headersList: [
              ["content-length", { name: "Content-Length", value: F }],
              ["content-type", { name: "Content-Type", value: D }],
            ],
          });
        return (J.body = g), Promise.resolve(J);
      }
      case "data:": {
        let I = dI(Q),
          E = jn(I);
        if (E === "failure")
          return Promise.resolve(uA("failed to fetch the data URL"));
        let C = fn(E.mimeType);
        return Promise.resolve(
          bY({
            statusText: "OK",
            headersList: [["content-type", { name: "Content-Type", value: C }]],
            body: mY(E.body)[0],
          }),
        );
      }
      case "file:":
        return Promise.resolve(uA("not implemented... yet..."));
      case "http:":
      case "https:":
        return R6(A).catch((I) => uA(I));
      default:
        return Promise.resolve(uA("unknown scheme"));
    }
  }
  function Sn(A, Q) {
    if (((A.request.done = !0), A.processResponseDone != null))
      queueMicrotask(() => A.processResponseDone(Q));
  }
  function pW(A, Q) {
    if (Q.type === "error")
      (Q.urlList = [A.request.urlList[0]]),
        (Q.timingInfo = oW({ startTime: A.timingInfo.startTime }));
    let B = () => {
      if (((A.request.done = !0), A.processResponseEndOfBody != null))
        queueMicrotask(() => A.processResponseEndOfBody(Q));
    };
    if (A.processResponse != null) queueMicrotask(() => A.processResponse(Q));
    if (Q.body == null) B();
    else {
      let E = new hn(
        {
          start() {},
          transform: (C, g) => {
            g.enqueue(C);
          },
          flush: B,
        },
        {
          size() {
            return 1;
          },
        },
        {
          size() {
            return 1;
          },
        },
      );
      Q.body = { stream: Q.body.stream.pipeThrough(E) };
    }
    if (A.processResponseConsumeBody != null) {
      let I = (C) => A.processResponseConsumeBody(Q, C),
        E = (C) => A.processResponseConsumeBody(Q, C);
      if (Q.body == null) queueMicrotask(() => I(null));
      else return W6(Q.body, I, E);
      return Promise.resolve();
    }
  }
  async function R6(A) {
    let Q = A.request,
      B = null,
      I = null,
      E = A.timingInfo;
    if (Q.serviceWorkers === "all");
    if (B === null) {
      if (Q.redirect === "follow") Q.serviceWorkers = "none";
      if (
        ((I = B = await V6(A)),
        Q.responseTainting === "cors" && Jn(Q, B) === "failure")
      )
        return uA("cors failure");
      if (En(Q, B) === "failure") Q.timingAllowFailed = !0;
    }
    if (
      (Q.responseTainting === "opaque" || B.type === "opaque") &&
      Nn(Q.origin, Q.client, Q.destination, I) === "blocked"
    )
      return uA("blocked");
    if (Z6.has(I.status)) {
      if (Q.redirect !== "manual") A.controller.connection.destroy();
      if (Q.redirect === "error") B = uA("unexpected redirect");
      else if (Q.redirect === "manual") B = I;
      else if (Q.redirect === "follow") B = await bn(A, B);
      else c0(!1);
    }
    return (B.timingInfo = E), B;
  }
  function bn(A, Q) {
    let B = A.request,
      I = Q.internalResponse ? Q.internalResponse : Q,
      E;
    try {
      if (((E = gn(I, dI(B).hash)), E == null)) return Q;
    } catch (g) {
      return Promise.resolve(uA(g));
    }
    if (!rW(E))
      return Promise.resolve(uA("URL scheme must be a HTTP(S) scheme"));
    if (B.redirectCount === 20)
      return Promise.resolve(uA("redirect count exceeded"));
    if (
      ((B.redirectCount += 1),
      B.mode === "cors" && (E.username || E.password) && !iW(B, E))
    )
      return Promise.resolve(
        uA('cross origin not allowed for request mode "cors"'),
      );
    if (B.responseTainting === "cors" && (E.username || E.password))
      return Promise.resolve(
        uA('URL cannot contain credentials for request mode "cors"'),
      );
    if (I.status !== 303 && B.body != null && B.body.source == null)
      return Promise.resolve(uA());
    if (
      ([301, 302].includes(I.status) && B.method === "POST") ||
      (I.status === 303 && !Pn.includes(B.method))
    ) {
      (B.method = "GET"), (B.body = null);
      for (let g of Vn) B.headersList.delete(g);
    }
    if (!iW(dI(B), E))
      B.headersList.delete("authorization"),
        B.headersList.delete("proxy-authorization", !0),
        B.headersList.delete("cookie"),
        B.headersList.delete("host");
    if (B.body != null)
      c0(B.body.source != null), (B.body = mY(B.body.source)[0]);
    let C = A.timingInfo;
    if (
      ((C.redirectEndTime = C.postRedirectStartTime =
        sW(A.crossOriginIsolatedCapability)),
      C.redirectStartTime === 0)
    )
      C.redirectStartTime = C.startTime;
    return B.urlList.push(E), Fn(B, I), L6(A, !0);
  }
  async function V6(A, Q = !1, B = !1) {
    let I = A.request,
      E = null,
      C = null,
      g = null,
      F = null,
      D = !1;
    if (I.window === "no-window" && I.redirect === "error") (E = A), (C = I);
    else (C = ei(I)), (E = { ...A }), (E.request = C);
    let J =
        I.credentials === "include" ||
        (I.credentials === "same-origin" && I.responseTainting === "basic"),
      Y = C.body ? C.body.length : null,
      N = null;
    if (C.body == null && ["POST", "PUT"].includes(C.method)) N = "0";
    if (Y != null) N = nW(`${Y}`);
    if (N != null) C.headersList.append("content-length", N);
    if (Y != null && C.keepalive);
    if (C.referrer instanceof URL)
      C.headersList.append("referer", nW(C.referrer.href));
    if ((Cn(C), Yn(C), !C.headersList.contains("user-agent")))
      C.headersList.append(
        "user-agent",
        typeof esbuildDetection > "u" ? "undici" : "node",
      );
    if (
      C.cache === "default" &&
      (C.headersList.contains("if-modified-since") ||
        C.headersList.contains("if-none-match") ||
        C.headersList.contains("if-unmodified-since") ||
        C.headersList.contains("if-match") ||
        C.headersList.contains("if-range"))
    )
      C.cache = "no-store";
    if (
      C.cache === "no-cache" &&
      !C.preventNoCacheCacheControlHeaderModification &&
      !C.headersList.contains("cache-control")
    )
      C.headersList.append("cache-control", "max-age=0");
    if (C.cache === "no-store" || C.cache === "reload") {
      if (!C.headersList.contains("pragma"))
        C.headersList.append("pragma", "no-cache");
      if (!C.headersList.contains("cache-control"))
        C.headersList.append("cache-control", "no-cache");
    }
    if (C.headersList.contains("range"))
      C.headersList.append("accept-encoding", "identity");
    if (!C.headersList.contains("accept-encoding"))
      if (Mn(dI(C)))
        C.headersList.append("accept-encoding", "br, gzip, deflate");
      else C.headersList.append("accept-encoding", "gzip, deflate");
    if ((C.headersList.delete("host"), F == null)) C.cache = "no-store";
    if (C.mode !== "no-store" && C.mode !== "reload");
    if (g == null) {
      if (C.mode === "only-if-cached") return uA("only if cached");
      let W = await mn(E, J, B);
      if (!Rn.has(C.method) && W.status >= 200 && W.status <= 399);
      if (D && W.status === 304);
      if (g == null) g = W;
    }
    if (((g.urlList = [...C.urlList]), C.headersList.contains("range")))
      g.rangeRequested = !0;
    if (((g.requestIncludesCredentials = J), g.status === 407)) {
      if (I.window === "no-window") return uA();
      if (d0(A)) return SY(A);
      return uA("proxy authentication required");
    }
    if (g.status === 421 && !B && (I.body == null || I.body.source != null)) {
      if (d0(A)) return SY(A);
      A.controller.connection.destroy(), (g = await V6(A, Q, !0));
    }
    return g;
  }
  async function mn(A, Q = !1, B = !1) {
    c0(!A.controller.connection || A.controller.connection.destroyed),
      (A.controller.connection = {
        abort: null,
        destroyed: !1,
        destroy(M) {
          if (!this.destroyed)
            (this.destroyed = !0),
              this.abort?.(
                M ?? new dY("The operation was aborted.", "AbortError"),
              );
        },
      });
    let I = A.request,
      E = null,
      C = A.timingInfo;
    if (!0) I.cache = "no-store";
    let F = B ? "yes" : "no";
    if (I.mode === "websocket");
    let D = null;
    if (I.body == null && A.processRequestEndOfBody)
      queueMicrotask(() => A.processRequestEndOfBody());
    else if (I.body != null) {
      let M = async function* (q) {
          if (d0(A)) return;
          yield q, A.processRequestBodyChunkLength?.(q.byteLength);
        },
        L = () => {
          if (d0(A)) return;
          if (A.processRequestEndOfBody) A.processRequestEndOfBody();
        },
        H = (q) => {
          if (d0(A)) return;
          if (q.name === "AbortError") A.controller.abort();
          else A.controller.terminate(q);
        };
      D = (async function* () {
        try {
          for await (let q of I.body.stream) yield* M(q);
          L();
        } catch (q) {
          H(q);
        }
      })();
    }
    try {
      let {
        body: M,
        status: L,
        statusText: H,
        headersList: q,
        socket: O,
      } = await X({ body: D });
      if (O) E = bY({ status: L, statusText: H, headersList: q, socket: O });
      else {
        let f = M[Symbol.asyncIterator]();
        (A.controller.next = () => f.next()),
          (E = bY({ status: L, statusText: H, headersList: q }));
      }
    } catch (M) {
      if (M.name === "AbortError")
        return A.controller.connection.destroy(), SY(A, M);
      return uA(M);
    }
    let J = () => {
        A.controller.resume();
      },
      Y = (M) => {
        A.controller.abort(M);
      };
    if (!uW) uW = $("stream/web").ReadableStream;
    let N = new uW(
      {
        async start(M) {
          A.controller.controller = M;
        },
        async pull(M) {
          await J(M);
        },
        async cancel(M) {
          await Y(M);
        },
      },
      {
        highWaterMark: 0,
        size() {
          return 1;
        },
      },
    );
    (E.body = { stream: N }),
      A.controller.on("terminated", W),
      (A.controller.resume = async () => {
        while (!0) {
          let M, L;
          try {
            let { done: H, value: q } = await A.controller.next();
            if (J6(A)) break;
            M = H ? void 0 : q;
          } catch (H) {
            if (A.controller.ended && !C.encodedBodySize) M = void 0;
            else (M = H), (L = !0);
          }
          if (M === void 0) {
            Xn(A.controller.controller), Sn(A, E);
            return;
          }
          if (((C.decodedBodySize += M?.byteLength ?? 0), L)) {
            A.controller.terminate(M);
            return;
          }
          if ((A.controller.controller.enqueue(new Uint8Array(M)), On(N))) {
            A.controller.terminate();
            return;
          }
          if (!A.controller.controller.desiredSize) return;
        }
      });
    function W(M) {
      if (J6(A)) {
        if (((E.aborted = !0), cY(N)))
          A.controller.controller.error(A.controller.serializedAbortReason);
      } else if (cY(N))
        A.controller.controller.error(
          TypeError("terminated", { cause: Zn(M) ? M : void 0 }),
        );
      A.controller.connection.destroy();
    }
    return E;
    async function X({ body: M }) {
      let L = dI(I),
        H = A.controller.dispatcher;
      return new Promise((q, O) =>
        H.dispatch(
          {
            path: L.pathname + L.search,
            origin: L.origin,
            method: I.method,
            body: A.controller.dispatcher.isMockActive
              ? I.body && (I.body.source || I.body.stream)
              : M,
            headers: I.headersList.entries,
            maxRedirections: 0,
            upgrade: I.mode === "websocket" ? "websocket" : void 0,
          },
          {
            body: null,
            abort: null,
            onConnect(f) {
              let { connection: S } = A.controller;
              if (S.destroyed)
                f(new dY("The operation was aborted.", "AbortError"));
              else A.controller.on("terminated", f), (this.abort = S.abort = f);
            },
            onHeaders(f, S, r, t) {
              if (f < 200) return;
              let IA = [],
                zA = "",
                DA = new Y6();
              if (Array.isArray(S))
                for (let EA = 0; EA < S.length; EA += 2) {
                  let RA = S[EA + 0].toString("latin1"),
                    CQ = S[EA + 1].toString("latin1");
                  if (RA.toLowerCase() === "content-encoding")
                    IA = CQ.toLowerCase()
                      .split(",")
                      .map((ZB) => ZB.trim());
                  else if (RA.toLowerCase() === "location") zA = CQ;
                  DA[m0].append(RA, CQ);
                }
              else {
                let EA = Object.keys(S);
                for (let RA of EA) {
                  let CQ = S[RA];
                  if (RA.toLowerCase() === "content-encoding")
                    IA = CQ.toLowerCase()
                      .split(",")
                      .map((ZB) => ZB.trim())
                      .reverse();
                  else if (RA.toLowerCase() === "location") zA = CQ;
                  DA[m0].append(RA, CQ);
                }
              }
              this.body = new Kn({ read: r });
              let MA = [],
                LA = I.redirect === "follow" && zA && Z6.has(f);
              if (
                I.method !== "HEAD" &&
                I.method !== "CONNECT" &&
                !X6.includes(f) &&
                !LA
              )
                for (let EA of IA)
                  if (EA === "x-gzip" || EA === "gzip")
                    MA.push(
                      wF.createGunzip({
                        flush: wF.constants.Z_SYNC_FLUSH,
                        finishFlush: wF.constants.Z_SYNC_FLUSH,
                      }),
                    );
                  else if (EA === "deflate") MA.push(wF.createInflate());
                  else if (EA === "br") MA.push(wF.createBrotliDecompress());
                  else {
                    MA.length = 0;
                    break;
                  }
              return (
                q({
                  status: f,
                  statusText: t,
                  headersList: DA[m0],
                  body: MA.length
                    ? zn(this.body, ...MA, () => {})
                    : this.body.on("error", () => {}),
                }),
                !0
              );
            },
            onData(f) {
              if (A.controller.dump) return;
              let S = f;
              return (C.encodedBodySize += S.byteLength), this.body.push(S);
            },
            onComplete() {
              if (this.abort) A.controller.off("terminated", this.abort);
              (A.controller.ended = !0), this.body.push(null);
            },
            onError(f) {
              if (this.abort) A.controller.off("terminated", this.abort);
              this.body?.destroy(f), A.controller.terminate(f), O(f);
            },
            onUpgrade(f, S, r) {
              if (f !== 101) return;
              let t = new Y6();
              for (let IA = 0; IA < S.length; IA += 2) {
                let zA = S[IA + 0].toString("latin1"),
                  DA = S[IA + 1].toString("latin1");
                t[m0].append(zA, DA);
              }
              return (
                q({
                  status: f,
                  statusText: vn[f],
                  headersList: t[m0],
                  socket: r,
                }),
                !0
              );
            },
          },
        ),
      );
    }
  }
  $6.exports = {
    fetch: _n,
    Fetch: tW,
    fetching: M6,
    finalizeAndReportTiming: w6,
  };
});
var eW = Z((v3A, H6) => {
  H6.exports = {
    kState: Symbol("FileReader state"),
    kResult: Symbol("FileReader result"),
    kError: Symbol("FileReader error"),
    kLastProgressEventFired: Symbol(
      "FileReader last progress event fired timestamp",
    ),
    kEvents: Symbol("FileReader events"),
    kAborted: Symbol("FileReader aborted"),
  };
});
var z6 = Z((P3A, K6) => {
  var { webidl: uB } = EB(),
    lY = Symbol("ProgressEvent state");
  class MF extends Event {
    constructor(A, Q = {}) {
      (A = uB.converters.DOMString(A)),
        (Q = uB.converters.ProgressEventInit(Q ?? {}));
      super(A, Q);
      this[lY] = {
        lengthComputable: Q.lengthComputable,
        loaded: Q.loaded,
        total: Q.total,
      };
    }
    get lengthComputable() {
      return uB.brandCheck(this, MF), this[lY].lengthComputable;
    }
    get loaded() {
      return uB.brandCheck(this, MF), this[lY].loaded;
    }
    get total() {
      return uB.brandCheck(this, MF), this[lY].total;
    }
  }
  uB.converters.ProgressEventInit = uB.dictionaryConverter([
    {
      key: "lengthComputable",
      converter: uB.converters.boolean,
      defaultValue: !1,
    },
    {
      key: "loaded",
      converter: uB.converters["unsigned long long"],
      defaultValue: 0,
    },
    {
      key: "total",
      converter: uB.converters["unsigned long long"],
      defaultValue: 0,
    },
    { key: "bubbles", converter: uB.converters.boolean, defaultValue: !1 },
    { key: "cancelable", converter: uB.converters.boolean, defaultValue: !1 },
    { key: "composed", converter: uB.converters.boolean, defaultValue: !1 },
  ]);
  K6.exports = { ProgressEvent: MF };
});
var O6 = Z((_3A, T6) => {
  function dn(A) {
    if (!A) return "failure";
    switch (A.trim().toLowerCase()) {
      case "unicode-1-1-utf-8":
      case "unicode11utf8":
      case "unicode20utf8":
      case "utf-8":
      case "utf8":
      case "x-unicode20utf8":
        return "UTF-8";
      case "866":
      case "cp866":
      case "csibm866":
      case "ibm866":
        return "IBM866";
      case "csisolatin2":
      case "iso-8859-2":
      case "iso-ir-101":
      case "iso8859-2":
      case "iso88592":
      case "iso_8859-2":
      case "iso_8859-2:1987":
      case "l2":
      case "latin2":
        return "ISO-8859-2";
      case "csisolatin3":
      case "iso-8859-3":
      case "iso-ir-109":
      case "iso8859-3":
      case "iso88593":
      case "iso_8859-3":
      case "iso_8859-3:1988":
      case "l3":
      case "latin3":
        return "ISO-8859-3";
      case "csisolatin4":
      case "iso-8859-4":
      case "iso-ir-110":
      case "iso8859-4":
      case "iso88594":
      case "iso_8859-4":
      case "iso_8859-4:1988":
      case "l4":
      case "latin4":
        return "ISO-8859-4";
      case "csisolatincyrillic":
      case "cyrillic":
      case "iso-8859-5":
      case "iso-ir-144":
      case "iso8859-5":
      case "iso88595":
      case "iso_8859-5":
      case "iso_8859-5:1988":
        return "ISO-8859-5";
      case "arabic":
      case "asmo-708":
      case "csiso88596e":
      case "csiso88596i":
      case "csisolatinarabic":
      case "ecma-114":
      case "iso-8859-6":
      case "iso-8859-6-e":
      case "iso-8859-6-i":
      case "iso-ir-127":
      case "iso8859-6":
      case "iso88596":
      case "iso_8859-6":
      case "iso_8859-6:1987":
        return "ISO-8859-6";
      case "csisolatingreek":
      case "ecma-118":
      case "elot_928":
      case "greek":
      case "greek8":
      case "iso-8859-7":
      case "iso-ir-126":
      case "iso8859-7":
      case "iso88597":
      case "iso_8859-7":
      case "iso_8859-7:1987":
      case "sun_eu_greek":
        return "ISO-8859-7";
      case "csiso88598e":
      case "csisolatinhebrew":
      case "hebrew":
      case "iso-8859-8":
      case "iso-8859-8-e":
      case "iso-ir-138":
      case "iso8859-8":
      case "iso88598":
      case "iso_8859-8":
      case "iso_8859-8:1988":
      case "visual":
        return "ISO-8859-8";
      case "csiso88598i":
      case "iso-8859-8-i":
      case "logical":
        return "ISO-8859-8-I";
      case "csisolatin6":
      case "iso-8859-10":
      case "iso-ir-157":
      case "iso8859-10":
      case "iso885910":
      case "l6":
      case "latin6":
        return "ISO-8859-10";
      case "iso-8859-13":
      case "iso8859-13":
      case "iso885913":
        return "ISO-8859-13";
      case "iso-8859-14":
      case "iso8859-14":
      case "iso885914":
        return "ISO-8859-14";
      case "csisolatin9":
      case "iso-8859-15":
      case "iso8859-15":
      case "iso885915":
      case "iso_8859-15":
      case "l9":
        return "ISO-8859-15";
      case "iso-8859-16":
        return "ISO-8859-16";
      case "cskoi8r":
      case "koi":
      case "koi8":
      case "koi8-r":
      case "koi8_r":
        return "KOI8-R";
      case "koi8-ru":
      case "koi8-u":
        return "KOI8-U";
      case "csmacintosh":
      case "mac":
      case "macintosh":
      case "x-mac-roman":
        return "macintosh";
      case "iso-8859-11":
      case "iso8859-11":
      case "iso885911":
      case "tis-620":
      case "windows-874":
        return "windows-874";
      case "cp1250":
      case "windows-1250":
      case "x-cp1250":
        return "windows-1250";
      case "cp1251":
      case "windows-1251":
      case "x-cp1251":
        return "windows-1251";
      case "ansi_x3.4-1968":
      case "ascii":
      case "cp1252":
      case "cp819":
      case "csisolatin1":
      case "ibm819":
      case "iso-8859-1":
      case "iso-ir-100":
      case "iso8859-1":
      case "iso88591":
      case "iso_8859-1":
      case "iso_8859-1:1987":
      case "l1":
      case "latin1":
      case "us-ascii":
      case "windows-1252":
      case "x-cp1252":
        return "windows-1252";
      case "cp1253":
      case "windows-1253":
      case "x-cp1253":
        return "windows-1253";
      case "cp1254":
      case "csisolatin5":
      case "iso-8859-9":
      case "iso-ir-148":
      case "iso8859-9":
      case "iso88599":
      case "iso_8859-9":
      case "iso_8859-9:1989":
      case "l5":
      case "latin5":
      case "windows-1254":
      case "x-cp1254":
        return "windows-1254";
      case "cp1255":
      case "windows-1255":
      case "x-cp1255":
        return "windows-1255";
      case "cp1256":
      case "windows-1256":
      case "x-cp1256":
        return "windows-1256";
      case "cp1257":
      case "windows-1257":
      case "x-cp1257":
        return "windows-1257";
      case "cp1258":
      case "windows-1258":
      case "x-cp1258":
        return "windows-1258";
      case "x-mac-cyrillic":
      case "x-mac-ukrainian":
        return "x-mac-cyrillic";
      case "chinese":
      case "csgb2312":
      case "csiso58gb231280":
      case "gb2312":
      case "gb_2312":
      case "gb_2312-80":
      case "gbk":
      case "iso-ir-58":
      case "x-gbk":
        return "GBK";
      case "gb18030":
        return "gb18030";
      case "big5":
      case "big5-hkscs":
      case "cn-big5":
      case "csbig5":
      case "x-x-big5":
        return "Big5";
      case "cseucpkdfmtjapanese":
      case "euc-jp":
      case "x-euc-jp":
        return "EUC-JP";
      case "csiso2022jp":
      case "iso-2022-jp":
        return "ISO-2022-JP";
      case "csshiftjis":
      case "ms932":
      case "ms_kanji":
      case "shift-jis":
      case "shift_jis":
      case "sjis":
      case "windows-31j":
      case "x-sjis":
        return "Shift_JIS";
      case "cseuckr":
      case "csksc56011987":
      case "euc-kr":
      case "iso-ir-149":
      case "korean":
      case "ks_c_5601-1987":
      case "ks_c_5601-1989":
      case "ksc5601":
      case "ksc_5601":
      case "windows-949":
        return "EUC-KR";
      case "csiso2022kr":
      case "hz-gb-2312":
      case "iso-2022-cn":
      case "iso-2022-cn-ext":
      case "iso-2022-kr":
      case "replacement":
        return "replacement";
      case "unicodefffe":
      case "utf-16be":
        return "UTF-16BE";
      case "csunicode":
      case "iso-10646-ucs-2":
      case "ucs-2":
      case "unicode":
      case "unicodefeff":
      case "utf-16":
      case "utf-16le":
        return "UTF-16LE";
      case "x-user-defined":
        return "x-user-defined";
      default:
        return "failure";
    }
  }
  T6.exports = { getEncoding: dn };
});
var P6 = Z((y3A, v6) => {
  var {
      kState: u0,
      kError: AZ,
      kResult: q6,
      kAborted: LF,
      kLastProgressEventFired: QZ,
    } = eW(),
    { ProgressEvent: cn } = z6(),
    { getEncoding: j6 } = O6(),
    { DOMException: un } = yE(),
    { serializeAMimeType: ln, parseMIMEType: f6 } = $I(),
    { types: pn } = $("util"),
    { StringDecoder: h6 } = $("string_decoder"),
    { btoa: k6 } = $("buffer"),
    nn = { enumerable: !0, writable: !1, configurable: !1 };
  function an(A, Q, B, I) {
    if (A[u0] === "loading") throw new un("Invalid state", "InvalidStateError");
    (A[u0] = "loading"), (A[q6] = null), (A[AZ] = null);
    let C = Q.stream().getReader(),
      g = [],
      F = C.read(),
      D = !0;
    (async () => {
      while (!A[LF])
        try {
          let { done: J, value: Y } = await F;
          if (D && !A[LF])
            queueMicrotask(() => {
              pE("loadstart", A);
            });
          if (((D = !1), !J && pn.isUint8Array(Y))) {
            if (
              (g.push(Y),
              (A[QZ] === void 0 || Date.now() - A[QZ] >= 50) && !A[LF])
            )
              (A[QZ] = Date.now()),
                queueMicrotask(() => {
                  pE("progress", A);
                });
            F = C.read();
          } else if (J) {
            queueMicrotask(() => {
              A[u0] = "done";
              try {
                let N = on(g, B, Q.type, I);
                if (A[LF]) return;
                (A[q6] = N), pE("load", A);
              } catch (N) {
                (A[AZ] = N), pE("error", A);
              }
              if (A[u0] !== "loading") pE("loadend", A);
            });
            break;
          }
        } catch (J) {
          if (A[LF]) return;
          queueMicrotask(() => {
            if (
              ((A[u0] = "done"),
              (A[AZ] = J),
              pE("error", A),
              A[u0] !== "loading")
            )
              pE("loadend", A);
          });
          break;
        }
    })();
  }
  function pE(A, Q) {
    let B = new cn(A, { bubbles: !1, cancelable: !1 });
    Q.dispatchEvent(B);
  }
  function on(A, Q, B, I) {
    switch (Q) {
      case "DataURL": {
        let E = "data:",
          C = f6(B || "application/octet-stream");
        if (C !== "failure") E += ln(C);
        E += ";base64,";
        let g = new h6("latin1");
        for (let F of A) E += k6(g.write(F));
        return (E += k6(g.end())), E;
      }
      case "Text": {
        let E = "failure";
        if (I) E = j6(I);
        if (E === "failure" && B) {
          let C = f6(B);
          if (C !== "failure") E = j6(C.parameters.get("charset"));
        }
        if (E === "failure") E = "UTF-8";
        return sn(A, E);
      }
      case "ArrayBuffer":
        return x6(A).buffer;
      case "BinaryString": {
        let E = "",
          C = new h6("latin1");
        for (let g of A) E += C.write(g);
        return (E += C.end()), E;
      }
    }
  }
  function sn(A, Q) {
    let B = x6(A),
      I = rn(B),
      E = 0;
    if (I !== null) (Q = I), (E = I === "UTF-8" ? 3 : 2);
    let C = B.slice(E);
    return new TextDecoder(Q).decode(C);
  }
  function rn(A) {
    let [Q, B, I] = A;
    if (Q === 239 && B === 187 && I === 191) return "UTF-8";
    else if (Q === 254 && B === 255) return "UTF-16BE";
    else if (Q === 255 && B === 254) return "UTF-16LE";
    return null;
  }
  function x6(A) {
    let Q = A.reduce((I, E) => {
        return I + E.byteLength;
      }, 0),
      B = 0;
    return A.reduce((I, E) => {
      return I.set(E, B), (B += E.byteLength), I;
    }, new Uint8Array(Q));
  }
  v6.exports = {
    staticPropertyDescriptors: nn,
    readOperation: an,
    fireAProgressEvent: pE,
  };
});
var b6 = Z((S3A, S6) => {
  var {
      staticPropertyDescriptors: l0,
      readOperation: pY,
      fireAProgressEvent: _6,
    } = P6(),
    { kState: SC, kError: y6, kResult: iY, kEvents: TA, kAborted: tn } = eW(),
    { webidl: mA } = EB(),
    { kEnumerableProperty: RB } = HA();
  class yA extends EventTarget {
    constructor() {
      super();
      (this[SC] = "empty"),
        (this[iY] = null),
        (this[y6] = null),
        (this[TA] = {
          loadend: null,
          error: null,
          abort: null,
          load: null,
          progress: null,
          loadstart: null,
        });
    }
    readAsArrayBuffer(A) {
      mA.brandCheck(this, yA),
        mA.argumentLengthCheck(arguments, 1, {
          header: "FileReader.readAsArrayBuffer",
        }),
        (A = mA.converters.Blob(A, { strict: !1 })),
        pY(this, A, "ArrayBuffer");
    }
    readAsBinaryString(A) {
      mA.brandCheck(this, yA),
        mA.argumentLengthCheck(arguments, 1, {
          header: "FileReader.readAsBinaryString",
        }),
        (A = mA.converters.Blob(A, { strict: !1 })),
        pY(this, A, "BinaryString");
    }
    readAsText(A, Q = void 0) {
      if (
        (mA.brandCheck(this, yA),
        mA.argumentLengthCheck(arguments, 1, {
          header: "FileReader.readAsText",
        }),
        (A = mA.converters.Blob(A, { strict: !1 })),
        Q !== void 0)
      )
        Q = mA.converters.DOMString(Q);
      pY(this, A, "Text", Q);
    }
    readAsDataURL(A) {
      mA.brandCheck(this, yA),
        mA.argumentLengthCheck(arguments, 1, {
          header: "FileReader.readAsDataURL",
        }),
        (A = mA.converters.Blob(A, { strict: !1 })),
        pY(this, A, "DataURL");
    }
    abort() {
      if (this[SC] === "empty" || this[SC] === "done") {
        this[iY] = null;
        return;
      }
      if (this[SC] === "loading") (this[SC] = "done"), (this[iY] = null);
      if (((this[tn] = !0), _6("abort", this), this[SC] !== "loading"))
        _6("loadend", this);
    }
    get readyState() {
      switch ((mA.brandCheck(this, yA), this[SC])) {
        case "empty":
          return this.EMPTY;
        case "loading":
          return this.LOADING;
        case "done":
          return this.DONE;
      }
    }
    get result() {
      return mA.brandCheck(this, yA), this[iY];
    }
    get error() {
      return mA.brandCheck(this, yA), this[y6];
    }
    get onloadend() {
      return mA.brandCheck(this, yA), this[TA].loadend;
    }
    set onloadend(A) {
      if ((mA.brandCheck(this, yA), this[TA].loadend))
        this.removeEventListener("loadend", this[TA].loadend);
      if (typeof A === "function")
        (this[TA].loadend = A), this.addEventListener("loadend", A);
      else this[TA].loadend = null;
    }
    get onerror() {
      return mA.brandCheck(this, yA), this[TA].error;
    }
    set onerror(A) {
      if ((mA.brandCheck(this, yA), this[TA].error))
        this.removeEventListener("error", this[TA].error);
      if (typeof A === "function")
        (this[TA].error = A), this.addEventListener("error", A);
      else this[TA].error = null;
    }
    get onloadstart() {
      return mA.brandCheck(this, yA), this[TA].loadstart;
    }
    set onloadstart(A) {
      if ((mA.brandCheck(this, yA), this[TA].loadstart))
        this.removeEventListener("loadstart", this[TA].loadstart);
      if (typeof A === "function")
        (this[TA].loadstart = A), this.addEventListener("loadstart", A);
      else this[TA].loadstart = null;
    }
    get onprogress() {
      return mA.brandCheck(this, yA), this[TA].progress;
    }
    set onprogress(A) {
      if ((mA.brandCheck(this, yA), this[TA].progress))
        this.removeEventListener("progress", this[TA].progress);
      if (typeof A === "function")
        (this[TA].progress = A), this.addEventListener("progress", A);
      else this[TA].progress = null;
    }
    get onload() {
      return mA.brandCheck(this, yA), this[TA].load;
    }
    set onload(A) {
      if ((mA.brandCheck(this, yA), this[TA].load))
        this.removeEventListener("load", this[TA].load);
      if (typeof A === "function")
        (this[TA].load = A), this.addEventListener("load", A);
      else this[TA].load = null;
    }
    get onabort() {
      return mA.brandCheck(this, yA), this[TA].abort;
    }
    set onabort(A) {
      if ((mA.brandCheck(this, yA), this[TA].abort))
        this.removeEventListener("abort", this[TA].abort);
      if (typeof A === "function")
        (this[TA].abort = A), this.addEventListener("abort", A);
      else this[TA].abort = null;
    }
  }
  yA.EMPTY = yA.prototype.EMPTY = 0;
  yA.LOADING = yA.prototype.LOADING = 1;
  yA.DONE = yA.prototype.DONE = 2;
  Object.defineProperties(yA.prototype, {
    EMPTY: l0,
    LOADING: l0,
    DONE: l0,
    readAsArrayBuffer: RB,
    readAsBinaryString: RB,
    readAsText: RB,
    readAsDataURL: RB,
    abort: RB,
    readyState: RB,
    result: RB,
    error: RB,
    onloadstart: RB,
    onprogress: RB,
    onload: RB,
    onabort: RB,
    onerror: RB,
    onloadend: RB,
    [Symbol.toStringTag]: {
      value: "FileReader",
      writable: !1,
      enumerable: !1,
      configurable: !0,
    },
  });
  Object.defineProperties(yA, { EMPTY: l0, LOADING: l0, DONE: l0 });
  S6.exports = { FileReader: yA };
});
var nY = Z((b3A, m6) => {
  m6.exports = { kConstruct: aA().kConstruct };
});
var u6 = Z((m3A, c6) => {
  var en = $("assert"),
    { URLSerializer: d6 } = $I(),
    { isValidHeaderName: Aa } = AI();
  function Qa(A, Q, B = !1) {
    let I = d6(A, B),
      E = d6(Q, B);
    return I === E;
  }
  function Ba(A) {
    en(A !== null);
    let Q = [];
    for (let B of A.split(",")) {
      if (((B = B.trim()), !B.length)) continue;
      else if (!Aa(B)) continue;
      Q.push(B);
    }
    return Q;
  }
  c6.exports = { urlEquals: Qa, fieldValues: Ba };
});
var o6 = Z((d3A, a6) => {
  var { kConstruct: Ia } = nY(),
    { urlEquals: Ea, fieldValues: BZ } = u6(),
    { kEnumerableProperty: bC, isDisturbed: Ca } = HA(),
    { kHeadersList: l6 } = aA(),
    { webidl: AA } = EB(),
    { Response: i6, cloneResponse: ga } = kY(),
    { Request: cI } = XF(),
    { kState: JB, kHeaders: aY, kGuard: p6, kRealm: Fa } = CE(),
    { fetching: Da } = uY(),
    {
      urlIsHttpHttpsScheme: oY,
      createDeferredPromise: p0,
      readAllBytes: Ya,
    } = AI(),
    IZ = $("assert"),
    { getGlobalDispatcher: Ja } = y0();
  class uI {
    #A;
    constructor() {
      if (arguments[0] !== Ia) AA.illegalConstructor();
      this.#A = arguments[1];
    }
    async match(A, Q = {}) {
      AA.brandCheck(this, uI),
        AA.argumentLengthCheck(arguments, 1, { header: "Cache.match" }),
        (A = AA.converters.RequestInfo(A)),
        (Q = AA.converters.CacheQueryOptions(Q));
      let B = await this.matchAll(A, Q);
      if (B.length === 0) return;
      return B[0];
    }
    async matchAll(A = void 0, Q = {}) {
      if ((AA.brandCheck(this, uI), A !== void 0))
        A = AA.converters.RequestInfo(A);
      Q = AA.converters.CacheQueryOptions(Q);
      let B = null;
      if (A !== void 0) {
        if (A instanceof cI) {
          if (((B = A[JB]), B.method !== "GET" && !Q.ignoreMethod)) return [];
        } else if (typeof A === "string") B = new cI(A)[JB];
      }
      let I = [];
      if (A === void 0) for (let C of this.#A) I.push(C[1]);
      else {
        let C = this.#I(B, Q);
        for (let g of C) I.push(g[1]);
      }
      let E = [];
      for (let C of I) {
        let g = new i6(C.body?.source ?? null),
          F = g[JB].body;
        (g[JB] = C),
          (g[JB].body = F),
          (g[aY][l6] = C.headersList),
          (g[aY][p6] = "immutable"),
          E.push(g);
      }
      return Object.freeze(E);
    }
    async add(A) {
      AA.brandCheck(this, uI),
        AA.argumentLengthCheck(arguments, 1, { header: "Cache.add" }),
        (A = AA.converters.RequestInfo(A));
      let Q = [A];
      return await this.addAll(Q);
    }
    async addAll(A) {
      AA.brandCheck(this, uI),
        AA.argumentLengthCheck(arguments, 1, { header: "Cache.addAll" }),
        (A = AA.converters["sequence<RequestInfo>"](A));
      let Q = [],
        B = [];
      for (let Y of A) {
        if (typeof Y === "string") continue;
        let N = Y[JB];
        if (!oY(N.url) || N.method !== "GET")
          throw AA.errors.exception({
            header: "Cache.addAll",
            message: "Expected http/s scheme when method is not GET.",
          });
      }
      let I = [];
      for (let Y of A) {
        let N = new cI(Y)[JB];
        if (!oY(N.url))
          throw AA.errors.exception({
            header: "Cache.addAll",
            message: "Expected http/s scheme.",
          });
        (N.initiator = "fetch"), (N.destination = "subresource"), B.push(N);
        let W = p0();
        I.push(
          Da({
            request: N,
            dispatcher: Ja(),
            processResponse(X) {
              if (
                X.type === "error" ||
                X.status === 206 ||
                X.status < 200 ||
                X.status > 299
              )
                W.reject(
                  AA.errors.exception({
                    header: "Cache.addAll",
                    message:
                      "Received an invalid status code or the request failed.",
                  }),
                );
              else if (X.headersList.contains("vary")) {
                let M = BZ(X.headersList.get("vary"));
                for (let L of M)
                  if (L === "*") {
                    W.reject(
                      AA.errors.exception({
                        header: "Cache.addAll",
                        message: "invalid vary field value",
                      }),
                    );
                    for (let H of I) H.abort();
                    return;
                  }
              }
            },
            processResponseEndOfBody(X) {
              if (X.aborted) {
                W.reject(new DOMException("aborted", "AbortError"));
                return;
              }
              W.resolve(X);
            },
          }),
        ),
          Q.push(W.promise);
      }
      let C = await Promise.all(Q),
        g = [],
        F = 0;
      for (let Y of C) {
        let N = { type: "put", request: B[F], response: Y };
        g.push(N), F++;
      }
      let D = p0(),
        J = null;
      try {
        this.#B(g);
      } catch (Y) {
        J = Y;
      }
      return (
        queueMicrotask(() => {
          if (J === null) D.resolve(void 0);
          else D.reject(J);
        }),
        D.promise
      );
    }
    async put(A, Q) {
      AA.brandCheck(this, uI),
        AA.argumentLengthCheck(arguments, 2, { header: "Cache.put" }),
        (A = AA.converters.RequestInfo(A)),
        (Q = AA.converters.Response(Q));
      let B = null;
      if (A instanceof cI) B = A[JB];
      else B = new cI(A)[JB];
      if (!oY(B.url) || B.method !== "GET")
        throw AA.errors.exception({
          header: "Cache.put",
          message: "Expected an http/s scheme when method is not GET",
        });
      let I = Q[JB];
      if (I.status === 206)
        throw AA.errors.exception({
          header: "Cache.put",
          message: "Got 206 status",
        });
      if (I.headersList.contains("vary")) {
        let N = BZ(I.headersList.get("vary"));
        for (let W of N)
          if (W === "*")
            throw AA.errors.exception({
              header: "Cache.put",
              message: "Got * vary field value",
            });
      }
      if (I.body && (Ca(I.body.stream) || I.body.stream.locked))
        throw AA.errors.exception({
          header: "Cache.put",
          message: "Response body is locked or disturbed",
        });
      let E = ga(I),
        C = p0();
      if (I.body != null) {
        let W = I.body.stream.getReader();
        Ya(W).then(C.resolve, C.reject);
      } else C.resolve(void 0);
      let g = [],
        F = { type: "put", request: B, response: E };
      g.push(F);
      let D = await C.promise;
      if (E.body != null) E.body.source = D;
      let J = p0(),
        Y = null;
      try {
        this.#B(g);
      } catch (N) {
        Y = N;
      }
      return (
        queueMicrotask(() => {
          if (Y === null) J.resolve();
          else J.reject(Y);
        }),
        J.promise
      );
    }
    async delete(A, Q = {}) {
      AA.brandCheck(this, uI),
        AA.argumentLengthCheck(arguments, 1, { header: "Cache.delete" }),
        (A = AA.converters.RequestInfo(A)),
        (Q = AA.converters.CacheQueryOptions(Q));
      let B = null;
      if (A instanceof cI) {
        if (((B = A[JB]), B.method !== "GET" && !Q.ignoreMethod)) return !1;
      } else IZ(typeof A === "string"), (B = new cI(A)[JB]);
      let I = [],
        E = { type: "delete", request: B, options: Q };
      I.push(E);
      let C = p0(),
        g = null,
        F;
      try {
        F = this.#B(I);
      } catch (D) {
        g = D;
      }
      return (
        queueMicrotask(() => {
          if (g === null) C.resolve(!!F?.length);
          else C.reject(g);
        }),
        C.promise
      );
    }
    async keys(A = void 0, Q = {}) {
      if ((AA.brandCheck(this, uI), A !== void 0))
        A = AA.converters.RequestInfo(A);
      Q = AA.converters.CacheQueryOptions(Q);
      let B = null;
      if (A !== void 0) {
        if (A instanceof cI) {
          if (((B = A[JB]), B.method !== "GET" && !Q.ignoreMethod)) return [];
        } else if (typeof A === "string") B = new cI(A)[JB];
      }
      let I = p0(),
        E = [];
      if (A === void 0) for (let C of this.#A) E.push(C[0]);
      else {
        let C = this.#I(B, Q);
        for (let g of C) E.push(g[0]);
      }
      return (
        queueMicrotask(() => {
          let C = [];
          for (let g of E) {
            let F = new cI("https://a");
            (F[JB] = g),
              (F[aY][l6] = g.headersList),
              (F[aY][p6] = "immutable"),
              (F[Fa] = g.client),
              C.push(F);
          }
          I.resolve(Object.freeze(C));
        }),
        I.promise
      );
    }
    #B(A) {
      let Q = this.#A,
        B = [...Q],
        I = [],
        E = [];
      try {
        for (let C of A) {
          if (C.type !== "delete" && C.type !== "put")
            throw AA.errors.exception({
              header: "Cache.#batchCacheOperations",
              message: 'operation type does not match "delete" or "put"',
            });
          if (C.type === "delete" && C.response != null)
            throw AA.errors.exception({
              header: "Cache.#batchCacheOperations",
              message:
                "delete operation should not have an associated response",
            });
          if (this.#I(C.request, C.options, I).length)
            throw new DOMException("???", "InvalidStateError");
          let g;
          if (C.type === "delete") {
            if (((g = this.#I(C.request, C.options)), g.length === 0))
              return [];
            for (let F of g) {
              let D = Q.indexOf(F);
              IZ(D !== -1), Q.splice(D, 1);
            }
          } else if (C.type === "put") {
            if (C.response == null)
              throw AA.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "put operation should have an associated response",
              });
            let F = C.request;
            if (!oY(F.url))
              throw AA.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "expected http or https scheme",
              });
            if (F.method !== "GET")
              throw AA.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "not get method",
              });
            if (C.options != null)
              throw AA.errors.exception({
                header: "Cache.#batchCacheOperations",
                message: "options must not be defined",
              });
            g = this.#I(C.request);
            for (let D of g) {
              let J = Q.indexOf(D);
              IZ(J !== -1), Q.splice(J, 1);
            }
            Q.push([C.request, C.response]), I.push([C.request, C.response]);
          }
          E.push([C.request, C.response]);
        }
        return E;
      } catch (C) {
        throw ((this.#A.length = 0), (this.#A = B), C);
      }
    }
    #I(A, Q, B) {
      let I = [],
        E = B ?? this.#A;
      for (let C of E) {
        let [g, F] = C;
        if (this.#Q(A, g, F, Q)) I.push(C);
      }
      return I;
    }
    #Q(A, Q, B = null, I) {
      let E = new URL(A.url),
        C = new URL(Q.url);
      if (I?.ignoreSearch) (C.search = ""), (E.search = "");
      if (!Ea(E, C, !0)) return !1;
      if (B == null || I?.ignoreVary || !B.headersList.contains("vary"))
        return !0;
      let g = BZ(B.headersList.get("vary"));
      for (let F of g) {
        if (F === "*") return !1;
        let D = Q.headersList.get(F),
          J = A.headersList.get(F);
        if (D !== J) return !1;
      }
      return !0;
    }
  }
  Object.defineProperties(uI.prototype, {
    [Symbol.toStringTag]: { value: "Cache", configurable: !0 },
    match: bC,
    matchAll: bC,
    add: bC,
    addAll: bC,
    put: bC,
    delete: bC,
    keys: bC,
  });
  var n6 = [
    { key: "ignoreSearch", converter: AA.converters.boolean, defaultValue: !1 },
    { key: "ignoreMethod", converter: AA.converters.boolean, defaultValue: !1 },
    { key: "ignoreVary", converter: AA.converters.boolean, defaultValue: !1 },
  ];
  AA.converters.CacheQueryOptions = AA.dictionaryConverter(n6);
  AA.converters.MultiCacheQueryOptions = AA.dictionaryConverter([
    ...n6,
    { key: "cacheName", converter: AA.converters.DOMString },
  ]);
  AA.converters.Response = AA.interfaceConverter(i6);
  AA.converters["sequence<RequestInfo>"] = AA.sequenceConverter(
    AA.converters.RequestInfo,
  );
  a6.exports = { Cache: uI };
});
var r6 = Z((c3A, s6) => {
  var { kConstruct: RF } = nY(),
    { Cache: sY } = o6(),
    { webidl: NB } = EB(),
    { kEnumerableProperty: VF } = HA();
  class iE {
    #A = new Map();
    constructor() {
      if (arguments[0] !== RF) NB.illegalConstructor();
    }
    async match(A, Q = {}) {
      if (
        (NB.brandCheck(this, iE),
        NB.argumentLengthCheck(arguments, 1, { header: "CacheStorage.match" }),
        (A = NB.converters.RequestInfo(A)),
        (Q = NB.converters.MultiCacheQueryOptions(Q)),
        Q.cacheName != null)
      ) {
        if (this.#A.has(Q.cacheName)) {
          let B = this.#A.get(Q.cacheName);
          return await new sY(RF, B).match(A, Q);
        }
      } else
        for (let B of this.#A.values()) {
          let E = await new sY(RF, B).match(A, Q);
          if (E !== void 0) return E;
        }
    }
    async has(A) {
      return (
        NB.brandCheck(this, iE),
        NB.argumentLengthCheck(arguments, 1, { header: "CacheStorage.has" }),
        (A = NB.converters.DOMString(A)),
        this.#A.has(A)
      );
    }
    async open(A) {
      if (
        (NB.brandCheck(this, iE),
        NB.argumentLengthCheck(arguments, 1, { header: "CacheStorage.open" }),
        (A = NB.converters.DOMString(A)),
        this.#A.has(A))
      ) {
        let B = this.#A.get(A);
        return new sY(RF, B);
      }
      let Q = [];
      return this.#A.set(A, Q), new sY(RF, Q);
    }
    async delete(A) {
      return (
        NB.brandCheck(this, iE),
        NB.argumentLengthCheck(arguments, 1, { header: "CacheStorage.delete" }),
        (A = NB.converters.DOMString(A)),
        this.#A.delete(A)
      );
    }
    async keys() {
      return NB.brandCheck(this, iE), [...this.#A.keys()];
    }
  }
  Object.defineProperties(iE.prototype, {
    [Symbol.toStringTag]: { value: "CacheStorage", configurable: !0 },
    match: VF,
    has: VF,
    open: VF,
    delete: VF,
    keys: VF,
  });
  s6.exports = { CacheStorage: iE };
});
var e6 = Z((u3A, t6) => {
  t6.exports = { maxAttributeValueSize: 1024, maxNameValuePairSize: 4096 };
});
var EZ = Z((l3A, E7) => {
  function Na(A) {
    if (A.length === 0) return !1;
    for (let Q of A) {
      let B = Q.charCodeAt(0);
      if (B >= 0 || B <= 8 || B >= 10 || B <= 31 || B === 127) return !1;
    }
  }
  function A7(A) {
    for (let Q of A) {
      let B = Q.charCodeAt(0);
      if (
        B <= 32 ||
        B > 127 ||
        Q === "(" ||
        Q === ")" ||
        Q === ">" ||
        Q === "<" ||
        Q === "@" ||
        Q === "," ||
        Q === ";" ||
        Q === ":" ||
        Q === "\\" ||
        Q === '"' ||
        Q === "/" ||
        Q === "[" ||
        Q === "]" ||
        Q === "?" ||
        Q === "=" ||
        Q === "{" ||
        Q === "}"
      )
        throw Error("Invalid cookie name");
    }
  }
  function Q7(A) {
    for (let Q of A) {
      let B = Q.charCodeAt(0);
      if (B < 33 || B === 34 || B === 44 || B === 59 || B === 92 || B > 126)
        throw Error("Invalid header value");
    }
  }
  function B7(A) {
    for (let Q of A)
      if (Q.charCodeAt(0) < 33 || Q === ";") throw Error("Invalid cookie path");
  }
  function Ga(A) {
    if (A.startsWith("-") || A.endsWith(".") || A.endsWith("-"))
      throw Error("Invalid cookie domain");
  }
  function I7(A) {
    if (typeof A === "number") A = new Date(A);
    let Q = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"],
      B = [
        "Jan",
        "Feb",
        "Mar",
        "Apr",
        "May",
        "Jun",
        "Jul",
        "Aug",
        "Sep",
        "Oct",
        "Nov",
        "Dec",
      ],
      I = Q[A.getUTCDay()],
      E = A.getUTCDate().toString().padStart(2, "0"),
      C = B[A.getUTCMonth()],
      g = A.getUTCFullYear(),
      F = A.getUTCHours().toString().padStart(2, "0"),
      D = A.getUTCMinutes().toString().padStart(2, "0"),
      J = A.getUTCSeconds().toString().padStart(2, "0");
    return `${I}, ${E} ${C} ${g} ${F}:${D}:${J} GMT`;
  }
  function Ua(A) {
    if (A < 0) throw Error("Invalid cookie max-age");
  }
  function Wa(A) {
    if (A.name.length === 0) return null;
    A7(A.name), Q7(A.value);
    let Q = [`${A.name}=${A.value}`];
    if (A.name.startsWith("__Secure-")) A.secure = !0;
    if (A.name.startsWith("__Host-"))
      (A.secure = !0), (A.domain = null), (A.path = "/");
    if (A.secure) Q.push("Secure");
    if (A.httpOnly) Q.push("HttpOnly");
    if (typeof A.maxAge === "number")
      Ua(A.maxAge), Q.push(`Max-Age=${A.maxAge}`);
    if (A.domain) Ga(A.domain), Q.push(`Domain=${A.domain}`);
    if (A.path) B7(A.path), Q.push(`Path=${A.path}`);
    if (A.expires && A.expires.toString() !== "Invalid Date")
      Q.push(`Expires=${I7(A.expires)}`);
    if (A.sameSite) Q.push(`SameSite=${A.sameSite}`);
    for (let B of A.unparsed) {
      if (!B.includes("=")) throw Error("Invalid unparsed");
      let [I, ...E] = B.split("=");
      Q.push(`${I.trim()}=${E.join("=")}`);
    }
    return Q.join("; ");
  }
  E7.exports = {
    isCTLExcludingHtab: Na,
    validateCookieName: A7,
    validateCookiePath: B7,
    validateCookieValue: Q7,
    toIMFDate: I7,
    stringify: Wa,
  };
});
var g7 = Z((p3A, C7) => {
  var { maxNameValuePairSize: Za, maxAttributeValueSize: Xa } = e6(),
    { isCTLExcludingHtab: wa } = EZ(),
    { collectASequenceOfCodePointsFast: rY } = $I(),
    Ma = $("assert");
  function La(A) {
    if (wa(A)) return null;
    let Q = "",
      B = "",
      I = "",
      E = "";
    if (A.includes(";")) {
      let C = { position: 0 };
      (Q = rY(";", A, C)), (B = A.slice(C.position));
    } else Q = A;
    if (!Q.includes("=")) E = Q;
    else {
      let C = { position: 0 };
      (I = rY("=", Q, C)), (E = Q.slice(C.position + 1));
    }
    if (((I = I.trim()), (E = E.trim()), I.length + E.length > Za)) return null;
    return { name: I, value: E, ...i0(B) };
  }
  function i0(A, Q = {}) {
    if (A.length === 0) return Q;
    Ma(A[0] === ";"), (A = A.slice(1));
    let B = "";
    if (A.includes(";"))
      (B = rY(";", A, { position: 0 })), (A = A.slice(B.length));
    else (B = A), (A = "");
    let I = "",
      E = "";
    if (B.includes("=")) {
      let g = { position: 0 };
      (I = rY("=", B, g)), (E = B.slice(g.position + 1));
    } else I = B;
    if (((I = I.trim()), (E = E.trim()), E.length > Xa)) return i0(A, Q);
    let C = I.toLowerCase();
    if (C === "expires") {
      let g = new Date(E);
      Q.expires = g;
    } else if (C === "max-age") {
      let g = E.charCodeAt(0);
      if ((g < 48 || g > 57) && E[0] !== "-") return i0(A, Q);
      if (!/^\d+$/.test(E)) return i0(A, Q);
      let F = Number(E);
      Q.maxAge = F;
    } else if (C === "domain") {
      let g = E;
      if (g[0] === ".") g = g.slice(1);
      (g = g.toLowerCase()), (Q.domain = g);
    } else if (C === "path") {
      let g = "";
      if (E.length === 0 || E[0] !== "/") g = "/";
      else g = E;
      Q.path = g;
    } else if (C === "secure") Q.secure = !0;
    else if (C === "httponly") Q.httpOnly = !0;
    else if (C === "samesite") {
      let g = "Default",
        F = E.toLowerCase();
      if (F.includes("none")) g = "None";
      if (F.includes("strict")) g = "Strict";
      if (F.includes("lax")) g = "Lax";
      Q.sameSite = g;
    } else (Q.unparsed ??= []), Q.unparsed.push(`${I}=${E}`);
    return i0(A, Q);
  }
  C7.exports = { parseSetCookie: La, parseUnparsedAttributes: i0 };
});
var J7 = Z((i3A, Y7) => {
  var { parseSetCookie: Ra } = g7(),
    { stringify: F7 } = EZ(),
    { webidl: XA } = EB(),
    { Headers: tY } = yC();
  function Va(A) {
    XA.argumentLengthCheck(arguments, 1, { header: "getCookies" }),
      XA.brandCheck(A, tY, { strict: !1 });
    let Q = A.get("cookie"),
      B = {};
    if (!Q) return B;
    for (let I of Q.split(";")) {
      let [E, ...C] = I.split("=");
      B[E.trim()] = C.join("=");
    }
    return B;
  }
  function $a(A, Q, B) {
    XA.argumentLengthCheck(arguments, 2, { header: "deleteCookie" }),
      XA.brandCheck(A, tY, { strict: !1 }),
      (Q = XA.converters.DOMString(Q)),
      (B = XA.converters.DeleteCookieAttributes(B)),
      D7(A, { name: Q, value: "", expires: new Date(0), ...B });
  }
  function Ha(A) {
    XA.argumentLengthCheck(arguments, 1, { header: "getSetCookies" }),
      XA.brandCheck(A, tY, { strict: !1 });
    let Q = A.getSetCookie();
    if (!Q) return [];
    return Q.map((B) => Ra(B));
  }
  function D7(A, Q) {
    if (
      (XA.argumentLengthCheck(arguments, 2, { header: "setCookie" }),
      XA.brandCheck(A, tY, { strict: !1 }),
      (Q = XA.converters.Cookie(Q)),
      F7(Q))
    )
      A.append("Set-Cookie", F7(Q));
  }
  XA.converters.DeleteCookieAttributes = XA.dictionaryConverter([
    {
      converter: XA.nullableConverter(XA.converters.DOMString),
      key: "path",
      defaultValue: null,
    },
    {
      converter: XA.nullableConverter(XA.converters.DOMString),
      key: "domain",
      defaultValue: null,
    },
  ]);
  XA.converters.Cookie = XA.dictionaryConverter([
    { converter: XA.converters.DOMString, key: "name" },
    { converter: XA.converters.DOMString, key: "value" },
    {
      converter: XA.nullableConverter((A) => {
        if (typeof A === "number")
          return XA.converters["unsigned long long"](A);
        return new Date(A);
      }),
      key: "expires",
      defaultValue: null,
    },
    {
      converter: XA.nullableConverter(XA.converters["long long"]),
      key: "maxAge",
      defaultValue: null,
    },
    {
      converter: XA.nullableConverter(XA.converters.DOMString),
      key: "domain",
      defaultValue: null,
    },
    {
      converter: XA.nullableConverter(XA.converters.DOMString),
      key: "path",
      defaultValue: null,
    },
    {
      converter: XA.nullableConverter(XA.converters.boolean),
      key: "secure",
      defaultValue: null,
    },
    {
      converter: XA.nullableConverter(XA.converters.boolean),
      key: "httpOnly",
      defaultValue: null,
    },
    {
      converter: XA.converters.USVString,
      key: "sameSite",
      allowedValues: ["Strict", "Lax", "None"],
    },
    {
      converter: XA.sequenceConverter(XA.converters.DOMString),
      key: "unparsed",
      defaultValue: [],
    },
  ]);
  Y7.exports = {
    getCookies: Va,
    deleteCookie: $a,
    getSetCookies: Ha,
    setCookie: D7,
  };
});
var n0 = Z((n3A, N7) => {
  var Ka = { enumerable: !0, writable: !1, configurable: !1 },
    za = { CONNECTING: 0, OPEN: 1, CLOSING: 2, CLOSED: 3 },
    Ta = { CONTINUATION: 0, TEXT: 1, BINARY: 2, CLOSE: 8, PING: 9, PONG: 10 },
    Oa = { INFO: 0, PAYLOADLENGTH_16: 2, PAYLOADLENGTH_64: 3, READ_DATA: 4 },
    qa = Buffer.allocUnsafe(0);
  N7.exports = {
    uid: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
    staticPropertyDescriptors: Ka,
    states: za,
    opcodes: Ta,
    maxUnsigned16Bit: 65535,
    parserStates: Oa,
    emptyBuffer: qa,
  };
});
var $F = Z((a3A, G7) => {
  G7.exports = {
    kWebSocketURL: Symbol("url"),
    kReadyState: Symbol("ready state"),
    kController: Symbol("controller"),
    kResponse: Symbol("response"),
    kBinaryType: Symbol("binary type"),
    kSentClose: Symbol("sent close"),
    kReceivedClose: Symbol("received close"),
    kByteParser: Symbol("byte parser"),
  };
});
var gZ = Z((o3A, U7) => {
  var { webidl: QA } = EB(),
    { kEnumerableProperty: VB } = HA(),
    { MessagePort: ja } = $("worker_threads");
  class lI extends Event {
    #A;
    constructor(A, Q = {}) {
      QA.argumentLengthCheck(arguments, 1, {
        header: "MessageEvent constructor",
      }),
        (A = QA.converters.DOMString(A)),
        (Q = QA.converters.MessageEventInit(Q));
      super(A, Q);
      this.#A = Q;
    }
    get data() {
      return QA.brandCheck(this, lI), this.#A.data;
    }
    get origin() {
      return QA.brandCheck(this, lI), this.#A.origin;
    }
    get lastEventId() {
      return QA.brandCheck(this, lI), this.#A.lastEventId;
    }
    get source() {
      return QA.brandCheck(this, lI), this.#A.source;
    }
    get ports() {
      if ((QA.brandCheck(this, lI), !Object.isFrozen(this.#A.ports)))
        Object.freeze(this.#A.ports);
      return this.#A.ports;
    }
    initMessageEvent(
      A,
      Q = !1,
      B = !1,
      I = null,
      E = "",
      C = "",
      g = null,
      F = [],
    ) {
      return (
        QA.brandCheck(this, lI),
        QA.argumentLengthCheck(arguments, 1, {
          header: "MessageEvent.initMessageEvent",
        }),
        new lI(A, {
          bubbles: Q,
          cancelable: B,
          data: I,
          origin: E,
          lastEventId: C,
          source: g,
          ports: F,
        })
      );
    }
  }
  class a0 extends Event {
    #A;
    constructor(A, Q = {}) {
      QA.argumentLengthCheck(arguments, 1, {
        header: "CloseEvent constructor",
      }),
        (A = QA.converters.DOMString(A)),
        (Q = QA.converters.CloseEventInit(Q));
      super(A, Q);
      this.#A = Q;
    }
    get wasClean() {
      return QA.brandCheck(this, a0), this.#A.wasClean;
    }
    get code() {
      return QA.brandCheck(this, a0), this.#A.code;
    }
    get reason() {
      return QA.brandCheck(this, a0), this.#A.reason;
    }
  }
  class nE extends Event {
    #A;
    constructor(A, Q) {
      QA.argumentLengthCheck(arguments, 1, {
        header: "ErrorEvent constructor",
      });
      super(A, Q);
      (A = QA.converters.DOMString(A)),
        (Q = QA.converters.ErrorEventInit(Q ?? {})),
        (this.#A = Q);
    }
    get message() {
      return QA.brandCheck(this, nE), this.#A.message;
    }
    get filename() {
      return QA.brandCheck(this, nE), this.#A.filename;
    }
    get lineno() {
      return QA.brandCheck(this, nE), this.#A.lineno;
    }
    get colno() {
      return QA.brandCheck(this, nE), this.#A.colno;
    }
    get error() {
      return QA.brandCheck(this, nE), this.#A.error;
    }
  }
  Object.defineProperties(lI.prototype, {
    [Symbol.toStringTag]: { value: "MessageEvent", configurable: !0 },
    data: VB,
    origin: VB,
    lastEventId: VB,
    source: VB,
    ports: VB,
    initMessageEvent: VB,
  });
  Object.defineProperties(a0.prototype, {
    [Symbol.toStringTag]: { value: "CloseEvent", configurable: !0 },
    reason: VB,
    code: VB,
    wasClean: VB,
  });
  Object.defineProperties(nE.prototype, {
    [Symbol.toStringTag]: { value: "ErrorEvent", configurable: !0 },
    message: VB,
    filename: VB,
    lineno: VB,
    colno: VB,
    error: VB,
  });
  QA.converters.MessagePort = QA.interfaceConverter(ja);
  QA.converters["sequence<MessagePort>"] = QA.sequenceConverter(
    QA.converters.MessagePort,
  );
  var CZ = [
    { key: "bubbles", converter: QA.converters.boolean, defaultValue: !1 },
    { key: "cancelable", converter: QA.converters.boolean, defaultValue: !1 },
    { key: "composed", converter: QA.converters.boolean, defaultValue: !1 },
  ];
  QA.converters.MessageEventInit = QA.dictionaryConverter([
    ...CZ,
    { key: "data", converter: QA.converters.any, defaultValue: null },
    { key: "origin", converter: QA.converters.USVString, defaultValue: "" },
    {
      key: "lastEventId",
      converter: QA.converters.DOMString,
      defaultValue: "",
    },
    {
      key: "source",
      converter: QA.nullableConverter(QA.converters.MessagePort),
      defaultValue: null,
    },
    {
      key: "ports",
      converter: QA.converters["sequence<MessagePort>"],
      get defaultValue() {
        return [];
      },
    },
  ]);
  QA.converters.CloseEventInit = QA.dictionaryConverter([
    ...CZ,
    { key: "wasClean", converter: QA.converters.boolean, defaultValue: !1 },
    {
      key: "code",
      converter: QA.converters["unsigned short"],
      defaultValue: 0,
    },
    { key: "reason", converter: QA.converters.USVString, defaultValue: "" },
  ]);
  QA.converters.ErrorEventInit = QA.dictionaryConverter([
    ...CZ,
    { key: "message", converter: QA.converters.DOMString, defaultValue: "" },
    { key: "filename", converter: QA.converters.USVString, defaultValue: "" },
    {
      key: "lineno",
      converter: QA.converters["unsigned long"],
      defaultValue: 0,
    },
    {
      key: "colno",
      converter: QA.converters["unsigned long"],
      defaultValue: 0,
    },
    { key: "error", converter: QA.converters.any },
  ]);
  U7.exports = { MessageEvent: lI, CloseEvent: a0, ErrorEvent: nE };
});
var QJ = Z((s3A, X7) => {
  var {
      kReadyState: eY,
      kController: fa,
      kResponse: ha,
      kBinaryType: ka,
      kWebSocketURL: xa,
    } = $F(),
    { states: AJ, opcodes: W7 } = n0(),
    { MessageEvent: va, ErrorEvent: Pa } = gZ();
  function _a(A) {
    return A[eY] === AJ.OPEN;
  }
  function ya(A) {
    return A[eY] === AJ.CLOSING;
  }
  function Sa(A) {
    return A[eY] === AJ.CLOSED;
  }
  function FZ(A, Q, B = Event, I) {
    let E = new B(A, I);
    Q.dispatchEvent(E);
  }
  function ba(A, Q, B) {
    if (A[eY] !== AJ.OPEN) return;
    let I;
    if (Q === W7.TEXT)
      try {
        I = new TextDecoder("utf-8", { fatal: !0 }).decode(B);
      } catch {
        Z7(A, "Received invalid UTF-8 in text frame.");
        return;
      }
    else if (Q === W7.BINARY)
      if (A[ka] === "blob") I = new Blob([B]);
      else I = new Uint8Array(B).buffer;
    FZ("message", A, va, { origin: A[xa].origin, data: I });
  }
  function ma(A) {
    if (A.length === 0) return !1;
    for (let Q of A) {
      let B = Q.charCodeAt(0);
      if (
        B < 33 ||
        B > 126 ||
        Q === "(" ||
        Q === ")" ||
        Q === "<" ||
        Q === ">" ||
        Q === "@" ||
        Q === "," ||
        Q === ";" ||
        Q === ":" ||
        Q === "\\" ||
        Q === '"' ||
        Q === "/" ||
        Q === "[" ||
        Q === "]" ||
        Q === "?" ||
        Q === "=" ||
        Q === "{" ||
        Q === "}" ||
        B === 32 ||
        B === 9
      )
        return !1;
    }
    return !0;
  }
  function da(A) {
    if (A >= 1000 && A < 1015) return A !== 1004 && A !== 1005 && A !== 1006;
    return A >= 3000 && A <= 4999;
  }
  function Z7(A, Q) {
    let { [fa]: B, [ha]: I } = A;
    if ((B.abort(), I?.socket && !I.socket.destroyed)) I.socket.destroy();
    if (Q) FZ("error", A, Pa, { error: Error(Q) });
  }
  X7.exports = {
    isEstablished: _a,
    isClosing: ya,
    isClosed: Sa,
    fireEvent: FZ,
    isValidSubprotocol: ma,
    isValidStatusCode: da,
    failWebsocketConnection: Z7,
    websocketMessageReceived: ba,
  };
});
var $7 = Z((r3A, V7) => {
  var YZ = $("diagnostics_channel"),
    { uid: ca, states: M7 } = n0(),
    {
      kReadyState: L7,
      kSentClose: w7,
      kByteParser: R7,
      kReceivedClose: ua,
    } = $F(),
    { fireEvent: la, failWebsocketConnection: mC } = QJ(),
    { CloseEvent: pa } = gZ(),
    { makeRequest: ia } = XF(),
    { fetching: na } = uY(),
    { Headers: aa } = yC(),
    { getGlobalDispatcher: oa } = y0(),
    { kHeadersList: sa } = aA(),
    WE = {};
  WE.open = YZ.channel("undici:websocket:open");
  WE.close = YZ.channel("undici:websocket:close");
  WE.socketError = YZ.channel("undici:websocket:socket_error");
  var DZ;
  try {
    DZ = $("crypto");
  } catch {}
  function ra(A, Q, B, I, E) {
    let C = A;
    C.protocol = A.protocol === "ws:" ? "http:" : "https:";
    let g = ia({
      urlList: [C],
      serviceWorkers: "none",
      referrer: "no-referrer",
      mode: "websocket",
      credentials: "include",
      cache: "no-store",
      redirect: "error",
    });
    if (E.headers) {
      let Y = new aa(E.headers)[sa];
      g.headersList = Y;
    }
    let F = DZ.randomBytes(16).toString("base64");
    g.headersList.append("sec-websocket-key", F),
      g.headersList.append("sec-websocket-version", "13");
    for (let Y of Q) g.headersList.append("sec-websocket-protocol", Y);
    let D = "";
    return na({
      request: g,
      useParallelQueue: !0,
      dispatcher: E.dispatcher ?? oa(),
      processResponse(Y) {
        if (Y.type === "error" || Y.status !== 101) {
          mC(B, "Received network error or non-101 status code.");
          return;
        }
        if (Q.length !== 0 && !Y.headersList.get("Sec-WebSocket-Protocol")) {
          mC(B, "Server did not respond with sent protocols.");
          return;
        }
        if (Y.headersList.get("Upgrade")?.toLowerCase() !== "websocket") {
          mC(B, 'Server did not set Upgrade header to "websocket".');
          return;
        }
        if (Y.headersList.get("Connection")?.toLowerCase() !== "upgrade") {
          mC(B, 'Server did not set Connection header to "upgrade".');
          return;
        }
        let N = Y.headersList.get("Sec-WebSocket-Accept"),
          W = DZ.createHash("sha1")
            .update(F + ca)
            .digest("base64");
        if (N !== W) {
          mC(B, "Incorrect hash received in Sec-WebSocket-Accept header.");
          return;
        }
        let X = Y.headersList.get("Sec-WebSocket-Extensions");
        if (X !== null && X !== D) {
          mC(B, "Received different permessage-deflate than the one set.");
          return;
        }
        let M = Y.headersList.get("Sec-WebSocket-Protocol");
        if (M !== null && M !== g.headersList.get("Sec-WebSocket-Protocol")) {
          mC(B, "Protocol was not set in the opening handshake.");
          return;
        }
        if (
          (Y.socket.on("data", ta),
          Y.socket.on("close", ea),
          Y.socket.on("error", Ao),
          WE.open.hasSubscribers)
        )
          WE.open.publish({
            address: Y.socket.address(),
            protocol: M,
            extensions: X,
          });
        I(Y);
      },
    });
  }
  function ta(A) {
    if (!this.ws[R7].write(A)) this.pause();
  }
  function ea() {
    let { ws: A } = this,
      Q = A[w7] && A[ua],
      B = 1005,
      I = "",
      E = A[R7].closingInfo;
    if (E) (B = E.code ?? 1005), (I = E.reason);
    else if (!A[w7]) B = 1006;
    if (
      ((A[L7] = M7.CLOSED),
      la("close", A, pa, { wasClean: Q, code: B, reason: I }),
      WE.close.hasSubscribers)
    )
      WE.close.publish({ websocket: A, code: B, reason: I });
  }
  function Ao(A) {
    let { ws: Q } = this;
    if (((Q[L7] = M7.CLOSING), WE.socketError.hasSubscribers))
      WE.socketError.publish(A);
    this.destroy();
  }
  V7.exports = { establishWebSocketConnection: ra };
});
var JZ = Z((t3A, z7) => {
  var { maxUnsigned16Bit: Qo } = n0(),
    H7;
  try {
    H7 = $("crypto");
  } catch {}
  class K7 {
    constructor(A) {
      (this.frameData = A), (this.maskKey = H7.randomBytes(4));
    }
    createFrame(A) {
      let Q = this.frameData?.byteLength ?? 0,
        B = Q,
        I = 6;
      if (Q > Qo) (I += 8), (B = 127);
      else if (Q > 125) (I += 2), (B = 126);
      let E = Buffer.allocUnsafe(Q + I);
      (E[0] = E[1] = 0), (E[0] |= 128), (E[0] = (E[0] & 240) + A);
      /*! ws. MIT License. Einar Otto Stangvik <einaros@gmail.com> */ if (
        ((E[I - 4] = this.maskKey[0]),
        (E[I - 3] = this.maskKey[1]),
        (E[I - 2] = this.maskKey[2]),
        (E[I - 1] = this.maskKey[3]),
        (E[1] = B),
        B === 126)
      )
        E.writeUInt16BE(Q, 2);
      else if (B === 127) (E[2] = E[3] = 0), E.writeUIntBE(Q, 4, 6);
      E[1] |= 128;
      for (let C = 0; C < Q; C++)
        E[I + C] = this.frameData[C] ^ this.maskKey[C % 4];
      return E;
    }
  }
  z7.exports = { WebsocketFrameSend: K7 };
});
var v7 = Z((e3A, x7) => {
  var { Writable: Bo } = $("stream"),
    h7 = $("diagnostics_channel"),
    { parserStates: II, opcodes: EI, states: Io, emptyBuffer: Eo } = n0(),
    {
      kReadyState: Co,
      kSentClose: T7,
      kResponse: O7,
      kReceivedClose: q7,
    } = $F(),
    {
      isValidStatusCode: j7,
      failWebsocketConnection: HF,
      websocketMessageReceived: go,
    } = QJ(),
    { WebsocketFrameSend: f7 } = JZ(),
    o0 = {};
  o0.ping = h7.channel("undici:websocket:ping");
  o0.pong = h7.channel("undici:websocket:pong");
  class k7 extends Bo {
    #A = [];
    #B = 0;
    #I = II.INFO;
    #Q = {};
    #E = [];
    constructor(A) {
      super();
      this.ws = A;
    }
    _write(A, Q, B) {
      this.#A.push(A), (this.#B += A.length), this.run(B);
    }
    run(A) {
      while (!0) {
        if (this.#I === II.INFO) {
          if (this.#B < 2) return A();
          let Q = this.consume(2);
          if (
            ((this.#Q.fin = (Q[0] & 128) !== 0),
            (this.#Q.opcode = Q[0] & 15),
            (this.#Q.originalOpcode ??= this.#Q.opcode),
            (this.#Q.fragmented =
              !this.#Q.fin && this.#Q.opcode !== EI.CONTINUATION),
            this.#Q.fragmented &&
              this.#Q.opcode !== EI.BINARY &&
              this.#Q.opcode !== EI.TEXT)
          ) {
            HF(this.ws, "Invalid frame type was fragmented.");
            return;
          }
          let B = Q[1] & 127;
          if (B <= 125) (this.#Q.payloadLength = B), (this.#I = II.READ_DATA);
          else if (B === 126) this.#I = II.PAYLOADLENGTH_16;
          else if (B === 127) this.#I = II.PAYLOADLENGTH_64;
          if (this.#Q.fragmented && B > 125) {
            HF(this.ws, "Fragmented frame exceeded 125 bytes.");
            return;
          } else if (
            (this.#Q.opcode === EI.PING ||
              this.#Q.opcode === EI.PONG ||
              this.#Q.opcode === EI.CLOSE) &&
            B > 125
          ) {
            HF(this.ws, "Payload length for control frame exceeded 125 bytes.");
            return;
          } else if (this.#Q.opcode === EI.CLOSE) {
            if (B === 1) {
              HF(this.ws, "Received close frame with a 1-byte body.");
              return;
            }
            let I = this.consume(B);
            if (
              ((this.#Q.closeInfo = this.parseCloseBody(!1, I)), !this.ws[T7])
            ) {
              let E = Buffer.allocUnsafe(2);
              E.writeUInt16BE(this.#Q.closeInfo.code, 0);
              let C = new f7(E);
              this.ws[O7].socket.write(C.createFrame(EI.CLOSE), (g) => {
                if (!g) this.ws[T7] = !0;
              });
            }
            (this.ws[Co] = Io.CLOSING), (this.ws[q7] = !0), this.end();
            return;
          } else if (this.#Q.opcode === EI.PING) {
            let I = this.consume(B);
            if (!this.ws[q7]) {
              let E = new f7(I);
              if (
                (this.ws[O7].socket.write(E.createFrame(EI.PONG)),
                o0.ping.hasSubscribers)
              )
                o0.ping.publish({ payload: I });
            }
            if (((this.#I = II.INFO), this.#B > 0)) continue;
            else {
              A();
              return;
            }
          } else if (this.#Q.opcode === EI.PONG) {
            let I = this.consume(B);
            if (o0.pong.hasSubscribers) o0.pong.publish({ payload: I });
            if (this.#B > 0) continue;
            else {
              A();
              return;
            }
          }
        } else if (this.#I === II.PAYLOADLENGTH_16) {
          if (this.#B < 2) return A();
          let Q = this.consume(2);
          (this.#Q.payloadLength = Q.readUInt16BE(0)), (this.#I = II.READ_DATA);
        } else if (this.#I === II.PAYLOADLENGTH_64) {
          if (this.#B < 8) return A();
          let Q = this.consume(8),
            B = Q.readUInt32BE(0);
          if (B > 2147483647) {
            HF(this.ws, "Received payload length > 2^31 bytes.");
            return;
          }
          let I = Q.readUInt32BE(4);
          (this.#Q.payloadLength = (B << 8) + I), (this.#I = II.READ_DATA);
        } else if (this.#I === II.READ_DATA) {
          if (this.#B < this.#Q.payloadLength) return A();
          else if (this.#B >= this.#Q.payloadLength) {
            let Q = this.consume(this.#Q.payloadLength);
            if (
              (this.#E.push(Q),
              !this.#Q.fragmented ||
                (this.#Q.fin && this.#Q.opcode === EI.CONTINUATION))
            ) {
              let B = Buffer.concat(this.#E);
              go(this.ws, this.#Q.originalOpcode, B),
                (this.#Q = {}),
                (this.#E.length = 0);
            }
            this.#I = II.INFO;
          }
        }
        if (this.#B > 0) continue;
        else {
          A();
          break;
        }
      }
    }
    consume(A) {
      if (A > this.#B) return null;
      else if (A === 0) return Eo;
      if (this.#A[0].length === A)
        return (this.#B -= this.#A[0].length), this.#A.shift();
      let Q = Buffer.allocUnsafe(A),
        B = 0;
      while (B !== A) {
        let I = this.#A[0],
          { length: E } = I;
        if (E + B === A) {
          Q.set(this.#A.shift(), B);
          break;
        } else if (E + B > A) {
          Q.set(I.subarray(0, A - B), B), (this.#A[0] = I.subarray(A - B));
          break;
        } else Q.set(this.#A.shift(), B), (B += I.length);
      }
      return (this.#B -= A), Q;
    }
    parseCloseBody(A, Q) {
      let B;
      if (Q.length >= 2) B = Q.readUInt16BE(0);
      if (A) {
        if (!j7(B)) return null;
        return { code: B };
      }
      let I = Q.subarray(2);
      if (I[0] === 239 && I[1] === 187 && I[2] === 191) I = I.subarray(3);
      if (B !== void 0 && !j7(B)) return null;
      try {
        I = new TextDecoder("utf-8", { fatal: !0 }).decode(I);
      } catch {
        return null;
      }
      return { code: B, reason: I };
    }
    get closingInfo() {
      return this.#Q.closeInfo;
    }
  }
  x7.exports = { ByteParser: k7 };
});
var c7 = Z((A$A, d7) => {
  var { webidl: YA } = EB(),
    { DOMException: aE } = yE(),
    { URLSerializer: Fo } = $I(),
    { getGlobalOrigin: Do } = w0(),
    {
      staticPropertyDescriptors: oE,
      states: s0,
      opcodes: KF,
      emptyBuffer: Yo,
    } = n0(),
    {
      kWebSocketURL: P7,
      kReadyState: ZE,
      kController: Jo,
      kBinaryType: BJ,
      kResponse: IJ,
      kSentClose: No,
      kByteParser: Go,
    } = $F(),
    {
      isEstablished: _7,
      isClosing: y7,
      isValidSubprotocol: Uo,
      failWebsocketConnection: Wo,
      fireEvent: Zo,
    } = QJ(),
    { establishWebSocketConnection: Xo } = $7(),
    { WebsocketFrameSend: zF } = JZ(),
    { ByteParser: wo } = v7(),
    { kEnumerableProperty: CI, isBlobLike: b7 } = HA(),
    { getGlobalDispatcher: Mo } = y0(),
    { types: m7 } = $("util"),
    S7 = !1;
  class VA extends EventTarget {
    #A = { open: null, error: null, close: null, message: null };
    #B = 0;
    #I = "";
    #Q = "";
    constructor(A, Q = []) {
      super();
      if (
        (YA.argumentLengthCheck(arguments, 1, {
          header: "WebSocket constructor",
        }),
        !S7)
      )
        (S7 = !0),
          process.emitWarning(
            "WebSockets are experimental, expect them to change at any time.",
            { code: "UNDICI-WS" },
          );
      let B =
        YA.converters["DOMString or sequence<DOMString> or WebSocketInit"](Q);
      (A = YA.converters.USVString(A)), (Q = B.protocols);
      let I = Do(),
        E;
      try {
        E = new URL(A, I);
      } catch (C) {
        throw new aE(C, "SyntaxError");
      }
      if (E.protocol === "http:") E.protocol = "ws:";
      else if (E.protocol === "https:") E.protocol = "wss:";
      if (E.protocol !== "ws:" && E.protocol !== "wss:")
        throw new aE(
          `Expected a ws: or wss: protocol, got ${E.protocol}`,
          "SyntaxError",
        );
      if (E.hash || E.href.endsWith("#"))
        throw new aE("Got fragment", "SyntaxError");
      if (typeof Q === "string") Q = [Q];
      if (Q.length !== new Set(Q.map((C) => C.toLowerCase())).size)
        throw new aE("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      if (Q.length > 0 && !Q.every((C) => Uo(C)))
        throw new aE("Invalid Sec-WebSocket-Protocol value", "SyntaxError");
      (this[P7] = new URL(E.href)),
        (this[Jo] = Xo(E, Q, this, (C) => this.#E(C), B)),
        (this[ZE] = VA.CONNECTING),
        (this[BJ] = "blob");
    }
    close(A = void 0, Q = void 0) {
      if ((YA.brandCheck(this, VA), A !== void 0))
        A = YA.converters["unsigned short"](A, { clamp: !0 });
      if (Q !== void 0) Q = YA.converters.USVString(Q);
      if (A !== void 0) {
        if (A !== 1000 && (A < 3000 || A > 4999))
          throw new aE("invalid code", "InvalidAccessError");
      }
      let B = 0;
      if (Q !== void 0) {
        if (((B = Buffer.byteLength(Q)), B > 123))
          throw new aE(
            `Reason must be less than 123 bytes; received ${B}`,
            "SyntaxError",
          );
      }
      if (this[ZE] === VA.CLOSING || this[ZE] === VA.CLOSED);
      else if (!_7(this))
        Wo(this, "Connection was closed before it was established."),
          (this[ZE] = VA.CLOSING);
      else if (!y7(this)) {
        let I = new zF();
        if (A !== void 0 && Q === void 0)
          (I.frameData = Buffer.allocUnsafe(2)),
            I.frameData.writeUInt16BE(A, 0);
        else if (A !== void 0 && Q !== void 0)
          (I.frameData = Buffer.allocUnsafe(2 + B)),
            I.frameData.writeUInt16BE(A, 0),
            I.frameData.write(Q, 2, "utf-8");
        else I.frameData = Yo;
        this[IJ].socket.write(I.createFrame(KF.CLOSE), (C) => {
          if (!C) this[No] = !0;
        }),
          (this[ZE] = s0.CLOSING);
      } else this[ZE] = VA.CLOSING;
    }
    send(A) {
      if (
        (YA.brandCheck(this, VA),
        YA.argumentLengthCheck(arguments, 1, { header: "WebSocket.send" }),
        (A = YA.converters.WebSocketSendData(A)),
        this[ZE] === VA.CONNECTING)
      )
        throw new aE("Sent before connected.", "InvalidStateError");
      if (!_7(this) || y7(this)) return;
      let Q = this[IJ].socket;
      if (typeof A === "string") {
        let B = Buffer.from(A),
          E = new zF(B).createFrame(KF.TEXT);
        (this.#B += B.byteLength),
          Q.write(E, () => {
            this.#B -= B.byteLength;
          });
      } else if (m7.isArrayBuffer(A)) {
        let B = Buffer.from(A),
          E = new zF(B).createFrame(KF.BINARY);
        (this.#B += B.byteLength),
          Q.write(E, () => {
            this.#B -= B.byteLength;
          });
      } else if (ArrayBuffer.isView(A)) {
        let B = Buffer.from(A, A.byteOffset, A.byteLength),
          E = new zF(B).createFrame(KF.BINARY);
        (this.#B += B.byteLength),
          Q.write(E, () => {
            this.#B -= B.byteLength;
          });
      } else if (b7(A)) {
        let B = new zF();
        A.arrayBuffer().then((I) => {
          let E = Buffer.from(I);
          B.frameData = E;
          let C = B.createFrame(KF.BINARY);
          (this.#B += E.byteLength),
            Q.write(C, () => {
              this.#B -= E.byteLength;
            });
        });
      }
    }
    get readyState() {
      return YA.brandCheck(this, VA), this[ZE];
    }
    get bufferedAmount() {
      return YA.brandCheck(this, VA), this.#B;
    }
    get url() {
      return YA.brandCheck(this, VA), Fo(this[P7]);
    }
    get extensions() {
      return YA.brandCheck(this, VA), this.#Q;
    }
    get protocol() {
      return YA.brandCheck(this, VA), this.#I;
    }
    get onopen() {
      return YA.brandCheck(this, VA), this.#A.open;
    }
    set onopen(A) {
      if ((YA.brandCheck(this, VA), this.#A.open))
        this.removeEventListener("open", this.#A.open);
      if (typeof A === "function")
        (this.#A.open = A), this.addEventListener("open", A);
      else this.#A.open = null;
    }
    get onerror() {
      return YA.brandCheck(this, VA), this.#A.error;
    }
    set onerror(A) {
      if ((YA.brandCheck(this, VA), this.#A.error))
        this.removeEventListener("error", this.#A.error);
      if (typeof A === "function")
        (this.#A.error = A), this.addEventListener("error", A);
      else this.#A.error = null;
    }
    get onclose() {
      return YA.brandCheck(this, VA), this.#A.close;
    }
    set onclose(A) {
      if ((YA.brandCheck(this, VA), this.#A.close))
        this.removeEventListener("close", this.#A.close);
      if (typeof A === "function")
        (this.#A.close = A), this.addEventListener("close", A);
      else this.#A.close = null;
    }
    get onmessage() {
      return YA.brandCheck(this, VA), this.#A.message;
    }
    set onmessage(A) {
      if ((YA.brandCheck(this, VA), this.#A.message))
        this.removeEventListener("message", this.#A.message);
      if (typeof A === "function")
        (this.#A.message = A), this.addEventListener("message", A);
      else this.#A.message = null;
    }
    get binaryType() {
      return YA.brandCheck(this, VA), this[BJ];
    }
    set binaryType(A) {
      if ((YA.brandCheck(this, VA), A !== "blob" && A !== "arraybuffer"))
        this[BJ] = "blob";
      else this[BJ] = A;
    }
    #E(A) {
      this[IJ] = A;
      let Q = new wo(this);
      Q.on("drain", function () {
        this.ws[IJ].socket.resume();
      }),
        (A.socket.ws = this),
        (this[Go] = Q),
        (this[ZE] = s0.OPEN);
      let B = A.headersList.get("sec-websocket-extensions");
      if (B !== null) this.#Q = B;
      let I = A.headersList.get("sec-websocket-protocol");
      if (I !== null) this.#I = I;
      Zo("open", this);
    }
  }
  VA.CONNECTING = VA.prototype.CONNECTING = s0.CONNECTING;
  VA.OPEN = VA.prototype.OPEN = s0.OPEN;
  VA.CLOSING = VA.prototype.CLOSING = s0.CLOSING;
  VA.CLOSED = VA.prototype.CLOSED = s0.CLOSED;
  Object.defineProperties(VA.prototype, {
    CONNECTING: oE,
    OPEN: oE,
    CLOSING: oE,
    CLOSED: oE,
    url: CI,
    readyState: CI,
    bufferedAmount: CI,
    onopen: CI,
    onerror: CI,
    onclose: CI,
    close: CI,
    onmessage: CI,
    binaryType: CI,
    send: CI,
    extensions: CI,
    protocol: CI,
    [Symbol.toStringTag]: {
      value: "WebSocket",
      writable: !1,
      enumerable: !1,
      configurable: !0,
    },
  });
  Object.defineProperties(VA, {
    CONNECTING: oE,
    OPEN: oE,
    CLOSING: oE,
    CLOSED: oE,
  });
  YA.converters["sequence<DOMString>"] = YA.sequenceConverter(
    YA.converters.DOMString,
  );
  YA.converters["DOMString or sequence<DOMString>"] = function (A) {
    if (YA.util.Type(A) === "Object" && Symbol.iterator in A)
      return YA.converters["sequence<DOMString>"](A);
    return YA.converters.DOMString(A);
  };
  YA.converters.WebSocketInit = YA.dictionaryConverter([
    {
      key: "protocols",
      converter: YA.converters["DOMString or sequence<DOMString>"],
      get defaultValue() {
        return [];
      },
    },
    {
      key: "dispatcher",
      converter: (A) => A,
      get defaultValue() {
        return Mo();
      },
    },
    {
      key: "headers",
      converter: YA.nullableConverter(YA.converters.HeadersInit),
    },
  ]);
  YA.converters["DOMString or sequence<DOMString> or WebSocketInit"] =
    function (A) {
      if (YA.util.Type(A) === "Object" && !(Symbol.iterator in A))
        return YA.converters.WebSocketInit(A);
      return {
        protocols: YA.converters["DOMString or sequence<DOMString>"](A),
      };
    };
  YA.converters.WebSocketSendData = function (A) {
    if (YA.util.Type(A) === "Object") {
      if (b7(A)) return YA.converters.Blob(A, { strict: !1 });
      if (ArrayBuffer.isView(A) || m7.isAnyArrayBuffer(A))
        return YA.converters.BufferSource(A);
    }
    return YA.converters.USVString(A);
  };
  d7.exports = { WebSocket: VA };
});
var i7 = Z((vo, JA) => {
  var Lo = BF(),
    u7 = oD(),
    l7 = dA(),
    Ro = j0(),
    Vo = m5(),
    $o = gF(),
    dC = HA(),
    { InvalidArgumentError: EJ } = l7,
    r0 = SM(),
    Ho = ag(),
    Ko = TW(),
    zo = zL(),
    To = qW(),
    Oo = XW(),
    qo = kL(),
    jo = yL(),
    { getGlobalDispatcher: p7, setGlobalDispatcher: fo } = y0(),
    ho = uL(),
    ko = PU(),
    xo = eD(),
    NZ;
  try {
    $("crypto"), (NZ = !0);
  } catch {
    NZ = !1;
  }
  Object.assign(u7.prototype, r0);
  vo.Dispatcher = u7;
  vo.Client = Lo;
  vo.Pool = Ro;
  vo.BalancedPool = Vo;
  vo.Agent = $o;
  vo.ProxyAgent = qo;
  vo.RetryHandler = jo;
  vo.DecoratorHandler = ho;
  vo.RedirectHandler = ko;
  vo.createRedirectInterceptor = xo;
  vo.buildConnector = Ho;
  vo.errors = l7;
  function TF(A) {
    return (Q, B, I) => {
      if (typeof B === "function") (I = B), (B = null);
      if (
        !Q ||
        (typeof Q !== "string" && typeof Q !== "object" && !(Q instanceof URL))
      )
        throw new EJ("invalid url");
      if (B != null && typeof B !== "object") throw new EJ("invalid opts");
      if (B && B.path != null) {
        if (typeof B.path !== "string") throw new EJ("invalid opts.path");
        let g = B.path;
        if (!B.path.startsWith("/")) g = `/${g}`;
        Q = new URL(dC.parseOrigin(Q).origin + g);
      } else {
        if (!B) B = typeof Q === "object" ? Q : {};
        Q = dC.parseURL(Q);
      }
      let { agent: E, dispatcher: C = p7() } = B;
      if (E) throw new EJ("unsupported opts.agent. Did you mean opts.client?");
      return A.call(
        C,
        {
          ...B,
          origin: Q.origin,
          path: Q.search ? `${Q.pathname}${Q.search}` : Q.pathname,
          method: B.method || (B.body ? "PUT" : "GET"),
        },
        I,
      );
    };
  }
  vo.setGlobalDispatcher = fo;
  vo.getGlobalDispatcher = p7;
  if (dC.nodeMajor > 16 || (dC.nodeMajor === 16 && dC.nodeMinor >= 8)) {
    let A = null;
    (vo.fetch = async function (g) {
      if (!A) A = uY().fetch;
      try {
        return await A(...arguments);
      } catch (F) {
        if (typeof F === "object") Error.captureStackTrace(F, this);
        throw F;
      }
    }),
      (vo.Headers = yC().Headers),
      (vo.Response = kY().Response),
      (vo.Request = XF().Request),
      (vo.FormData = pD().FormData),
      (vo.File = uD().File),
      (vo.FileReader = b6().FileReader);
    let { setGlobalOrigin: Q, getGlobalOrigin: B } = w0();
    (vo.setGlobalOrigin = Q), (vo.getGlobalOrigin = B);
    let { CacheStorage: I } = r6(),
      { kConstruct: E } = nY();
    vo.caches = new I(E);
  }
  if (dC.nodeMajor >= 16) {
    let {
      deleteCookie: A,
      getCookies: Q,
      getSetCookies: B,
      setCookie: I,
    } = J7();
    (vo.deleteCookie = A),
      (vo.getCookies = Q),
      (vo.getSetCookies = B),
      (vo.setCookie = I);
    let { parseMIMEType: E, serializeAMimeType: C } = $I();
    (vo.parseMIMEType = E), (vo.serializeAMimeType = C);
  }
  if (dC.nodeMajor >= 18 && NZ) {
    let { WebSocket: A } = c7();
    vo.WebSocket = A;
  }
  vo.request = TF(r0.request);
  vo.stream = TF(r0.stream);
  vo.pipeline = TF(r0.pipeline);
  vo.connect = TF(r0.connect);
  vo.upgrade = TF(r0.upgrade);
  vo.MockClient = Ko;
  vo.MockPool = To;
  vo.MockAgent = zo;
  vo.mockErrors = Oo;
});
var OF = Z((iA) => {
  var Cs =
      (iA && iA.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            var E = Object.getOwnPropertyDescriptor(Q, B);
            if (
              !E ||
              ("get" in E ? !Q.__esModule : E.writable || E.configurable)
            )
              E = {
                enumerable: !0,
                get: function () {
                  return Q[B];
                },
              };
            Object.defineProperty(A, I, E);
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    gs =
      (iA && iA.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    FJ =
      (iA && iA.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.prototype.hasOwnProperty.call(A, B))
              Cs(Q, A, B);
        }
        return gs(Q, A), Q;
      },
    wQ =
      (iA && iA.__awaiter) ||
      function (A, Q, B, I) {
        function E(C) {
          return C instanceof B
            ? C
            : new B(function (g) {
                g(C);
              });
        }
        return new (B || (B = Promise))(function (C, g) {
          function F(Y) {
            try {
              J(I.next(Y));
            } catch (N) {
              g(N);
            }
          }
          function D(Y) {
            try {
              J(I.throw(Y));
            } catch (N) {
              g(N);
            }
          }
          function J(Y) {
            Y.done ? C(Y.value) : E(Y.value).then(F, D);
          }
          J((I = I.apply(A, Q || [])).next());
        });
      };
  Object.defineProperty(iA, "__esModule", { value: !0 });
  iA.HttpClient =
    iA.isHttps =
    iA.HttpClientResponse =
    iA.HttpClientError =
    iA.getProxyUrl =
    iA.MediaTypes =
    iA.Headers =
    iA.HttpCodes =
      void 0;
  var GZ = FJ($("http")),
    n7 = FJ($("https")),
    UZ = FJ(Zw()),
    CJ = FJ(Lw()),
    Fs = i7(),
    gI;
  (function (A) {
    (A[(A.OK = 200)] = "OK"),
      (A[(A.MultipleChoices = 300)] = "MultipleChoices"),
      (A[(A.MovedPermanently = 301)] = "MovedPermanently"),
      (A[(A.ResourceMoved = 302)] = "ResourceMoved"),
      (A[(A.SeeOther = 303)] = "SeeOther"),
      (A[(A.NotModified = 304)] = "NotModified"),
      (A[(A.UseProxy = 305)] = "UseProxy"),
      (A[(A.SwitchProxy = 306)] = "SwitchProxy"),
      (A[(A.TemporaryRedirect = 307)] = "TemporaryRedirect"),
      (A[(A.PermanentRedirect = 308)] = "PermanentRedirect"),
      (A[(A.BadRequest = 400)] = "BadRequest"),
      (A[(A.Unauthorized = 401)] = "Unauthorized"),
      (A[(A.PaymentRequired = 402)] = "PaymentRequired"),
      (A[(A.Forbidden = 403)] = "Forbidden"),
      (A[(A.NotFound = 404)] = "NotFound"),
      (A[(A.MethodNotAllowed = 405)] = "MethodNotAllowed"),
      (A[(A.NotAcceptable = 406)] = "NotAcceptable"),
      (A[(A.ProxyAuthenticationRequired = 407)] =
        "ProxyAuthenticationRequired"),
      (A[(A.RequestTimeout = 408)] = "RequestTimeout"),
      (A[(A.Conflict = 409)] = "Conflict"),
      (A[(A.Gone = 410)] = "Gone"),
      (A[(A.TooManyRequests = 429)] = "TooManyRequests"),
      (A[(A.InternalServerError = 500)] = "InternalServerError"),
      (A[(A.NotImplemented = 501)] = "NotImplemented"),
      (A[(A.BadGateway = 502)] = "BadGateway"),
      (A[(A.ServiceUnavailable = 503)] = "ServiceUnavailable"),
      (A[(A.GatewayTimeout = 504)] = "GatewayTimeout");
  })(gI || (iA.HttpCodes = gI = {}));
  var tQ;
  (function (A) {
    (A.Accept = "accept"), (A.ContentType = "content-type");
  })(tQ || (iA.Headers = tQ = {}));
  var XE;
  (function (A) {
    A.ApplicationJson = "application/json";
  })(XE || (iA.MediaTypes = XE = {}));
  function Ds(A) {
    let Q = UZ.getProxyUrl(new URL(A));
    return Q ? Q.href : "";
  }
  iA.getProxyUrl = Ds;
  var Ys = [
      gI.MovedPermanently,
      gI.ResourceMoved,
      gI.SeeOther,
      gI.TemporaryRedirect,
      gI.PermanentRedirect,
    ],
    Js = [gI.BadGateway, gI.ServiceUnavailable, gI.GatewayTimeout],
    Ns = ["OPTIONS", "GET", "DELETE", "HEAD"],
    Gs = 10,
    Us = 5;
  class DJ extends Error {
    constructor(A, Q) {
      super(A);
      (this.name = "HttpClientError"),
        (this.statusCode = Q),
        Object.setPrototypeOf(this, DJ.prototype);
    }
  }
  iA.HttpClientError = DJ;
  class WZ {
    constructor(A) {
      this.message = A;
    }
    readBody() {
      return wQ(this, void 0, void 0, function* () {
        return new Promise((A) =>
          wQ(this, void 0, void 0, function* () {
            let Q = Buffer.alloc(0);
            this.message.on("data", (B) => {
              Q = Buffer.concat([Q, B]);
            }),
              this.message.on("end", () => {
                A(Q.toString());
              });
          }),
        );
      });
    }
    readBodyBuffer() {
      return wQ(this, void 0, void 0, function* () {
        return new Promise((A) =>
          wQ(this, void 0, void 0, function* () {
            let Q = [];
            this.message.on("data", (B) => {
              Q.push(B);
            }),
              this.message.on("end", () => {
                A(Buffer.concat(Q));
              });
          }),
        );
      });
    }
  }
  iA.HttpClientResponse = WZ;
  function Ws(A) {
    return new URL(A).protocol === "https:";
  }
  iA.isHttps = Ws;
  class a7 {
    constructor(A, Q, B) {
      if (
        ((this._ignoreSslError = !1),
        (this._allowRedirects = !0),
        (this._allowRedirectDowngrade = !1),
        (this._maxRedirects = 50),
        (this._allowRetries = !1),
        (this._maxRetries = 1),
        (this._keepAlive = !1),
        (this._disposed = !1),
        (this.userAgent = A),
        (this.handlers = Q || []),
        (this.requestOptions = B),
        B)
      ) {
        if (B.ignoreSslError != null) this._ignoreSslError = B.ignoreSslError;
        if (((this._socketTimeout = B.socketTimeout), B.allowRedirects != null))
          this._allowRedirects = B.allowRedirects;
        if (B.allowRedirectDowngrade != null)
          this._allowRedirectDowngrade = B.allowRedirectDowngrade;
        if (B.maxRedirects != null)
          this._maxRedirects = Math.max(B.maxRedirects, 0);
        if (B.keepAlive != null) this._keepAlive = B.keepAlive;
        if (B.allowRetries != null) this._allowRetries = B.allowRetries;
        if (B.maxRetries != null) this._maxRetries = B.maxRetries;
      }
    }
    options(A, Q) {
      return wQ(this, void 0, void 0, function* () {
        return this.request("OPTIONS", A, null, Q || {});
      });
    }
    get(A, Q) {
      return wQ(this, void 0, void 0, function* () {
        return this.request("GET", A, null, Q || {});
      });
    }
    del(A, Q) {
      return wQ(this, void 0, void 0, function* () {
        return this.request("DELETE", A, null, Q || {});
      });
    }
    post(A, Q, B) {
      return wQ(this, void 0, void 0, function* () {
        return this.request("POST", A, Q, B || {});
      });
    }
    patch(A, Q, B) {
      return wQ(this, void 0, void 0, function* () {
        return this.request("PATCH", A, Q, B || {});
      });
    }
    put(A, Q, B) {
      return wQ(this, void 0, void 0, function* () {
        return this.request("PUT", A, Q, B || {});
      });
    }
    head(A, Q) {
      return wQ(this, void 0, void 0, function* () {
        return this.request("HEAD", A, null, Q || {});
      });
    }
    sendStream(A, Q, B, I) {
      return wQ(this, void 0, void 0, function* () {
        return this.request(A, Q, B, I);
      });
    }
    getJson(A, Q = {}) {
      return wQ(this, void 0, void 0, function* () {
        Q[tQ.Accept] = this._getExistingOrDefaultHeader(
          Q,
          tQ.Accept,
          XE.ApplicationJson,
        );
        let B = yield this.get(A, Q);
        return this._processResponse(B, this.requestOptions);
      });
    }
    postJson(A, Q, B = {}) {
      return wQ(this, void 0, void 0, function* () {
        let I = JSON.stringify(Q, null, 2);
        (B[tQ.Accept] = this._getExistingOrDefaultHeader(
          B,
          tQ.Accept,
          XE.ApplicationJson,
        )),
          (B[tQ.ContentType] = this._getExistingOrDefaultHeader(
            B,
            tQ.ContentType,
            XE.ApplicationJson,
          ));
        let E = yield this.post(A, I, B);
        return this._processResponse(E, this.requestOptions);
      });
    }
    putJson(A, Q, B = {}) {
      return wQ(this, void 0, void 0, function* () {
        let I = JSON.stringify(Q, null, 2);
        (B[tQ.Accept] = this._getExistingOrDefaultHeader(
          B,
          tQ.Accept,
          XE.ApplicationJson,
        )),
          (B[tQ.ContentType] = this._getExistingOrDefaultHeader(
            B,
            tQ.ContentType,
            XE.ApplicationJson,
          ));
        let E = yield this.put(A, I, B);
        return this._processResponse(E, this.requestOptions);
      });
    }
    patchJson(A, Q, B = {}) {
      return wQ(this, void 0, void 0, function* () {
        let I = JSON.stringify(Q, null, 2);
        (B[tQ.Accept] = this._getExistingOrDefaultHeader(
          B,
          tQ.Accept,
          XE.ApplicationJson,
        )),
          (B[tQ.ContentType] = this._getExistingOrDefaultHeader(
            B,
            tQ.ContentType,
            XE.ApplicationJson,
          ));
        let E = yield this.patch(A, I, B);
        return this._processResponse(E, this.requestOptions);
      });
    }
    request(A, Q, B, I) {
      return wQ(this, void 0, void 0, function* () {
        if (this._disposed) throw Error("Client has already been disposed.");
        let E = new URL(Q),
          C = this._prepareRequest(A, E, I),
          g = this._allowRetries && Ns.includes(A) ? this._maxRetries + 1 : 1,
          F = 0,
          D;
        do {
          if (
            ((D = yield this.requestRaw(C, B)),
            D && D.message && D.message.statusCode === gI.Unauthorized)
          ) {
            let Y;
            for (let N of this.handlers)
              if (N.canHandleAuthentication(D)) {
                Y = N;
                break;
              }
            if (Y) return Y.handleAuthentication(this, C, B);
            else return D;
          }
          let J = this._maxRedirects;
          while (
            D.message.statusCode &&
            Ys.includes(D.message.statusCode) &&
            this._allowRedirects &&
            J > 0
          ) {
            let Y = D.message.headers.location;
            if (!Y) break;
            let N = new URL(Y);
            if (
              E.protocol === "https:" &&
              E.protocol !== N.protocol &&
              !this._allowRedirectDowngrade
            )
              throw Error(
                "Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.",
              );
            if ((yield D.readBody(), N.hostname !== E.hostname)) {
              for (let W in I)
                if (W.toLowerCase() === "authorization") delete I[W];
            }
            (C = this._prepareRequest(A, N, I)),
              (D = yield this.requestRaw(C, B)),
              J--;
          }
          if (!D.message.statusCode || !Js.includes(D.message.statusCode))
            return D;
          if (((F += 1), F < g))
            yield D.readBody(), yield this._performExponentialBackoff(F);
        } while (F < g);
        return D;
      });
    }
    dispose() {
      if (this._agent) this._agent.destroy();
      this._disposed = !0;
    }
    requestRaw(A, Q) {
      return wQ(this, void 0, void 0, function* () {
        return new Promise((B, I) => {
          function E(C, g) {
            if (C) I(C);
            else if (!g) I(Error("Unknown error"));
            else B(g);
          }
          this.requestRawWithCallback(A, Q, E);
        });
      });
    }
    requestRawWithCallback(A, Q, B) {
      if (typeof Q === "string") {
        if (!A.options.headers) A.options.headers = {};
        A.options.headers["Content-Length"] = Buffer.byteLength(Q, "utf8");
      }
      let I = !1;
      function E(F, D) {
        if (!I) (I = !0), B(F, D);
      }
      let C = A.httpModule.request(A.options, (F) => {
          let D = new WZ(F);
          E(void 0, D);
        }),
        g;
      if (
        (C.on("socket", (F) => {
          g = F;
        }),
        C.setTimeout(this._socketTimeout || 180000, () => {
          if (g) g.end();
          E(Error(`Request timeout: ${A.options.path}`));
        }),
        C.on("error", function (F) {
          E(F);
        }),
        Q && typeof Q === "string")
      )
        C.write(Q, "utf8");
      if (Q && typeof Q !== "string")
        Q.on("close", function () {
          C.end();
        }),
          Q.pipe(C);
      else C.end();
    }
    getAgent(A) {
      let Q = new URL(A);
      return this._getAgent(Q);
    }
    getAgentDispatcher(A) {
      let Q = new URL(A),
        B = UZ.getProxyUrl(Q);
      if (!(B && B.hostname)) return;
      return this._getProxyAgentDispatcher(Q, B);
    }
    _prepareRequest(A, Q, B) {
      let I = {};
      I.parsedUrl = Q;
      let E = I.parsedUrl.protocol === "https:";
      I.httpModule = E ? n7 : GZ;
      let C = E ? 443 : 80;
      if (
        ((I.options = {}),
        (I.options.host = I.parsedUrl.hostname),
        (I.options.port = I.parsedUrl.port ? parseInt(I.parsedUrl.port) : C),
        (I.options.path =
          (I.parsedUrl.pathname || "") + (I.parsedUrl.search || "")),
        (I.options.method = A),
        (I.options.headers = this._mergeHeaders(B)),
        this.userAgent != null)
      )
        I.options.headers["user-agent"] = this.userAgent;
      if (((I.options.agent = this._getAgent(I.parsedUrl)), this.handlers))
        for (let g of this.handlers) g.prepareRequest(I.options);
      return I;
    }
    _mergeHeaders(A) {
      if (this.requestOptions && this.requestOptions.headers)
        return Object.assign({}, gJ(this.requestOptions.headers), gJ(A || {}));
      return gJ(A || {});
    }
    _getExistingOrDefaultHeader(A, Q, B) {
      let I;
      if (this.requestOptions && this.requestOptions.headers)
        I = gJ(this.requestOptions.headers)[Q];
      return A[Q] || I || B;
    }
    _getAgent(A) {
      let Q,
        B = UZ.getProxyUrl(A),
        I = B && B.hostname;
      if (this._keepAlive && I) Q = this._proxyAgent;
      if (!I) Q = this._agent;
      if (Q) return Q;
      let E = A.protocol === "https:",
        C = 100;
      if (this.requestOptions)
        C = this.requestOptions.maxSockets || GZ.globalAgent.maxSockets;
      if (B && B.hostname) {
        let g = {
            maxSockets: C,
            keepAlive: this._keepAlive,
            proxy: Object.assign(
              Object.assign(
                {},
                (B.username || B.password) && {
                  proxyAuth: `${B.username}:${B.password}`,
                },
              ),
              { host: B.hostname, port: B.port },
            ),
          },
          F,
          D = B.protocol === "https:";
        if (E) F = D ? CJ.httpsOverHttps : CJ.httpsOverHttp;
        else F = D ? CJ.httpOverHttps : CJ.httpOverHttp;
        (Q = F(g)), (this._proxyAgent = Q);
      }
      if (!Q) {
        let g = { keepAlive: this._keepAlive, maxSockets: C };
        (Q = E ? new n7.Agent(g) : new GZ.Agent(g)), (this._agent = Q);
      }
      if (E && this._ignoreSslError)
        Q.options = Object.assign(Q.options || {}, { rejectUnauthorized: !1 });
      return Q;
    }
    _getProxyAgentDispatcher(A, Q) {
      let B;
      if (this._keepAlive) B = this._proxyAgentDispatcher;
      if (B) return B;
      let I = A.protocol === "https:";
      if (
        ((B = new Fs.ProxyAgent(
          Object.assign(
            { uri: Q.href, pipelining: !this._keepAlive ? 0 : 1 },
            (Q.username || Q.password) && {
              token: `Basic ${Buffer.from(`${Q.username}:${Q.password}`).toString("base64")}`,
            },
          ),
        )),
        (this._proxyAgentDispatcher = B),
        I && this._ignoreSslError)
      )
        B.options = Object.assign(B.options.requestTls || {}, {
          rejectUnauthorized: !1,
        });
      return B;
    }
    _performExponentialBackoff(A) {
      return wQ(this, void 0, void 0, function* () {
        A = Math.min(Gs, A);
        let Q = Us * Math.pow(2, A);
        return new Promise((B) => setTimeout(() => B(), Q));
      });
    }
    _processResponse(A, Q) {
      return wQ(this, void 0, void 0, function* () {
        return new Promise((B, I) =>
          wQ(this, void 0, void 0, function* () {
            let E = A.message.statusCode || 0,
              C = { statusCode: E, result: null, headers: {} };
            if (E === gI.NotFound) B(C);
            function g(J, Y) {
              if (typeof Y === "string") {
                let N = new Date(Y);
                if (!isNaN(N.valueOf())) return N;
              }
              return Y;
            }
            let F, D;
            try {
              if (((D = yield A.readBody()), D && D.length > 0)) {
                if (Q && Q.deserializeDates) F = JSON.parse(D, g);
                else F = JSON.parse(D);
                C.result = F;
              }
              C.headers = A.message.headers;
            } catch (J) {}
            if (E > 299) {
              let J;
              if (F && F.message) J = F.message;
              else if (D && D.length > 0) J = D;
              else J = `Failed request: (${E})`;
              let Y = new DJ(J, E);
              (Y.result = C.result), I(Y);
            } else B(C);
          }),
        );
      });
    }
  }
  iA.HttpClient = a7;
  var gJ = (A) =>
    Object.keys(A).reduce((Q, B) => ((Q[B.toLowerCase()] = A[B]), Q), {});
});
var XZ = Z((pI) => {
  var ZZ =
    (pI && pI.__awaiter) ||
    function (A, Q, B, I) {
      function E(C) {
        return C instanceof B
          ? C
          : new B(function (g) {
              g(C);
            });
      }
      return new (B || (B = Promise))(function (C, g) {
        function F(Y) {
          try {
            J(I.next(Y));
          } catch (N) {
            g(N);
          }
        }
        function D(Y) {
          try {
            J(I.throw(Y));
          } catch (N) {
            g(N);
          }
        }
        function J(Y) {
          Y.done ? C(Y.value) : E(Y.value).then(F, D);
        }
        J((I = I.apply(A, Q || [])).next());
      });
    };
  Object.defineProperty(pI, "__esModule", { value: !0 });
  pI.PersonalAccessTokenCredentialHandler =
    pI.BearerCredentialHandler =
    pI.BasicCredentialHandler =
      void 0;
  class o7 {
    constructor(A, Q) {
      (this.username = A), (this.password = Q);
    }
    prepareRequest(A) {
      if (!A.headers) throw Error("The request has no headers");
      A.headers.Authorization = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString("base64")}`;
    }
    canHandleAuthentication() {
      return !1;
    }
    handleAuthentication() {
      return ZZ(this, void 0, void 0, function* () {
        throw Error("not implemented");
      });
    }
  }
  pI.BasicCredentialHandler = o7;
  class s7 {
    constructor(A) {
      this.token = A;
    }
    prepareRequest(A) {
      if (!A.headers) throw Error("The request has no headers");
      A.headers.Authorization = `Bearer ${this.token}`;
    }
    canHandleAuthentication() {
      return !1;
    }
    handleAuthentication() {
      return ZZ(this, void 0, void 0, function* () {
        throw Error("not implemented");
      });
    }
  }
  pI.BearerCredentialHandler = s7;
  class r7 {
    constructor(A) {
      this.token = A;
    }
    prepareRequest(A) {
      if (!A.headers) throw Error("The request has no headers");
      A.headers.Authorization = `Basic ${Buffer.from(`PAT:${this.token}`).toString("base64")}`;
    }
    canHandleAuthentication() {
      return !1;
    }
    handleAuthentication() {
      return ZZ(this, void 0, void 0, function* () {
        throw Error("not implemented");
      });
    }
  }
  pI.PersonalAccessTokenCredentialHandler = r7;
});
var AR = Z((e0) => {
  var t7 =
    (e0 && e0.__awaiter) ||
    function (A, Q, B, I) {
      function E(C) {
        return C instanceof B
          ? C
          : new B(function (g) {
              g(C);
            });
      }
      return new (B || (B = Promise))(function (C, g) {
        function F(Y) {
          try {
            J(I.next(Y));
          } catch (N) {
            g(N);
          }
        }
        function D(Y) {
          try {
            J(I.throw(Y));
          } catch (N) {
            g(N);
          }
        }
        function J(Y) {
          Y.done ? C(Y.value) : E(Y.value).then(F, D);
        }
        J((I = I.apply(A, Q || [])).next());
      });
    };
  Object.defineProperty(e0, "__esModule", { value: !0 });
  e0.OidcClient = void 0;
  var Zs = OF(),
    Xs = XZ(),
    e7 = $B();
  class t0 {
    static createHttpClient(A = !0, Q = 10) {
      let B = { allowRetries: A, maxRetries: Q };
      return new Zs.HttpClient(
        "actions/oidc-client",
        [new Xs.BearerCredentialHandler(t0.getRequestToken())],
        B,
      );
    }
    static getRequestToken() {
      let A = process.env.ACTIONS_ID_TOKEN_REQUEST_TOKEN;
      if (!A)
        throw Error(
          "Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable",
        );
      return A;
    }
    static getIDTokenUrl() {
      let A = process.env.ACTIONS_ID_TOKEN_REQUEST_URL;
      if (!A)
        throw Error("Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable");
      return A;
    }
    static getCall(A) {
      var Q;
      return t7(this, void 0, void 0, function* () {
        let E =
          (Q = (yield t0
            .createHttpClient()
            .getJson(A)
            .catch((C) => {
              throw Error(`Failed to get ID Token. 
 
        Error Code : ${C.statusCode}
 
        Error Message: ${C.message}`);
            })).result) === null || Q === void 0
            ? void 0
            : Q.value;
        if (!E) throw Error("Response json body do not have ID Token field");
        return E;
      });
    }
    static getIDToken(A) {
      return t7(this, void 0, void 0, function* () {
        try {
          let Q = t0.getIDTokenUrl();
          if (A) {
            let I = encodeURIComponent(A);
            Q = `${Q}&audience=${I}`;
          }
          (0, e7.debug)(`ID token url is ${Q}`);
          let B = yield t0.getCall(Q);
          return (0, e7.setSecret)(B), B;
        } catch (Q) {
          throw Error(`Error message: ${Q.message}`);
        }
      });
    }
  }
  e0.OidcClient = t0;
});
var LZ = Z((HB) => {
  var wZ =
    (HB && HB.__awaiter) ||
    function (A, Q, B, I) {
      function E(C) {
        return C instanceof B
          ? C
          : new B(function (g) {
              g(C);
            });
      }
      return new (B || (B = Promise))(function (C, g) {
        function F(Y) {
          try {
            J(I.next(Y));
          } catch (N) {
            g(N);
          }
        }
        function D(Y) {
          try {
            J(I.throw(Y));
          } catch (N) {
            g(N);
          }
        }
        function J(Y) {
          Y.done ? C(Y.value) : E(Y.value).then(F, D);
        }
        J((I = I.apply(A, Q || [])).next());
      });
    };
  Object.defineProperty(HB, "__esModule", { value: !0 });
  HB.summary =
    HB.markdownSummary =
    HB.SUMMARY_DOCS_URL =
    HB.SUMMARY_ENV_VAR =
      void 0;
  var ws = $("os"),
    MZ = $("fs"),
    { access: Ms, appendFile: Ls, writeFile: Rs } = MZ.promises;
  HB.SUMMARY_ENV_VAR = "GITHUB_STEP_SUMMARY";
  HB.SUMMARY_DOCS_URL =
    "https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary";
  class QR {
    constructor() {
      this._buffer = "";
    }
    filePath() {
      return wZ(this, void 0, void 0, function* () {
        if (this._filePath) return this._filePath;
        let A = process.env[HB.SUMMARY_ENV_VAR];
        if (!A)
          throw Error(
            `Unable to find environment variable for $${HB.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`,
          );
        try {
          yield Ms(A, MZ.constants.R_OK | MZ.constants.W_OK);
        } catch (Q) {
          throw Error(
            `Unable to access summary file: '${A}'. Check if the file has correct read/write permissions.`,
          );
        }
        return (this._filePath = A), this._filePath;
      });
    }
    wrap(A, Q, B = {}) {
      let I = Object.entries(B)
        .map(([E, C]) => ` ${E}="${C}"`)
        .join("");
      if (!Q) return `<${A}${I}>`;
      return `<${A}${I}>${Q}</${A}>`;
    }
    write(A) {
      return wZ(this, void 0, void 0, function* () {
        let Q = !!(A === null || A === void 0 ? void 0 : A.overwrite),
          B = yield this.filePath();
        return (
          yield (Q ? Rs : Ls)(B, this._buffer, { encoding: "utf8" }),
          this.emptyBuffer()
        );
      });
    }
    clear() {
      return wZ(this, void 0, void 0, function* () {
        return this.emptyBuffer().write({ overwrite: !0 });
      });
    }
    stringify() {
      return this._buffer;
    }
    isEmptyBuffer() {
      return this._buffer.length === 0;
    }
    emptyBuffer() {
      return (this._buffer = ""), this;
    }
    addRaw(A, Q = !1) {
      return (this._buffer += A), Q ? this.addEOL() : this;
    }
    addEOL() {
      return this.addRaw(ws.EOL);
    }
    addCodeBlock(A, Q) {
      let B = Object.assign({}, Q && { lang: Q }),
        I = this.wrap("pre", this.wrap("code", A), B);
      return this.addRaw(I).addEOL();
    }
    addList(A, Q = !1) {
      let B = Q ? "ol" : "ul",
        I = A.map((C) => this.wrap("li", C)).join(""),
        E = this.wrap(B, I);
      return this.addRaw(E).addEOL();
    }
    addTable(A) {
      let Q = A.map((I) => {
          let E = I.map((C) => {
            if (typeof C === "string") return this.wrap("td", C);
            let { header: g, data: F, colspan: D, rowspan: J } = C,
              Y = g ? "th" : "td",
              N = Object.assign(
                Object.assign({}, D && { colspan: D }),
                J && { rowspan: J },
              );
            return this.wrap(Y, F, N);
          }).join("");
          return this.wrap("tr", E);
        }).join(""),
        B = this.wrap("table", Q);
      return this.addRaw(B).addEOL();
    }
    addDetails(A, Q) {
      let B = this.wrap("details", this.wrap("summary", A) + Q);
      return this.addRaw(B).addEOL();
    }
    addImage(A, Q, B) {
      let { width: I, height: E } = B || {},
        C = Object.assign(
          Object.assign({}, I && { width: I }),
          E && { height: E },
        ),
        g = this.wrap("img", null, Object.assign({ src: A, alt: Q }, C));
      return this.addRaw(g).addEOL();
    }
    addHeading(A, Q) {
      let B = `h${Q}`,
        I = ["h1", "h2", "h3", "h4", "h5", "h6"].includes(B) ? B : "h1",
        E = this.wrap(I, A);
      return this.addRaw(E).addEOL();
    }
    addSeparator() {
      let A = this.wrap("hr", null);
      return this.addRaw(A).addEOL();
    }
    addBreak() {
      let A = this.wrap("br", null);
      return this.addRaw(A).addEOL();
    }
    addQuote(A, Q) {
      let B = Object.assign({}, Q && { cite: Q }),
        I = this.wrap("blockquote", A, B);
      return this.addRaw(I).addEOL();
    }
    addLink(A, Q) {
      let B = this.wrap("a", A, { href: Q });
      return this.addRaw(B).addEOL();
    }
  }
  var BR = new QR();
  HB.markdownSummary = BR;
  HB.summary = BR;
});
var IR = Z((KB) => {
  var Vs =
      (KB && KB.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            var E = Object.getOwnPropertyDescriptor(Q, B);
            if (
              !E ||
              ("get" in E ? !Q.__esModule : E.writable || E.configurable)
            )
              E = {
                enumerable: !0,
                get: function () {
                  return Q[B];
                },
              };
            Object.defineProperty(A, I, E);
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    $s =
      (KB && KB.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    Hs =
      (KB && KB.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.prototype.hasOwnProperty.call(A, B))
              Vs(Q, A, B);
        }
        return $s(Q, A), Q;
      };
  Object.defineProperty(KB, "__esModule", { value: !0 });
  KB.toPlatformPath = KB.toWin32Path = KB.toPosixPath = void 0;
  var Ks = Hs($("path"));
  function zs(A) {
    return A.replace(/[\\]/g, "/");
  }
  KB.toPosixPath = zs;
  function Ts(A) {
    return A.replace(/[/]/g, "\\");
  }
  KB.toWin32Path = Ts;
  function Os(A) {
    return A.replace(/[/\\]/g, Ks.sep);
  }
  KB.toPlatformPath = Os;
});
var VZ = Z((i) => {
  var qs =
      (i && i.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            Object.defineProperty(A, I, {
              enumerable: !0,
              get: function () {
                return Q[B];
              },
            });
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    js =
      (i && i.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    CR =
      (i && i.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.hasOwnProperty.call(A, B))
              qs(Q, A, B);
        }
        return js(Q, A), Q;
      },
    RZ =
      (i && i.__awaiter) ||
      function (A, Q, B, I) {
        function E(C) {
          return C instanceof B
            ? C
            : new B(function (g) {
                g(C);
              });
        }
        return new (B || (B = Promise))(function (C, g) {
          function F(Y) {
            try {
              J(I.next(Y));
            } catch (N) {
              g(N);
            }
          }
          function D(Y) {
            try {
              J(I.throw(Y));
            } catch (N) {
              g(N);
            }
          }
          function J(Y) {
            Y.done ? C(Y.value) : E(Y.value).then(F, D);
          }
          J((I = I.apply(A, Q || [])).next());
        });
      },
    zB;
  Object.defineProperty(i, "__esModule", { value: !0 });
  i.getCmdPath =
    i.tryGetExecutablePath =
    i.isRooted =
    i.isDirectory =
    i.exists =
    i.READONLY =
    i.UV_FS_O_EXLOCK =
    i.IS_WINDOWS =
    i.unlink =
    i.symlink =
    i.stat =
    i.rmdir =
    i.rm =
    i.rename =
    i.readlink =
    i.readdir =
    i.open =
    i.mkdir =
    i.lstat =
    i.copyFile =
    i.chmod =
      void 0;
  var gR = CR($("fs")),
    YJ = CR($("path"));
  (zB = gR.promises),
    (i.chmod = zB.chmod),
    (i.copyFile = zB.copyFile),
    (i.lstat = zB.lstat),
    (i.mkdir = zB.mkdir),
    (i.open = zB.open),
    (i.readdir = zB.readdir),
    (i.readlink = zB.readlink),
    (i.rename = zB.rename),
    (i.rm = zB.rm),
    (i.rmdir = zB.rmdir),
    (i.stat = zB.stat),
    (i.symlink = zB.symlink),
    (i.unlink = zB.unlink);
  i.IS_WINDOWS = process.platform === "win32";
  i.UV_FS_O_EXLOCK = 268435456;
  i.READONLY = gR.constants.O_RDONLY;
  function fs(A) {
    return RZ(this, void 0, void 0, function* () {
      try {
        yield i.stat(A);
      } catch (Q) {
        if (Q.code === "ENOENT") return !1;
        throw Q;
      }
      return !0;
    });
  }
  i.exists = fs;
  function hs(A, Q = !1) {
    return RZ(this, void 0, void 0, function* () {
      return (Q ? yield i.stat(A) : yield i.lstat(A)).isDirectory();
    });
  }
  i.isDirectory = hs;
  function ks(A) {
    if (((A = vs(A)), !A))
      throw Error('isRooted() parameter "p" cannot be empty');
    if (i.IS_WINDOWS) return A.startsWith("\\") || /^[A-Z]:/i.test(A);
    return A.startsWith("/");
  }
  i.isRooted = ks;
  function xs(A, Q) {
    return RZ(this, void 0, void 0, function* () {
      let B = void 0;
      try {
        B = yield i.stat(A);
      } catch (E) {
        if (E.code !== "ENOENT")
          console.log(
            `Unexpected error attempting to determine if executable file exists '${A}': ${E}`,
          );
      }
      if (B && B.isFile()) {
        if (i.IS_WINDOWS) {
          let E = YJ.extname(A).toUpperCase();
          if (Q.some((C) => C.toUpperCase() === E)) return A;
        } else if (ER(B)) return A;
      }
      let I = A;
      for (let E of Q) {
        (A = I + E), (B = void 0);
        try {
          B = yield i.stat(A);
        } catch (C) {
          if (C.code !== "ENOENT")
            console.log(
              `Unexpected error attempting to determine if executable file exists '${A}': ${C}`,
            );
        }
        if (B && B.isFile()) {
          if (i.IS_WINDOWS) {
            try {
              let C = YJ.dirname(A),
                g = YJ.basename(A).toUpperCase();
              for (let F of yield i.readdir(C))
                if (g === F.toUpperCase()) {
                  A = YJ.join(C, F);
                  break;
                }
            } catch (C) {
              console.log(
                `Unexpected error attempting to determine the actual case of the file '${A}': ${C}`,
              );
            }
            return A;
          } else if (ER(B)) return A;
        }
      }
      return "";
    });
  }
  i.tryGetExecutablePath = xs;
  function vs(A) {
    if (((A = A || ""), i.IS_WINDOWS))
      return (A = A.replace(/\//g, "\\")), A.replace(/\\\\+/g, "\\");
    return A.replace(/\/\/+/g, "/");
  }
  function ER(A) {
    return (
      (A.mode & 1) > 0 ||
      ((A.mode & 8) > 0 && A.gid === process.getgid()) ||
      ((A.mode & 64) > 0 && A.uid === process.getuid())
    );
  }
  function Ps() {
    var A;
    return (A = process.env.COMSPEC) !== null && A !== void 0 ? A : "cmd.exe";
  }
  i.getCmdPath = Ps;
});
var qF = Z((NQ) => {
  var _s =
      (NQ && NQ.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            Object.defineProperty(A, I, {
              enumerable: !0,
              get: function () {
                return Q[B];
              },
            });
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    ys =
      (NQ && NQ.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    FR =
      (NQ && NQ.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.hasOwnProperty.call(A, B))
              _s(Q, A, B);
        }
        return ys(Q, A), Q;
      },
    sE =
      (NQ && NQ.__awaiter) ||
      function (A, Q, B, I) {
        function E(C) {
          return C instanceof B
            ? C
            : new B(function (g) {
                g(C);
              });
        }
        return new (B || (B = Promise))(function (C, g) {
          function F(Y) {
            try {
              J(I.next(Y));
            } catch (N) {
              g(N);
            }
          }
          function D(Y) {
            try {
              J(I.throw(Y));
            } catch (N) {
              g(N);
            }
          }
          function J(Y) {
            Y.done ? C(Y.value) : E(Y.value).then(F, D);
          }
          J((I = I.apply(A, Q || [])).next());
        });
      };
  Object.defineProperty(NQ, "__esModule", { value: !0 });
  NQ.findInPath = NQ.which = NQ.mkdirP = NQ.rmRF = NQ.mv = NQ.cp = void 0;
  var Ss = $("assert"),
    iI = FR($("path")),
    qA = FR(VZ());
  function bs(A, Q, B = {}) {
    return sE(this, void 0, void 0, function* () {
      let { force: I, recursive: E, copySourceDirectory: C } = ds(B),
        g = (yield qA.exists(Q)) ? yield qA.stat(Q) : null;
      if (g && g.isFile() && !I) return;
      let F = g && g.isDirectory() && C ? iI.join(Q, iI.basename(A)) : Q;
      if (!(yield qA.exists(A))) throw Error(`no such file or directory: ${A}`);
      if ((yield qA.stat(A)).isDirectory())
        if (!E)
          throw Error(
            `Failed to copy. ${A} is a directory, but tried to copy without recursive flag.`,
          );
        else yield NR(A, F, 0, I);
      else {
        if (iI.relative(A, F) === "")
          throw Error(`'${F}' and '${A}' are the same file`);
        yield GR(A, F, I);
      }
    });
  }
  NQ.cp = bs;
  function ms(A, Q, B = {}) {
    return sE(this, void 0, void 0, function* () {
      if (yield qA.exists(Q)) {
        let I = !0;
        if (yield qA.isDirectory(Q))
          (Q = iI.join(Q, iI.basename(A))), (I = yield qA.exists(Q));
        if (I)
          if (B.force == null || B.force) yield DR(Q);
          else throw Error("Destination already exists");
      }
      yield $Z(iI.dirname(Q)), yield qA.rename(A, Q);
    });
  }
  NQ.mv = ms;
  function DR(A) {
    return sE(this, void 0, void 0, function* () {
      if (qA.IS_WINDOWS) {
        if (/[*"<>|]/.test(A))
          throw Error(
            'File path must not contain `*`, `"`, `<`, `>` or `|` on Windows',
          );
      }
      try {
        yield qA.rm(A, {
          force: !0,
          maxRetries: 3,
          recursive: !0,
          retryDelay: 300,
        });
      } catch (Q) {
        throw Error(`File was unable to be removed ${Q}`);
      }
    });
  }
  NQ.rmRF = DR;
  function $Z(A) {
    return sE(this, void 0, void 0, function* () {
      Ss.ok(A, "a path argument must be provided"),
        yield qA.mkdir(A, { recursive: !0 });
    });
  }
  NQ.mkdirP = $Z;
  function YR(A, Q) {
    return sE(this, void 0, void 0, function* () {
      if (!A) throw Error("parameter 'tool' is required");
      if (Q) {
        let I = yield YR(A, !1);
        if (!I)
          if (qA.IS_WINDOWS)
            throw Error(
              `Unable to locate executable file: ${A}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`,
            );
          else
            throw Error(
              `Unable to locate executable file: ${A}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`,
            );
        return I;
      }
      let B = yield JR(A);
      if (B && B.length > 0) return B[0];
      return "";
    });
  }
  NQ.which = YR;
  function JR(A) {
    return sE(this, void 0, void 0, function* () {
      if (!A) throw Error("parameter 'tool' is required");
      let Q = [];
      if (qA.IS_WINDOWS && process.env.PATHEXT) {
        for (let E of process.env.PATHEXT.split(iI.delimiter)) if (E) Q.push(E);
      }
      if (qA.isRooted(A)) {
        let E = yield qA.tryGetExecutablePath(A, Q);
        if (E) return [E];
        return [];
      }
      if (A.includes(iI.sep)) return [];
      let B = [];
      if (process.env.PATH) {
        for (let E of process.env.PATH.split(iI.delimiter)) if (E) B.push(E);
      }
      let I = [];
      for (let E of B) {
        let C = yield qA.tryGetExecutablePath(iI.join(E, A), Q);
        if (C) I.push(C);
      }
      return I;
    });
  }
  NQ.findInPath = JR;
  function ds(A) {
    let Q = A.force == null ? !0 : A.force,
      B = Boolean(A.recursive),
      I = A.copySourceDirectory == null ? !0 : Boolean(A.copySourceDirectory);
    return { force: Q, recursive: B, copySourceDirectory: I };
  }
  function NR(A, Q, B, I) {
    return sE(this, void 0, void 0, function* () {
      if (B >= 255) return;
      B++, yield $Z(Q);
      let E = yield qA.readdir(A);
      for (let C of E) {
        let g = `${A}/${C}`,
          F = `${Q}/${C}`;
        if ((yield qA.lstat(g)).isDirectory()) yield NR(g, F, B, I);
        else yield GR(g, F, I);
      }
      yield qA.chmod(Q, (yield qA.stat(A)).mode);
    });
  }
  function GR(A, Q, B) {
    return sE(this, void 0, void 0, function* () {
      if ((yield qA.lstat(A)).isSymbolicLink()) {
        try {
          yield qA.lstat(Q), yield qA.unlink(Q);
        } catch (E) {
          if (E.code === "EPERM") yield qA.chmod(Q, "0666"), yield qA.unlink(Q);
        }
        let I = yield qA.readlink(A);
        yield qA.symlink(I, Q, qA.IS_WINDOWS ? "junction" : null);
      } else if (!(yield qA.exists(Q)) || B) yield qA.copyFile(A, Q);
    });
  }
});
var wR = Z((TB) => {
  var cs =
      (TB && TB.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            Object.defineProperty(A, I, {
              enumerable: !0,
              get: function () {
                return Q[B];
              },
            });
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    us =
      (TB && TB.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    Ag =
      (TB && TB.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.hasOwnProperty.call(A, B))
              cs(Q, A, B);
        }
        return us(Q, A), Q;
      },
    UR =
      (TB && TB.__awaiter) ||
      function (A, Q, B, I) {
        function E(C) {
          return C instanceof B
            ? C
            : new B(function (g) {
                g(C);
              });
        }
        return new (B || (B = Promise))(function (C, g) {
          function F(Y) {
            try {
              J(I.next(Y));
            } catch (N) {
              g(N);
            }
          }
          function D(Y) {
            try {
              J(I.throw(Y));
            } catch (N) {
              g(N);
            }
          }
          function J(Y) {
            Y.done ? C(Y.value) : E(Y.value).then(F, D);
          }
          J((I = I.apply(A, Q || [])).next());
        });
      };
  Object.defineProperty(TB, "__esModule", { value: !0 });
  TB.argStringToArray = TB.ToolRunner = void 0;
  var JJ = Ag($("os")),
    ZR = Ag($("events")),
    ls = Ag($("child_process")),
    ps = Ag($("path")),
    is = Ag(qF()),
    WR = Ag(VZ()),
    ns = $("timers"),
    NJ = process.platform === "win32";
  class XR extends ZR.EventEmitter {
    constructor(A, Q, B) {
      super();
      if (!A) throw Error("Parameter 'toolPath' cannot be null or empty.");
      (this.toolPath = A), (this.args = Q || []), (this.options = B || {});
    }
    _debug(A) {
      if (this.options.listeners && this.options.listeners.debug)
        this.options.listeners.debug(A);
    }
    _getCommandString(A, Q) {
      let B = this._getSpawnFileName(),
        I = this._getSpawnArgs(A),
        E = Q ? "" : "[command]";
      if (NJ)
        if (this._isCmdFile()) {
          E += B;
          for (let C of I) E += ` ${C}`;
        } else if (A.windowsVerbatimArguments) {
          E += `"${B}"`;
          for (let C of I) E += ` ${C}`;
        } else {
          E += this._windowsQuoteCmdArg(B);
          for (let C of I) E += ` ${this._windowsQuoteCmdArg(C)}`;
        }
      else {
        E += B;
        for (let C of I) E += ` ${C}`;
      }
      return E;
    }
    _processLineBuffer(A, Q, B) {
      try {
        let I = Q + A.toString(),
          E = I.indexOf(JJ.EOL);
        while (E > -1) {
          let C = I.substring(0, E);
          B(C), (I = I.substring(E + JJ.EOL.length)), (E = I.indexOf(JJ.EOL));
        }
        return I;
      } catch (I) {
        return this._debug(`error processing line. Failed with error ${I}`), "";
      }
    }
    _getSpawnFileName() {
      if (NJ) {
        if (this._isCmdFile()) return process.env.COMSPEC || "cmd.exe";
      }
      return this.toolPath;
    }
    _getSpawnArgs(A) {
      if (NJ) {
        if (this._isCmdFile()) {
          let Q = `/D /S /C "${this._windowsQuoteCmdArg(this.toolPath)}`;
          for (let B of this.args)
            (Q += " "),
              (Q += A.windowsVerbatimArguments
                ? B
                : this._windowsQuoteCmdArg(B));
          return (Q += '"'), [Q];
        }
      }
      return this.args;
    }
    _endsWith(A, Q) {
      return A.endsWith(Q);
    }
    _isCmdFile() {
      let A = this.toolPath.toUpperCase();
      return this._endsWith(A, ".CMD") || this._endsWith(A, ".BAT");
    }
    _windowsQuoteCmdArg(A) {
      if (!this._isCmdFile()) return this._uvQuoteCmdArg(A);
      if (!A) return '""';
      let Q = [
          " ",
          "\t",
          "&",
          "(",
          ")",
          "[",
          "]",
          "{",
          "}",
          "^",
          "=",
          ";",
          "!",
          "'",
          "+",
          ",",
          "`",
          "~",
          "|",
          "<",
          ">",
          '"',
        ],
        B = !1;
      for (let C of A)
        if (Q.some((g) => g === C)) {
          B = !0;
          break;
        }
      if (!B) return A;
      let I = '"',
        E = !0;
      for (let C = A.length; C > 0; C--)
        if (((I += A[C - 1]), E && A[C - 1] === "\\")) I += "\\";
        else if (A[C - 1] === '"') (E = !0), (I += '"');
        else E = !1;
      return (I += '"'), I.split("").reverse().join("");
    }
    _uvQuoteCmdArg(A) {
      if (!A) return '""';
      if (!A.includes(" ") && !A.includes("\t") && !A.includes('"')) return A;
      if (!A.includes('"') && !A.includes("\\")) return `"${A}"`;
      let Q = '"',
        B = !0;
      for (let I = A.length; I > 0; I--)
        if (((Q += A[I - 1]), B && A[I - 1] === "\\")) Q += "\\";
        else if (A[I - 1] === '"') (B = !0), (Q += "\\");
        else B = !1;
      return (Q += '"'), Q.split("").reverse().join("");
    }
    _cloneExecOptions(A) {
      A = A || {};
      let Q = {
        cwd: A.cwd || process.cwd(),
        env: A.env || process.env,
        silent: A.silent || !1,
        windowsVerbatimArguments: A.windowsVerbatimArguments || !1,
        failOnStdErr: A.failOnStdErr || !1,
        ignoreReturnCode: A.ignoreReturnCode || !1,
        delay: A.delay || 1e4,
      };
      return (
        (Q.outStream = A.outStream || process.stdout),
        (Q.errStream = A.errStream || process.stderr),
        Q
      );
    }
    _getSpawnOptions(A, Q) {
      A = A || {};
      let B = {};
      if (
        ((B.cwd = A.cwd),
        (B.env = A.env),
        (B.windowsVerbatimArguments =
          A.windowsVerbatimArguments || this._isCmdFile()),
        A.windowsVerbatimArguments)
      )
        B.argv0 = `"${Q}"`;
      return B;
    }
    exec() {
      return UR(this, void 0, void 0, function* () {
        if (
          !WR.isRooted(this.toolPath) &&
          (this.toolPath.includes("/") || (NJ && this.toolPath.includes("\\")))
        )
          this.toolPath = ps.resolve(
            process.cwd(),
            this.options.cwd || process.cwd(),
            this.toolPath,
          );
        return (
          (this.toolPath = yield is.which(this.toolPath, !0)),
          new Promise((A, Q) =>
            UR(this, void 0, void 0, function* () {
              this._debug(`exec tool: ${this.toolPath}`),
                this._debug("arguments:");
              for (let D of this.args) this._debug(`   ${D}`);
              let B = this._cloneExecOptions(this.options);
              if (!B.silent && B.outStream)
                B.outStream.write(this._getCommandString(B) + JJ.EOL);
              let I = new HZ(B, this.toolPath);
              if (
                (I.on("debug", (D) => {
                  this._debug(D);
                }),
                this.options.cwd && !(yield WR.exists(this.options.cwd)))
              )
                return Q(Error(`The cwd: ${this.options.cwd} does not exist!`));
              let E = this._getSpawnFileName(),
                C = ls.spawn(
                  E,
                  this._getSpawnArgs(B),
                  this._getSpawnOptions(this.options, E),
                ),
                g = "";
              if (C.stdout)
                C.stdout.on("data", (D) => {
                  if (this.options.listeners && this.options.listeners.stdout)
                    this.options.listeners.stdout(D);
                  if (!B.silent && B.outStream) B.outStream.write(D);
                  g = this._processLineBuffer(D, g, (J) => {
                    if (
                      this.options.listeners &&
                      this.options.listeners.stdline
                    )
                      this.options.listeners.stdline(J);
                  });
                });
              let F = "";
              if (C.stderr)
                C.stderr.on("data", (D) => {
                  if (
                    ((I.processStderr = !0),
                    this.options.listeners && this.options.listeners.stderr)
                  )
                    this.options.listeners.stderr(D);
                  if (!B.silent && B.errStream && B.outStream)
                    (B.failOnStdErr ? B.errStream : B.outStream).write(D);
                  F = this._processLineBuffer(D, F, (J) => {
                    if (
                      this.options.listeners &&
                      this.options.listeners.errline
                    )
                      this.options.listeners.errline(J);
                  });
                });
              if (
                (C.on("error", (D) => {
                  (I.processError = D.message),
                    (I.processExited = !0),
                    (I.processClosed = !0),
                    I.CheckComplete();
                }),
                C.on("exit", (D) => {
                  (I.processExitCode = D),
                    (I.processExited = !0),
                    this._debug(
                      `Exit code ${D} received from tool '${this.toolPath}'`,
                    ),
                    I.CheckComplete();
                }),
                C.on("close", (D) => {
                  (I.processExitCode = D),
                    (I.processExited = !0),
                    (I.processClosed = !0),
                    this._debug(
                      `STDIO streams have closed for tool '${this.toolPath}'`,
                    ),
                    I.CheckComplete();
                }),
                I.on("done", (D, J) => {
                  if (g.length > 0) this.emit("stdline", g);
                  if (F.length > 0) this.emit("errline", F);
                  if ((C.removeAllListeners(), D)) Q(D);
                  else A(J);
                }),
                this.options.input)
              ) {
                if (!C.stdin) throw Error("child process missing stdin");
                C.stdin.end(this.options.input);
              }
            }),
          )
        );
      });
    }
  }
  TB.ToolRunner = XR;
  function as(A) {
    let Q = [],
      B = !1,
      I = !1,
      E = "";
    function C(g) {
      if (I && g !== '"') E += "\\";
      (E += g), (I = !1);
    }
    for (let g = 0; g < A.length; g++) {
      let F = A.charAt(g);
      if (F === '"') {
        if (!I) B = !B;
        else C(F);
        continue;
      }
      if (F === "\\" && I) {
        C(F);
        continue;
      }
      if (F === "\\" && B) {
        I = !0;
        continue;
      }
      if (F === " " && !B) {
        if (E.length > 0) Q.push(E), (E = "");
        continue;
      }
      C(F);
    }
    if (E.length > 0) Q.push(E.trim());
    return Q;
  }
  TB.argStringToArray = as;
  class HZ extends ZR.EventEmitter {
    constructor(A, Q) {
      super();
      if (
        ((this.processClosed = !1),
        (this.processError = ""),
        (this.processExitCode = 0),
        (this.processExited = !1),
        (this.processStderr = !1),
        (this.delay = 1e4),
        (this.done = !1),
        (this.timeout = null),
        !Q)
      )
        throw Error("toolPath must not be empty");
      if (((this.options = A), (this.toolPath = Q), A.delay))
        this.delay = A.delay;
    }
    CheckComplete() {
      if (this.done) return;
      if (this.processClosed) this._setResult();
      else if (this.processExited)
        this.timeout = ns.setTimeout(HZ.HandleTimeout, this.delay, this);
    }
    _debug(A) {
      this.emit("debug", A);
    }
    _setResult() {
      let A;
      if (this.processExited) {
        if (this.processError)
          A = Error(
            `There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`,
          );
        else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode)
          A = Error(
            `The process '${this.toolPath}' failed with exit code ${this.processExitCode}`,
          );
        else if (this.processStderr && this.options.failOnStdErr)
          A = Error(
            `The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`,
          );
      }
      if (this.timeout) clearTimeout(this.timeout), (this.timeout = null);
      (this.done = !0), this.emit("done", A, this.processExitCode);
    }
    static HandleTimeout(A) {
      if (A.done) return;
      if (!A.processClosed && A.processExited) {
        let Q = `The STDIO streams did not close within ${A.delay / 1000} seconds of the exit event from process '${A.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;
        A._debug(Q);
      }
      A._setResult();
    }
  }
});
var Qg = Z((OB) => {
  var os =
      (OB && OB.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            Object.defineProperty(A, I, {
              enumerable: !0,
              get: function () {
                return Q[B];
              },
            });
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    ss =
      (OB && OB.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    rs =
      (OB && OB.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.hasOwnProperty.call(A, B))
              os(Q, A, B);
        }
        return ss(Q, A), Q;
      },
    RR =
      (OB && OB.__awaiter) ||
      function (A, Q, B, I) {
        function E(C) {
          return C instanceof B
            ? C
            : new B(function (g) {
                g(C);
              });
        }
        return new (B || (B = Promise))(function (C, g) {
          function F(Y) {
            try {
              J(I.next(Y));
            } catch (N) {
              g(N);
            }
          }
          function D(Y) {
            try {
              J(I.throw(Y));
            } catch (N) {
              g(N);
            }
          }
          function J(Y) {
            Y.done ? C(Y.value) : E(Y.value).then(F, D);
          }
          J((I = I.apply(A, Q || [])).next());
        });
      };
  Object.defineProperty(OB, "__esModule", { value: !0 });
  OB.getExecOutput = OB.exec = void 0;
  var MR = $("string_decoder"),
    LR = rs(wR());
  function VR(A, Q, B) {
    return RR(this, void 0, void 0, function* () {
      let I = LR.argStringToArray(A);
      if (I.length === 0)
        throw Error("Parameter 'commandLine' cannot be null or empty.");
      let E = I[0];
      return (
        (Q = I.slice(1).concat(Q || [])), new LR.ToolRunner(E, Q, B).exec()
      );
    });
  }
  OB.exec = VR;
  function ts(A, Q, B) {
    var I, E;
    return RR(this, void 0, void 0, function* () {
      let C = "",
        g = "",
        F = new MR.StringDecoder("utf8"),
        D = new MR.StringDecoder("utf8"),
        J =
          (I = B === null || B === void 0 ? void 0 : B.listeners) === null ||
          I === void 0
            ? void 0
            : I.stdout,
        Y =
          (E = B === null || B === void 0 ? void 0 : B.listeners) === null ||
          E === void 0
            ? void 0
            : E.stderr,
        N = (L) => {
          if (((g += D.write(L)), Y)) Y(L);
        },
        W = (L) => {
          if (((C += F.write(L)), J)) J(L);
        },
        X = Object.assign(
          Object.assign({}, B === null || B === void 0 ? void 0 : B.listeners),
          { stdout: W, stderr: N },
        ),
        M = yield VR(
          A,
          Q,
          Object.assign(Object.assign({}, B), { listeners: X }),
        );
      return (
        (C += F.end()), (g += D.end()), { exitCode: M, stdout: C, stderr: g }
      );
    });
  }
  OB.getExecOutput = ts;
});
var HR = Z((KA) => {
  var es =
      (KA && KA.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            var E = Object.getOwnPropertyDescriptor(Q, B);
            if (
              !E ||
              ("get" in E ? !Q.__esModule : E.writable || E.configurable)
            )
              E = {
                enumerable: !0,
                get: function () {
                  return Q[B];
                },
              };
            Object.defineProperty(A, I, E);
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    Ar =
      (KA && KA.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    Qr =
      (KA && KA.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.prototype.hasOwnProperty.call(A, B))
              es(Q, A, B);
        }
        return Ar(Q, A), Q;
      },
    UJ =
      (KA && KA.__awaiter) ||
      function (A, Q, B, I) {
        function E(C) {
          return C instanceof B
            ? C
            : new B(function (g) {
                g(C);
              });
        }
        return new (B || (B = Promise))(function (C, g) {
          function F(Y) {
            try {
              J(I.next(Y));
            } catch (N) {
              g(N);
            }
          }
          function D(Y) {
            try {
              J(I.throw(Y));
            } catch (N) {
              g(N);
            }
          }
          function J(Y) {
            Y.done ? C(Y.value) : E(Y.value).then(F, D);
          }
          J((I = I.apply(A, Q || [])).next());
        });
      },
    Br =
      (KA && KA.__importDefault) ||
      function (A) {
        return A && A.__esModule ? A : { default: A };
      };
  Object.defineProperty(KA, "__esModule", { value: !0 });
  KA.getDetails =
    KA.isLinux =
    KA.isMacOS =
    KA.isWindows =
    KA.arch =
    KA.platform =
      void 0;
  var $R = Br($("os")),
    GJ = Qr(Qg()),
    Ir = () =>
      UJ(void 0, void 0, void 0, function* () {
        let { stdout: A } = yield GJ.getExecOutput(
            'powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Version"',
            void 0,
            { silent: !0 },
          ),
          { stdout: Q } = yield GJ.getExecOutput(
            'powershell -command "(Get-CimInstance -ClassName Win32_OperatingSystem).Caption"',
            void 0,
            { silent: !0 },
          );
        return { name: Q.trim(), version: A.trim() };
      }),
    Er = () =>
      UJ(void 0, void 0, void 0, function* () {
        var A, Q, B, I;
        let { stdout: E } = yield GJ.getExecOutput("sw_vers", void 0, {
            silent: !0,
          }),
          C =
            (Q =
              (A = E.match(/ProductVersion:\s*(.+)/)) === null || A === void 0
                ? void 0
                : A[1]) !== null && Q !== void 0
              ? Q
              : "";
        return {
          name:
            (I =
              (B = E.match(/ProductName:\s*(.+)/)) === null || B === void 0
                ? void 0
                : B[1]) !== null && I !== void 0
              ? I
              : "",
          version: C,
        };
      }),
    Cr = () =>
      UJ(void 0, void 0, void 0, function* () {
        let { stdout: A } = yield GJ.getExecOutput(
            "lsb_release",
            ["-i", "-r", "-s"],
            { silent: !0 },
          ),
          [Q, B] = A.trim().split(`
`);
        return { name: Q, version: B };
      });
  KA.platform = $R.default.platform();
  KA.arch = $R.default.arch();
  KA.isWindows = KA.platform === "win32";
  KA.isMacOS = KA.platform === "darwin";
  KA.isLinux = KA.platform === "linux";
  function gr() {
    return UJ(this, void 0, void 0, function* () {
      return Object.assign(
        Object.assign({}, yield KA.isWindows ? Ir() : KA.isMacOS ? Er() : Cr()),
        {
          platform: KA.platform,
          arch: KA.arch,
          isWindows: KA.isWindows,
          isMacOS: KA.isMacOS,
          isLinux: KA.isLinux,
        },
      );
    });
  }
  KA.getDetails = gr;
});
var $B = Z((l) => {
  var Fr =
      (l && l.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            var E = Object.getOwnPropertyDescriptor(Q, B);
            if (
              !E ||
              ("get" in E ? !Q.__esModule : E.writable || E.configurable)
            )
              E = {
                enumerable: !0,
                get: function () {
                  return Q[B];
                },
              };
            Object.defineProperty(A, I, E);
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    Dr =
      (l && l.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    zZ =
      (l && l.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.prototype.hasOwnProperty.call(A, B))
              Fr(Q, A, B);
        }
        return Dr(Q, A), Q;
      },
    KR =
      (l && l.__awaiter) ||
      function (A, Q, B, I) {
        function E(C) {
          return C instanceof B
            ? C
            : new B(function (g) {
                g(C);
              });
        }
        return new (B || (B = Promise))(function (C, g) {
          function F(Y) {
            try {
              J(I.next(Y));
            } catch (N) {
              g(N);
            }
          }
          function D(Y) {
            try {
              J(I.throw(Y));
            } catch (N) {
              g(N);
            }
          }
          function J(Y) {
            Y.done ? C(Y.value) : E(Y.value).then(F, D);
          }
          J((I = I.apply(A, Q || [])).next());
        });
      };
  Object.defineProperty(l, "__esModule", { value: !0 });
  l.platform =
    l.toPlatformPath =
    l.toWin32Path =
    l.toPosixPath =
    l.markdownSummary =
    l.summary =
    l.getIDToken =
    l.getState =
    l.saveState =
    l.group =
    l.endGroup =
    l.startGroup =
    l.info =
    l.notice =
    l.warning =
    l.error =
    l.debug =
    l.isDebug =
    l.setFailed =
    l.setCommandEcho =
    l.setOutput =
    l.getBooleanInput =
    l.getMultilineInput =
    l.getInput =
    l.addPath =
    l.setSecret =
    l.exportVariable =
    l.ExitCode =
      void 0;
  var FI = Dw(),
    cC = Nw(),
    Bg = qD(),
    zR = zZ($("os")),
    Yr = zZ($("path")),
    Jr = AR(),
    KZ;
  (function (A) {
    (A[(A.Success = 0)] = "Success"), (A[(A.Failure = 1)] = "Failure");
  })(KZ || (l.ExitCode = KZ = {}));
  function Nr(A, Q) {
    let B = (0, Bg.toCommandValue)(Q);
    if (((process.env[A] = B), process.env.GITHUB_ENV || ""))
      return (0, cC.issueFileCommand)(
        "ENV",
        (0, cC.prepareKeyValueMessage)(A, Q),
      );
    (0, FI.issueCommand)("set-env", { name: A }, B);
  }
  l.exportVariable = Nr;
  function Gr(A) {
    (0, FI.issueCommand)("add-mask", {}, A);
  }
  l.setSecret = Gr;
  function Ur(A) {
    if (process.env.GITHUB_PATH || "") (0, cC.issueFileCommand)("PATH", A);
    else (0, FI.issueCommand)("add-path", {}, A);
    process.env.PATH = `${A}${Yr.delimiter}${process.env.PATH}`;
  }
  l.addPath = Ur;
  function TZ(A, Q) {
    let B = process.env[`INPUT_${A.replace(/ /g, "_").toUpperCase()}`] || "";
    if (Q && Q.required && !B)
      throw Error(`Input required and not supplied: ${A}`);
    if (Q && Q.trimWhitespace === !1) return B;
    return B.trim();
  }
  l.getInput = TZ;
  function Wr(A, Q) {
    let B = TZ(A, Q)
      .split(
        `
`,
      )
      .filter((I) => I !== "");
    if (Q && Q.trimWhitespace === !1) return B;
    return B.map((I) => I.trim());
  }
  l.getMultilineInput = Wr;
  function Zr(A, Q) {
    let B = ["true", "True", "TRUE"],
      I = ["false", "False", "FALSE"],
      E = TZ(A, Q);
    if (B.includes(E)) return !0;
    if (I.includes(E)) return !1;
    throw TypeError(`Input does not meet YAML 1.2 "Core Schema" specification: ${A}
Support boolean input list: \`true | True | TRUE | false | False | FALSE\``);
  }
  l.getBooleanInput = Zr;
  function Xr(A, Q) {
    if (process.env.GITHUB_OUTPUT || "")
      return (0, cC.issueFileCommand)(
        "OUTPUT",
        (0, cC.prepareKeyValueMessage)(A, Q),
      );
    process.stdout.write(zR.EOL),
      (0, FI.issueCommand)(
        "set-output",
        { name: A },
        (0, Bg.toCommandValue)(Q),
      );
  }
  l.setOutput = Xr;
  function wr(A) {
    (0, FI.issue)("echo", A ? "on" : "off");
  }
  l.setCommandEcho = wr;
  function Mr(A) {
    (process.exitCode = KZ.Failure), TR(A);
  }
  l.setFailed = Mr;
  function Lr() {
    return process.env.RUNNER_DEBUG === "1";
  }
  l.isDebug = Lr;
  function Rr(A) {
    (0, FI.issueCommand)("debug", {}, A);
  }
  l.debug = Rr;
  function TR(A, Q = {}) {
    (0, FI.issueCommand)(
      "error",
      (0, Bg.toCommandProperties)(Q),
      A instanceof Error ? A.toString() : A,
    );
  }
  l.error = TR;
  function Vr(A, Q = {}) {
    (0, FI.issueCommand)(
      "warning",
      (0, Bg.toCommandProperties)(Q),
      A instanceof Error ? A.toString() : A,
    );
  }
  l.warning = Vr;
  function $r(A, Q = {}) {
    (0, FI.issueCommand)(
      "notice",
      (0, Bg.toCommandProperties)(Q),
      A instanceof Error ? A.toString() : A,
    );
  }
  l.notice = $r;
  function Hr(A) {
    process.stdout.write(A + zR.EOL);
  }
  l.info = Hr;
  function OR(A) {
    (0, FI.issue)("group", A);
  }
  l.startGroup = OR;
  function qR() {
    (0, FI.issue)("endgroup");
  }
  l.endGroup = qR;
  function Kr(A, Q) {
    return KR(this, void 0, void 0, function* () {
      OR(A);
      let B;
      try {
        B = yield Q();
      } finally {
        qR();
      }
      return B;
    });
  }
  l.group = Kr;
  function zr(A, Q) {
    if (process.env.GITHUB_STATE || "")
      return (0, cC.issueFileCommand)(
        "STATE",
        (0, cC.prepareKeyValueMessage)(A, Q),
      );
    (0, FI.issueCommand)("save-state", { name: A }, (0, Bg.toCommandValue)(Q));
  }
  l.saveState = zr;
  function Tr(A) {
    return process.env[`STATE_${A}`] || "";
  }
  l.getState = Tr;
  function Or(A) {
    return KR(this, void 0, void 0, function* () {
      return yield Jr.OidcClient.getIDToken(A);
    });
  }
  l.getIDToken = Or;
  var qr = LZ();
  Object.defineProperty(l, "summary", {
    enumerable: !0,
    get: function () {
      return qr.summary;
    },
  });
  var jr = LZ();
  Object.defineProperty(l, "markdownSummary", {
    enumerable: !0,
    get: function () {
      return jr.markdownSummary;
    },
  });
  var OZ = IR();
  Object.defineProperty(l, "toPosixPath", {
    enumerable: !0,
    get: function () {
      return OZ.toPosixPath;
    },
  });
  Object.defineProperty(l, "toWin32Path", {
    enumerable: !0,
    get: function () {
      return OZ.toWin32Path;
    },
  });
  Object.defineProperty(l, "toPlatformPath", {
    enumerable: !0,
    get: function () {
      return OZ.toPlatformPath;
    },
  });
  l.platform = zZ(HR());
});
var vR = Z((nI) => {
  var kr =
      (nI && nI.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            Object.defineProperty(A, I, {
              enumerable: !0,
              get: function () {
                return Q[B];
              },
            });
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    xr =
      (nI && nI.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    vr =
      (nI && nI.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.hasOwnProperty.call(A, B))
              kr(Q, A, B);
        }
        return xr(Q, A), Q;
      };
  Object.defineProperty(nI, "__esModule", { value: !0 });
  nI.getOptions = void 0;
  var hZ = vr($B());
  function Pr(A) {
    let Q = {
      followSymbolicLinks: !0,
      implicitDescendants: !0,
      omitBrokenSymbolicLinks: !0,
    };
    if (A) {
      if (typeof A.followSymbolicLinks === "boolean")
        (Q.followSymbolicLinks = A.followSymbolicLinks),
          hZ.debug(`followSymbolicLinks '${Q.followSymbolicLinks}'`);
      if (typeof A.implicitDescendants === "boolean")
        (Q.implicitDescendants = A.implicitDescendants),
          hZ.debug(`implicitDescendants '${Q.implicitDescendants}'`);
      if (typeof A.omitBrokenSymbolicLinks === "boolean")
        (Q.omitBrokenSymbolicLinks = A.omitBrokenSymbolicLinks),
          hZ.debug(`omitBrokenSymbolicLinks '${Q.omitBrokenSymbolicLinks}'`);
    }
    return Q;
  }
  nI.getOptions = Pr;
});
var ZJ = Z((GQ) => {
  var _r =
      (GQ && GQ.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            Object.defineProperty(A, I, {
              enumerable: !0,
              get: function () {
                return Q[B];
              },
            });
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    yr =
      (GQ && GQ.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    Sr =
      (GQ && GQ.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.hasOwnProperty.call(A, B))
              _r(Q, A, B);
        }
        return yr(Q, A), Q;
      },
    br =
      (GQ && GQ.__importDefault) ||
      function (A) {
        return A && A.__esModule ? A : { default: A };
      };
  Object.defineProperty(GQ, "__esModule", { value: !0 });
  GQ.safeTrimTrailingSeparator =
    GQ.normalizeSeparators =
    GQ.hasRoot =
    GQ.hasAbsoluteRoot =
    GQ.ensureAbsoluteRoot =
    GQ.dirname =
      void 0;
  var WJ = Sr($("path")),
    lC = br($("assert")),
    tE = process.platform === "win32";
  function mr(A) {
    if (((A = xZ(A)), tE && /^\\\\[^\\]+(\\[^\\]+)?$/.test(A))) return A;
    let Q = WJ.dirname(A);
    if (tE && /^\\\\[^\\]+\\[^\\]+\\$/.test(Q)) Q = xZ(Q);
    return Q;
  }
  GQ.dirname = mr;
  function dr(A, Q) {
    if (
      (lC.default(A, "ensureAbsoluteRoot parameter 'root' must not be empty"),
      lC.default(
        Q,
        "ensureAbsoluteRoot parameter 'itemPath' must not be empty",
      ),
      kZ(Q))
    )
      return Q;
    if (tE) {
      if (Q.match(/^[A-Z]:[^\\/]|^[A-Z]:$/i)) {
        let B = process.cwd();
        if (
          (lC.default(
            B.match(/^[A-Z]:\\/i),
            `Expected current directory to start with an absolute drive root. Actual '${B}'`,
          ),
          Q[0].toUpperCase() === B[0].toUpperCase())
        )
          if (Q.length === 2) return `${Q[0]}:\\${B.substr(3)}`;
          else {
            if (!B.endsWith("\\")) B += "\\";
            return `${Q[0]}:\\${B.substr(3)}${Q.substr(2)}`;
          }
        else return `${Q[0]}:\\${Q.substr(2)}`;
      } else if (jF(Q).match(/^\\$|^\\[^\\]/)) {
        let B = process.cwd();
        return (
          lC.default(
            B.match(/^[A-Z]:\\/i),
            `Expected current directory to start with an absolute drive root. Actual '${B}'`,
          ),
          `${B[0]}:\\${Q.substr(1)}`
        );
      }
    }
    if (
      (lC.default(
        kZ(A),
        "ensureAbsoluteRoot parameter 'root' must have an absolute root",
      ),
      A.endsWith("/") || (tE && A.endsWith("\\")))
    );
    else A += WJ.sep;
    return A + Q;
  }
  GQ.ensureAbsoluteRoot = dr;
  function kZ(A) {
    if (
      (lC.default(A, "hasAbsoluteRoot parameter 'itemPath' must not be empty"),
      (A = jF(A)),
      tE)
    )
      return A.startsWith("\\\\") || /^[A-Z]:\\/i.test(A);
    return A.startsWith("/");
  }
  GQ.hasAbsoluteRoot = kZ;
  function cr(A) {
    if (
      (lC.default(A, "isRooted parameter 'itemPath' must not be empty"),
      (A = jF(A)),
      tE)
    )
      return A.startsWith("\\") || /^[A-Z]:/i.test(A);
    return A.startsWith("/");
  }
  GQ.hasRoot = cr;
  function jF(A) {
    if (((A = A || ""), tE))
      return (
        (A = A.replace(/\//g, "\\")),
        (/^\\\\+[^\\]/.test(A) ? "\\" : "") + A.replace(/\\\\+/g, "\\")
      );
    return A.replace(/\/\/+/g, "/");
  }
  GQ.normalizeSeparators = jF;
  function xZ(A) {
    if (!A) return "";
    if (((A = jF(A)), !A.endsWith(WJ.sep))) return A;
    if (A === WJ.sep) return A;
    if (tE && /^[A-Z]:\\$/i.test(A)) return A;
    return A.substr(0, A.length - 1);
  }
  GQ.safeTrimTrailingSeparator = xZ;
});
var XJ = Z((PR) => {
  Object.defineProperty(PR, "__esModule", { value: !0 });
  PR.MatchKind = void 0;
  var ur;
  (function (A) {
    (A[(A.None = 0)] = "None"),
      (A[(A.Directory = 1)] = "Directory"),
      (A[(A.File = 2)] = "File"),
      (A[(A.All = 3)] = "All");
  })((ur = PR.MatchKind || (PR.MatchKind = {})));
});
var SR = Z((qB) => {
  var lr =
      (qB && qB.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            Object.defineProperty(A, I, {
              enumerable: !0,
              get: function () {
                return Q[B];
              },
            });
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    pr =
      (qB && qB.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    ir =
      (qB && qB.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.hasOwnProperty.call(A, B))
              lr(Q, A, B);
        }
        return pr(Q, A), Q;
      };
  Object.defineProperty(qB, "__esModule", { value: !0 });
  qB.partialMatch = qB.match = qB.getSearchPaths = void 0;
  var _R = ir(ZJ()),
    nr = XJ(),
    yR = process.platform === "win32";
  function ar(A) {
    A = A.filter((I) => !I.negate);
    let Q = {};
    for (let I of A) {
      let E = yR ? I.searchPath.toUpperCase() : I.searchPath;
      Q[E] = "candidate";
    }
    let B = [];
    for (let I of A) {
      let E = yR ? I.searchPath.toUpperCase() : I.searchPath;
      if (Q[E] === "included") continue;
      let C = !1,
        g = E,
        F = _R.dirname(g);
      while (F !== g) {
        if (Q[F]) {
          C = !0;
          break;
        }
        (g = F), (F = _R.dirname(g));
      }
      if (!C) B.push(I.searchPath), (Q[E] = "included");
    }
    return B;
  }
  qB.getSearchPaths = ar;
  function or(A, Q) {
    let B = nr.MatchKind.None;
    for (let I of A)
      if (I.negate) B &= ~I.match(Q);
      else B |= I.match(Q);
    return B;
  }
  qB.match = or;
  function sr(A, Q) {
    return A.some((B) => !B.negate && B.partialMatch(Q));
  }
  qB.partialMatch = sr;
});
var mR = Z((v$A, bR) => {
  bR.exports = function (A, Q) {
    var B = [];
    for (var I = 0; I < A.length; I++) {
      var E = Q(A[I], I);
      if (rr(E)) B.push.apply(B, E);
      else B.push(E);
    }
    return B;
  };
  var rr =
    Array.isArray ||
    function (A) {
      return Object.prototype.toString.call(A) === "[object Array]";
    };
});
var pR = Z((P$A, lR) => {
  lR.exports = cR;
  function cR(A, Q, B) {
    if (A instanceof RegExp) A = dR(A, B);
    if (Q instanceof RegExp) Q = dR(Q, B);
    var I = uR(A, Q, B);
    return (
      I && {
        start: I[0],
        end: I[1],
        pre: B.slice(0, I[0]),
        body: B.slice(I[0] + A.length, I[1]),
        post: B.slice(I[1] + Q.length),
      }
    );
  }
  function dR(A, Q) {
    var B = Q.match(A);
    return B ? B[0] : null;
  }
  cR.range = uR;
  function uR(A, Q, B) {
    var I,
      E,
      C,
      g,
      F,
      D = B.indexOf(A),
      J = B.indexOf(Q, D + 1),
      Y = D;
    if (D >= 0 && J > 0) {
      if (A === Q) return [D, J];
      (I = []), (C = B.length);
      while (Y >= 0 && !F) {
        if (Y == D) I.push(Y), (D = B.indexOf(A, Y + 1));
        else if (I.length == 1) F = [I.pop(), J];
        else {
          if (((E = I.pop()), E < C)) (C = E), (g = J);
          J = B.indexOf(Q, Y + 1);
        }
        Y = D < J && D >= 0 ? D : J;
      }
      if (I.length) F = [C, g];
    }
    return F;
  }
});
var eR = Z((_$A, tR) => {
  var tr = mR(),
    iR = pR();
  tR.exports = Qt;
  var nR = "\x00SLASH" + Math.random() + "\x00",
    aR = "\x00OPEN" + Math.random() + "\x00",
    _Z = "\x00CLOSE" + Math.random() + "\x00",
    oR = "\x00COMMA" + Math.random() + "\x00",
    sR = "\x00PERIOD" + Math.random() + "\x00";
  function PZ(A) {
    return parseInt(A, 10) == A ? parseInt(A, 10) : A.charCodeAt(0);
  }
  function er(A) {
    return A.split("\\\\")
      .join(nR)
      .split("\\{")
      .join(aR)
      .split("\\}")
      .join(_Z)
      .split("\\,")
      .join(oR)
      .split("\\.")
      .join(sR);
  }
  function At(A) {
    return A.split(nR)
      .join("\\")
      .split(aR)
      .join("{")
      .split(_Z)
      .join("}")
      .split(oR)
      .join(",")
      .split(sR)
      .join(".");
  }
  function rR(A) {
    if (!A) return [""];
    var Q = [],
      B = iR("{", "}", A);
    if (!B) return A.split(",");
    var { pre: I, body: E, post: C } = B,
      g = I.split(",");
    g[g.length - 1] += "{" + E + "}";
    var F = rR(C);
    if (C.length) (g[g.length - 1] += F.shift()), g.push.apply(g, F);
    return Q.push.apply(Q, g), Q;
  }
  function Qt(A) {
    if (!A) return [];
    if (A.substr(0, 2) === "{}") A = "\\{\\}" + A.substr(2);
    return Ig(er(A), !0).map(At);
  }
  function Bt(A) {
    return "{" + A + "}";
  }
  function It(A) {
    return /^-?0\d/.test(A);
  }
  function Et(A, Q) {
    return A <= Q;
  }
  function Ct(A, Q) {
    return A >= Q;
  }
  function Ig(A, Q) {
    var B = [],
      I = iR("{", "}", A);
    if (!I || /\$$/.test(I.pre)) return [A];
    var E = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(I.body),
      C = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(I.body),
      g = E || C,
      F = I.body.indexOf(",") >= 0;
    if (!g && !F) {
      if (I.post.match(/,(?!,).*\}/))
        return (A = I.pre + "{" + I.body + _Z + I.post), Ig(A);
      return [A];
    }
    var D;
    if (g) D = I.body.split(/\.\./);
    else if (((D = rR(I.body)), D.length === 1)) {
      if (((D = Ig(D[0], !1).map(Bt)), D.length === 1)) {
        var Y = I.post.length ? Ig(I.post, !1) : [""];
        return Y.map(function (LA) {
          return I.pre + D[0] + LA;
        });
      }
    }
    var J = I.pre,
      Y = I.post.length ? Ig(I.post, !1) : [""],
      N;
    if (g) {
      var W = PZ(D[0]),
        X = PZ(D[1]),
        M = Math.max(D[0].length, D[1].length),
        L = D.length == 3 ? Math.abs(PZ(D[2])) : 1,
        H = Et,
        q = X < W;
      if (q) (L *= -1), (H = Ct);
      var O = D.some(It);
      N = [];
      for (var f = W; H(f, X); f += L) {
        var S;
        if (C) {
          if (((S = String.fromCharCode(f)), S === "\\")) S = "";
        } else if (((S = String(f)), O)) {
          var r = M - S.length;
          if (r > 0) {
            var t = Array(r + 1).join("0");
            if (f < 0) S = "-" + t + S.slice(1);
            else S = t + S;
          }
        }
        N.push(S);
      }
    } else
      N = tr(D, function (MA) {
        return Ig(MA, !1);
      });
    for (var IA = 0; IA < N.length; IA++)
      for (var zA = 0; zA < Y.length; zA++) {
        var DA = J + N[IA] + Y[zA];
        if (!Q || g || DA) B.push(DA);
      }
    return B;
  }
});
var CV = Z((y$A, EV) => {
  EV.exports = lB;
  lB.Minimatch = iQ;
  var fF = (function () {
    try {
      return $("path");
    } catch (A) {}
  })() || { sep: "/" };
  lB.sep = fF.sep;
  var bZ = (lB.GLOBSTAR = iQ.GLOBSTAR = {}),
    gt = eR(),
    AV = {
      "!": { open: "(?:(?!(?:", close: "))[^/]*?)" },
      "?": { open: "(?:", close: ")?" },
      "+": { open: "(?:", close: ")+" },
      "*": { open: "(?:", close: ")*" },
      "@": { open: "(?:", close: ")" },
    },
    yZ = "[^/]",
    SZ = yZ + "*?",
    Ft = "(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?",
    Dt = "(?:(?!(?:\\/|^)\\.).)*?",
    QV = Yt("().*{}+?[]^$\\!");
  function Yt(A) {
    return A.split("").reduce(function (Q, B) {
      return (Q[B] = !0), Q;
    }, {});
  }
  var BV = /\/+/;
  lB.filter = Jt;
  function Jt(A, Q) {
    return (
      (Q = Q || {}),
      function (B, I, E) {
        return lB(B, A, Q);
      }
    );
  }
  function eE(A, Q) {
    Q = Q || {};
    var B = {};
    return (
      Object.keys(A).forEach(function (I) {
        B[I] = A[I];
      }),
      Object.keys(Q).forEach(function (I) {
        B[I] = Q[I];
      }),
      B
    );
  }
  lB.defaults = function (A) {
    if (!A || typeof A !== "object" || !Object.keys(A).length) return lB;
    var Q = lB,
      B = function (E, C, g) {
        return Q(E, C, eE(A, g));
      };
    return (
      (B.Minimatch = function (E, C) {
        return new Q.Minimatch(E, eE(A, C));
      }),
      (B.Minimatch.defaults = function (E) {
        return Q.defaults(eE(A, E)).Minimatch;
      }),
      (B.filter = function (E, C) {
        return Q.filter(E, eE(A, C));
      }),
      (B.defaults = function (E) {
        return Q.defaults(eE(A, E));
      }),
      (B.makeRe = function (E, C) {
        return Q.makeRe(E, eE(A, C));
      }),
      (B.braceExpand = function (E, C) {
        return Q.braceExpand(E, eE(A, C));
      }),
      (B.match = function (I, E, C) {
        return Q.match(I, E, eE(A, C));
      }),
      B
    );
  };
  iQ.defaults = function (A) {
    return lB.defaults(A).Minimatch;
  };
  function lB(A, Q, B) {
    if ((MJ(Q), !B)) B = {};
    if (!B.nocomment && Q.charAt(0) === "#") return !1;
    return new iQ(Q, B).match(A);
  }
  function iQ(A, Q) {
    if (!(this instanceof iQ)) return new iQ(A, Q);
    if ((MJ(A), !Q)) Q = {};
    if (((A = A.trim()), !Q.allowWindowsEscape && fF.sep !== "/"))
      A = A.split(fF.sep).join("/");
    (this.options = Q),
      (this.set = []),
      (this.pattern = A),
      (this.regexp = null),
      (this.negate = !1),
      (this.comment = !1),
      (this.empty = !1),
      (this.partial = !!Q.partial),
      this.make();
  }
  iQ.prototype.debug = function () {};
  iQ.prototype.make = Nt;
  function Nt() {
    var A = this.pattern,
      Q = this.options;
    if (!Q.nocomment && A.charAt(0) === "#") {
      this.comment = !0;
      return;
    }
    if (!A) {
      this.empty = !0;
      return;
    }
    this.parseNegate();
    var B = (this.globSet = this.braceExpand());
    if (Q.debug)
      this.debug = function () {
        console.error.apply(console, arguments);
      };
    this.debug(this.pattern, B),
      (B = this.globParts =
        B.map(function (I) {
          return I.split(BV);
        })),
      this.debug(this.pattern, B),
      (B = B.map(function (I, E, C) {
        return I.map(this.parse, this);
      }, this)),
      this.debug(this.pattern, B),
      (B = B.filter(function (I) {
        return I.indexOf(!1) === -1;
      })),
      this.debug(this.pattern, B),
      (this.set = B);
  }
  iQ.prototype.parseNegate = Gt;
  function Gt() {
    var A = this.pattern,
      Q = !1,
      B = this.options,
      I = 0;
    if (B.nonegate) return;
    for (var E = 0, C = A.length; E < C && A.charAt(E) === "!"; E++)
      (Q = !Q), I++;
    if (I) this.pattern = A.substr(I);
    this.negate = Q;
  }
  lB.braceExpand = function (A, Q) {
    return IV(A, Q);
  };
  iQ.prototype.braceExpand = IV;
  function IV(A, Q) {
    if (!Q)
      if (this instanceof iQ) Q = this.options;
      else Q = {};
    if (
      ((A = typeof A > "u" ? this.pattern : A),
      MJ(A),
      Q.nobrace || !/\{(?:(?!\{).)*\}/.test(A))
    )
      return [A];
    return gt(A);
  }
  var Ut = 65536,
    MJ = function (A) {
      if (typeof A !== "string") throw TypeError("invalid pattern");
      if (A.length > Ut) throw TypeError("pattern is too long");
    };
  iQ.prototype.parse = Wt;
  var wJ = {};
  function Wt(A, Q) {
    MJ(A);
    var B = this.options;
    if (A === "**")
      if (!B.noglobstar) return bZ;
      else A = "*";
    if (A === "") return "";
    var I = "",
      E = !!B.nocase,
      C = !1,
      g = [],
      F = [],
      D,
      J = !1,
      Y = -1,
      N = -1,
      W =
        A.charAt(0) === "."
          ? ""
          : B.dot
            ? "(?!(?:^|\\/)\\.{1,2}(?:$|\\/))"
            : "(?!\\.)",
      X = this;
    function M() {
      if (D) {
        switch (D) {
          case "*":
            (I += SZ), (E = !0);
            break;
          case "?":
            (I += yZ), (E = !0);
            break;
          default:
            I += "\\" + D;
            break;
        }
        X.debug("clearStateChar %j %j", D, I), (D = !1);
      }
    }
    for (var L = 0, H = A.length, q; L < H && (q = A.charAt(L)); L++) {
      if ((this.debug("%s\t%s %s %j", A, L, I, q), C && QV[q])) {
        (I += "\\" + q), (C = !1);
        continue;
      }
      switch (q) {
        case "/":
          return !1;
        case "\\":
          M(), (C = !0);
          continue;
        case "?":
        case "*":
        case "+":
        case "@":
        case "!":
          if ((this.debug("%s\t%s %s %j <-- stateChar", A, L, I, q), J)) {
            if ((this.debug("  in class"), q === "!" && L === N + 1)) q = "^";
            I += q;
            continue;
          }
          if ((X.debug("call clearStateChar %j", D), M(), (D = q), B.noext))
            M();
          continue;
        case "(":
          if (J) {
            I += "(";
            continue;
          }
          if (!D) {
            I += "\\(";
            continue;
          }
          g.push({
            type: D,
            start: L - 1,
            reStart: I.length,
            open: AV[D].open,
            close: AV[D].close,
          }),
            (I += D === "!" ? "(?:(?!(?:" : "(?:"),
            this.debug("plType %j %j", D, I),
            (D = !1);
          continue;
        case ")":
          if (J || !g.length) {
            I += "\\)";
            continue;
          }
          M(), (E = !0);
          var O = g.pop();
          if (((I += O.close), O.type === "!")) F.push(O);
          O.reEnd = I.length;
          continue;
        case "|":
          if (J || !g.length || C) {
            (I += "\\|"), (C = !1);
            continue;
          }
          M(), (I += "|");
          continue;
        case "[":
          if ((M(), J)) {
            I += "\\" + q;
            continue;
          }
          (J = !0), (N = L), (Y = I.length), (I += q);
          continue;
        case "]":
          if (L === N + 1 || !J) {
            (I += "\\" + q), (C = !1);
            continue;
          }
          var f = A.substring(N + 1, L);
          try {
            RegExp("[" + f + "]");
          } catch (qI) {
            var S = this.parse(f, wJ);
            (I = I.substr(0, Y) + "\\[" + S[0] + "\\]"),
              (E = E || S[1]),
              (J = !1);
            continue;
          }
          (E = !0), (J = !1), (I += q);
          continue;
        default:
          if ((M(), C)) C = !1;
          else if (QV[q] && !(q === "^" && J)) I += "\\";
          I += q;
      }
    }
    if (J)
      (f = A.substr(N + 1)),
        (S = this.parse(f, wJ)),
        (I = I.substr(0, Y) + "\\[" + S[0]),
        (E = E || S[1]);
    for (O = g.pop(); O; O = g.pop()) {
      var r = I.slice(O.reStart + O.open.length);
      this.debug("setting tail", I, O),
        (r = r.replace(/((?:\\{2}){0,64})(\\?)\|/g, function (qI, hE, BE) {
          if (!BE) BE = "\\";
          return hE + hE + BE + "|";
        })),
        this.debug(
          `tail=%j
   %s`,
          r,
          r,
          O,
          I,
        );
      var t = O.type === "*" ? SZ : O.type === "?" ? yZ : "\\" + O.type;
      (E = !0), (I = I.slice(0, O.reStart) + t + "\\(" + r);
    }
    if ((M(), C)) I += "\\\\";
    var IA = !1;
    switch (I.charAt(0)) {
      case "[":
      case ".":
      case "(":
        IA = !0;
    }
    for (var zA = F.length - 1; zA > -1; zA--) {
      var DA = F[zA],
        MA = I.slice(0, DA.reStart),
        LA = I.slice(DA.reStart, DA.reEnd - 8),
        EA = I.slice(DA.reEnd - 8, DA.reEnd),
        RA = I.slice(DA.reEnd);
      EA += RA;
      var CQ = MA.split("(").length - 1,
        ZB = RA;
      for (L = 0; L < CQ; L++) ZB = ZB.replace(/\)[+*?]?/, "");
      RA = ZB;
      var jQ = "";
      if (RA === "" && Q !== wJ) jQ = "$";
      var QE = MA + LA + RA + jQ + EA;
      I = QE;
    }
    if (I !== "" && E) I = "(?=.)" + I;
    if (IA) I = W + I;
    if (Q === wJ) return [I, E];
    if (!E) return Xt(A);
    var fE = B.nocase ? "i" : "";
    try {
      var LI = new RegExp("^" + I + "$", fE);
    } catch (qI) {
      return new RegExp("$.");
    }
    return (LI._glob = A), (LI._src = I), LI;
  }
  lB.makeRe = function (A, Q) {
    return new iQ(A, Q || {}).makeRe();
  };
  iQ.prototype.makeRe = Zt;
  function Zt() {
    if (this.regexp || this.regexp === !1) return this.regexp;
    var A = this.set;
    if (!A.length) return (this.regexp = !1), this.regexp;
    var Q = this.options,
      B = Q.noglobstar ? SZ : Q.dot ? Ft : Dt,
      I = Q.nocase ? "i" : "",
      E = A.map(function (C) {
        return C.map(function (g) {
          return g === bZ ? B : typeof g === "string" ? wt(g) : g._src;
        }).join("\\/");
      }).join("|");
    if (((E = "^(?:" + E + ")$"), this.negate)) E = "^(?!" + E + ").*$";
    try {
      this.regexp = new RegExp(E, I);
    } catch (C) {
      this.regexp = !1;
    }
    return this.regexp;
  }
  lB.match = function (A, Q, B) {
    B = B || {};
    var I = new iQ(Q, B);
    if (
      ((A = A.filter(function (E) {
        return I.match(E);
      })),
      I.options.nonull && !A.length)
    )
      A.push(Q);
    return A;
  };
  iQ.prototype.match = function (Q, B) {
    if (typeof B > "u") B = this.partial;
    if ((this.debug("match", Q, this.pattern), this.comment)) return !1;
    if (this.empty) return Q === "";
    if (Q === "/" && B) return !0;
    var I = this.options;
    if (fF.sep !== "/") Q = Q.split(fF.sep).join("/");
    (Q = Q.split(BV)), this.debug(this.pattern, "split", Q);
    var E = this.set;
    this.debug(this.pattern, "set", E);
    var C, g;
    for (g = Q.length - 1; g >= 0; g--) if (((C = Q[g]), C)) break;
    for (g = 0; g < E.length; g++) {
      var F = E[g],
        D = Q;
      if (I.matchBase && F.length === 1) D = [C];
      var J = this.matchOne(D, F, B);
      if (J) {
        if (I.flipNegate) return !0;
        return !this.negate;
      }
    }
    if (I.flipNegate) return !1;
    return this.negate;
  };
  iQ.prototype.matchOne = function (A, Q, B) {
    var I = this.options;
    this.debug("matchOne", { this: this, file: A, pattern: Q }),
      this.debug("matchOne", A.length, Q.length);
    for (
      var E = 0, C = 0, g = A.length, F = Q.length;
      E < g && C < F;
      E++, C++
    ) {
      this.debug("matchOne loop");
      var D = Q[C],
        J = A[E];
      if ((this.debug(Q, D, J), D === !1)) return !1;
      if (D === bZ) {
        this.debug("GLOBSTAR", [Q, D, J]);
        var Y = E,
          N = C + 1;
        if (N === F) {
          this.debug("** at the end");
          for (; E < g; E++)
            if (
              A[E] === "." ||
              A[E] === ".." ||
              (!I.dot && A[E].charAt(0) === ".")
            )
              return !1;
          return !0;
        }
        while (Y < g) {
          var W = A[Y];
          if (
            (this.debug(
              `
globstar while`,
              A,
              Y,
              Q,
              N,
              W,
            ),
            this.matchOne(A.slice(Y), Q.slice(N), B))
          )
            return this.debug("globstar found match!", Y, g, W), !0;
          else {
            if (W === "." || W === ".." || (!I.dot && W.charAt(0) === ".")) {
              this.debug("dot detected!", A, Y, Q, N);
              break;
            }
            this.debug("globstar swallow a segment, and continue"), Y++;
          }
        }
        if (B) {
          if (
            (this.debug(
              `
>>> no match, partial?`,
              A,
              Y,
              Q,
              N,
            ),
            Y === g)
          )
            return !0;
        }
        return !1;
      }
      var X;
      if (typeof D === "string")
        (X = J === D), this.debug("string match", D, J, X);
      else (X = J.match(D)), this.debug("pattern match", D, J, X);
      if (!X) return !1;
    }
    if (E === g && C === F) return !0;
    else if (E === g) return B;
    else if (C === F) return E === g - 1 && A[E] === "";
    throw Error("wtf?");
  };
  function Xt(A) {
    return A.replace(/\\(.)/g, "$1");
  }
  function wt(A) {
    return A.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&");
  }
});
var DV = Z((DI) => {
  var Mt =
      (DI && DI.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            Object.defineProperty(A, I, {
              enumerable: !0,
              get: function () {
                return Q[B];
              },
            });
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    Lt =
      (DI && DI.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    gV =
      (DI && DI.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.hasOwnProperty.call(A, B))
              Mt(Q, A, B);
        }
        return Lt(Q, A), Q;
      },
    Rt =
      (DI && DI.__importDefault) ||
      function (A) {
        return A && A.__esModule ? A : { default: A };
      };
  Object.defineProperty(DI, "__esModule", { value: !0 });
  DI.Path = void 0;
  var hF = gV($("path")),
    AC = gV(ZJ()),
    kF = Rt($("assert")),
    Vt = process.platform === "win32";
  class FV {
    constructor(A) {
      if (((this.segments = []), typeof A === "string"))
        if (
          (kF.default(A, "Parameter 'itemPath' must not be empty"),
          (A = AC.safeTrimTrailingSeparator(A)),
          !AC.hasRoot(A))
        )
          this.segments = A.split(hF.sep);
        else {
          let Q = A,
            B = AC.dirname(Q);
          while (B !== Q) {
            let I = hF.basename(Q);
            this.segments.unshift(I), (Q = B), (B = AC.dirname(Q));
          }
          this.segments.unshift(Q);
        }
      else {
        kF.default(
          A.length > 0,
          "Parameter 'itemPath' must not be an empty array",
        );
        for (let Q = 0; Q < A.length; Q++) {
          let B = A[Q];
          if (
            (kF.default(
              B,
              "Parameter 'itemPath' must not contain any empty segments",
            ),
            (B = AC.normalizeSeparators(A[Q])),
            Q === 0 && AC.hasRoot(B))
          )
            (B = AC.safeTrimTrailingSeparator(B)),
              kF.default(
                B === AC.dirname(B),
                "Parameter 'itemPath' root segment contains information for multiple segments",
              ),
              this.segments.push(B);
          else
            kF.default(
              !B.includes(hF.sep),
              "Parameter 'itemPath' contains unexpected path separators",
            ),
              this.segments.push(B);
        }
      }
    }
    toString() {
      let A = this.segments[0],
        Q = A.endsWith(hF.sep) || (Vt && /^[A-Z]:$/i.test(A));
      for (let B = 1; B < this.segments.length; B++) {
        if (Q) Q = !1;
        else A += hF.sep;
        A += this.segments[B];
      }
      return A;
    }
  }
  DI.Path = FV;
});
var YV = Z((JI) => {
  var $t =
      (JI && JI.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            Object.defineProperty(A, I, {
              enumerable: !0,
              get: function () {
                return Q[B];
              },
            });
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    Ht =
      (JI && JI.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    dZ =
      (JI && JI.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.hasOwnProperty.call(A, B))
              $t(Q, A, B);
        }
        return Ht(Q, A), Q;
      },
    Kt =
      (JI && JI.__importDefault) ||
      function (A) {
        return A && A.__esModule ? A : { default: A };
      };
  Object.defineProperty(JI, "__esModule", { value: !0 });
  JI.Pattern = void 0;
  var zt = dZ($("os")),
    xF = dZ($("path")),
    jB = dZ(ZJ()),
    pC = Kt($("assert")),
    Tt = CV(),
    mZ = XJ(),
    LJ = DV(),
    wE = process.platform === "win32";
  class YI {
    constructor(A, Q = !1, B, I) {
      this.negate = !1;
      let E;
      if (typeof A === "string") E = A.trim();
      else {
        (B = B || []),
          pC.default(B.length, "Parameter 'segments' must not empty");
        let D = YI.getLiteral(B[0]);
        if (
          (pC.default(
            D && jB.hasAbsoluteRoot(D),
            "Parameter 'segments' first element must be a root path",
          ),
          (E = new LJ.Path(B).toString().trim()),
          A)
        )
          E = `!${E}`;
      }
      while (E.startsWith("!"))
        (this.negate = !this.negate), (E = E.substr(1).trim());
      (E = YI.fixupPattern(E, I)),
        (this.segments = new LJ.Path(E).segments),
        (this.trailingSeparator = jB.normalizeSeparators(E).endsWith(xF.sep)),
        (E = jB.safeTrimTrailingSeparator(E));
      let C = !1,
        g = this.segments
          .map((D) => YI.getLiteral(D))
          .filter((D) => !C && !(C = D === ""));
      (this.searchPath = new LJ.Path(g).toString()),
        (this.rootRegExp = new RegExp(YI.regExpEscape(g[0]), wE ? "i" : "")),
        (this.isImplicitPattern = Q);
      let F = {
        dot: !0,
        nobrace: !0,
        nocase: wE,
        nocomment: !0,
        noext: !0,
        nonegate: !0,
      };
      (E = wE ? E.replace(/\\/g, "/") : E),
        (this.minimatch = new Tt.Minimatch(E, F));
    }
    match(A) {
      if (this.segments[this.segments.length - 1] === "**") {
        if (
          ((A = jB.normalizeSeparators(A)),
          !A.endsWith(xF.sep) && this.isImplicitPattern === !1)
        )
          A = `${A}${xF.sep}`;
      } else A = jB.safeTrimTrailingSeparator(A);
      if (this.minimatch.match(A))
        return this.trailingSeparator
          ? mZ.MatchKind.Directory
          : mZ.MatchKind.All;
      return mZ.MatchKind.None;
    }
    partialMatch(A) {
      if (((A = jB.safeTrimTrailingSeparator(A)), jB.dirname(A) === A))
        return this.rootRegExp.test(A);
      return this.minimatch.matchOne(
        A.split(wE ? /\\+/ : /\/+/),
        this.minimatch.set[0],
        !0,
      );
    }
    static globEscape(A) {
      return (wE ? A : A.replace(/\\/g, "\\\\"))
        .replace(/(\[)(?=[^/]+\])/g, "[[]")
        .replace(/\?/g, "[?]")
        .replace(/\*/g, "[*]");
    }
    static fixupPattern(A, Q) {
      pC.default(A, "pattern cannot be empty");
      let B = new LJ.Path(A).segments.map((I) => YI.getLiteral(I));
      if (
        (pC.default(
          B.every((I, E) => (I !== "." || E === 0) && I !== ".."),
          `Invalid pattern '${A}'. Relative pathing '.' and '..' is not allowed.`,
        ),
        pC.default(
          !jB.hasRoot(A) || B[0],
          `Invalid pattern '${A}'. Root segment must not contain globs.`,
        ),
        (A = jB.normalizeSeparators(A)),
        A === "." || A.startsWith(`.${xF.sep}`))
      )
        A = YI.globEscape(process.cwd()) + A.substr(1);
      else if (A === "~" || A.startsWith(`~${xF.sep}`))
        (Q = Q || zt.homedir()),
          pC.default(Q, "Unable to determine HOME directory"),
          pC.default(
            jB.hasAbsoluteRoot(Q),
            `Expected HOME directory to be a rooted path. Actual '${Q}'`,
          ),
          (A = YI.globEscape(Q) + A.substr(1));
      else if (wE && (A.match(/^[A-Z]:$/i) || A.match(/^[A-Z]:[^\\]/i))) {
        let I = jB.ensureAbsoluteRoot("C:\\dummy-root", A.substr(0, 2));
        if (A.length > 2 && !I.endsWith("\\")) I += "\\";
        A = YI.globEscape(I) + A.substr(2);
      } else if (wE && (A === "\\" || A.match(/^\\[^\\]/))) {
        let I = jB.ensureAbsoluteRoot("C:\\dummy-root", "\\");
        if (!I.endsWith("\\")) I += "\\";
        A = YI.globEscape(I) + A.substr(1);
      } else A = jB.ensureAbsoluteRoot(YI.globEscape(process.cwd()), A);
      return jB.normalizeSeparators(A);
    }
    static getLiteral(A) {
      let Q = "";
      for (let B = 0; B < A.length; B++) {
        let I = A[B];
        if (I === "\\" && !wE && B + 1 < A.length) {
          Q += A[++B];
          continue;
        } else if (I === "*" || I === "?") return "";
        else if (I === "[" && B + 1 < A.length) {
          let E = "",
            C = -1;
          for (let g = B + 1; g < A.length; g++) {
            let F = A[g];
            if (F === "\\" && !wE && g + 1 < A.length) {
              E += A[++g];
              continue;
            } else if (F === "]") {
              C = g;
              break;
            } else E += F;
          }
          if (C >= 0) {
            if (E.length > 1) return "";
            if (E) {
              (Q += E), (B = C);
              continue;
            }
          }
        }
        Q += I;
      }
      return Q;
    }
    static regExpEscape(A) {
      return A.replace(/[[\\^$.|?*+()]/g, "\\$&");
    }
  }
  JI.Pattern = YI;
});
var UV = Z((NV) => {
  Object.defineProperty(NV, "__esModule", { value: !0 });
  NV.SearchState = void 0;
  class JV {
    constructor(A, Q) {
      (this.path = A), (this.level = Q);
    }
  }
  NV.SearchState = JV;
});
var MV = Z((PQ) => {
  var Ot =
      (PQ && PQ.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            Object.defineProperty(A, I, {
              enumerable: !0,
              get: function () {
                return Q[B];
              },
            });
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    qt =
      (PQ && PQ.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    PF =
      (PQ && PQ.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.hasOwnProperty.call(A, B))
              Ot(Q, A, B);
        }
        return qt(Q, A), Q;
      },
    cZ =
      (PQ && PQ.__awaiter) ||
      function (A, Q, B, I) {
        function E(C) {
          return C instanceof B
            ? C
            : new B(function (g) {
                g(C);
              });
        }
        return new (B || (B = Promise))(function (C, g) {
          function F(Y) {
            try {
              J(I.next(Y));
            } catch (N) {
              g(N);
            }
          }
          function D(Y) {
            try {
              J(I.throw(Y));
            } catch (N) {
              g(N);
            }
          }
          function J(Y) {
            Y.done ? C(Y.value) : E(Y.value).then(F, D);
          }
          J((I = I.apply(A, Q || [])).next());
        });
      },
    jt =
      (PQ && PQ.__asyncValues) ||
      function (A) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var Q = A[Symbol.asyncIterator],
          B;
        return Q
          ? Q.call(A)
          : ((A =
              typeof __values === "function"
                ? __values(A)
                : A[Symbol.iterator]()),
            (B = {}),
            I("next"),
            I("throw"),
            I("return"),
            (B[Symbol.asyncIterator] = function () {
              return this;
            }),
            B);
        function I(C) {
          B[C] =
            A[C] &&
            function (g) {
              return new Promise(function (F, D) {
                (g = A[C](g)), E(F, D, g.done, g.value);
              });
            };
        }
        function E(C, g, F, D) {
          Promise.resolve(D).then(function (J) {
            C({ value: J, done: F });
          }, g);
        }
      },
    QC =
      (PQ && PQ.__await) ||
      function (A) {
        return this instanceof QC ? ((this.v = A), this) : new QC(A);
      },
    ft =
      (PQ && PQ.__asyncGenerator) ||
      function (A, Q, B) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var I = B.apply(A, Q || []),
          E,
          C = [];
        return (
          (E = {}),
          g("next"),
          g("throw"),
          g("return"),
          (E[Symbol.asyncIterator] = function () {
            return this;
          }),
          E
        );
        function g(W) {
          if (I[W])
            E[W] = function (X) {
              return new Promise(function (M, L) {
                C.push([W, X, M, L]) > 1 || F(W, X);
              });
            };
        }
        function F(W, X) {
          try {
            D(I[W](X));
          } catch (M) {
            N(C[0][3], M);
          }
        }
        function D(W) {
          W.value instanceof QC
            ? Promise.resolve(W.value.v).then(J, Y)
            : N(C[0][2], W);
        }
        function J(W) {
          F("next", W);
        }
        function Y(W) {
          F("throw", W);
        }
        function N(W, X) {
          if ((W(X), C.shift(), C.length)) F(C[0][0], C[0][1]);
        }
      };
  Object.defineProperty(PQ, "__esModule", { value: !0 });
  PQ.DefaultGlobber = void 0;
  var uZ = PF($B()),
    vF = PF($("fs")),
    WV = PF(vR()),
    ht = PF($("path")),
    RJ = PF(SR()),
    ZV = XJ(),
    XV = YV(),
    wV = UV(),
    kt = process.platform === "win32";
  class VJ {
    constructor(A) {
      (this.patterns = []),
        (this.searchPaths = []),
        (this.options = WV.getOptions(A));
    }
    getSearchPaths() {
      return this.searchPaths.slice();
    }
    glob() {
      var A, Q;
      return cZ(this, void 0, void 0, function* () {
        let B = [];
        try {
          for (
            var I = jt(this.globGenerator()), E;
            (E = yield I.next()), !E.done;

          ) {
            let C = E.value;
            B.push(C);
          }
        } catch (C) {
          A = { error: C };
        } finally {
          try {
            if (E && !E.done && (Q = I.return)) yield Q.call(I);
          } finally {
            if (A) throw A.error;
          }
        }
        return B;
      });
    }
    globGenerator() {
      return ft(this, arguments, function* () {
        let Q = WV.getOptions(this.options),
          B = [];
        for (let C of this.patterns)
          if (
            (B.push(C),
            Q.implicitDescendants &&
              (C.trailingSeparator ||
                C.segments[C.segments.length - 1] !== "**"))
          )
            B.push(new XV.Pattern(C.negate, !0, C.segments.concat("**")));
        let I = [];
        for (let C of RJ.getSearchPaths(B)) {
          uZ.debug(`Search path '${C}'`);
          try {
            yield QC(vF.promises.lstat(C));
          } catch (g) {
            if (g.code === "ENOENT") continue;
            throw g;
          }
          I.unshift(new wV.SearchState(C, 1));
        }
        let E = [];
        while (I.length) {
          let C = I.pop(),
            g = RJ.match(B, C.path),
            F = !!g || RJ.partialMatch(B, C.path);
          if (!g && !F) continue;
          let D = yield QC(VJ.stat(C, Q, E));
          if (!D) continue;
          if (D.isDirectory()) {
            if (g & ZV.MatchKind.Directory) yield yield QC(C.path);
            else if (!F) continue;
            let J = C.level + 1,
              Y = (yield QC(vF.promises.readdir(C.path))).map(
                (N) => new wV.SearchState(ht.join(C.path, N), J),
              );
            I.push(...Y.reverse());
          } else if (g & ZV.MatchKind.File) yield yield QC(C.path);
        }
      });
    }
    static create(A, Q) {
      return cZ(this, void 0, void 0, function* () {
        let B = new VJ(Q);
        if (kt)
          (A = A.replace(
            /\r\n/g,
            `
`,
          )),
            (A = A.replace(
              /\r/g,
              `
`,
            ));
        let I = A.split(
          `
`,
        ).map((E) => E.trim());
        for (let E of I)
          if (!E || E.startsWith("#")) continue;
          else B.patterns.push(new XV.Pattern(E));
        return B.searchPaths.push(...RJ.getSearchPaths(B.patterns)), B;
      });
    }
    static stat(A, Q, B) {
      return cZ(this, void 0, void 0, function* () {
        let I;
        if (Q.followSymbolicLinks)
          try {
            I = yield vF.promises.stat(A.path);
          } catch (E) {
            if (E.code === "ENOENT") {
              if (Q.omitBrokenSymbolicLinks) {
                uZ.debug(`Broken symlink '${A.path}'`);
                return;
              }
              throw Error(
                `No information found for the path '${A.path}'. This may indicate a broken symbolic link.`,
              );
            }
            throw E;
          }
        else I = yield vF.promises.lstat(A.path);
        if (I.isDirectory() && Q.followSymbolicLinks) {
          let E = yield vF.promises.realpath(A.path);
          while (B.length >= A.level) B.pop();
          if (B.some((C) => C === E)) {
            uZ.debug(
              `Symlink cycle detected for path '${A.path}' and realpath '${E}'`,
            );
            return;
          }
          B.push(E);
        }
        return I;
      });
    }
  }
  PQ.DefaultGlobber = VJ;
});
var LV = Z((Eg) => {
  var xt =
    (Eg && Eg.__awaiter) ||
    function (A, Q, B, I) {
      function E(C) {
        return C instanceof B
          ? C
          : new B(function (g) {
              g(C);
            });
      }
      return new (B || (B = Promise))(function (C, g) {
        function F(Y) {
          try {
            J(I.next(Y));
          } catch (N) {
            g(N);
          }
        }
        function D(Y) {
          try {
            J(I.throw(Y));
          } catch (N) {
            g(N);
          }
        }
        function J(Y) {
          Y.done ? C(Y.value) : E(Y.value).then(F, D);
        }
        J((I = I.apply(A, Q || [])).next());
      });
    };
  Object.defineProperty(Eg, "__esModule", { value: !0 });
  Eg.create = void 0;
  var vt = MV();
  function Pt(A, Q) {
    return xt(this, void 0, void 0, function* () {
      return yield vt.DefaultGlobber.create(A, Q);
    });
  }
  Eg.create = Pt;
});
var zV = Z((FA, KV) => {
  FA = KV.exports = GA;
  var fA;
  if (
    typeof process === "object" &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)
  )
    fA = function () {
      var A = Array.prototype.slice.call(arguments, 0);
      A.unshift("SEMVER"), console.log.apply(console, A);
    };
  else fA = function () {};
  FA.SEMVER_SPEC_VERSION = "2.0.0";
  var _F = 256,
    $J = Number.MAX_SAFE_INTEGER || 9007199254740991,
    lZ = 16,
    _t = _F - 6,
    Cg = (FA.re = []),
    jA = (FA.safeRe = []),
    _ = (FA.src = []),
    x = (FA.tokens = {}),
    $V = 0;
  function WA(A) {
    x[A] = $V++;
  }
  var iZ = "[a-zA-Z0-9-]",
    pZ = [
      ["\\s", 1],
      ["\\d", _F],
      [iZ, _t],
    ];
  function SF(A) {
    for (var Q = 0; Q < pZ.length; Q++) {
      var B = pZ[Q][0],
        I = pZ[Q][1];
      A = A.split(B + "*")
        .join(B + "{0," + I + "}")
        .split(B + "+")
        .join(B + "{1," + I + "}");
    }
    return A;
  }
  WA("NUMERICIDENTIFIER");
  _[x.NUMERICIDENTIFIER] = "0|[1-9]\\d*";
  WA("NUMERICIDENTIFIERLOOSE");
  _[x.NUMERICIDENTIFIERLOOSE] = "\\d+";
  WA("NONNUMERICIDENTIFIER");
  _[x.NONNUMERICIDENTIFIER] = "\\d*[a-zA-Z-]" + iZ + "*";
  WA("MAINVERSION");
  _[x.MAINVERSION] =
    "(" +
    _[x.NUMERICIDENTIFIER] +
    ")\\.(" +
    _[x.NUMERICIDENTIFIER] +
    ")\\.(" +
    _[x.NUMERICIDENTIFIER] +
    ")";
  WA("MAINVERSIONLOOSE");
  _[x.MAINVERSIONLOOSE] =
    "(" +
    _[x.NUMERICIDENTIFIERLOOSE] +
    ")\\.(" +
    _[x.NUMERICIDENTIFIERLOOSE] +
    ")\\.(" +
    _[x.NUMERICIDENTIFIERLOOSE] +
    ")";
  WA("PRERELEASEIDENTIFIER");
  _[x.PRERELEASEIDENTIFIER] =
    "(?:" + _[x.NUMERICIDENTIFIER] + "|" + _[x.NONNUMERICIDENTIFIER] + ")";
  WA("PRERELEASEIDENTIFIERLOOSE");
  _[x.PRERELEASEIDENTIFIERLOOSE] =
    "(?:" + _[x.NUMERICIDENTIFIERLOOSE] + "|" + _[x.NONNUMERICIDENTIFIER] + ")";
  WA("PRERELEASE");
  _[x.PRERELEASE] =
    "(?:-(" +
    _[x.PRERELEASEIDENTIFIER] +
    "(?:\\." +
    _[x.PRERELEASEIDENTIFIER] +
    ")*))";
  WA("PRERELEASELOOSE");
  _[x.PRERELEASELOOSE] =
    "(?:-?(" +
    _[x.PRERELEASEIDENTIFIERLOOSE] +
    "(?:\\." +
    _[x.PRERELEASEIDENTIFIERLOOSE] +
    ")*))";
  WA("BUILDIDENTIFIER");
  _[x.BUILDIDENTIFIER] = iZ + "+";
  WA("BUILD");
  _[x.BUILD] =
    "(?:\\+(" + _[x.BUILDIDENTIFIER] + "(?:\\." + _[x.BUILDIDENTIFIER] + ")*))";
  WA("FULL");
  WA("FULLPLAIN");
  _[x.FULLPLAIN] =
    "v?" + _[x.MAINVERSION] + _[x.PRERELEASE] + "?" + _[x.BUILD] + "?";
  _[x.FULL] = "^" + _[x.FULLPLAIN] + "$";
  WA("LOOSEPLAIN");
  _[x.LOOSEPLAIN] =
    "[v=\\s]*" +
    _[x.MAINVERSIONLOOSE] +
    _[x.PRERELEASELOOSE] +
    "?" +
    _[x.BUILD] +
    "?";
  WA("LOOSE");
  _[x.LOOSE] = "^" + _[x.LOOSEPLAIN] + "$";
  WA("GTLT");
  _[x.GTLT] = "((?:<|>)?=?)";
  WA("XRANGEIDENTIFIERLOOSE");
  _[x.XRANGEIDENTIFIERLOOSE] = _[x.NUMERICIDENTIFIERLOOSE] + "|x|X|\\*";
  WA("XRANGEIDENTIFIER");
  _[x.XRANGEIDENTIFIER] = _[x.NUMERICIDENTIFIER] + "|x|X|\\*";
  WA("XRANGEPLAIN");
  _[x.XRANGEPLAIN] =
    "[v=\\s]*(" +
    _[x.XRANGEIDENTIFIER] +
    ")(?:\\.(" +
    _[x.XRANGEIDENTIFIER] +
    ")(?:\\.(" +
    _[x.XRANGEIDENTIFIER] +
    ")(?:" +
    _[x.PRERELEASE] +
    ")?" +
    _[x.BUILD] +
    "?)?)?";
  WA("XRANGEPLAINLOOSE");
  _[x.XRANGEPLAINLOOSE] =
    "[v=\\s]*(" +
    _[x.XRANGEIDENTIFIERLOOSE] +
    ")(?:\\.(" +
    _[x.XRANGEIDENTIFIERLOOSE] +
    ")(?:\\.(" +
    _[x.XRANGEIDENTIFIERLOOSE] +
    ")(?:" +
    _[x.PRERELEASELOOSE] +
    ")?" +
    _[x.BUILD] +
    "?)?)?";
  WA("XRANGE");
  _[x.XRANGE] = "^" + _[x.GTLT] + "\\s*" + _[x.XRANGEPLAIN] + "$";
  WA("XRANGELOOSE");
  _[x.XRANGELOOSE] = "^" + _[x.GTLT] + "\\s*" + _[x.XRANGEPLAINLOOSE] + "$";
  WA("COERCE");
  _[x.COERCE] =
    "(^|[^\\d])(\\d{1," +
    lZ +
    "})(?:\\.(\\d{1," +
    lZ +
    "}))?(?:\\.(\\d{1," +
    lZ +
    "}))?(?:$|[^\\d])";
  WA("COERCERTL");
  Cg[x.COERCERTL] = new RegExp(_[x.COERCE], "g");
  jA[x.COERCERTL] = new RegExp(SF(_[x.COERCE]), "g");
  WA("LONETILDE");
  _[x.LONETILDE] = "(?:~>?)";
  WA("TILDETRIM");
  _[x.TILDETRIM] = "(\\s*)" + _[x.LONETILDE] + "\\s+";
  Cg[x.TILDETRIM] = new RegExp(_[x.TILDETRIM], "g");
  jA[x.TILDETRIM] = new RegExp(SF(_[x.TILDETRIM]), "g");
  var yt = "$1~";
  WA("TILDE");
  _[x.TILDE] = "^" + _[x.LONETILDE] + _[x.XRANGEPLAIN] + "$";
  WA("TILDELOOSE");
  _[x.TILDELOOSE] = "^" + _[x.LONETILDE] + _[x.XRANGEPLAINLOOSE] + "$";
  WA("LONECARET");
  _[x.LONECARET] = "(?:\\^)";
  WA("CARETTRIM");
  _[x.CARETTRIM] = "(\\s*)" + _[x.LONECARET] + "\\s+";
  Cg[x.CARETTRIM] = new RegExp(_[x.CARETTRIM], "g");
  jA[x.CARETTRIM] = new RegExp(SF(_[x.CARETTRIM]), "g");
  var St = "$1^";
  WA("CARET");
  _[x.CARET] = "^" + _[x.LONECARET] + _[x.XRANGEPLAIN] + "$";
  WA("CARETLOOSE");
  _[x.CARETLOOSE] = "^" + _[x.LONECARET] + _[x.XRANGEPLAINLOOSE] + "$";
  WA("COMPARATORLOOSE");
  _[x.COMPARATORLOOSE] = "^" + _[x.GTLT] + "\\s*(" + _[x.LOOSEPLAIN] + ")$|^$";
  WA("COMPARATOR");
  _[x.COMPARATOR] = "^" + _[x.GTLT] + "\\s*(" + _[x.FULLPLAIN] + ")$|^$";
  WA("COMPARATORTRIM");
  _[x.COMPARATORTRIM] =
    "(\\s*)" +
    _[x.GTLT] +
    "\\s*(" +
    _[x.LOOSEPLAIN] +
    "|" +
    _[x.XRANGEPLAIN] +
    ")";
  Cg[x.COMPARATORTRIM] = new RegExp(_[x.COMPARATORTRIM], "g");
  jA[x.COMPARATORTRIM] = new RegExp(SF(_[x.COMPARATORTRIM]), "g");
  var bt = "$1$2$3";
  WA("HYPHENRANGE");
  _[x.HYPHENRANGE] =
    "^\\s*(" + _[x.XRANGEPLAIN] + ")\\s+-\\s+(" + _[x.XRANGEPLAIN] + ")\\s*$";
  WA("HYPHENRANGELOOSE");
  _[x.HYPHENRANGELOOSE] =
    "^\\s*(" +
    _[x.XRANGEPLAINLOOSE] +
    ")\\s+-\\s+(" +
    _[x.XRANGEPLAINLOOSE] +
    ")\\s*$";
  WA("STAR");
  _[x.STAR] = "(<|>)?=?\\s*\\*";
  for (TI = 0; TI < $V; TI++)
    if ((fA(TI, _[TI]), !Cg[TI]))
      (Cg[TI] = new RegExp(_[TI])), (jA[TI] = new RegExp(SF(_[TI])));
  var TI;
  FA.parse = nC;
  function nC(A, Q) {
    if (!Q || typeof Q !== "object") Q = { loose: !!Q, includePrerelease: !1 };
    if (A instanceof GA) return A;
    if (typeof A !== "string") return null;
    if (A.length > _F) return null;
    var B = Q.loose ? jA[x.LOOSE] : jA[x.FULL];
    if (!B.test(A)) return null;
    try {
      return new GA(A, Q);
    } catch (I) {
      return null;
    }
  }
  FA.valid = mt;
  function mt(A, Q) {
    var B = nC(A, Q);
    return B ? B.version : null;
  }
  FA.clean = dt;
  function dt(A, Q) {
    var B = nC(A.trim().replace(/^[=v]+/, ""), Q);
    return B ? B.version : null;
  }
  FA.SemVer = GA;
  function GA(A, Q) {
    if (!Q || typeof Q !== "object") Q = { loose: !!Q, includePrerelease: !1 };
    if (A instanceof GA)
      if (A.loose === Q.loose) return A;
      else A = A.version;
    else if (typeof A !== "string") throw TypeError("Invalid Version: " + A);
    if (A.length > _F)
      throw TypeError("version is longer than " + _F + " characters");
    if (!(this instanceof GA)) return new GA(A, Q);
    fA("SemVer", A, Q), (this.options = Q), (this.loose = !!Q.loose);
    var B = A.trim().match(Q.loose ? jA[x.LOOSE] : jA[x.FULL]);
    if (!B) throw TypeError("Invalid Version: " + A);
    if (
      ((this.raw = A),
      (this.major = +B[1]),
      (this.minor = +B[2]),
      (this.patch = +B[3]),
      this.major > $J || this.major < 0)
    )
      throw TypeError("Invalid major version");
    if (this.minor > $J || this.minor < 0)
      throw TypeError("Invalid minor version");
    if (this.patch > $J || this.patch < 0)
      throw TypeError("Invalid patch version");
    if (!B[4]) this.prerelease = [];
    else
      this.prerelease = B[4].split(".").map(function (I) {
        if (/^[0-9]+$/.test(I)) {
          var E = +I;
          if (E >= 0 && E < $J) return E;
        }
        return I;
      });
    (this.build = B[5] ? B[5].split(".") : []), this.format();
  }
  GA.prototype.format = function () {
    if (
      ((this.version = this.major + "." + this.minor + "." + this.patch),
      this.prerelease.length)
    )
      this.version += "-" + this.prerelease.join(".");
    return this.version;
  };
  GA.prototype.toString = function () {
    return this.version;
  };
  GA.prototype.compare = function (A) {
    if (
      (fA("SemVer.compare", this.version, this.options, A), !(A instanceof GA))
    )
      A = new GA(A, this.options);
    return this.compareMain(A) || this.comparePre(A);
  };
  GA.prototype.compareMain = function (A) {
    if (!(A instanceof GA)) A = new GA(A, this.options);
    return (
      iC(this.major, A.major) ||
      iC(this.minor, A.minor) ||
      iC(this.patch, A.patch)
    );
  };
  GA.prototype.comparePre = function (A) {
    if (!(A instanceof GA)) A = new GA(A, this.options);
    if (this.prerelease.length && !A.prerelease.length) return -1;
    else if (!this.prerelease.length && A.prerelease.length) return 1;
    else if (!this.prerelease.length && !A.prerelease.length) return 0;
    var Q = 0;
    do {
      var B = this.prerelease[Q],
        I = A.prerelease[Q];
      if ((fA("prerelease compare", Q, B, I), B === void 0 && I === void 0))
        return 0;
      else if (I === void 0) return 1;
      else if (B === void 0) return -1;
      else if (B === I) continue;
      else return iC(B, I);
    } while (++Q);
  };
  GA.prototype.compareBuild = function (A) {
    if (!(A instanceof GA)) A = new GA(A, this.options);
    var Q = 0;
    do {
      var B = this.build[Q],
        I = A.build[Q];
      if ((fA("prerelease compare", Q, B, I), B === void 0 && I === void 0))
        return 0;
      else if (I === void 0) return 1;
      else if (B === void 0) return -1;
      else if (B === I) continue;
      else return iC(B, I);
    } while (++Q);
  };
  GA.prototype.inc = function (A, Q) {
    switch (A) {
      case "premajor":
        (this.prerelease.length = 0),
          (this.patch = 0),
          (this.minor = 0),
          this.major++,
          this.inc("pre", Q);
        break;
      case "preminor":
        (this.prerelease.length = 0),
          (this.patch = 0),
          this.minor++,
          this.inc("pre", Q);
        break;
      case "prepatch":
        (this.prerelease.length = 0), this.inc("patch", Q), this.inc("pre", Q);
        break;
      case "prerelease":
        if (this.prerelease.length === 0) this.inc("patch", Q);
        this.inc("pre", Q);
        break;
      case "major":
        if (
          this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0
        )
          this.major++;
        (this.minor = 0), (this.patch = 0), (this.prerelease = []);
        break;
      case "minor":
        if (this.patch !== 0 || this.prerelease.length === 0) this.minor++;
        (this.patch = 0), (this.prerelease = []);
        break;
      case "patch":
        if (this.prerelease.length === 0) this.patch++;
        this.prerelease = [];
        break;
      case "pre":
        if (this.prerelease.length === 0) this.prerelease = [0];
        else {
          var B = this.prerelease.length;
          while (--B >= 0)
            if (typeof this.prerelease[B] === "number")
              this.prerelease[B]++, (B = -2);
          if (B === -1) this.prerelease.push(0);
        }
        if (Q)
          if (this.prerelease[0] === Q) {
            if (isNaN(this.prerelease[1])) this.prerelease = [Q, 0];
          } else this.prerelease = [Q, 0];
        break;
      default:
        throw Error("invalid increment argument: " + A);
    }
    return this.format(), (this.raw = this.version), this;
  };
  FA.inc = ct;
  function ct(A, Q, B, I) {
    if (typeof B === "string") (I = B), (B = void 0);
    try {
      return new GA(A, B).inc(Q, I).version;
    } catch (E) {
      return null;
    }
  }
  FA.diff = ut;
  function ut(A, Q) {
    if (nZ(A, Q)) return null;
    else {
      var B = nC(A),
        I = nC(Q),
        E = "";
      if (B.prerelease.length || I.prerelease.length) {
        E = "pre";
        var C = "prerelease";
      }
      for (var g in B)
        if (g === "major" || g === "minor" || g === "patch") {
          if (B[g] !== I[g]) return E + g;
        }
      return C;
    }
  }
  FA.compareIdentifiers = iC;
  var RV = /^[0-9]+$/;
  function iC(A, Q) {
    var B = RV.test(A),
      I = RV.test(Q);
    if (B && I) (A = +A), (Q = +Q);
    return A === Q ? 0 : B && !I ? -1 : I && !B ? 1 : A < Q ? -1 : 1;
  }
  FA.rcompareIdentifiers = lt;
  function lt(A, Q) {
    return iC(Q, A);
  }
  FA.major = pt;
  function pt(A, Q) {
    return new GA(A, Q).major;
  }
  FA.minor = it;
  function it(A, Q) {
    return new GA(A, Q).minor;
  }
  FA.patch = nt;
  function nt(A, Q) {
    return new GA(A, Q).patch;
  }
  FA.compare = ME;
  function ME(A, Q, B) {
    return new GA(A, B).compare(new GA(Q, B));
  }
  FA.compareLoose = at;
  function at(A, Q) {
    return ME(A, Q, !0);
  }
  FA.compareBuild = ot;
  function ot(A, Q, B) {
    var I = new GA(A, B),
      E = new GA(Q, B);
    return I.compare(E) || I.compareBuild(E);
  }
  FA.rcompare = st;
  function st(A, Q, B) {
    return ME(Q, A, B);
  }
  FA.sort = rt;
  function rt(A, Q) {
    return A.sort(function (B, I) {
      return FA.compareBuild(B, I, Q);
    });
  }
  FA.rsort = tt;
  function tt(A, Q) {
    return A.sort(function (B, I) {
      return FA.compareBuild(I, B, Q);
    });
  }
  FA.gt = yF;
  function yF(A, Q, B) {
    return ME(A, Q, B) > 0;
  }
  FA.lt = HJ;
  function HJ(A, Q, B) {
    return ME(A, Q, B) < 0;
  }
  FA.eq = nZ;
  function nZ(A, Q, B) {
    return ME(A, Q, B) === 0;
  }
  FA.neq = HV;
  function HV(A, Q, B) {
    return ME(A, Q, B) !== 0;
  }
  FA.gte = aZ;
  function aZ(A, Q, B) {
    return ME(A, Q, B) >= 0;
  }
  FA.lte = oZ;
  function oZ(A, Q, B) {
    return ME(A, Q, B) <= 0;
  }
  FA.cmp = KJ;
  function KJ(A, Q, B, I) {
    switch (Q) {
      case "===":
        if (typeof A === "object") A = A.version;
        if (typeof B === "object") B = B.version;
        return A === B;
      case "!==":
        if (typeof A === "object") A = A.version;
        if (typeof B === "object") B = B.version;
        return A !== B;
      case "":
      case "=":
      case "==":
        return nZ(A, B, I);
      case "!=":
        return HV(A, B, I);
      case ">":
        return yF(A, B, I);
      case ">=":
        return aZ(A, B, I);
      case "<":
        return HJ(A, B, I);
      case "<=":
        return oZ(A, B, I);
      default:
        throw TypeError("Invalid operator: " + Q);
    }
  }
  FA.Comparator = NI;
  function NI(A, Q) {
    if (!Q || typeof Q !== "object") Q = { loose: !!Q, includePrerelease: !1 };
    if (A instanceof NI)
      if (A.loose === !!Q.loose) return A;
      else A = A.value;
    if (!(this instanceof NI)) return new NI(A, Q);
    if (
      ((A = A.trim().split(/\s+/).join(" ")),
      fA("comparator", A, Q),
      (this.options = Q),
      (this.loose = !!Q.loose),
      this.parse(A),
      this.semver === gg)
    )
      this.value = "";
    else this.value = this.operator + this.semver.version;
    fA("comp", this);
  }
  var gg = {};
  NI.prototype.parse = function (A) {
    var Q = this.options.loose ? jA[x.COMPARATORLOOSE] : jA[x.COMPARATOR],
      B = A.match(Q);
    if (!B) throw TypeError("Invalid comparator: " + A);
    if (((this.operator = B[1] !== void 0 ? B[1] : ""), this.operator === "="))
      this.operator = "";
    if (!B[2]) this.semver = gg;
    else this.semver = new GA(B[2], this.options.loose);
  };
  NI.prototype.toString = function () {
    return this.value;
  };
  NI.prototype.test = function (A) {
    if (
      (fA("Comparator.test", A, this.options.loose),
      this.semver === gg || A === gg)
    )
      return !0;
    if (typeof A === "string")
      try {
        A = new GA(A, this.options);
      } catch (Q) {
        return !1;
      }
    return KJ(A, this.operator, this.semver, this.options);
  };
  NI.prototype.intersects = function (A, Q) {
    if (!(A instanceof NI)) throw TypeError("a Comparator is required");
    if (!Q || typeof Q !== "object") Q = { loose: !!Q, includePrerelease: !1 };
    var B;
    if (this.operator === "") {
      if (this.value === "") return !0;
      return (B = new FQ(A.value, Q)), zJ(this.value, B, Q);
    } else if (A.operator === "") {
      if (A.value === "") return !0;
      return (B = new FQ(this.value, Q)), zJ(A.semver, B, Q);
    }
    var I =
        (this.operator === ">=" || this.operator === ">") &&
        (A.operator === ">=" || A.operator === ">"),
      E =
        (this.operator === "<=" || this.operator === "<") &&
        (A.operator === "<=" || A.operator === "<"),
      C = this.semver.version === A.semver.version,
      g =
        (this.operator === ">=" || this.operator === "<=") &&
        (A.operator === ">=" || A.operator === "<="),
      F =
        KJ(this.semver, "<", A.semver, Q) &&
        (this.operator === ">=" || this.operator === ">") &&
        (A.operator === "<=" || A.operator === "<"),
      D =
        KJ(this.semver, ">", A.semver, Q) &&
        (this.operator === "<=" || this.operator === "<") &&
        (A.operator === ">=" || A.operator === ">");
    return I || E || (C && g) || F || D;
  };
  FA.Range = FQ;
  function FQ(A, Q) {
    if (!Q || typeof Q !== "object") Q = { loose: !!Q, includePrerelease: !1 };
    if (A instanceof FQ)
      if (
        A.loose === !!Q.loose &&
        A.includePrerelease === !!Q.includePrerelease
      )
        return A;
      else return new FQ(A.raw, Q);
    if (A instanceof NI) return new FQ(A.value, Q);
    if (!(this instanceof FQ)) return new FQ(A, Q);
    if (
      ((this.options = Q),
      (this.loose = !!Q.loose),
      (this.includePrerelease = !!Q.includePrerelease),
      (this.raw = A.trim().split(/\s+/).join(" ")),
      (this.set = this.raw
        .split("||")
        .map(function (B) {
          return this.parseRange(B.trim());
        }, this)
        .filter(function (B) {
          return B.length;
        })),
      !this.set.length)
    )
      throw TypeError("Invalid SemVer Range: " + this.raw);
    this.format();
  }
  FQ.prototype.format = function () {
    return (
      (this.range = this.set
        .map(function (A) {
          return A.join(" ").trim();
        })
        .join("||")
        .trim()),
      this.range
    );
  };
  FQ.prototype.toString = function () {
    return this.range;
  };
  FQ.prototype.parseRange = function (A) {
    var Q = this.options.loose,
      B = Q ? jA[x.HYPHENRANGELOOSE] : jA[x.HYPHENRANGE];
    (A = A.replace(B, De)),
      fA("hyphen replace", A),
      (A = A.replace(jA[x.COMPARATORTRIM], bt)),
      fA("comparator trim", A, jA[x.COMPARATORTRIM]),
      (A = A.replace(jA[x.TILDETRIM], yt)),
      (A = A.replace(jA[x.CARETTRIM], St)),
      (A = A.split(/\s+/).join(" "));
    var I = Q ? jA[x.COMPARATORLOOSE] : jA[x.COMPARATOR],
      E = A.split(" ")
        .map(function (C) {
          return Ae(C, this.options);
        }, this)
        .join(" ")
        .split(/\s+/);
    if (this.options.loose)
      E = E.filter(function (C) {
        return !!C.match(I);
      });
    return (
      (E = E.map(function (C) {
        return new NI(C, this.options);
      }, this)),
      E
    );
  };
  FQ.prototype.intersects = function (A, Q) {
    if (!(A instanceof FQ)) throw TypeError("a Range is required");
    return this.set.some(function (B) {
      return (
        VV(B, Q) &&
        A.set.some(function (I) {
          return (
            VV(I, Q) &&
            B.every(function (E) {
              return I.every(function (C) {
                return E.intersects(C, Q);
              });
            })
          );
        })
      );
    });
  };
  function VV(A, Q) {
    var B = !0,
      I = A.slice(),
      E = I.pop();
    while (B && I.length)
      (B = I.every(function (C) {
        return E.intersects(C, Q);
      })),
        (E = I.pop());
    return B;
  }
  FA.toComparators = et;
  function et(A, Q) {
    return new FQ(A, Q).set.map(function (B) {
      return B.map(function (I) {
        return I.value;
      })
        .join(" ")
        .trim()
        .split(" ");
    });
  }
  function Ae(A, Q) {
    return (
      fA("comp", A, Q),
      (A = Ie(A, Q)),
      fA("caret", A),
      (A = Qe(A, Q)),
      fA("tildes", A),
      (A = Ce(A, Q)),
      fA("xrange", A),
      (A = Fe(A, Q)),
      fA("stars", A),
      A
    );
  }
  function GB(A) {
    return !A || A.toLowerCase() === "x" || A === "*";
  }
  function Qe(A, Q) {
    return A.trim()
      .split(/\s+/)
      .map(function (B) {
        return Be(B, Q);
      })
      .join(" ");
  }
  function Be(A, Q) {
    var B = Q.loose ? jA[x.TILDELOOSE] : jA[x.TILDE];
    return A.replace(B, function (I, E, C, g, F) {
      fA("tilde", A, I, E, C, g, F);
      var D;
      if (GB(E)) D = "";
      else if (GB(C)) D = ">=" + E + ".0.0 <" + (+E + 1) + ".0.0";
      else if (GB(g))
        D = ">=" + E + "." + C + ".0 <" + E + "." + (+C + 1) + ".0";
      else if (F)
        fA("replaceTilde pr", F),
          (D =
            ">=" +
            E +
            "." +
            C +
            "." +
            g +
            "-" +
            F +
            " <" +
            E +
            "." +
            (+C + 1) +
            ".0");
      else D = ">=" + E + "." + C + "." + g + " <" + E + "." + (+C + 1) + ".0";
      return fA("tilde return", D), D;
    });
  }
  function Ie(A, Q) {
    return A.trim()
      .split(/\s+/)
      .map(function (B) {
        return Ee(B, Q);
      })
      .join(" ");
  }
  function Ee(A, Q) {
    fA("caret", A, Q);
    var B = Q.loose ? jA[x.CARETLOOSE] : jA[x.CARET];
    return A.replace(B, function (I, E, C, g, F) {
      fA("caret", A, I, E, C, g, F);
      var D;
      if (GB(E)) D = "";
      else if (GB(C)) D = ">=" + E + ".0.0 <" + (+E + 1) + ".0.0";
      else if (GB(g))
        if (E === "0")
          D = ">=" + E + "." + C + ".0 <" + E + "." + (+C + 1) + ".0";
        else D = ">=" + E + "." + C + ".0 <" + (+E + 1) + ".0.0";
      else if (F)
        if ((fA("replaceCaret pr", F), E === "0"))
          if (C === "0")
            D =
              ">=" +
              E +
              "." +
              C +
              "." +
              g +
              "-" +
              F +
              " <" +
              E +
              "." +
              C +
              "." +
              (+g + 1);
          else
            D =
              ">=" +
              E +
              "." +
              C +
              "." +
              g +
              "-" +
              F +
              " <" +
              E +
              "." +
              (+C + 1) +
              ".0";
        else
          D = ">=" + E + "." + C + "." + g + "-" + F + " <" + (+E + 1) + ".0.0";
      else if ((fA("no pr"), E === "0"))
        if (C === "0")
          D =
            ">=" + E + "." + C + "." + g + " <" + E + "." + C + "." + (+g + 1);
        else
          D = ">=" + E + "." + C + "." + g + " <" + E + "." + (+C + 1) + ".0";
      else D = ">=" + E + "." + C + "." + g + " <" + (+E + 1) + ".0.0";
      return fA("caret return", D), D;
    });
  }
  function Ce(A, Q) {
    return (
      fA("replaceXRanges", A, Q),
      A.split(/\s+/)
        .map(function (B) {
          return ge(B, Q);
        })
        .join(" ")
    );
  }
  function ge(A, Q) {
    A = A.trim();
    var B = Q.loose ? jA[x.XRANGELOOSE] : jA[x.XRANGE];
    return A.replace(B, function (I, E, C, g, F, D) {
      fA("xRange", A, I, E, C, g, F, D);
      var J = GB(C),
        Y = J || GB(g),
        N = Y || GB(F),
        W = N;
      if (E === "=" && W) E = "";
      if (((D = Q.includePrerelease ? "-0" : ""), J))
        if (E === ">" || E === "<") I = "<0.0.0-0";
        else I = "*";
      else if (E && W) {
        if (Y) g = 0;
        if (((F = 0), E === ">"))
          if (((E = ">="), Y)) (C = +C + 1), (g = 0), (F = 0);
          else (g = +g + 1), (F = 0);
        else if (E === "<=")
          if (((E = "<"), Y)) C = +C + 1;
          else g = +g + 1;
        I = E + C + "." + g + "." + F + D;
      } else if (Y) I = ">=" + C + ".0.0" + D + " <" + (+C + 1) + ".0.0" + D;
      else if (N)
        I =
          ">=" + C + "." + g + ".0" + D + " <" + C + "." + (+g + 1) + ".0" + D;
      return fA("xRange return", I), I;
    });
  }
  function Fe(A, Q) {
    return fA("replaceStars", A, Q), A.trim().replace(jA[x.STAR], "");
  }
  function De(A, Q, B, I, E, C, g, F, D, J, Y, N, W) {
    if (GB(B)) Q = "";
    else if (GB(I)) Q = ">=" + B + ".0.0";
    else if (GB(E)) Q = ">=" + B + "." + I + ".0";
    else Q = ">=" + Q;
    if (GB(D)) F = "";
    else if (GB(J)) F = "<" + (+D + 1) + ".0.0";
    else if (GB(Y)) F = "<" + D + "." + (+J + 1) + ".0";
    else if (N) F = "<=" + D + "." + J + "." + Y + "-" + N;
    else F = "<=" + F;
    return (Q + " " + F).trim();
  }
  FQ.prototype.test = function (A) {
    if (!A) return !1;
    if (typeof A === "string")
      try {
        A = new GA(A, this.options);
      } catch (B) {
        return !1;
      }
    for (var Q = 0; Q < this.set.length; Q++)
      if (Ye(this.set[Q], A, this.options)) return !0;
    return !1;
  };
  function Ye(A, Q, B) {
    for (var I = 0; I < A.length; I++) if (!A[I].test(Q)) return !1;
    if (Q.prerelease.length && !B.includePrerelease) {
      for (I = 0; I < A.length; I++) {
        if ((fA(A[I].semver), A[I].semver === gg)) continue;
        if (A[I].semver.prerelease.length > 0) {
          var E = A[I].semver;
          if (E.major === Q.major && E.minor === Q.minor && E.patch === Q.patch)
            return !0;
        }
      }
      return !1;
    }
    return !0;
  }
  FA.satisfies = zJ;
  function zJ(A, Q, B) {
    try {
      Q = new FQ(Q, B);
    } catch (I) {
      return !1;
    }
    return Q.test(A);
  }
  FA.maxSatisfying = Je;
  function Je(A, Q, B) {
    var I = null,
      E = null;
    try {
      var C = new FQ(Q, B);
    } catch (g) {
      return null;
    }
    return (
      A.forEach(function (g) {
        if (C.test(g)) {
          if (!I || E.compare(g) === -1) (I = g), (E = new GA(I, B));
        }
      }),
      I
    );
  }
  FA.minSatisfying = Ne;
  function Ne(A, Q, B) {
    var I = null,
      E = null;
    try {
      var C = new FQ(Q, B);
    } catch (g) {
      return null;
    }
    return (
      A.forEach(function (g) {
        if (C.test(g)) {
          if (!I || E.compare(g) === 1) (I = g), (E = new GA(I, B));
        }
      }),
      I
    );
  }
  FA.minVersion = Ge;
  function Ge(A, Q) {
    A = new FQ(A, Q);
    var B = new GA("0.0.0");
    if (A.test(B)) return B;
    if (((B = new GA("0.0.0-0")), A.test(B))) return B;
    B = null;
    for (var I = 0; I < A.set.length; ++I) {
      var E = A.set[I];
      E.forEach(function (C) {
        var g = new GA(C.semver.version);
        switch (C.operator) {
          case ">":
            if (g.prerelease.length === 0) g.patch++;
            else g.prerelease.push(0);
            g.raw = g.format();
          case "":
          case ">=":
            if (!B || yF(B, g)) B = g;
            break;
          case "<":
          case "<=":
            break;
          default:
            throw Error("Unexpected operation: " + C.operator);
        }
      });
    }
    if (B && A.test(B)) return B;
    return null;
  }
  FA.validRange = Ue;
  function Ue(A, Q) {
    try {
      return new FQ(A, Q).range || "*";
    } catch (B) {
      return null;
    }
  }
  FA.ltr = We;
  function We(A, Q, B) {
    return sZ(A, Q, "<", B);
  }
  FA.gtr = Ze;
  function Ze(A, Q, B) {
    return sZ(A, Q, ">", B);
  }
  FA.outside = sZ;
  function sZ(A, Q, B, I) {
    (A = new GA(A, I)), (Q = new FQ(Q, I));
    var E, C, g, F, D;
    switch (B) {
      case ">":
        (E = yF), (C = oZ), (g = HJ), (F = ">"), (D = ">=");
        break;
      case "<":
        (E = HJ), (C = aZ), (g = yF), (F = "<"), (D = "<=");
        break;
      default:
        throw TypeError('Must provide a hilo val of "<" or ">"');
    }
    if (zJ(A, Q, I)) return !1;
    for (var J = 0; J < Q.set.length; ++J) {
      var Y = Q.set[J],
        N = null,
        W = null;
      if (
        (Y.forEach(function (X) {
          if (X.semver === gg) X = new NI(">=0.0.0");
          if (((N = N || X), (W = W || X), E(X.semver, N.semver, I))) N = X;
          else if (g(X.semver, W.semver, I)) W = X;
        }),
        N.operator === F || N.operator === D)
      )
        return !1;
      if ((!W.operator || W.operator === F) && C(A, W.semver)) return !1;
      else if (W.operator === D && g(A, W.semver)) return !1;
    }
    return !0;
  }
  FA.prerelease = Xe;
  function Xe(A, Q) {
    var B = nC(A, Q);
    return B && B.prerelease.length ? B.prerelease : null;
  }
  FA.intersects = we;
  function we(A, Q, B) {
    return (A = new FQ(A, B)), (Q = new FQ(Q, B)), A.intersects(Q);
  }
  FA.coerce = Me;
  function Me(A, Q) {
    if (A instanceof GA) return A;
    if (typeof A === "number") A = String(A);
    if (typeof A !== "string") return null;
    Q = Q || {};
    var B = null;
    if (!Q.rtl) B = A.match(jA[x.COERCE]);
    else {
      var I;
      while (
        (I = jA[x.COERCERTL].exec(A)) &&
        (!B || B.index + B[0].length !== A.length)
      ) {
        if (!B || I.index + I[0].length !== B.index + B[0].length) B = I;
        jA[x.COERCERTL].lastIndex = I.index + I[1].length + I[2].length;
      }
      jA[x.COERCERTL].lastIndex = -1;
    }
    if (B === null) return null;
    return nC(B[2] + "." + (B[3] || "0") + "." + (B[4] || "0"), Q);
  }
});
var bF = Z((jV) => {
  Object.defineProperty(jV, "__esModule", { value: !0 });
  jV.ManifestFilename =
    jV.TarFilename =
    jV.SystemTarPathOnWindows =
    jV.GnuTarPathOnWindows =
    jV.SocketTimeout =
    jV.DefaultRetryDelay =
    jV.DefaultRetryAttempts =
    jV.ArchiveToolType =
    jV.CompressionMethod =
    jV.CacheFilename =
      void 0;
  var TV;
  (function (A) {
    (A.Gzip = "cache.tgz"), (A.Zstd = "cache.tzst");
  })(TV || (jV.CacheFilename = TV = {}));
  var OV;
  (function (A) {
    (A.Gzip = "gzip"),
      (A.ZstdWithoutLong = "zstd-without-long"),
      (A.Zstd = "zstd");
  })(OV || (jV.CompressionMethod = OV = {}));
  var qV;
  (function (A) {
    (A.GNU = "gnu"), (A.BSD = "bsd");
  })(qV || (jV.ArchiveToolType = qV = {}));
  jV.DefaultRetryAttempts = 2;
  jV.DefaultRetryDelay = 5000;
  jV.SocketTimeout = 5000;
  jV.GnuTarPathOnWindows = `${process.env.PROGRAMFILES}\\Git\\usr\\bin\\tar.exe`;
  jV.SystemTarPathOnWindows = `${process.env.SYSTEMDRIVE}\\Windows\\System32\\tar.exe`;
  jV.TarFilename = "cache.tar";
  jV.ManifestFilename = "manifest.txt";
});
var dF = Z((hA) => {
  var qe =
      (hA && hA.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            var E = Object.getOwnPropertyDescriptor(Q, B);
            if (
              !E ||
              ("get" in E ? !Q.__esModule : E.writable || E.configurable)
            )
              E = {
                enumerable: !0,
                get: function () {
                  return Q[B];
                },
              };
            Object.defineProperty(A, I, E);
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    je =
      (hA && hA.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    LE =
      (hA && hA.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.prototype.hasOwnProperty.call(A, B))
              qe(Q, A, B);
        }
        return je(Q, A), Q;
      },
    Fg =
      (hA && hA.__awaiter) ||
      function (A, Q, B, I) {
        function E(C) {
          return C instanceof B
            ? C
            : new B(function (g) {
                g(C);
              });
        }
        return new (B || (B = Promise))(function (C, g) {
          function F(Y) {
            try {
              J(I.next(Y));
            } catch (N) {
              g(N);
            }
          }
          function D(Y) {
            try {
              J(I.throw(Y));
            } catch (N) {
              g(N);
            }
          }
          function J(Y) {
            Y.done ? C(Y.value) : E(Y.value).then(F, D);
          }
          J((I = I.apply(A, Q || [])).next());
        });
      },
    fe =
      (hA && hA.__asyncValues) ||
      function (A) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var Q = A[Symbol.asyncIterator],
          B;
        return Q
          ? Q.call(A)
          : ((A =
              typeof __values === "function"
                ? __values(A)
                : A[Symbol.iterator]()),
            (B = {}),
            I("next"),
            I("throw"),
            I("return"),
            (B[Symbol.asyncIterator] = function () {
              return this;
            }),
            B);
        function I(C) {
          B[C] =
            A[C] &&
            function (g) {
              return new Promise(function (F, D) {
                (g = A[C](g)), E(F, D, g.done, g.value);
              });
            };
        }
        function E(C, g, F, D) {
          Promise.resolve(D).then(function (J) {
            C({ value: J, done: F });
          }, g);
        }
      };
  Object.defineProperty(hA, "__esModule", { value: !0 });
  hA.isGhes =
    hA.assertDefined =
    hA.getGnuTarPathOnWindows =
    hA.getCacheFileName =
    hA.getCompressionMethod =
    hA.unlinkFile =
    hA.resolvePaths =
    hA.getArchiveFileSizeInBytes =
    hA.createTempDirectory =
      void 0;
  var mF = LE($B()),
    he = LE(Qg()),
    ke = LE(LV()),
    hV = LE(qF()),
    xe = LE($("crypto")),
    rZ = LE($("fs")),
    TJ = LE($("path")),
    ve = LE(zV()),
    Pe = LE($("util")),
    aC = bF();
  function _e() {
    return Fg(this, void 0, void 0, function* () {
      let A = process.platform === "win32",
        Q = process.env.RUNNER_TEMP || "";
      if (!Q) {
        let I;
        if (A) I = process.env.USERPROFILE || "C:\\";
        else if (process.platform === "darwin") I = "/Users";
        else I = "/home";
        Q = TJ.join(I, "actions", "temp");
      }
      let B = TJ.join(Q, xe.randomUUID());
      return yield hV.mkdirP(B), B;
    });
  }
  hA.createTempDirectory = _e;
  function ye(A) {
    return rZ.statSync(A).size;
  }
  hA.getArchiveFileSizeInBytes = ye;
  function Se(A) {
    var Q, B, I, E, C;
    return Fg(this, void 0, void 0, function* () {
      let g = [],
        F =
          (C = process.env.GITHUB_WORKSPACE) !== null && C !== void 0
            ? C
            : process.cwd(),
        D = yield ke.create(
          A.join(`
`),
          { implicitDescendants: !1 },
        );
      try {
        for (
          var J = !0, Y = fe(D.globGenerator()), N;
          (N = yield Y.next()), (Q = N.done), !Q;
          J = !0
        ) {
          (E = N.value), (J = !1);
          let W = E,
            X = TJ.relative(F, W).replace(new RegExp(`\\${TJ.sep}`, "g"), "/");
          if ((mF.debug(`Matched: ${X}`), X === "")) g.push(".");
          else g.push(`${X}`);
        }
      } catch (W) {
        B = { error: W };
      } finally {
        try {
          if (!J && !Q && (I = Y.return)) yield I.call(Y);
        } finally {
          if (B) throw B.error;
        }
      }
      return g;
    });
  }
  hA.resolvePaths = Se;
  function be(A) {
    return Fg(this, void 0, void 0, function* () {
      return Pe.promisify(rZ.unlink)(A);
    });
  }
  hA.unlinkFile = be;
  function kV(A, Q = []) {
    return Fg(this, void 0, void 0, function* () {
      let B = "";
      Q.push("--version"), mF.debug(`Checking ${A} ${Q.join(" ")}`);
      try {
        yield he.exec(`${A}`, Q, {
          ignoreReturnCode: !0,
          silent: !0,
          listeners: {
            stdout: (I) => (B += I.toString()),
            stderr: (I) => (B += I.toString()),
          },
        });
      } catch (I) {
        mF.debug(I.message);
      }
      return (B = B.trim()), mF.debug(B), B;
    });
  }
  function me() {
    return Fg(this, void 0, void 0, function* () {
      let A = yield kV("zstd", ["--quiet"]),
        Q = ve.clean(A);
      if ((mF.debug(`zstd version: ${Q}`), A === ""))
        return aC.CompressionMethod.Gzip;
      else return aC.CompressionMethod.ZstdWithoutLong;
    });
  }
  hA.getCompressionMethod = me;
  function de(A) {
    return A === aC.CompressionMethod.Gzip
      ? aC.CacheFilename.Gzip
      : aC.CacheFilename.Zstd;
  }
  hA.getCacheFileName = de;
  function ce() {
    return Fg(this, void 0, void 0, function* () {
      if (rZ.existsSync(aC.GnuTarPathOnWindows)) return aC.GnuTarPathOnWindows;
      return (yield kV("tar")).toLowerCase().includes("gnu tar")
        ? hV.which("tar")
        : "";
    });
  }
  hA.getGnuTarPathOnWindows = ce;
  function ue(A, Q) {
    if (Q === void 0) throw Error(`Expected ${A} but value was undefiend`);
    return Q;
  }
  hA.assertDefined = ue;
  function le() {
    let Q = new URL(
        process.env.GITHUB_SERVER_URL || "https://github.com",
      ).hostname
        .trimEnd()
        .toUpperCase(),
      B = Q === "GITHUB.COM",
      I = Q.endsWith(".GHE.COM") || Q.endsWith(".GHE.LOCALHOST");
    return !B && !I;
  }
  hA.isGhes = le;
});
var BQ = Z((p$A, jJ) => {
  var xV,
    vV,
    PV,
    _V,
    yV,
    SV,
    bV,
    mV,
    dV,
    cV,
    uV,
    lV,
    pV,
    OJ,
    tZ,
    iV,
    nV,
    aV,
    Dg,
    oV,
    sV,
    rV,
    tV,
    eV,
    A3,
    Q3,
    B3,
    I3,
    qJ,
    E3,
    C3,
    g3;
  (function (A) {
    var Q =
      typeof global === "object"
        ? global
        : typeof self === "object"
          ? self
          : typeof this === "object"
            ? this
            : {};
    if (typeof define === "function" && define.amd)
      define("tslib", ["exports"], function (I) {
        A(B(Q, B(I)));
      });
    else if (typeof jJ === "object" && typeof p$A === "object") A(B(Q, B(p$A)));
    else A(B(Q));
    function B(I, E) {
      if (I !== Q)
        if (typeof Object.create === "function")
          Object.defineProperty(I, "__esModule", { value: !0 });
        else I.__esModule = !0;
      return function (C, g) {
        return (I[C] = E ? E(C, g) : g);
      };
    }
  })(function (A) {
    var Q =
      Object.setPrototypeOf ||
      ({ __proto__: [] } instanceof Array &&
        function (C, g) {
          C.__proto__ = g;
        }) ||
      function (C, g) {
        for (var F in g)
          if (Object.prototype.hasOwnProperty.call(g, F)) C[F] = g[F];
      };
    (xV = function (C, g) {
      if (typeof g !== "function" && g !== null)
        throw TypeError(
          "Class extends value " + String(g) + " is not a constructor or null",
        );
      Q(C, g);
      function F() {
        this.constructor = C;
      }
      C.prototype =
        g === null ? Object.create(g) : ((F.prototype = g.prototype), new F());
    }),
      (vV =
        Object.assign ||
        function (C) {
          for (var g, F = 1, D = arguments.length; F < D; F++) {
            g = arguments[F];
            for (var J in g)
              if (Object.prototype.hasOwnProperty.call(g, J)) C[J] = g[J];
          }
          return C;
        }),
      (PV = function (C, g) {
        var F = {};
        for (var D in C)
          if (Object.prototype.hasOwnProperty.call(C, D) && g.indexOf(D) < 0)
            F[D] = C[D];
        if (C != null && typeof Object.getOwnPropertySymbols === "function") {
          for (
            var J = 0, D = Object.getOwnPropertySymbols(C);
            J < D.length;
            J++
          )
            if (
              g.indexOf(D[J]) < 0 &&
              Object.prototype.propertyIsEnumerable.call(C, D[J])
            )
              F[D[J]] = C[D[J]];
        }
        return F;
      }),
      (_V = function (C, g, F, D) {
        var J = arguments.length,
          Y =
            J < 3
              ? g
              : D === null
                ? (D = Object.getOwnPropertyDescriptor(g, F))
                : D,
          N;
        if (
          typeof Reflect === "object" &&
          typeof Reflect.decorate === "function"
        )
          Y = Reflect.decorate(C, g, F, D);
        else
          for (var W = C.length - 1; W >= 0; W--)
            if ((N = C[W]))
              Y = (J < 3 ? N(Y) : J > 3 ? N(g, F, Y) : N(g, F)) || Y;
        return J > 3 && Y && Object.defineProperty(g, F, Y), Y;
      }),
      (yV = function (C, g) {
        return function (F, D) {
          g(F, D, C);
        };
      }),
      (SV = function (C, g, F, D, J, Y) {
        function N(t) {
          if (t !== void 0 && typeof t !== "function")
            throw TypeError("Function expected");
          return t;
        }
        var W = D.kind,
          X = W === "getter" ? "get" : W === "setter" ? "set" : "value",
          M = !g && C ? (D.static ? C : C.prototype) : null,
          L = g || (M ? Object.getOwnPropertyDescriptor(M, D.name) : {}),
          H,
          q = !1;
        for (var O = F.length - 1; O >= 0; O--) {
          var f = {};
          for (var S in D) f[S] = S === "access" ? {} : D[S];
          for (var S in D.access) f.access[S] = D.access[S];
          f.addInitializer = function (t) {
            if (q)
              throw TypeError(
                "Cannot add initializers after decoration has completed",
              );
            Y.push(N(t || null));
          };
          var r = (0, F[O])(
            W === "accessor" ? { get: L.get, set: L.set } : L[X],
            f,
          );
          if (W === "accessor") {
            if (r === void 0) continue;
            if (r === null || typeof r !== "object")
              throw TypeError("Object expected");
            if ((H = N(r.get))) L.get = H;
            if ((H = N(r.set))) L.set = H;
            if ((H = N(r.init))) J.unshift(H);
          } else if ((H = N(r)))
            if (W === "field") J.unshift(H);
            else L[X] = H;
        }
        if (M) Object.defineProperty(M, D.name, L);
        q = !0;
      }),
      (bV = function (C, g, F) {
        var D = arguments.length > 2;
        for (var J = 0; J < g.length; J++)
          F = D ? g[J].call(C, F) : g[J].call(C);
        return D ? F : void 0;
      }),
      (mV = function (C) {
        return typeof C === "symbol" ? C : "".concat(C);
      }),
      (dV = function (C, g, F) {
        if (typeof g === "symbol")
          g = g.description ? "[".concat(g.description, "]") : "";
        return Object.defineProperty(C, "name", {
          configurable: !0,
          value: F ? "".concat(F, " ", g) : g,
        });
      }),
      (cV = function (C, g) {
        if (
          typeof Reflect === "object" &&
          typeof Reflect.metadata === "function"
        )
          return Reflect.metadata(C, g);
      }),
      (uV = function (C, g, F, D) {
        function J(Y) {
          return Y instanceof F
            ? Y
            : new F(function (N) {
                N(Y);
              });
        }
        return new (F || (F = Promise))(function (Y, N) {
          function W(L) {
            try {
              M(D.next(L));
            } catch (H) {
              N(H);
            }
          }
          function X(L) {
            try {
              M(D.throw(L));
            } catch (H) {
              N(H);
            }
          }
          function M(L) {
            L.done ? Y(L.value) : J(L.value).then(W, X);
          }
          M((D = D.apply(C, g || [])).next());
        });
      }),
      (lV = function (C, g) {
        var F = {
            label: 0,
            sent: function () {
              if (Y[0] & 1) throw Y[1];
              return Y[1];
            },
            trys: [],
            ops: [],
          },
          D,
          J,
          Y,
          N = Object.create(
            (typeof Iterator === "function" ? Iterator : Object).prototype,
          );
        return (
          (N.next = W(0)),
          (N.throw = W(1)),
          (N.return = W(2)),
          typeof Symbol === "function" &&
            (N[Symbol.iterator] = function () {
              return this;
            }),
          N
        );
        function W(M) {
          return function (L) {
            return X([M, L]);
          };
        }
        function X(M) {
          if (D) throw TypeError("Generator is already executing.");
          while ((N && ((N = 0), M[0] && (F = 0)), F))
            try {
              if (
                ((D = 1),
                J &&
                  (Y =
                    M[0] & 2
                      ? J.return
                      : M[0]
                        ? J.throw || ((Y = J.return) && Y.call(J), 0)
                        : J.next) &&
                  !(Y = Y.call(J, M[1])).done)
              )
                return Y;
              if (((J = 0), Y)) M = [M[0] & 2, Y.value];
              switch (M[0]) {
                case 0:
                case 1:
                  Y = M;
                  break;
                case 4:
                  return F.label++, { value: M[1], done: !1 };
                case 5:
                  F.label++, (J = M[1]), (M = [0]);
                  continue;
                case 7:
                  (M = F.ops.pop()), F.trys.pop();
                  continue;
                default:
                  if (
                    ((Y = F.trys), !(Y = Y.length > 0 && Y[Y.length - 1])) &&
                    (M[0] === 6 || M[0] === 2)
                  ) {
                    F = 0;
                    continue;
                  }
                  if (M[0] === 3 && (!Y || (M[1] > Y[0] && M[1] < Y[3]))) {
                    F.label = M[1];
                    break;
                  }
                  if (M[0] === 6 && F.label < Y[1]) {
                    (F.label = Y[1]), (Y = M);
                    break;
                  }
                  if (Y && F.label < Y[2]) {
                    (F.label = Y[2]), F.ops.push(M);
                    break;
                  }
                  if (Y[2]) F.ops.pop();
                  F.trys.pop();
                  continue;
              }
              M = g.call(C, F);
            } catch (L) {
              (M = [6, L]), (J = 0);
            } finally {
              D = Y = 0;
            }
          if (M[0] & 5) throw M[1];
          return { value: M[0] ? M[1] : void 0, done: !0 };
        }
      }),
      (pV = function (C, g) {
        for (var F in C)
          if (F !== "default" && !Object.prototype.hasOwnProperty.call(g, F))
            qJ(g, C, F);
      }),
      (qJ = Object.create
        ? function (C, g, F, D) {
            if (D === void 0) D = F;
            var J = Object.getOwnPropertyDescriptor(g, F);
            if (
              !J ||
              ("get" in J ? !g.__esModule : J.writable || J.configurable)
            )
              J = {
                enumerable: !0,
                get: function () {
                  return g[F];
                },
              };
            Object.defineProperty(C, D, J);
          }
        : function (C, g, F, D) {
            if (D === void 0) D = F;
            C[D] = g[F];
          }),
      (OJ = function (C) {
        var g = typeof Symbol === "function" && Symbol.iterator,
          F = g && C[g],
          D = 0;
        if (F) return F.call(C);
        if (C && typeof C.length === "number")
          return {
            next: function () {
              if (C && D >= C.length) C = void 0;
              return { value: C && C[D++], done: !C };
            },
          };
        throw TypeError(
          g ? "Object is not iterable." : "Symbol.iterator is not defined.",
        );
      }),
      (tZ = function (C, g) {
        var F = typeof Symbol === "function" && C[Symbol.iterator];
        if (!F) return C;
        var D = F.call(C),
          J,
          Y = [],
          N;
        try {
          while ((g === void 0 || g-- > 0) && !(J = D.next()).done)
            Y.push(J.value);
        } catch (W) {
          N = { error: W };
        } finally {
          try {
            if (J && !J.done && (F = D.return)) F.call(D);
          } finally {
            if (N) throw N.error;
          }
        }
        return Y;
      }),
      (iV = function () {
        for (var C = [], g = 0; g < arguments.length; g++)
          C = C.concat(tZ(arguments[g]));
        return C;
      }),
      (nV = function () {
        for (var C = 0, g = 0, F = arguments.length; g < F; g++)
          C += arguments[g].length;
        for (var D = Array(C), J = 0, g = 0; g < F; g++)
          for (var Y = arguments[g], N = 0, W = Y.length; N < W; N++, J++)
            D[J] = Y[N];
        return D;
      }),
      (aV = function (C, g, F) {
        if (F || arguments.length === 2) {
          for (var D = 0, J = g.length, Y; D < J; D++)
            if (Y || !(D in g)) {
              if (!Y) Y = Array.prototype.slice.call(g, 0, D);
              Y[D] = g[D];
            }
        }
        return C.concat(Y || Array.prototype.slice.call(g));
      }),
      (Dg = function (C) {
        return this instanceof Dg ? ((this.v = C), this) : new Dg(C);
      }),
      (oV = function (C, g, F) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var D = F.apply(C, g || []),
          J,
          Y = [];
        return (
          (J = Object.create(
            (typeof AsyncIterator === "function" ? AsyncIterator : Object)
              .prototype,
          )),
          W("next"),
          W("throw"),
          W("return", N),
          (J[Symbol.asyncIterator] = function () {
            return this;
          }),
          J
        );
        function N(O) {
          return function (f) {
            return Promise.resolve(f).then(O, H);
          };
        }
        function W(O, f) {
          if (D[O]) {
            if (
              ((J[O] = function (S) {
                return new Promise(function (r, t) {
                  Y.push([O, S, r, t]) > 1 || X(O, S);
                });
              }),
              f)
            )
              J[O] = f(J[O]);
          }
        }
        function X(O, f) {
          try {
            M(D[O](f));
          } catch (S) {
            q(Y[0][3], S);
          }
        }
        function M(O) {
          O.value instanceof Dg
            ? Promise.resolve(O.value.v).then(L, H)
            : q(Y[0][2], O);
        }
        function L(O) {
          X("next", O);
        }
        function H(O) {
          X("throw", O);
        }
        function q(O, f) {
          if ((O(f), Y.shift(), Y.length)) X(Y[0][0], Y[0][1]);
        }
      }),
      (sV = function (C) {
        var g, F;
        return (
          (g = {}),
          D("next"),
          D("throw", function (J) {
            throw J;
          }),
          D("return"),
          (g[Symbol.iterator] = function () {
            return this;
          }),
          g
        );
        function D(J, Y) {
          g[J] = C[J]
            ? function (N) {
                return (F = !F)
                  ? { value: Dg(C[J](N)), done: !1 }
                  : Y
                    ? Y(N)
                    : N;
              }
            : Y;
        }
      }),
      (rV = function (C) {
        if (!Symbol.asyncIterator)
          throw TypeError("Symbol.asyncIterator is not defined.");
        var g = C[Symbol.asyncIterator],
          F;
        return g
          ? g.call(C)
          : ((C = typeof OJ === "function" ? OJ(C) : C[Symbol.iterator]()),
            (F = {}),
            D("next"),
            D("throw"),
            D("return"),
            (F[Symbol.asyncIterator] = function () {
              return this;
            }),
            F);
        function D(Y) {
          F[Y] =
            C[Y] &&
            function (N) {
              return new Promise(function (W, X) {
                (N = C[Y](N)), J(W, X, N.done, N.value);
              });
            };
        }
        function J(Y, N, W, X) {
          Promise.resolve(X).then(function (M) {
            Y({ value: M, done: W });
          }, N);
        }
      }),
      (tV = function (C, g) {
        if (Object.defineProperty)
          Object.defineProperty(C, "raw", { value: g });
        else C.raw = g;
        return C;
      });
    var B = Object.create
        ? function (C, g) {
            Object.defineProperty(C, "default", { enumerable: !0, value: g });
          }
        : function (C, g) {
            C.default = g;
          },
      I = function (C) {
        return (
          (I =
            Object.getOwnPropertyNames ||
            function (g) {
              var F = [];
              for (var D in g)
                if (Object.prototype.hasOwnProperty.call(g, D)) F[F.length] = D;
              return F;
            }),
          I(C)
        );
      };
    (eV = function (C) {
      if (C && C.__esModule) return C;
      var g = {};
      if (C != null) {
        for (var F = I(C), D = 0; D < F.length; D++)
          if (F[D] !== "default") qJ(g, C, F[D]);
      }
      return B(g, C), g;
    }),
      (A3 = function (C) {
        return C && C.__esModule ? C : { default: C };
      }),
      (Q3 = function (C, g, F, D) {
        if (F === "a" && !D)
          throw TypeError("Private accessor was defined without a getter");
        if (typeof g === "function" ? C !== g || !D : !g.has(C))
          throw TypeError(
            "Cannot read private member from an object whose class did not declare it",
          );
        return F === "m" ? D : F === "a" ? D.call(C) : D ? D.value : g.get(C);
      }),
      (B3 = function (C, g, F, D, J) {
        if (D === "m") throw TypeError("Private method is not writable");
        if (D === "a" && !J)
          throw TypeError("Private accessor was defined without a setter");
        if (typeof g === "function" ? C !== g || !J : !g.has(C))
          throw TypeError(
            "Cannot write private member to an object whose class did not declare it",
          );
        return D === "a" ? J.call(C, F) : J ? (J.value = F) : g.set(C, F), F;
      }),
      (I3 = function (C, g) {
        if (g === null || (typeof g !== "object" && typeof g !== "function"))
          throw TypeError("Cannot use 'in' operator on non-object");
        return typeof C === "function" ? g === C : C.has(g);
      }),
      (E3 = function (C, g, F) {
        if (g !== null && g !== void 0) {
          if (typeof g !== "object" && typeof g !== "function")
            throw TypeError("Object expected.");
          var D, J;
          if (F) {
            if (!Symbol.asyncDispose)
              throw TypeError("Symbol.asyncDispose is not defined.");
            D = g[Symbol.asyncDispose];
          }
          if (D === void 0) {
            if (!Symbol.dispose)
              throw TypeError("Symbol.dispose is not defined.");
            if (((D = g[Symbol.dispose]), F)) J = D;
          }
          if (typeof D !== "function")
            throw TypeError("Object not disposable.");
          if (J)
            D = function () {
              try {
                J.call(this);
              } catch (Y) {
                return Promise.reject(Y);
              }
            };
          C.stack.push({ value: g, dispose: D, async: F });
        } else if (F) C.stack.push({ async: !0 });
        return g;
      });
    var E =
      typeof SuppressedError === "function"
        ? SuppressedError
        : function (C, g, F) {
            var D = Error(F);
            return (
              (D.name = "SuppressedError"), (D.error = C), (D.suppressed = g), D
            );
          };
    (C3 = function (C) {
      function g(Y) {
        (C.error = C.hasError
          ? new E(Y, C.error, "An error was suppressed during disposal.")
          : Y),
          (C.hasError = !0);
      }
      var F,
        D = 0;
      function J() {
        while ((F = C.stack.pop()))
          try {
            if (!F.async && D === 1)
              return (D = 0), C.stack.push(F), Promise.resolve().then(J);
            if (F.dispose) {
              var Y = F.dispose.call(F.value);
              if (F.async)
                return (
                  (D |= 2),
                  Promise.resolve(Y).then(J, function (N) {
                    return g(N), J();
                  })
                );
            } else D |= 1;
          } catch (N) {
            g(N);
          }
        if (D === 1)
          return C.hasError ? Promise.reject(C.error) : Promise.resolve();
        if (C.hasError) throw C.error;
      }
      return J();
    }),
      (g3 = function (C, g) {
        if (typeof C === "string" && /^\.\.?\//.test(C))
          return C.replace(
            /\.(tsx)$|((?:\.d)?)((?:\.[^./]+?)?)\.([cm]?)ts$/i,
            function (F, D, J, Y, N) {
              return D
                ? g
                  ? ".jsx"
                  : ".js"
                : J && (!Y || !N)
                  ? F
                  : J + Y + "." + N.toLowerCase() + "js";
            },
          );
        return C;
      }),
      A("__extends", xV),
      A("__assign", vV),
      A("__rest", PV),
      A("__decorate", _V),
      A("__param", yV),
      A("__esDecorate", SV),
      A("__runInitializers", bV),
      A("__propKey", mV),
      A("__setFunctionName", dV),
      A("__metadata", cV),
      A("__awaiter", uV),
      A("__generator", lV),
      A("__exportStar", pV),
      A("__createBinding", qJ),
      A("__values", OJ),
      A("__read", tZ),
      A("__spread", iV),
      A("__spreadArrays", nV),
      A("__spreadArray", aV),
      A("__await", Dg),
      A("__asyncGenerator", oV),
      A("__asyncDelegator", sV),
      A("__asyncValues", rV),
      A("__makeTemplateObject", tV),
      A("__importStar", eV),
      A("__importDefault", A3),
      A("__classPrivateFieldGet", Q3),
      A("__classPrivateFieldSet", B3),
      A("__classPrivateFieldIn", I3),
      A("__addDisposableResource", E3),
      A("__disposeResources", C3),
      A("__rewriteRelativeImportExtension", g3);
  });
});
var cF = Z((D3) => {
  Object.defineProperty(D3, "__esModule", { value: !0 });
  D3.AbortError = void 0;
  class F3 extends Error {
    constructor(A) {
      super(A);
      this.name = "AbortError";
    }
  }
  D3.AbortError = F3;
});
var G3 = Z((N3) => {
  Object.defineProperty(N3, "__esModule", { value: !0 });
  N3.log = ae;
  var J3 = BQ(),
    pe = $("node:os"),
    ie = J3.__importDefault($("node:util")),
    ne = J3.__importDefault($("node:process"));
  function ae(A, ...Q) {
    ne.default.stderr.write(`${ie.default.format(A, ...Q)}${pe.EOL}`);
  }
});
var L3 = Z((M3) => {
  Object.defineProperty(M3, "__esModule", { value: !0 });
  var se = G3(),
    U3 = (typeof process < "u" && process.env && process.env.DEBUG) || void 0,
    Z3,
    eZ = [],
    A9 = [],
    fJ = [];
  if (U3) Q9(U3);
  var X3 = Object.assign(
    (A) => {
      return w3(A);
    },
    { enable: Q9, enabled: B9, disable: re, log: se.log },
  );
  function Q9(A) {
    (Z3 = A), (eZ = []), (A9 = []);
    let Q = A.split(",").map((B) => B.trim());
    for (let B of Q)
      if (B.startsWith("-")) A9.push(B.substring(1));
      else eZ.push(B);
    for (let B of fJ) B.enabled = B9(B.namespace);
  }
  function B9(A) {
    if (A.endsWith("*")) return !0;
    for (let Q of A9) if (W3(A, Q)) return !1;
    for (let Q of eZ) if (W3(A, Q)) return !0;
    return !1;
  }
  function W3(A, Q) {
    if (Q.indexOf("*") === -1) return A === Q;
    let B = Q;
    if (Q.indexOf("**") !== -1) {
      let W = [],
        X = "";
      for (let M of Q)
        if (M === "*" && X === "*") continue;
        else (X = M), W.push(M);
      B = W.join("");
    }
    let I = 0,
      E = 0,
      C = B.length,
      g = A.length,
      F = -1,
      D = -1;
    while (I < g && E < C)
      if (B[E] === "*") {
        if (((F = E), E++, E === C)) return !0;
        while (A[I] !== B[E]) if ((I++, I === g)) return !1;
        (D = I), I++, E++;
        continue;
      } else if (B[E] === A[I]) E++, I++;
      else if (F >= 0) {
        if (((E = F + 1), (I = D + 1), I === g)) return !1;
        while (A[I] !== B[E]) if ((I++, I === g)) return !1;
        (D = I), I++, E++;
        continue;
      } else return !1;
    let J = I === A.length,
      Y = E === B.length,
      N = E === B.length - 1 && B[E] === "*";
    return J && (Y || N);
  }
  function re() {
    let A = Z3 || "";
    return Q9(""), A;
  }
  function w3(A) {
    let Q = Object.assign(B, {
      enabled: B9(A),
      destroy: te,
      log: X3.log,
      namespace: A,
      extend: ee,
    });
    function B(...I) {
      if (!Q.enabled) return;
      if (I.length > 0) I[0] = `${A} ${I[0]}`;
      Q.log(...I);
    }
    return fJ.push(Q), Q;
  }
  function te() {
    let A = fJ.indexOf(this);
    if (A >= 0) return fJ.splice(A, 1), !0;
    return !1;
  }
  function ee(A) {
    let Q = w3(`${this.namespace}:${A}`);
    return (Q.log = this.log), Q;
  }
  M3.default = X3;
});
var lF = Z((K3) => {
  Object.defineProperty(K3, "__esModule", { value: !0 });
  K3.TypeSpecRuntimeLogger = void 0;
  K3.createLoggerContext = H3;
  K3.setLogLevel = BAA;
  K3.getLogLevel = IAA;
  K3.createClientLogger = EAA;
  var QAA = BQ(),
    uF = QAA.__importDefault(L3()),
    I9 = ["verbose", "info", "warning", "error"],
    R3 = { verbose: 400, info: 300, warning: 200, error: 100 };
  function V3(A, Q) {
    Q.log = (...B) => {
      A.log(...B);
    };
  }
  function $3(A) {
    return I9.includes(A);
  }
  function H3(A) {
    let Q = new Set(),
      B =
        (typeof process < "u" &&
          process.env &&
          process.env[A.logLevelEnvVarName]) ||
        void 0,
      I,
      E = (0, uF.default)(A.namespace);
    E.log = (...Y) => {
      uF.default.log(...Y);
    };
    function C(Y) {
      if (Y && !$3(Y))
        throw Error(
          `Unknown log level '${Y}'. Acceptable values: ${I9.join(",")}`,
        );
      I = Y;
      let N = [];
      for (let W of Q) if (g(W)) N.push(W.namespace);
      uF.default.enable(N.join(","));
    }
    if (B)
      if ($3(B)) C(B);
      else
        console.error(
          `${A.logLevelEnvVarName} set to unknown log level '${B}'; logging is not enabled. Acceptable values: ${I9.join(", ")}.`,
        );
    function g(Y) {
      return Boolean(I && R3[Y.level] <= R3[I]);
    }
    function F(Y, N) {
      let W = Object.assign(Y.extend(N), { level: N });
      if ((V3(Y, W), g(W))) {
        let X = uF.default.disable();
        uF.default.enable(X + "," + W.namespace);
      }
      return Q.add(W), W;
    }
    function D() {
      return I;
    }
    function J(Y) {
      let N = E.extend(Y);
      return (
        V3(E, N),
        {
          error: F(N, "error"),
          warning: F(N, "warning"),
          info: F(N, "info"),
          verbose: F(N, "verbose"),
        }
      );
    }
    return { setLogLevel: C, getLogLevel: D, createClientLogger: J, logger: E };
  }
  var hJ = H3({
    logLevelEnvVarName: "TYPESPEC_RUNTIME_LOG_LEVEL",
    namespace: "typeSpecRuntime",
  });
  K3.TypeSpecRuntimeLogger = hJ.logger;
  function BAA(A) {
    hJ.setLogLevel(A);
  }
  function IAA() {
    return hJ.getLogLevel();
  }
  function EAA(A) {
    return hJ.createClientLogger(A);
  }
});
var BC = Z((O3) => {
  Object.defineProperty(O3, "__esModule", { value: !0 });
  O3.createHttpHeaders = JAA;
  function kJ(A) {
    return A.toLowerCase();
  }
  function* YAA(A) {
    for (let Q of A.values()) yield [Q.name, Q.value];
  }
  class T3 {
    _headersMap;
    constructor(A) {
      if (((this._headersMap = new Map()), A))
        for (let Q of Object.keys(A)) this.set(Q, A[Q]);
    }
    set(A, Q) {
      this._headersMap.set(kJ(A), { name: A, value: String(Q).trim() });
    }
    get(A) {
      return this._headersMap.get(kJ(A))?.value;
    }
    has(A) {
      return this._headersMap.has(kJ(A));
    }
    delete(A) {
      this._headersMap.delete(kJ(A));
    }
    toJSON(A = {}) {
      let Q = {};
      if (A.preserveCase)
        for (let B of this._headersMap.values()) Q[B.name] = B.value;
      else for (let [B, I] of this._headersMap) Q[B] = I.value;
      return Q;
    }
    toString() {
      return JSON.stringify(this.toJSON({ preserveCase: !0 }));
    }
    [Symbol.iterator]() {
      return YAA(this._headersMap);
    }
  }
  function JAA(A) {
    return new T3(A);
  }
});
var j3 = Z((q3) => {
  Object.defineProperty(q3, "__esModule", { value: !0 });
});
var h3 = Z((f3) => {
  Object.defineProperty(f3, "__esModule", { value: !0 });
});
var xJ = Z((k3) => {
  Object.defineProperty(k3, "__esModule", { value: !0 });
  k3.randomUUID = WAA;
  var GAA = $("node:crypto"),
    UAA =
      typeof globalThis?.crypto?.randomUUID === "function"
        ? globalThis.crypto.randomUUID.bind(globalThis.crypto)
        : GAA.randomUUID;
  function WAA() {
    return UAA();
  }
});
var E9 = Z((v3) => {
  Object.defineProperty(v3, "__esModule", { value: !0 });
  v3.createPipelineRequest = MAA;
  var XAA = BC(),
    wAA = xJ();
  class x3 {
    url;
    method;
    headers;
    timeout;
    withCredentials;
    body;
    multipartBody;
    formData;
    streamResponseStatusCodes;
    enableBrowserStreams;
    proxySettings;
    disableKeepAlive;
    abortSignal;
    requestId;
    allowInsecureConnection;
    onUploadProgress;
    onDownloadProgress;
    requestOverrides;
    authSchemes;
    constructor(A) {
      (this.url = A.url),
        (this.body = A.body),
        (this.headers = A.headers ?? (0, XAA.createHttpHeaders)()),
        (this.method = A.method ?? "GET"),
        (this.timeout = A.timeout ?? 0),
        (this.multipartBody = A.multipartBody),
        (this.formData = A.formData),
        (this.disableKeepAlive = A.disableKeepAlive ?? !1),
        (this.proxySettings = A.proxySettings),
        (this.streamResponseStatusCodes = A.streamResponseStatusCodes),
        (this.withCredentials = A.withCredentials ?? !1),
        (this.abortSignal = A.abortSignal),
        (this.onUploadProgress = A.onUploadProgress),
        (this.onDownloadProgress = A.onDownloadProgress),
        (this.requestId = A.requestId || (0, wAA.randomUUID)()),
        (this.allowInsecureConnection = A.allowInsecureConnection ?? !1),
        (this.enableBrowserStreams = A.enableBrowserStreams ?? !1),
        (this.requestOverrides = A.requestOverrides),
        (this.authSchemes = A.authSchemes);
    }
  }
  function MAA(A) {
    return new x3(A);
  }
});
var C9 = Z((_3) => {
  Object.defineProperty(_3, "__esModule", { value: !0 });
  _3.createEmptyPipeline = RAA;
  var P3 = new Set(["Deserialize", "Serialize", "Retry", "Sign"]);
  class vJ {
    _policies = [];
    _orderedPolicies;
    constructor(A) {
      (this._policies = A?.slice(0) ?? []), (this._orderedPolicies = void 0);
    }
    addPolicy(A, Q = {}) {
      if (Q.phase && Q.afterPhase)
        throw Error("Policies inside a phase cannot specify afterPhase.");
      if (Q.phase && !P3.has(Q.phase))
        throw Error(`Invalid phase name: ${Q.phase}`);
      if (Q.afterPhase && !P3.has(Q.afterPhase))
        throw Error(`Invalid afterPhase name: ${Q.afterPhase}`);
      this._policies.push({ policy: A, options: Q }),
        (this._orderedPolicies = void 0);
    }
    removePolicy(A) {
      let Q = [];
      return (
        (this._policies = this._policies.filter((B) => {
          if (
            (A.name && B.policy.name === A.name) ||
            (A.phase && B.options.phase === A.phase)
          )
            return Q.push(B.policy), !1;
          else return !0;
        })),
        (this._orderedPolicies = void 0),
        Q
      );
    }
    sendRequest(A, Q) {
      return this.getOrderedPolicies().reduceRight(
        (E, C) => {
          return (g) => {
            return C.sendRequest(g, E);
          };
        },
        (E) => A.sendRequest(E),
      )(Q);
    }
    getOrderedPolicies() {
      if (!this._orderedPolicies) this._orderedPolicies = this.orderPolicies();
      return this._orderedPolicies;
    }
    clone() {
      return new vJ(this._policies);
    }
    static create() {
      return new vJ();
    }
    orderPolicies() {
      let A = [],
        Q = new Map();
      function B(X) {
        return {
          name: X,
          policies: new Set(),
          hasRun: !1,
          hasAfterPolicies: !1,
        };
      }
      let I = B("Serialize"),
        E = B("None"),
        C = B("Deserialize"),
        g = B("Retry"),
        F = B("Sign"),
        D = [I, E, C, g, F];
      function J(X) {
        if (X === "Retry") return g;
        else if (X === "Serialize") return I;
        else if (X === "Deserialize") return C;
        else if (X === "Sign") return F;
        else return E;
      }
      for (let X of this._policies) {
        let { policy: M, options: L } = X,
          H = M.name;
        if (Q.has(H))
          throw Error("Duplicate policy names not allowed in pipeline");
        let q = { policy: M, dependsOn: new Set(), dependants: new Set() };
        if (L.afterPhase)
          (q.afterPhase = J(L.afterPhase)),
            (q.afterPhase.hasAfterPolicies = !0);
        Q.set(H, q), J(L.phase).policies.add(q);
      }
      for (let X of this._policies) {
        let { policy: M, options: L } = X,
          H = M.name,
          q = Q.get(H);
        if (!q) throw Error(`Missing node for policy ${H}`);
        if (L.afterPolicies)
          for (let O of L.afterPolicies) {
            let f = Q.get(O);
            if (f) q.dependsOn.add(f), f.dependants.add(q);
          }
        if (L.beforePolicies)
          for (let O of L.beforePolicies) {
            let f = Q.get(O);
            if (f) f.dependsOn.add(q), q.dependants.add(f);
          }
      }
      function Y(X) {
        X.hasRun = !0;
        for (let M of X.policies) {
          if (
            M.afterPhase &&
            (!M.afterPhase.hasRun || M.afterPhase.policies.size)
          )
            continue;
          if (M.dependsOn.size === 0) {
            A.push(M.policy);
            for (let L of M.dependants) L.dependsOn.delete(M);
            Q.delete(M.policy.name), X.policies.delete(M);
          }
        }
      }
      function N() {
        for (let X of D) {
          if ((Y(X), X.policies.size > 0 && X !== E)) {
            if (!E.hasRun) Y(E);
            return;
          }
          if (X.hasAfterPolicies) Y(E);
        }
      }
      let W = 0;
      while (Q.size > 0) {
        W++;
        let X = A.length;
        if ((N(), A.length <= X && W > 1))
          throw Error(
            "Cannot satisfy policy dependencies due to requirements cycle.",
          );
      }
      return A;
    }
  }
  function RAA() {
    return vJ.create();
  }
});
var PJ = Z((y3) => {
  Object.defineProperty(y3, "__esModule", { value: !0 });
  y3.isObject = $AA;
  function $AA(A) {
    return (
      typeof A === "object" &&
      A !== null &&
      !Array.isArray(A) &&
      !(A instanceof RegExp) &&
      !(A instanceof Date)
    );
  }
});
var g9 = Z((S3) => {
  Object.defineProperty(S3, "__esModule", { value: !0 });
  S3.isError = zAA;
  var KAA = PJ();
  function zAA(A) {
    if ((0, KAA.isObject)(A)) {
      let Q = typeof A.name === "string",
        B = typeof A.message === "string";
      return Q && B;
    }
    return !1;
  }
});
var d3 = Z((b3) => {
  Object.defineProperty(b3, "__esModule", { value: !0 });
  b3.custom = void 0;
  var OAA = $("node:util");
  b3.custom = OAA.inspect.custom;
});
var pF = Z((u3) => {
  Object.defineProperty(u3, "__esModule", { value: !0 });
  u3.Sanitizer = void 0;
  var qAA = PJ(),
    F9 = "REDACTED",
    jAA = [
      "x-ms-client-request-id",
      "x-ms-return-client-request-id",
      "x-ms-useragent",
      "x-ms-correlation-request-id",
      "x-ms-request-id",
      "client-request-id",
      "ms-cv",
      "return-client-request-id",
      "traceparent",
      "Access-Control-Allow-Credentials",
      "Access-Control-Allow-Headers",
      "Access-Control-Allow-Methods",
      "Access-Control-Allow-Origin",
      "Access-Control-Expose-Headers",
      "Access-Control-Max-Age",
      "Access-Control-Request-Headers",
      "Access-Control-Request-Method",
      "Origin",
      "Accept",
      "Accept-Encoding",
      "Cache-Control",
      "Connection",
      "Content-Length",
      "Content-Type",
      "Date",
      "ETag",
      "Expires",
      "If-Match",
      "If-Modified-Since",
      "If-None-Match",
      "If-Unmodified-Since",
      "Last-Modified",
      "Pragma",
      "Request-Id",
      "Retry-After",
      "Server",
      "Transfer-Encoding",
      "User-Agent",
      "WWW-Authenticate",
    ],
    fAA = ["api-version"];
  class c3 {
    allowedHeaderNames;
    allowedQueryParameters;
    constructor({
      additionalAllowedHeaderNames: A = [],
      additionalAllowedQueryParameters: Q = [],
    } = {}) {
      (A = jAA.concat(A)),
        (Q = fAA.concat(Q)),
        (this.allowedHeaderNames = new Set(A.map((B) => B.toLowerCase()))),
        (this.allowedQueryParameters = new Set(Q.map((B) => B.toLowerCase())));
    }
    sanitize(A) {
      let Q = new Set();
      return JSON.stringify(
        A,
        (B, I) => {
          if (I instanceof Error)
            return { ...I, name: I.name, message: I.message };
          if (B === "headers") return this.sanitizeHeaders(I);
          else if (B === "url") return this.sanitizeUrl(I);
          else if (B === "query") return this.sanitizeQuery(I);
          else if (B === "body") return;
          else if (B === "response") return;
          else if (B === "operationSpec") return;
          else if (Array.isArray(I) || (0, qAA.isObject)(I)) {
            if (Q.has(I)) return "[Circular]";
            Q.add(I);
          }
          return I;
        },
        2,
      );
    }
    sanitizeUrl(A) {
      if (typeof A !== "string" || A === null || A === "") return A;
      let Q = new URL(A);
      if (!Q.search) return A;
      for (let [B] of Q.searchParams)
        if (!this.allowedQueryParameters.has(B.toLowerCase()))
          Q.searchParams.set(B, F9);
      return Q.toString();
    }
    sanitizeHeaders(A) {
      let Q = {};
      for (let B of Object.keys(A))
        if (this.allowedHeaderNames.has(B.toLowerCase())) Q[B] = A[B];
        else Q[B] = F9;
      return Q;
    }
    sanitizeQuery(A) {
      if (typeof A !== "object" || A === null) return A;
      let Q = {};
      for (let B of Object.keys(A))
        if (this.allowedQueryParameters.has(B.toLowerCase())) Q[B] = A[B];
        else Q[B] = F9;
      return Q;
    }
  }
  u3.Sanitizer = c3;
});
var Yg = Z((p3) => {
  Object.defineProperty(p3, "__esModule", { value: !0 });
  p3.RestError = void 0;
  p3.isRestError = PAA;
  var hAA = g9(),
    kAA = d3(),
    xAA = pF(),
    vAA = new xAA.Sanitizer();
  class _J extends Error {
    static REQUEST_SEND_ERROR = "REQUEST_SEND_ERROR";
    static PARSE_ERROR = "PARSE_ERROR";
    code;
    statusCode;
    request;
    response;
    details;
    constructor(A, Q = {}) {
      super(A);
      (this.name = "RestError"),
        (this.code = Q.code),
        (this.statusCode = Q.statusCode),
        Object.defineProperty(this, "request", {
          value: Q.request,
          enumerable: !1,
        }),
        Object.defineProperty(this, "response", {
          value: Q.response,
          enumerable: !1,
        });
      let B = this.request?.agent
        ? {
            maxFreeSockets: this.request.agent.maxFreeSockets,
            maxSockets: this.request.agent.maxSockets,
          }
        : void 0;
      Object.defineProperty(this, kAA.custom, {
        value: () => {
          return `RestError: ${this.message} 
 ${vAA.sanitize({ ...this, request: { ...this.request, agent: B }, response: this.response })}`;
        },
        enumerable: !1,
      }),
        Object.setPrototypeOf(this, _J.prototype);
    }
  }
  p3.RestError = _J;
  function PAA(A) {
    if (A instanceof _J) return !0;
    return (0, hAA.isError)(A) && A.name === "RestError";
  }
});
var oC = Z((n3) => {
  Object.defineProperty(n3, "__esModule", { value: !0 });
  n3.uint8ArrayToString = yAA;
  n3.stringToUint8Array = SAA;
  function yAA(A, Q) {
    return Buffer.from(A).toString(Q);
  }
  function SAA(A, Q) {
    return Buffer.from(A, Q);
  }
});
var iF = Z((a3) => {
  Object.defineProperty(a3, "__esModule", { value: !0 });
  a3.logger = void 0;
  var dAA = lF();
  a3.logger = (0, dAA.createClientLogger)("ts-http-runtime");
});
var I$ = Z((B$) => {
  Object.defineProperty(B$, "__esModule", { value: !0 });
  B$.getBodyLength = Q$;
  B$.createNodeHttpClient = oAA;
  var N9 = BQ(),
    D9 = N9.__importDefault($("node:http")),
    Y9 = N9.__importDefault($("node:https")),
    s3 = N9.__importDefault($("node:zlib")),
    cAA = $("node:stream"),
    r3 = cF(),
    uAA = BC(),
    aF = Yg(),
    Jg = iF(),
    lAA = pF(),
    pAA = {};
  function nF(A) {
    return A && typeof A.pipe === "function";
  }
  function t3(A) {
    if (A.readable === !1) return Promise.resolve();
    return new Promise((Q) => {
      let B = () => {
        Q(),
          A.removeListener("close", B),
          A.removeListener("end", B),
          A.removeListener("error", B);
      };
      A.on("close", B), A.on("end", B), A.on("error", B);
    });
  }
  function e3(A) {
    return A && typeof A.byteLength === "number";
  }
  class J9 extends cAA.Transform {
    loadedBytes = 0;
    progressCallback;
    _transform(A, Q, B) {
      this.push(A), (this.loadedBytes += A.length);
      try {
        this.progressCallback({ loadedBytes: this.loadedBytes }), B();
      } catch (I) {
        B(I);
      }
    }
    constructor(A) {
      super();
      this.progressCallback = A;
    }
  }
  class A$ {
    cachedHttpAgent;
    cachedHttpsAgents = new WeakMap();
    async sendRequest(A) {
      let Q = new AbortController(),
        B;
      if (A.abortSignal) {
        if (A.abortSignal.aborted)
          throw new r3.AbortError(
            "The operation was aborted. Request has already been canceled.",
          );
        (B = (D) => {
          if (D.type === "abort") Q.abort();
        }),
          A.abortSignal.addEventListener("abort", B);
      }
      let I;
      if (A.timeout > 0)
        I = setTimeout(() => {
          let D = new lAA.Sanitizer();
          Jg.logger.info(
            `request to '${D.sanitizeUrl(A.url)}' timed out. canceling...`,
          ),
            Q.abort();
        }, A.timeout);
      let E = A.headers.get("Accept-Encoding"),
        C = E?.includes("gzip") || E?.includes("deflate"),
        g = typeof A.body === "function" ? A.body() : A.body;
      if (g && !A.headers.has("Content-Length")) {
        let D = Q$(g);
        if (D !== null) A.headers.set("Content-Length", D);
      }
      let F;
      try {
        if (g && A.onUploadProgress) {
          let X = A.onUploadProgress,
            M = new J9(X);
          if (
            (M.on("error", (L) => {
              Jg.logger.error("Error in upload progress", L);
            }),
            nF(g))
          )
            g.pipe(M);
          else M.end(g);
          g = M;
        }
        let D = await this.makeRequest(A, Q, g);
        if (I !== void 0) clearTimeout(I);
        let J = iAA(D),
          N = { status: D.statusCode ?? 0, headers: J, request: A };
        if (A.method === "HEAD") return D.resume(), N;
        F = C ? nAA(D, J) : D;
        let W = A.onDownloadProgress;
        if (W) {
          let X = new J9(W);
          X.on("error", (M) => {
            Jg.logger.error("Error in download progress", M);
          }),
            F.pipe(X),
            (F = X);
        }
        if (
          A.streamResponseStatusCodes?.has(Number.POSITIVE_INFINITY) ||
          A.streamResponseStatusCodes?.has(N.status)
        )
          N.readableStreamBody = F;
        else N.bodyAsText = await aAA(F);
        return N;
      } finally {
        if (A.abortSignal && B) {
          let D = Promise.resolve();
          if (nF(g)) D = t3(g);
          let J = Promise.resolve();
          if (nF(F)) J = t3(F);
          Promise.all([D, J])
            .then(() => {
              if (B) A.abortSignal?.removeEventListener("abort", B);
            })
            .catch((Y) => {
              Jg.logger.warning(
                "Error when cleaning up abortListener on httpRequest",
                Y,
              );
            });
        }
      }
    }
    makeRequest(A, Q, B) {
      let I = new URL(A.url),
        E = I.protocol !== "https:";
      if (E && !A.allowInsecureConnection)
        throw Error(
          `Cannot connect to ${A.url} while allowInsecureConnection is false.`,
        );
      let g = {
        agent: A.agent ?? this.getOrCreateAgent(A, E),
        hostname: I.hostname,
        path: `${I.pathname}${I.search}`,
        port: I.port,
        method: A.method,
        headers: A.headers.toJSON({ preserveCase: !0 }),
        ...A.requestOverrides,
      };
      return new Promise((F, D) => {
        let J = E ? D9.default.request(g, F) : Y9.default.request(g, F);
        if (
          (J.once("error", (Y) => {
            D(
              new aF.RestError(Y.message, {
                code: Y.code ?? aF.RestError.REQUEST_SEND_ERROR,
                request: A,
              }),
            );
          }),
          Q.signal.addEventListener("abort", () => {
            let Y = new r3.AbortError(
              "The operation was aborted. Rejecting from abort signal callback while making request.",
            );
            J.destroy(Y), D(Y);
          }),
          B && nF(B))
        )
          B.pipe(J);
        else if (B)
          if (typeof B === "string" || Buffer.isBuffer(B)) J.end(B);
          else if (e3(B))
            J.end(
              ArrayBuffer.isView(B) ? Buffer.from(B.buffer) : Buffer.from(B),
            );
          else
            Jg.logger.error("Unrecognized body type", B),
              D(new aF.RestError("Unrecognized body type"));
        else J.end();
      });
    }
    getOrCreateAgent(A, Q) {
      let B = A.disableKeepAlive;
      if (Q) {
        if (B) return D9.default.globalAgent;
        if (!this.cachedHttpAgent)
          this.cachedHttpAgent = new D9.default.Agent({ keepAlive: !0 });
        return this.cachedHttpAgent;
      } else {
        if (B && !A.tlsSettings) return Y9.default.globalAgent;
        let I = A.tlsSettings ?? pAA,
          E = this.cachedHttpsAgents.get(I);
        if (E && E.options.keepAlive === !B) return E;
        return (
          Jg.logger.info("No cached TLS Agent exist, creating a new Agent"),
          (E = new Y9.default.Agent({ keepAlive: !B, ...I })),
          this.cachedHttpsAgents.set(I, E),
          E
        );
      }
    }
  }
  function iAA(A) {
    let Q = (0, uAA.createHttpHeaders)();
    for (let B of Object.keys(A.headers)) {
      let I = A.headers[B];
      if (Array.isArray(I)) {
        if (I.length > 0) Q.set(B, I[0]);
      } else if (I) Q.set(B, I);
    }
    return Q;
  }
  function nAA(A, Q) {
    let B = Q.get("Content-Encoding");
    if (B === "gzip") {
      let I = s3.default.createGunzip();
      return A.pipe(I), I;
    } else if (B === "deflate") {
      let I = s3.default.createInflate();
      return A.pipe(I), I;
    }
    return A;
  }
  function aAA(A) {
    return new Promise((Q, B) => {
      let I = [];
      A.on("data", (E) => {
        if (Buffer.isBuffer(E)) I.push(E);
        else I.push(Buffer.from(E));
      }),
        A.on("end", () => {
          Q(Buffer.concat(I).toString("utf8"));
        }),
        A.on("error", (E) => {
          if (E && E?.name === "AbortError") B(E);
          else
            B(
              new aF.RestError(`Error reading response as text: ${E.message}`, {
                code: aF.RestError.PARSE_ERROR,
              }),
            );
        });
    });
  }
  function Q$(A) {
    if (!A) return 0;
    else if (Buffer.isBuffer(A)) return A.length;
    else if (nF(A)) return null;
    else if (e3(A)) return A.byteLength;
    else if (typeof A === "string") return Buffer.from(A).length;
    else return null;
  }
  function oAA() {
    return new A$();
  }
});
var G9 = Z((E$) => {
  Object.defineProperty(E$, "__esModule", { value: !0 });
  E$.createDefaultHttpClient = eAA;
  var tAA = I$();
  function eAA() {
    return (0, tAA.createNodeHttpClient)();
  }
});
var W9 = Z((C$) => {
  Object.defineProperty(C$, "__esModule", { value: !0 });
  C$.logPolicyName = void 0;
  C$.logPolicy = IQA;
  var QQA = iF(),
    BQA = pF();
  C$.logPolicyName = "logPolicy";
  function IQA(A = {}) {
    let Q = A.logger ?? QQA.logger.info,
      B = new BQA.Sanitizer({
        additionalAllowedHeaderNames: A.additionalAllowedHeaderNames,
        additionalAllowedQueryParameters: A.additionalAllowedQueryParameters,
      });
    return {
      name: C$.logPolicyName,
      async sendRequest(I, E) {
        if (!Q.enabled) return E(I);
        Q(`Request: ${B.sanitize(I)}`);
        let C = await E(I);
        return (
          Q(`Response status code: ${C.status}`),
          Q(`Headers: ${B.sanitize(C.headers)}`),
          C
        );
      },
    };
  }
});
var X9 = Z((D$) => {
  Object.defineProperty(D$, "__esModule", { value: !0 });
  D$.redirectPolicyName = void 0;
  D$.redirectPolicy = CQA;
  D$.redirectPolicyName = "redirectPolicy";
  var g$ = ["GET", "HEAD"];
  function CQA(A = {}) {
    let { maxRetries: Q = 20 } = A;
    return {
      name: D$.redirectPolicyName,
      async sendRequest(B, I) {
        let E = await I(B);
        return F$(I, E, Q);
      },
    };
  }
  async function F$(A, Q, B, I = 0) {
    let { request: E, status: C, headers: g } = Q,
      F = g.get("location");
    if (
      F &&
      (C === 300 ||
        (C === 301 && g$.includes(E.method)) ||
        (C === 302 && g$.includes(E.method)) ||
        (C === 303 && E.method === "POST") ||
        C === 307) &&
      I < B
    ) {
      let D = new URL(F, E.url);
      if (((E.url = D.toString()), C === 303))
        (E.method = "GET"), E.headers.delete("Content-Length"), delete E.body;
      E.headers.delete("Authorization");
      let J = await A(E);
      return F$(A, J, B, I + 1);
    }
    return Q;
  }
});
var N$ = Z((J$) => {
  Object.defineProperty(J$, "__esModule", { value: !0 });
  J$.getHeaderName = FQA;
  J$.setPlatformSpecificData = DQA;
  var Y$ = BQ(),
    w9 = Y$.__importDefault($("node:os")),
    M9 = Y$.__importDefault($("node:process"));
  function FQA() {
    return "User-Agent";
  }
  async function DQA(A) {
    if (M9.default && M9.default.versions) {
      let Q = M9.default.versions;
      if (Q.bun) A.set("Bun", Q.bun);
      else if (Q.deno) A.set("Deno", Q.deno);
      else if (Q.node) A.set("Node", Q.node);
    }
    A.set(
      "OS",
      `(${w9.default.arch()}-${w9.default.type()}-${w9.default.release()})`,
    );
  }
});
var sC = Z((G$) => {
  Object.defineProperty(G$, "__esModule", { value: !0 });
  G$.DEFAULT_RETRY_POLICY_COUNT = G$.SDK_VERSION = void 0;
  G$.SDK_VERSION = "0.3.1";
  G$.DEFAULT_RETRY_POLICY_COUNT = 3;
});
var X$ = Z((Z$) => {
  Object.defineProperty(Z$, "__esModule", { value: !0 });
  Z$.getUserAgentHeaderName = WQA;
  Z$.getUserAgentValue = ZQA;
  var W$ = N$(),
    GQA = sC();
  function UQA(A) {
    let Q = [];
    for (let [B, I] of A) {
      let E = I ? `${B}/${I}` : B;
      Q.push(E);
    }
    return Q.join(" ");
  }
  function WQA() {
    return (0, W$.getHeaderName)();
  }
  async function ZQA(A) {
    let Q = new Map();
    Q.set("ts-http-runtime", GQA.SDK_VERSION),
      await (0, W$.setPlatformSpecificData)(Q);
    let B = UQA(Q);
    return A ? `${A} ${B}` : B;
  }
});
var R9 = Z((L$) => {
  Object.defineProperty(L$, "__esModule", { value: !0 });
  L$.userAgentPolicyName = void 0;
  L$.userAgentPolicy = MQA;
  var M$ = X$(),
    w$ = (0, M$.getUserAgentHeaderName)();
  L$.userAgentPolicyName = "userAgentPolicy";
  function MQA(A = {}) {
    let Q = (0, M$.getUserAgentValue)(A.userAgentPrefix);
    return {
      name: L$.userAgentPolicyName,
      async sendRequest(B, I) {
        if (!B.headers.has(w$)) B.headers.set(w$, await Q);
        return I(B);
      },
    };
  }
});
var $9 = Z((R$) => {
  Object.defineProperty(R$, "__esModule", { value: !0 });
  R$.decompressResponsePolicyName = void 0;
  R$.decompressResponsePolicy = RQA;
  R$.decompressResponsePolicyName = "decompressResponsePolicy";
  function RQA() {
    return {
      name: R$.decompressResponsePolicyName,
      async sendRequest(A, Q) {
        if (A.method !== "HEAD")
          A.headers.set("Accept-Encoding", "gzip,deflate");
        return Q(A);
      },
    };
  }
});
var H9 = Z((V$) => {
  Object.defineProperty(V$, "__esModule", { value: !0 });
  V$.getRandomIntegerInclusive = $QA;
  function $QA(A, Q) {
    return (
      (A = Math.ceil(A)),
      (Q = Math.floor(Q)),
      Math.floor(Math.random() * (Q - A + 1)) + A
    );
  }
});
var K9 = Z(($$) => {
  Object.defineProperty($$, "__esModule", { value: !0 });
  $$.calculateRetryDelay = zQA;
  var KQA = H9();
  function zQA(A, Q) {
    let B = Q.retryDelayInMs * Math.pow(2, A),
      I = Math.min(Q.maxRetryDelayInMs, B);
    return {
      retryAfterInMs: I / 2 + (0, KQA.getRandomIntegerInclusive)(0, I / 2),
    };
  }
});
var z9 = Z((H$) => {
  Object.defineProperty(H$, "__esModule", { value: !0 });
  H$.delay = jQA;
  H$.parseHeaderValueAsNumber = fQA;
  var OQA = cF(),
    qQA = "The operation was aborted.";
  function jQA(A, Q, B) {
    return new Promise((I, E) => {
      let C = void 0,
        g = void 0,
        F = () => {
          return E(
            new OQA.AbortError(B?.abortErrorMsg ? B?.abortErrorMsg : qQA),
          );
        },
        D = () => {
          if (B?.abortSignal && g)
            B.abortSignal.removeEventListener("abort", g);
        };
      if (
        ((g = () => {
          if (C) clearTimeout(C);
          return D(), F();
        }),
        B?.abortSignal && B.abortSignal.aborted)
      )
        return F();
      if (
        ((C = setTimeout(() => {
          D(), I(Q);
        }, A)),
        B?.abortSignal)
      )
        B.abortSignal.addEventListener("abort", g);
    });
  }
  function fQA(A, Q) {
    let B = A.headers.get(Q);
    if (!B) return;
    let I = Number(B);
    if (Number.isNaN(I)) return;
    return I;
  }
});
var yJ = Z((z$) => {
  Object.defineProperty(z$, "__esModule", { value: !0 });
  z$.isThrottlingRetryResponse = PQA;
  z$.throttlingRetryStrategy = _QA;
  var xQA = z9(),
    T9 = "Retry-After",
    vQA = ["retry-after-ms", "x-ms-retry-after-ms", T9];
  function K$(A) {
    if (!(A && [429, 503].includes(A.status))) return;
    try {
      for (let E of vQA) {
        let C = (0, xQA.parseHeaderValueAsNumber)(A, E);
        if (C === 0 || C) return C * (E === T9 ? 1000 : 1);
      }
      let Q = A.headers.get(T9);
      if (!Q) return;
      let I = Date.parse(Q) - Date.now();
      return Number.isFinite(I) ? Math.max(0, I) : void 0;
    } catch {
      return;
    }
  }
  function PQA(A) {
    return Number.isFinite(K$(A));
  }
  function _QA() {
    return {
      name: "throttlingRetryStrategy",
      retry({ response: A }) {
        let Q = K$(A);
        if (!Number.isFinite(Q)) return { skipStrategy: !0 };
        return { retryAfterInMs: Q };
      },
    };
  }
});
var SJ = Z((q$) => {
  Object.defineProperty(q$, "__esModule", { value: !0 });
  q$.exponentialRetryStrategy = uQA;
  q$.isExponentialRetryResponse = T$;
  q$.isSystemError = O$;
  var bQA = K9(),
    mQA = yJ(),
    dQA = 1000,
    cQA = 64000;
  function uQA(A = {}) {
    let Q = A.retryDelayInMs ?? dQA,
      B = A.maxRetryDelayInMs ?? cQA;
    return {
      name: "exponentialRetryStrategy",
      retry({ retryCount: I, response: E, responseError: C }) {
        let g = O$(C),
          F = g && A.ignoreSystemErrors,
          D = T$(E),
          J = D && A.ignoreHttpStatusCodes;
        if ((E && ((0, mQA.isThrottlingRetryResponse)(E) || !D)) || J || F)
          return { skipStrategy: !0 };
        if (C && !g && !D) return { errorToThrow: C };
        return (0, bQA.calculateRetryDelay)(I, {
          retryDelayInMs: Q,
          maxRetryDelayInMs: B,
        });
      },
    };
  }
  function T$(A) {
    return Boolean(
      A &&
        A.status !== void 0 &&
        (A.status >= 500 || A.status === 408) &&
        A.status !== 501 &&
        A.status !== 505,
    );
  }
  function O$(A) {
    if (!A) return !1;
    return (
      A.code === "ETIMEDOUT" ||
      A.code === "ESOCKETTIMEDOUT" ||
      A.code === "ECONNREFUSED" ||
      A.code === "ECONNRESET" ||
      A.code === "ENOENT" ||
      A.code === "ENOTFOUND"
    );
  }
});
var Ng = Z((f$) => {
  Object.defineProperty(f$, "__esModule", { value: !0 });
  f$.retryPolicy = tQA;
  var nQA = z9(),
    aQA = cF(),
    oQA = lF(),
    j$ = sC(),
    sQA = (0, oQA.createClientLogger)("ts-http-runtime retryPolicy"),
    rQA = "retryPolicy";
  function tQA(A, Q = { maxRetries: j$.DEFAULT_RETRY_POLICY_COUNT }) {
    let B = Q.logger || sQA;
    return {
      name: rQA,
      async sendRequest(I, E) {
        let C,
          g,
          F = -1;
        A: while (!0) {
          (F += 1), (C = void 0), (g = void 0);
          try {
            B.info(`Retry ${F}: Attempting to send request`, I.requestId),
              (C = await E(I)),
              B.info(
                `Retry ${F}: Received a response from request`,
                I.requestId,
              );
          } catch (D) {
            if (
              (B.error(
                `Retry ${F}: Received an error from request`,
                I.requestId,
              ),
              (g = D),
              !D || g.name !== "RestError")
            )
              throw D;
            C = g.response;
          }
          if (I.abortSignal?.aborted)
            throw (
              (B.error(`Retry ${F}: Request aborted.`), new aQA.AbortError())
            );
          if (F >= (Q.maxRetries ?? j$.DEFAULT_RETRY_POLICY_COUNT))
            if (
              (B.info(
                `Retry ${F}: Maximum retries reached. Returning the last received response, or throwing the last received error.`,
              ),
              g)
            )
              throw g;
            else if (C) return C;
            else
              throw Error(
                "Maximum retries reached with no response or error to throw",
              );
          B.info(`Retry ${F}: Processing ${A.length} retry strategies.`);
          Q: for (let D of A) {
            let J = D.logger || B;
            J.info(`Retry ${F}: Processing retry strategy ${D.name}.`);
            let Y = D.retry({ retryCount: F, response: C, responseError: g });
            if (Y.skipStrategy) {
              J.info(`Retry ${F}: Skipped.`);
              continue Q;
            }
            let { errorToThrow: N, retryAfterInMs: W, redirectTo: X } = Y;
            if (N)
              throw (
                (J.error(
                  `Retry ${F}: Retry strategy ${D.name} throws error:`,
                  N,
                ),
                N)
              );
            if (W || W === 0) {
              J.info(`Retry ${F}: Retry strategy ${D.name} retries after ${W}`),
                await (0, nQA.delay)(W, void 0, { abortSignal: I.abortSignal });
              continue A;
            }
            if (X) {
              J.info(`Retry ${F}: Retry strategy ${D.name} redirects to ${X}`),
                (I.url = X);
              continue A;
            }
          }
          if (g)
            throw (
              (B.info(
                "None of the retry strategies could work with the received error. Throwing it.",
              ),
              g)
            );
          if (C)
            return (
              B.info(
                "None of the retry strategies could work with the received response. Returning it.",
              ),
              C
            );
        }
      },
    };
  }
});
var q9 = Z((h$) => {
  Object.defineProperty(h$, "__esModule", { value: !0 });
  h$.defaultRetryPolicyName = void 0;
  h$.defaultRetryPolicy = EBA;
  var ABA = SJ(),
    QBA = yJ(),
    BBA = Ng(),
    IBA = sC();
  h$.defaultRetryPolicyName = "defaultRetryPolicy";
  function EBA(A = {}) {
    return {
      name: h$.defaultRetryPolicyName,
      sendRequest: (0, BBA.retryPolicy)(
        [
          (0, QBA.throttlingRetryStrategy)(),
          (0, ABA.exponentialRetryStrategy)(A),
        ],
        { maxRetries: A.maxRetries ?? IBA.DEFAULT_RETRY_POLICY_COUNT },
      ).sendRequest,
    };
  }
});
var oF = Z((k$) => {
  Object.defineProperty(k$, "__esModule", { value: !0 });
  k$.isReactNative =
    k$.isNodeRuntime =
    k$.isNodeLike =
    k$.isBun =
    k$.isDeno =
    k$.isWebWorker =
    k$.isBrowser =
      void 0;
  k$.isBrowser = typeof window < "u" && typeof window.document < "u";
  k$.isWebWorker =
    typeof self === "object" &&
    typeof self?.importScripts === "function" &&
    (self.constructor?.name === "DedicatedWorkerGlobalScope" ||
      self.constructor?.name === "ServiceWorkerGlobalScope" ||
      self.constructor?.name === "SharedWorkerGlobalScope");
  k$.isDeno =
    typeof Deno < "u" &&
    typeof Deno.version < "u" &&
    typeof Deno.version.deno < "u";
  k$.isBun = typeof Bun < "u" && typeof Bun.version < "u";
  k$.isNodeLike =
    typeof globalThis.process < "u" &&
    Boolean(globalThis.process.version) &&
    Boolean(globalThis.process.versions?.node);
  k$.isNodeRuntime = k$.isNodeLike && !k$.isBun && !k$.isDeno;
  k$.isReactNative =
    typeof navigator < "u" && navigator?.product === "ReactNative";
});
var f9 = Z((S$) => {
  Object.defineProperty(S$, "__esModule", { value: !0 });
  S$.formDataPolicyName = void 0;
  S$.formDataPolicy = GBA;
  var YBA = oC(),
    JBA = oF(),
    y$ = BC();
  S$.formDataPolicyName = "formDataPolicy";
  function NBA(A) {
    let Q = {};
    for (let [B, I] of A.entries()) (Q[B] ??= []), Q[B].push(I);
    return Q;
  }
  function GBA() {
    return {
      name: S$.formDataPolicyName,
      async sendRequest(A, Q) {
        if (
          JBA.isNodeLike &&
          typeof FormData < "u" &&
          A.body instanceof FormData
        )
          (A.formData = NBA(A.body)), (A.body = void 0);
        if (A.formData) {
          let B = A.headers.get("Content-Type");
          if (B && B.indexOf("application/x-www-form-urlencoded") !== -1)
            A.body = UBA(A.formData);
          else await WBA(A.formData, A);
          A.formData = void 0;
        }
        return Q(A);
      },
    };
  }
  function UBA(A) {
    let Q = new URLSearchParams();
    for (let [B, I] of Object.entries(A))
      if (Array.isArray(I)) for (let E of I) Q.append(B, E.toString());
      else Q.append(B, I.toString());
    return Q.toString();
  }
  async function WBA(A, Q) {
    let B = Q.headers.get("Content-Type");
    if (B && !B.startsWith("multipart/form-data")) return;
    Q.headers.set("Content-Type", B ?? "multipart/form-data");
    let I = [];
    for (let [E, C] of Object.entries(A))
      for (let g of Array.isArray(C) ? C : [C])
        if (typeof g === "string")
          I.push({
            headers: (0, y$.createHttpHeaders)({
              "Content-Disposition": `form-data; name="${E}"`,
            }),
            body: (0, YBA.stringToUint8Array)(g, "utf-8"),
          });
        else if (g === void 0 || g === null || typeof g !== "object")
          throw Error(
            `Unexpected value for key ${E}: ${g}. Value should be serialized to string first.`,
          );
        else {
          let F = g.name || "blob",
            D = (0, y$.createHttpHeaders)();
          D.set(
            "Content-Disposition",
            `form-data; name="${E}"; filename="${F}"`,
          ),
            D.set("Content-Type", g.type || "application/octet-stream"),
            I.push({ headers: D, body: g });
        }
    Q.multipartBody = { parts: I };
  }
});
var m$ = Z((OHA, b$) => {
  var Gg = 1000,
    Ug = Gg * 60,
    Wg = Ug * 60,
    rC = Wg * 24,
    XBA = rC * 7,
    wBA = rC * 365.25;
  b$.exports = function (A, Q) {
    Q = Q || {};
    var B = typeof A;
    if (B === "string" && A.length > 0) return MBA(A);
    else if (B === "number" && isFinite(A)) return Q.long ? RBA(A) : LBA(A);
    throw Error(
      "val is not a non-empty string or a valid number. val=" +
        JSON.stringify(A),
    );
  };
  function MBA(A) {
    if (((A = String(A)), A.length > 100)) return;
    var Q =
      /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
        A,
      );
    if (!Q) return;
    var B = parseFloat(Q[1]),
      I = (Q[2] || "ms").toLowerCase();
    switch (I) {
      case "years":
      case "year":
      case "yrs":
      case "yr":
      case "y":
        return B * wBA;
      case "weeks":
      case "week":
      case "w":
        return B * XBA;
      case "days":
      case "day":
      case "d":
        return B * rC;
      case "hours":
      case "hour":
      case "hrs":
      case "hr":
      case "h":
        return B * Wg;
      case "minutes":
      case "minute":
      case "mins":
      case "min":
      case "m":
        return B * Ug;
      case "seconds":
      case "second":
      case "secs":
      case "sec":
      case "s":
        return B * Gg;
      case "milliseconds":
      case "millisecond":
      case "msecs":
      case "msec":
      case "ms":
        return B;
      default:
        return;
    }
  }
  function LBA(A) {
    var Q = Math.abs(A);
    if (Q >= rC) return Math.round(A / rC) + "d";
    if (Q >= Wg) return Math.round(A / Wg) + "h";
    if (Q >= Ug) return Math.round(A / Ug) + "m";
    if (Q >= Gg) return Math.round(A / Gg) + "s";
    return A + "ms";
  }
  function RBA(A) {
    var Q = Math.abs(A);
    if (Q >= rC) return bJ(A, Q, rC, "day");
    if (Q >= Wg) return bJ(A, Q, Wg, "hour");
    if (Q >= Ug) return bJ(A, Q, Ug, "minute");
    if (Q >= Gg) return bJ(A, Q, Gg, "second");
    return A + " ms";
  }
  function bJ(A, Q, B, I) {
    var E = Q >= B * 1.5;
    return Math.round(A / B) + " " + I + (E ? "s" : "");
  }
});
var h9 = Z((qHA, d$) => {
  function VBA(A) {
    (B.debug = B),
      (B.default = B),
      (B.coerce = D),
      (B.disable = g),
      (B.enable = E),
      (B.enabled = F),
      (B.humanize = m$()),
      (B.destroy = J),
      Object.keys(A).forEach((Y) => {
        B[Y] = A[Y];
      }),
      (B.names = []),
      (B.skips = []),
      (B.formatters = {});
    function Q(Y) {
      let N = 0;
      for (let W = 0; W < Y.length; W++)
        (N = (N << 5) - N + Y.charCodeAt(W)), (N |= 0);
      return B.colors[Math.abs(N) % B.colors.length];
    }
    B.selectColor = Q;
    function B(Y) {
      let N,
        W = null,
        X,
        M;
      function L(...H) {
        if (!L.enabled) return;
        let q = L,
          O = Number(new Date()),
          f = O - (N || O);
        if (
          ((q.diff = f),
          (q.prev = N),
          (q.curr = O),
          (N = O),
          (H[0] = B.coerce(H[0])),
          typeof H[0] !== "string")
        )
          H.unshift("%O");
        let S = 0;
        (H[0] = H[0].replace(/%([a-zA-Z%])/g, (t, IA) => {
          if (t === "%%") return "%";
          S++;
          let zA = B.formatters[IA];
          if (typeof zA === "function") {
            let DA = H[S];
            (t = zA.call(q, DA)), H.splice(S, 1), S--;
          }
          return t;
        })),
          B.formatArgs.call(q, H),
          (q.log || B.log).apply(q, H);
      }
      if (
        ((L.namespace = Y),
        (L.useColors = B.useColors()),
        (L.color = B.selectColor(Y)),
        (L.extend = I),
        (L.destroy = B.destroy),
        Object.defineProperty(L, "enabled", {
          enumerable: !0,
          configurable: !1,
          get: () => {
            if (W !== null) return W;
            if (X !== B.namespaces) (X = B.namespaces), (M = B.enabled(Y));
            return M;
          },
          set: (H) => {
            W = H;
          },
        }),
        typeof B.init === "function")
      )
        B.init(L);
      return L;
    }
    function I(Y, N) {
      let W = B(this.namespace + (typeof N > "u" ? ":" : N) + Y);
      return (W.log = this.log), W;
    }
    function E(Y) {
      B.save(Y), (B.namespaces = Y), (B.names = []), (B.skips = []);
      let N = (typeof Y === "string" ? Y : "")
        .trim()
        .replace(/\s+/g, ",")
        .split(",")
        .filter(Boolean);
      for (let W of N)
        if (W[0] === "-") B.skips.push(W.slice(1));
        else B.names.push(W);
    }
    function C(Y, N) {
      let W = 0,
        X = 0,
        M = -1,
        L = 0;
      while (W < Y.length)
        if (X < N.length && (N[X] === Y[W] || N[X] === "*"))
          if (N[X] === "*") (M = X), (L = W), X++;
          else W++, X++;
        else if (M !== -1) (X = M + 1), L++, (W = L);
        else return !1;
      while (X < N.length && N[X] === "*") X++;
      return X === N.length;
    }
    function g() {
      let Y = [...B.names, ...B.skips.map((N) => "-" + N)].join(",");
      return B.enable(""), Y;
    }
    function F(Y) {
      for (let N of B.skips) if (C(Y, N)) return !1;
      for (let N of B.names) if (C(Y, N)) return !0;
      return !1;
    }
    function D(Y) {
      if (Y instanceof Error) return Y.stack || Y.message;
      return Y;
    }
    function J() {
      console.warn(
        "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
      );
    }
    return B.enable(B.load()), B;
  }
  d$.exports = VBA;
});
var u$ = Z((c$, mJ) => {
  c$.formatArgs = HBA;
  c$.save = KBA;
  c$.load = zBA;
  c$.useColors = $BA;
  c$.storage = TBA();
  c$.destroy = (() => {
    let A = !1;
    return () => {
      if (!A)
        (A = !0),
          console.warn(
            "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
          );
    };
  })();
  c$.colors = [
    "#0000CC",
    "#0000FF",
    "#0033CC",
    "#0033FF",
    "#0066CC",
    "#0066FF",
    "#0099CC",
    "#0099FF",
    "#00CC00",
    "#00CC33",
    "#00CC66",
    "#00CC99",
    "#00CCCC",
    "#00CCFF",
    "#3300CC",
    "#3300FF",
    "#3333CC",
    "#3333FF",
    "#3366CC",
    "#3366FF",
    "#3399CC",
    "#3399FF",
    "#33CC00",
    "#33CC33",
    "#33CC66",
    "#33CC99",
    "#33CCCC",
    "#33CCFF",
    "#6600CC",
    "#6600FF",
    "#6633CC",
    "#6633FF",
    "#66CC00",
    "#66CC33",
    "#9900CC",
    "#9900FF",
    "#9933CC",
    "#9933FF",
    "#99CC00",
    "#99CC33",
    "#CC0000",
    "#CC0033",
    "#CC0066",
    "#CC0099",
    "#CC00CC",
    "#CC00FF",
    "#CC3300",
    "#CC3333",
    "#CC3366",
    "#CC3399",
    "#CC33CC",
    "#CC33FF",
    "#CC6600",
    "#CC6633",
    "#CC9900",
    "#CC9933",
    "#CCCC00",
    "#CCCC33",
    "#FF0000",
    "#FF0033",
    "#FF0066",
    "#FF0099",
    "#FF00CC",
    "#FF00FF",
    "#FF3300",
    "#FF3333",
    "#FF3366",
    "#FF3399",
    "#FF33CC",
    "#FF33FF",
    "#FF6600",
    "#FF6633",
    "#FF9900",
    "#FF9933",
    "#FFCC00",
    "#FFCC33",
  ];
  function $BA() {
    if (
      typeof window < "u" &&
      window.process &&
      (window.process.type === "renderer" || window.process.__nwjs)
    )
      return !0;
    if (
      typeof navigator < "u" &&
      navigator.userAgent &&
      navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)
    )
      return !1;
    let A;
    return (
      (typeof document < "u" &&
        document.documentElement &&
        document.documentElement.style &&
        document.documentElement.style.WebkitAppearance) ||
      (typeof window < "u" &&
        window.console &&
        (window.console.firebug ||
          (window.console.exception && window.console.table))) ||
      (typeof navigator < "u" &&
        navigator.userAgent &&
        (A = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) &&
        parseInt(A[1], 10) >= 31) ||
      (typeof navigator < "u" &&
        navigator.userAgent &&
        navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/))
    );
  }
  function HBA(A) {
    if (
      ((A[0] =
        (this.useColors ? "%c" : "") +
        this.namespace +
        (this.useColors ? " %c" : " ") +
        A[0] +
        (this.useColors ? "%c " : " ") +
        "+" +
        mJ.exports.humanize(this.diff)),
      !this.useColors)
    )
      return;
    let Q = "color: " + this.color;
    A.splice(1, 0, Q, "color: inherit");
    let B = 0,
      I = 0;
    A[0].replace(/%[a-zA-Z%]/g, (E) => {
      if (E === "%%") return;
      if ((B++, E === "%c")) I = B;
    }),
      A.splice(I, 0, Q);
  }
  c$.log = console.debug || console.log || (() => {});
  function KBA(A) {
    try {
      if (A) c$.storage.setItem("debug", A);
      else c$.storage.removeItem("debug");
    } catch (Q) {}
  }
  function zBA() {
    let A;
    try {
      A = c$.storage.getItem("debug") || c$.storage.getItem("DEBUG");
    } catch (Q) {}
    if (!A && typeof process < "u" && "env" in process) A = process.env.DEBUG;
    return A;
  }
  function TBA() {
    try {
      return localStorage;
    } catch (A) {}
  }
  mJ.exports = h9()(c$);
  var { formatters: OBA } = mJ.exports;
  OBA.j = function (A) {
    try {
      return JSON.stringify(A);
    } catch (Q) {
      return "[UnexpectedJSONParseError]: " + Q.message;
    }
  };
});
var n$ = Z((p$, cJ) => {
  var PBA = $("tty"),
    dJ = $("util");
  p$.init = cBA;
  p$.log = bBA;
  p$.formatArgs = yBA;
  p$.save = mBA;
  p$.load = dBA;
  p$.useColors = _BA;
  p$.destroy = dJ.deprecate(
    () => {},
    "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.",
  );
  p$.colors = [6, 2, 3, 4, 5, 1];
  try {
    let A = (() => {
      throw new Error("Cannot require module " + "supports-color");
    })();
    if (A && (A.stderr || A).level >= 2)
      p$.colors = [
        20, 21, 26, 27, 32, 33, 38, 39, 40, 41, 42, 43, 44, 45, 56, 57, 62, 63,
        68, 69, 74, 75, 76, 77, 78, 79, 80, 81, 92, 93, 98, 99, 112, 113, 128,
        129, 134, 135, 148, 149, 160, 161, 162, 163, 164, 165, 166, 167, 168,
        169, 170, 171, 172, 173, 178, 179, 184, 185, 196, 197, 198, 199, 200,
        201, 202, 203, 204, 205, 206, 207, 208, 209, 214, 215, 220, 221,
      ];
  } catch (A) {}
  p$.inspectOpts = Object.keys(process.env)
    .filter((A) => {
      return /^debug_/i.test(A);
    })
    .reduce((A, Q) => {
      let B = Q.substring(6)
          .toLowerCase()
          .replace(/_([a-z])/g, (E, C) => {
            return C.toUpperCase();
          }),
        I = process.env[Q];
      if (/^(yes|on|true|enabled)$/i.test(I)) I = !0;
      else if (/^(no|off|false|disabled)$/i.test(I)) I = !1;
      else if (I === "null") I = null;
      else I = Number(I);
      return (A[B] = I), A;
    }, {});
  function _BA() {
    return "colors" in p$.inspectOpts
      ? Boolean(p$.inspectOpts.colors)
      : PBA.isatty(process.stderr.fd);
  }
  function yBA(A) {
    let { namespace: Q, useColors: B } = this;
    if (B) {
      let I = this.color,
        E = "\x1B[3" + (I < 8 ? I : "8;5;" + I),
        C = `  ${E};1m${Q} \x1B[0m`;
      (A[0] =
        C +
        A[0]
          .split(
            `
`,
          )
          .join(
            `
` + C,
          )),
        A.push(E + "m+" + cJ.exports.humanize(this.diff) + "\x1B[0m");
    } else A[0] = SBA() + Q + " " + A[0];
  }
  function SBA() {
    if (p$.inspectOpts.hideDate) return "";
    return new Date().toISOString() + " ";
  }
  function bBA(...A) {
    return process.stderr.write(
      dJ.formatWithOptions(p$.inspectOpts, ...A) +
        `
`,
    );
  }
  function mBA(A) {
    if (A) process.env.DEBUG = A;
    else delete process.env.DEBUG;
  }
  function dBA() {
    return process.env.DEBUG;
  }
  function cBA(A) {
    A.inspectOpts = {};
    let Q = Object.keys(p$.inspectOpts);
    for (let B = 0; B < Q.length; B++)
      A.inspectOpts[Q[B]] = p$.inspectOpts[Q[B]];
  }
  cJ.exports = h9()(p$);
  var { formatters: l$ } = cJ.exports;
  l$.o = function (A) {
    return (
      (this.inspectOpts.colors = this.useColors),
      dJ
        .inspect(A, this.inspectOpts)
        .split(
          `
`,
        )
        .map((Q) => Q.trim())
        .join(" ")
    );
  };
  l$.O = function (A) {
    return (
      (this.inspectOpts.colors = this.useColors),
      dJ.inspect(A, this.inspectOpts)
    );
  };
});
var uJ = Z((hHA, k9) => {
  if (
    typeof process > "u" ||
    process.type === "renderer" ||
    !1 ||
    process.__nwjs
  )
    k9.exports = u$();
  else k9.exports = n$();
});
var s$ = Z((fB) => {
  var sBA =
      (fB && fB.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            var E = Object.getOwnPropertyDescriptor(Q, B);
            if (
              !E ||
              ("get" in E ? !Q.__esModule : E.writable || E.configurable)
            )
              E = {
                enumerable: !0,
                get: function () {
                  return Q[B];
                },
              };
            Object.defineProperty(A, I, E);
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    rBA =
      (fB && fB.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    a$ =
      (fB && fB.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.prototype.hasOwnProperty.call(A, B))
              sBA(Q, A, B);
        }
        return rBA(Q, A), Q;
      };
  Object.defineProperty(fB, "__esModule", { value: !0 });
  fB.req = fB.json = fB.toBuffer = void 0;
  var tBA = a$($("http")),
    eBA = a$($("https"));
  async function o$(A) {
    let Q = 0,
      B = [];
    for await (let I of A) (Q += I.length), B.push(I);
    return Buffer.concat(B, Q);
  }
  fB.toBuffer = o$;
  async function AIA(A) {
    let B = (await o$(A)).toString("utf8");
    try {
      return JSON.parse(B);
    } catch (I) {
      let E = I;
      throw ((E.message += ` (input: ${B})`), E);
    }
  }
  fB.json = AIA;
  function QIA(A, Q = {}) {
    let I = (
        (typeof A === "string" ? A : A.href).startsWith("https:") ? eBA : tBA
      ).request(A, Q),
      E = new Promise((C, g) => {
        I.once("response", C).once("error", g).end();
      });
    return (I.then = E.then.bind(E)), I;
  }
  fB.req = QIA;
});
var x9 = Z((pB) => {
  var t$ =
      (pB && pB.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            var E = Object.getOwnPropertyDescriptor(Q, B);
            if (
              !E ||
              ("get" in E ? !Q.__esModule : E.writable || E.configurable)
            )
              E = {
                enumerable: !0,
                get: function () {
                  return Q[B];
                },
              };
            Object.defineProperty(A, I, E);
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    BIA =
      (pB && pB.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    e$ =
      (pB && pB.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.prototype.hasOwnProperty.call(A, B))
              t$(Q, A, B);
        }
        return BIA(Q, A), Q;
      },
    IIA =
      (pB && pB.__exportStar) ||
      function (A, Q) {
        for (var B in A)
          if (B !== "default" && !Object.prototype.hasOwnProperty.call(Q, B))
            t$(Q, A, B);
      };
  Object.defineProperty(pB, "__esModule", { value: !0 });
  pB.Agent = void 0;
  var EIA = e$($("net")),
    r$ = e$($("http")),
    CIA = $("https");
  IIA(s$(), pB);
  var aI = Symbol("AgentBaseInternalState");
  class AH extends r$.Agent {
    constructor(A) {
      super(A);
      this[aI] = {};
    }
    isSecureEndpoint(A) {
      if (A) {
        if (typeof A.secureEndpoint === "boolean") return A.secureEndpoint;
        if (typeof A.protocol === "string") return A.protocol === "https:";
      }
      let { stack: Q } = Error();
      if (typeof Q !== "string") return !1;
      return Q.split(
        `
`,
      ).some(
        (B) =>
          B.indexOf("(https.js:") !== -1 || B.indexOf("node:https:") !== -1,
      );
    }
    incrementSockets(A) {
      if (this.maxSockets === 1 / 0 && this.maxTotalSockets === 1 / 0)
        return null;
      if (!this.sockets[A]) this.sockets[A] = [];
      let Q = new EIA.Socket({ writable: !1 });
      return this.sockets[A].push(Q), this.totalSocketCount++, Q;
    }
    decrementSockets(A, Q) {
      if (!this.sockets[A] || Q === null) return;
      let B = this.sockets[A],
        I = B.indexOf(Q);
      if (I !== -1) {
        if ((B.splice(I, 1), this.totalSocketCount--, B.length === 0))
          delete this.sockets[A];
      }
    }
    getName(A) {
      if (this.isSecureEndpoint(A))
        return CIA.Agent.prototype.getName.call(this, A);
      return super.getName(A);
    }
    createSocket(A, Q, B) {
      let I = { ...Q, secureEndpoint: this.isSecureEndpoint(Q) },
        E = this.getName(I),
        C = this.incrementSockets(E);
      Promise.resolve()
        .then(() => this.connect(A, I))
        .then(
          (g) => {
            if ((this.decrementSockets(E, C), g instanceof r$.Agent))
              try {
                return g.addRequest(A, I);
              } catch (F) {
                return B(F);
              }
            (this[aI].currentSocket = g), super.createSocket(A, Q, B);
          },
          (g) => {
            this.decrementSockets(E, C), B(g);
          },
        );
    }
    createConnection() {
      let A = this[aI].currentSocket;
      if (((this[aI].currentSocket = void 0), !A))
        throw Error("No socket was returned in the `connect()` function");
      return A;
    }
    get defaultPort() {
      return this[aI].defaultPort ?? (this.protocol === "https:" ? 443 : 80);
    }
    set defaultPort(A) {
      if (this[aI]) this[aI].defaultPort = A;
    }
    get protocol() {
      return (
        this[aI].protocol ?? (this.isSecureEndpoint() ? "https:" : "http:")
      );
    }
    set protocol(A) {
      if (this[aI]) this[aI].protocol = A;
    }
  }
  pB.Agent = AH;
});
var QH = Z((Zg) => {
  var gIA =
    (Zg && Zg.__importDefault) ||
    function (A) {
      return A && A.__esModule ? A : { default: A };
    };
  Object.defineProperty(Zg, "__esModule", { value: !0 });
  Zg.parseProxyResponse = void 0;
  var FIA = gIA(uJ()),
    lJ = (0, FIA.default)("https-proxy-agent:parse-proxy-response");
  function DIA(A) {
    return new Promise((Q, B) => {
      let I = 0,
        E = [];
      function C() {
        let Y = A.read();
        if (Y) J(Y);
        else A.once("readable", C);
      }
      function g() {
        A.removeListener("end", F),
          A.removeListener("error", D),
          A.removeListener("readable", C);
      }
      function F() {
        g(),
          lJ("onend"),
          B(Error("Proxy connection ended before receiving CONNECT response"));
      }
      function D(Y) {
        g(), lJ("onerror %o", Y), B(Y);
      }
      function J(Y) {
        E.push(Y), (I += Y.length);
        let N = Buffer.concat(E, I),
          W = N.indexOf(`\r
\r
`);
        if (W === -1) {
          lJ("have not received end of HTTP headers yet..."), C();
          return;
        }
        let X = N.slice(0, W).toString("ascii").split(`\r
`),
          M = X.shift();
        if (!M)
          return (
            A.destroy(),
            B(Error("No header received from proxy CONNECT response"))
          );
        let L = M.split(" "),
          H = +L[1],
          q = L.slice(2).join(" "),
          O = {};
        for (let f of X) {
          if (!f) continue;
          let S = f.indexOf(":");
          if (S === -1)
            return (
              A.destroy(),
              B(Error(`Invalid header from proxy CONNECT response: "${f}"`))
            );
          let r = f.slice(0, S).toLowerCase(),
            t = f.slice(S + 1).trimStart(),
            IA = O[r];
          if (typeof IA === "string") O[r] = [IA, t];
          else if (Array.isArray(IA)) IA.push(t);
          else O[r] = t;
        }
        lJ("got proxy server response: %o %o", M, O),
          g(),
          Q({
            connect: { statusCode: H, statusText: q, headers: O },
            buffered: N,
          });
      }
      A.on("error", D), A.on("end", F), C();
    });
  }
  Zg.parseProxyResponse = DIA;
});
var FH = Z((GI) => {
  var YIA =
      (GI && GI.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            var E = Object.getOwnPropertyDescriptor(Q, B);
            if (
              !E ||
              ("get" in E ? !Q.__esModule : E.writable || E.configurable)
            )
              E = {
                enumerable: !0,
                get: function () {
                  return Q[B];
                },
              };
            Object.defineProperty(A, I, E);
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    JIA =
      (GI && GI.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    CH =
      (GI && GI.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.prototype.hasOwnProperty.call(A, B))
              YIA(Q, A, B);
        }
        return JIA(Q, A), Q;
      },
    gH =
      (GI && GI.__importDefault) ||
      function (A) {
        return A && A.__esModule ? A : { default: A };
      };
  Object.defineProperty(GI, "__esModule", { value: !0 });
  GI.HttpsProxyAgent = void 0;
  var pJ = CH($("net")),
    BH = CH($("tls")),
    NIA = gH($("assert")),
    GIA = gH(uJ()),
    UIA = x9(),
    WIA = $("url"),
    ZIA = QH(),
    rF = (0, GIA.default)("https-proxy-agent"),
    IH = (A) => {
      if (A.servername === void 0 && A.host && !pJ.isIP(A.host))
        return { ...A, servername: A.host };
      return A;
    };
  class v9 extends UIA.Agent {
    constructor(A, Q) {
      super(Q);
      (this.options = { path: void 0 }),
        (this.proxy = typeof A === "string" ? new WIA.URL(A) : A),
        (this.proxyHeaders = Q?.headers ?? {}),
        rF("Creating new HttpsProxyAgent instance: %o", this.proxy.href);
      let B = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, ""),
        I = this.proxy.port
          ? parseInt(this.proxy.port, 10)
          : this.proxy.protocol === "https:"
            ? 443
            : 80;
      this.connectOpts = {
        ALPNProtocols: ["http/1.1"],
        ...(Q ? EH(Q, "headers") : null),
        host: B,
        port: I,
      };
    }
    async connect(A, Q) {
      let { proxy: B } = this;
      if (!Q.host) throw TypeError('No "host" provided');
      let I;
      if (B.protocol === "https:")
        rF("Creating `tls.Socket`: %o", this.connectOpts),
          (I = BH.connect(IH(this.connectOpts)));
      else
        rF("Creating `net.Socket`: %o", this.connectOpts),
          (I = pJ.connect(this.connectOpts));
      let E =
          typeof this.proxyHeaders === "function"
            ? this.proxyHeaders()
            : { ...this.proxyHeaders },
        C = pJ.isIPv6(Q.host) ? `[${Q.host}]` : Q.host,
        g = `CONNECT ${C}:${Q.port} HTTP/1.1\r
`;
      if (B.username || B.password) {
        let N = `${decodeURIComponent(B.username)}:${decodeURIComponent(B.password)}`;
        E["Proxy-Authorization"] = `Basic ${Buffer.from(N).toString("base64")}`;
      }
      if (((E.Host = `${C}:${Q.port}`), !E["Proxy-Connection"]))
        E["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
      for (let N of Object.keys(E))
        g += `${N}: ${E[N]}\r
`;
      let F = (0, ZIA.parseProxyResponse)(I);
      I.write(`${g}\r
`);
      let { connect: D, buffered: J } = await F;
      if (
        (A.emit("proxyConnect", D),
        this.emit("proxyConnect", D, A),
        D.statusCode === 200)
      ) {
        if ((A.once("socket", XIA), Q.secureEndpoint))
          return (
            rF("Upgrading socket connection to TLS"),
            BH.connect({ ...EH(IH(Q), "host", "path", "port"), socket: I })
          );
        return I;
      }
      I.destroy();
      let Y = new pJ.Socket({ writable: !1 });
      return (
        (Y.readable = !0),
        A.once("socket", (N) => {
          rF("Replaying proxy buffer for failed request"),
            (0, NIA.default)(N.listenerCount("data") > 0),
            N.push(J),
            N.push(null);
        }),
        Y
      );
    }
  }
  v9.protocols = ["http", "https"];
  GI.HttpsProxyAgent = v9;
  function XIA(A) {
    A.resume();
  }
  function EH(A, ...Q) {
    let B = {},
      I;
    for (I in A) if (!Q.includes(I)) B[I] = A[I];
    return B;
  }
});
var JH = Z((UI) => {
  var wIA =
      (UI && UI.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            var E = Object.getOwnPropertyDescriptor(Q, B);
            if (
              !E ||
              ("get" in E ? !Q.__esModule : E.writable || E.configurable)
            )
              E = {
                enumerable: !0,
                get: function () {
                  return Q[B];
                },
              };
            Object.defineProperty(A, I, E);
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    MIA =
      (UI && UI.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    YH =
      (UI && UI.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.prototype.hasOwnProperty.call(A, B))
              wIA(Q, A, B);
        }
        return MIA(Q, A), Q;
      },
    LIA =
      (UI && UI.__importDefault) ||
      function (A) {
        return A && A.__esModule ? A : { default: A };
      };
  Object.defineProperty(UI, "__esModule", { value: !0 });
  UI.HttpProxyAgent = void 0;
  var RIA = YH($("net")),
    VIA = YH($("tls")),
    $IA = LIA(uJ()),
    HIA = $("events"),
    KIA = x9(),
    DH = $("url"),
    Xg = (0, $IA.default)("http-proxy-agent");
  class P9 extends KIA.Agent {
    constructor(A, Q) {
      super(Q);
      (this.proxy = typeof A === "string" ? new DH.URL(A) : A),
        (this.proxyHeaders = Q?.headers ?? {}),
        Xg("Creating new HttpProxyAgent instance: %o", this.proxy.href);
      let B = (this.proxy.hostname || this.proxy.host).replace(/^\[|\]$/g, ""),
        I = this.proxy.port
          ? parseInt(this.proxy.port, 10)
          : this.proxy.protocol === "https:"
            ? 443
            : 80;
      this.connectOpts = {
        ...(Q ? zIA(Q, "headers") : null),
        host: B,
        port: I,
      };
    }
    addRequest(A, Q) {
      (A._header = null), this.setRequestProps(A, Q), super.addRequest(A, Q);
    }
    setRequestProps(A, Q) {
      let { proxy: B } = this,
        I = Q.secureEndpoint ? "https:" : "http:",
        E = A.getHeader("host") || "localhost",
        C = `${I}//${E}`,
        g = new DH.URL(A.path, C);
      if (Q.port !== 80) g.port = String(Q.port);
      A.path = String(g);
      let F =
        typeof this.proxyHeaders === "function"
          ? this.proxyHeaders()
          : { ...this.proxyHeaders };
      if (B.username || B.password) {
        let D = `${decodeURIComponent(B.username)}:${decodeURIComponent(B.password)}`;
        F["Proxy-Authorization"] = `Basic ${Buffer.from(D).toString("base64")}`;
      }
      if (!F["Proxy-Connection"])
        F["Proxy-Connection"] = this.keepAlive ? "Keep-Alive" : "close";
      for (let D of Object.keys(F)) {
        let J = F[D];
        if (J) A.setHeader(D, J);
      }
    }
    async connect(A, Q) {
      if (((A._header = null), !A.path.includes("://")))
        this.setRequestProps(A, Q);
      let B, I;
      if (
        (Xg("Regenerating stored HTTP header string for request"),
        A._implicitHeader(),
        A.outputData && A.outputData.length > 0)
      )
        Xg("Patching connection write() output buffer with updated header"),
          (B = A.outputData[0].data),
          (I =
            B.indexOf(`\r
\r
`) + 4),
          (A.outputData[0].data = A._header + B.substring(I)),
          Xg("Output buffer: %o", A.outputData[0].data);
      let E;
      if (this.proxy.protocol === "https:")
        Xg("Creating `tls.Socket`: %o", this.connectOpts),
          (E = VIA.connect(this.connectOpts));
      else
        Xg("Creating `net.Socket`: %o", this.connectOpts),
          (E = RIA.connect(this.connectOpts));
      return await (0, HIA.once)(E, "connect"), E;
    }
  }
  P9.protocols = ["http", "https"];
  UI.HttpProxyAgent = P9;
  function zIA(A, ...Q) {
    let B = {},
      I;
    for (I in A) if (!Q.includes(I)) B[I] = A[I];
    return B;
  }
});
var _9 = Z((XH) => {
  Object.defineProperty(XH, "__esModule", { value: !0 });
  XH.globalNoProxyList = XH.proxyPolicyName = void 0;
  XH.loadNoProxy = ZH;
  XH.getDefaultProxySettings = PIA;
  XH.proxyPolicy = yIA;
  var TIA = FH(),
    OIA = JH(),
    qIA = iF(),
    jIA = "HTTPS_PROXY",
    fIA = "HTTP_PROXY",
    hIA = "ALL_PROXY",
    kIA = "NO_PROXY";
  XH.proxyPolicyName = "proxyPolicy";
  XH.globalNoProxyList = [];
  var UH = !1,
    xIA = new Map();
  function iJ(A) {
    if (process.env[A]) return process.env[A];
    else if (process.env[A.toLowerCase()]) return process.env[A.toLowerCase()];
    return;
  }
  function WH() {
    if (!process) return;
    let A = iJ(jIA),
      Q = iJ(hIA),
      B = iJ(fIA);
    return A || Q || B;
  }
  function vIA(A, Q, B) {
    if (Q.length === 0) return !1;
    let I = new URL(A).hostname;
    if (B?.has(I)) return B.get(I);
    let E = !1;
    for (let C of Q)
      if (C[0] === ".") {
        if (I.endsWith(C)) E = !0;
        else if (I.length === C.length - 1 && I === C.slice(1)) E = !0;
      } else if (I === C) E = !0;
    return B?.set(I, E), E;
  }
  function ZH() {
    let A = iJ(kIA);
    if (((UH = !0), A))
      return A.split(",")
        .map((Q) => Q.trim())
        .filter((Q) => Q.length);
    return [];
  }
  function PIA(A) {
    if (!A) {
      if (((A = WH()), !A)) return;
    }
    let Q = new URL(A);
    return {
      host: (Q.protocol ? Q.protocol + "//" : "") + Q.hostname,
      port: Number.parseInt(Q.port || "80"),
      username: Q.username,
      password: Q.password,
    };
  }
  function _IA() {
    let A = WH();
    return A ? new URL(A) : void 0;
  }
  function NH(A) {
    let Q;
    try {
      Q = new URL(A.host);
    } catch {
      throw Error(
        `Expecting a valid host string in proxy settings, but found "${A.host}".`,
      );
    }
    if (((Q.port = String(A.port)), A.username)) Q.username = A.username;
    if (A.password) Q.password = A.password;
    return Q;
  }
  function GH(A, Q, B) {
    if (A.agent) return;
    let E = new URL(A.url).protocol !== "https:";
    if (A.tlsSettings)
      qIA.logger.warning(
        "TLS settings are not supported in combination with custom Proxy, certificates provided to the client will be ignored.",
      );
    let C = A.headers.toJSON();
    if (E) {
      if (!Q.httpProxyAgent)
        Q.httpProxyAgent = new OIA.HttpProxyAgent(B, { headers: C });
      A.agent = Q.httpProxyAgent;
    } else {
      if (!Q.httpsProxyAgent)
        Q.httpsProxyAgent = new TIA.HttpsProxyAgent(B, { headers: C });
      A.agent = Q.httpsProxyAgent;
    }
  }
  function yIA(A, Q) {
    if (!UH) XH.globalNoProxyList.push(...ZH());
    let B = A ? NH(A) : _IA(),
      I = {};
    return {
      name: XH.proxyPolicyName,
      async sendRequest(E, C) {
        if (
          !E.proxySettings &&
          B &&
          !vIA(
            E.url,
            Q?.customNoProxyList ?? XH.globalNoProxyList,
            Q?.customNoProxyList ? void 0 : xIA,
          )
        )
          GH(E, I, B);
        else if (E.proxySettings) GH(E, I, NH(E.proxySettings));
        return C(E);
      },
    };
  }
});
var S9 = Z((MH) => {
  Object.defineProperty(MH, "__esModule", { value: !0 });
  MH.agentPolicyName = void 0;
  MH.agentPolicy = dIA;
  MH.agentPolicyName = "agentPolicy";
  function dIA(A) {
    return {
      name: MH.agentPolicyName,
      sendRequest: async (Q, B) => {
        if (!Q.agent) Q.agent = A;
        return B(Q);
      },
    };
  }
});
var m9 = Z((LH) => {
  Object.defineProperty(LH, "__esModule", { value: !0 });
  LH.tlsPolicyName = void 0;
  LH.tlsPolicy = uIA;
  LH.tlsPolicyName = "tlsPolicy";
  function uIA(A) {
    return {
      name: LH.tlsPolicyName,
      sendRequest: async (Q, B) => {
        if (!Q.tlsSettings) Q.tlsSettings = A;
        return B(Q);
      },
    };
  }
});
var tF = Z((HH) => {
  Object.defineProperty(HH, "__esModule", { value: !0 });
  HH.isNodeReadableStream = RH;
  HH.isWebReadableStream = VH;
  HH.isBinaryBody = pIA;
  HH.isReadableStream = $H;
  HH.isBlob = iIA;
  function RH(A) {
    return Boolean(A && typeof A.pipe === "function");
  }
  function VH(A) {
    return Boolean(
      A && typeof A.getReader === "function" && typeof A.tee === "function",
    );
  }
  function pIA(A) {
    return (
      A !== void 0 &&
      (A instanceof Uint8Array ||
        $H(A) ||
        typeof A === "function" ||
        A instanceof Blob)
    );
  }
  function $H(A) {
    return RH(A) || VH(A);
  }
  function iIA(A) {
    return typeof A.stream === "function";
  }
});
var OH = Z((TH) => {
  Object.defineProperty(TH, "__esModule", { value: !0 });
  TH.concat = QEA;
  var d9 = $("stream"),
    tIA = tF();
  async function* KH() {
    let A = this.getReader();
    try {
      while (!0) {
        let { done: Q, value: B } = await A.read();
        if (Q) return;
        yield B;
      }
    } finally {
      A.releaseLock();
    }
  }
  function eIA(A) {
    if (!A[Symbol.asyncIterator]) A[Symbol.asyncIterator] = KH.bind(A);
    if (!A.values) A.values = KH.bind(A);
  }
  function zH(A) {
    if (A instanceof ReadableStream) return eIA(A), d9.Readable.fromWeb(A);
    else return A;
  }
  function AEA(A) {
    if (A instanceof Uint8Array) return d9.Readable.from(Buffer.from(A));
    else if ((0, tIA.isBlob)(A)) return zH(A.stream());
    else return zH(A);
  }
  async function QEA(A) {
    return function () {
      let Q = A.map((B) => (typeof B === "function" ? B() : B)).map(AEA);
      return d9.Readable.from(
        (async function* () {
          for (let B of Q) for await (let I of B) yield I;
        })(),
      );
    };
  }
});
var u9 = Z((qH) => {
  Object.defineProperty(qH, "__esModule", { value: !0 });
  qH.multipartPolicyName = void 0;
  qH.multipartPolicy = WEA;
  var wg = oC(),
    IEA = tF(),
    EEA = xJ(),
    CEA = OH();
  function gEA() {
    return `----AzSDKFormBoundary${(0, EEA.randomUUID)()}`;
  }
  function FEA(A) {
    let Q = "";
    for (let [B, I] of A)
      Q += `${B}: ${I}\r
`;
    return Q;
  }
  function DEA(A) {
    if (A instanceof Uint8Array) return A.byteLength;
    else if ((0, IEA.isBlob)(A)) return A.size === -1 ? void 0 : A.size;
    else return;
  }
  function YEA(A) {
    let Q = 0;
    for (let B of A) {
      let I = DEA(B);
      if (I === void 0) return;
      else Q += I;
    }
    return Q;
  }
  async function JEA(A, Q, B) {
    let I = [
        (0, wg.stringToUint8Array)(`--${B}`, "utf-8"),
        ...Q.flatMap((C) => [
          (0, wg.stringToUint8Array)(
            `\r
`,
            "utf-8",
          ),
          (0, wg.stringToUint8Array)(FEA(C.headers), "utf-8"),
          (0, wg.stringToUint8Array)(
            `\r
`,
            "utf-8",
          ),
          C.body,
          (0, wg.stringToUint8Array)(
            `\r
--${B}`,
            "utf-8",
          ),
        ]),
        (0, wg.stringToUint8Array)(
          `--\r
\r
`,
          "utf-8",
        ),
      ],
      E = YEA(I);
    if (E) A.headers.set("Content-Length", E);
    A.body = await (0, CEA.concat)(I);
  }
  qH.multipartPolicyName = "multipartPolicy";
  var NEA = 70,
    GEA = new Set(
      "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789'()+,-./:=?",
    );
  function UEA(A) {
    if (A.length > NEA)
      throw Error(
        `Multipart boundary "${A}" exceeds maximum length of 70 characters`,
      );
    if (Array.from(A).some((Q) => !GEA.has(Q)))
      throw Error(`Multipart boundary "${A}" contains invalid characters`);
  }
  function WEA() {
    return {
      name: qH.multipartPolicyName,
      async sendRequest(A, Q) {
        if (!A.multipartBody) return Q(A);
        if (A.body)
          throw Error(
            "multipartBody and regular body cannot be set at the same time",
          );
        let B = A.multipartBody.boundary,
          I = A.headers.get("Content-Type") ?? "multipart/mixed",
          E = I.match(/^(multipart\/[^ ;]+)(?:; *boundary=(.+))?$/);
        if (!E)
          throw Error(
            `Got multipart request body, but content-type header was not multipart: ${I}`,
          );
        let [, C, g] = E;
        if (g && B && g !== B)
          throw Error(
            `Multipart boundary was specified as ${g} in the header, but got ${B} in the request body`,
          );
        if (((B ??= g), B)) UEA(B);
        else B = gEA();
        return (
          A.headers.set("Content-Type", `${C}; boundary=${B}`),
          await JEA(A, A.multipartBody.parts, B),
          (A.multipartBody = void 0),
          Q(A)
        );
      },
    };
  }
});
var kH = Z((hH) => {
  Object.defineProperty(hH, "__esModule", { value: !0 });
  hH.createPipelineFromOptions = TEA;
  var XEA = W9(),
    wEA = C9(),
    MEA = X9(),
    LEA = R9(),
    REA = $9(),
    VEA = q9(),
    $EA = f9(),
    jH = oF(),
    HEA = _9(),
    KEA = S9(),
    zEA = m9(),
    fH = u9();
  function TEA(A) {
    let Q = (0, wEA.createEmptyPipeline)();
    if (jH.isNodeLike) {
      if (A.agent) Q.addPolicy((0, KEA.agentPolicy)(A.agent));
      if (A.tlsOptions) Q.addPolicy((0, zEA.tlsPolicy)(A.tlsOptions));
      Q.addPolicy((0, HEA.proxyPolicy)(A.proxyOptions)),
        Q.addPolicy((0, REA.decompressResponsePolicy)());
    }
    if (
      (Q.addPolicy((0, $EA.formDataPolicy)(), {
        beforePolicies: [fH.multipartPolicyName],
      }),
      Q.addPolicy((0, LEA.userAgentPolicy)(A.userAgentOptions)),
      Q.addPolicy((0, fH.multipartPolicy)(), { afterPhase: "Deserialize" }),
      Q.addPolicy((0, VEA.defaultRetryPolicy)(A.retryOptions), {
        phase: "Retry",
      }),
      jH.isNodeLike)
    )
      Q.addPolicy((0, MEA.redirectPolicy)(A.redirectOptions), {
        afterPhase: "Retry",
      });
    return (
      Q.addPolicy((0, XEA.logPolicy)(A.loggingOptions), { afterPhase: "Sign" }),
      Q
    );
  }
});
var vH = Z((xH) => {
  Object.defineProperty(xH, "__esModule", { value: !0 });
  xH.apiVersionPolicyName = void 0;
  xH.apiVersionPolicy = qEA;
  xH.apiVersionPolicyName = "ApiVersionPolicy";
  function qEA(A) {
    return {
      name: xH.apiVersionPolicyName,
      sendRequest: (Q, B) => {
        let I = new URL(Q.url);
        if (!I.searchParams.get("api-version") && A.apiVersion)
          Q.url = `${Q.url}${Array.from(I.searchParams.keys()).length > 0 ? "&" : "?"}api-version=${A.apiVersion}`;
        return B(Q);
      },
    };
  }
});
var _H = Z((PH) => {
  Object.defineProperty(PH, "__esModule", { value: !0 });
  PH.isOAuth2TokenCredential = fEA;
  PH.isBearerTokenCredential = hEA;
  PH.isBasicCredential = kEA;
  PH.isApiKeyCredential = xEA;
  function fEA(A) {
    return "getOAuth2Token" in A;
  }
  function hEA(A) {
    return "getBearerToken" in A;
  }
  function kEA(A) {
    return "username" in A && "password" in A;
  }
  function xEA(A) {
    return "key" in A;
  }
});
var eF = Z((SH) => {
  Object.defineProperty(SH, "__esModule", { value: !0 });
  SH.ensureSecureConnection = dEA;
  var SEA = iF(),
    yH = !1;
  function bEA(A, Q) {
    if (Q.allowInsecureConnection && A.allowInsecureConnection) {
      let B = new URL(A.url);
      if (B.hostname === "localhost" || B.hostname === "127.0.0.1") return !0;
    }
    return !1;
  }
  function mEA() {
    if (
      (SEA.logger.warning(
        "Sending token over insecure transport. Assume any token issued is compromised.",
      ),
      typeof process?.emitWarning === "function" && !yH)
    )
      (yH = !0),
        process.emitWarning(
          "Sending token over insecure transport. Assume any token issued is compromised.",
        );
  }
  function dEA(A, Q) {
    if (!A.url.toLowerCase().startsWith("https://"))
      if (bEA(A, Q)) mEA();
      else
        throw Error(
          "Authentication is not permitted for non-TLS protected (non-https) URLs when allowInsecureConnection is false.",
        );
  }
});
var mH = Z((bH) => {
  Object.defineProperty(bH, "__esModule", { value: !0 });
  bH.apiKeyAuthenticationPolicyName = void 0;
  bH.apiKeyAuthenticationPolicy = lEA;
  var uEA = eF();
  bH.apiKeyAuthenticationPolicyName = "apiKeyAuthenticationPolicy";
  function lEA(A) {
    return {
      name: bH.apiKeyAuthenticationPolicyName,
      async sendRequest(Q, B) {
        (0, uEA.ensureSecureConnection)(Q, A);
        let I = (Q.authSchemes ?? A.authSchemes)?.find(
          (E) => E.kind === "apiKey",
        );
        if (!I) return B(Q);
        if (I.apiKeyLocation !== "header")
          throw Error(`Unsupported API key location: ${I.apiKeyLocation}`);
        return Q.headers.set(I.name, A.credential.key), B(Q);
      },
    };
  }
});
var uH = Z((cH) => {
  Object.defineProperty(cH, "__esModule", { value: !0 });
  cH.basicAuthenticationPolicyName = void 0;
  cH.basicAuthenticationPolicy = nEA;
  var dH = oC(),
    iEA = eF();
  cH.basicAuthenticationPolicyName = "bearerAuthenticationPolicy";
  function nEA(A) {
    return {
      name: cH.basicAuthenticationPolicyName,
      async sendRequest(Q, B) {
        if (
          ((0, iEA.ensureSecureConnection)(Q, A),
          !(Q.authSchemes ?? A.authSchemes)?.find(
            (F) => F.kind === "http" && F.scheme === "basic",
          ))
        )
          return B(Q);
        let { username: E, password: C } = A.credential,
          g = (0, dH.uint8ArrayToString)(
            (0, dH.stringToUint8Array)(`${E}:${C}`, "utf-8"),
            "base64",
          );
        return Q.headers.set("Authorization", `Basic ${g}`), B(Q);
      },
    };
  }
});
var pH = Z((lH) => {
  Object.defineProperty(lH, "__esModule", { value: !0 });
  lH.bearerAuthenticationPolicyName = void 0;
  lH.bearerAuthenticationPolicy = sEA;
  var oEA = eF();
  lH.bearerAuthenticationPolicyName = "bearerAuthenticationPolicy";
  function sEA(A) {
    return {
      name: lH.bearerAuthenticationPolicyName,
      async sendRequest(Q, B) {
        if (
          ((0, oEA.ensureSecureConnection)(Q, A),
          !(Q.authSchemes ?? A.authSchemes)?.find(
            (C) => C.kind === "http" && C.scheme === "bearer",
          ))
        )
          return B(Q);
        let E = await A.credential.getBearerToken({
          abortSignal: Q.abortSignal,
        });
        return Q.headers.set("Authorization", `Bearer ${E}`), B(Q);
      },
    };
  }
});
var nH = Z((iH) => {
  Object.defineProperty(iH, "__esModule", { value: !0 });
  iH.oauth2AuthenticationPolicyName = void 0;
  iH.oauth2AuthenticationPolicy = eEA;
  var tEA = eF();
  iH.oauth2AuthenticationPolicyName = "oauth2AuthenticationPolicy";
  function eEA(A) {
    return {
      name: iH.oauth2AuthenticationPolicyName,
      async sendRequest(Q, B) {
        (0, tEA.ensureSecureConnection)(Q, A);
        let I = (Q.authSchemes ?? A.authSchemes)?.find(
          (C) => C.kind === "oauth2",
        );
        if (!I) return B(Q);
        let E = await A.credential.getOAuth2Token(I.flows, {
          abortSignal: Q.abortSignal,
        });
        return Q.headers.set("Authorization", `Bearer ${E}`), B(Q);
      },
    };
  }
});
var s9 = Z((aH) => {
  Object.defineProperty(aH, "__esModule", { value: !0 });
  aH.createDefaultPipeline = DCA;
  aH.getCachedDefaultHttpsClient = YCA;
  var QCA = G9(),
    BCA = kH(),
    ICA = vH(),
    aJ = _H(),
    ECA = mH(),
    CCA = uH(),
    gCA = pH(),
    FCA = nH(),
    o9;
  function DCA(A = {}) {
    let Q = (0, BCA.createPipelineFromOptions)(A);
    Q.addPolicy((0, ICA.apiVersionPolicy)(A));
    let { credential: B, authSchemes: I, allowInsecureConnection: E } = A;
    if (B) {
      if ((0, aJ.isApiKeyCredential)(B))
        Q.addPolicy(
          (0, ECA.apiKeyAuthenticationPolicy)({
            authSchemes: I,
            credential: B,
            allowInsecureConnection: E,
          }),
        );
      else if ((0, aJ.isBasicCredential)(B))
        Q.addPolicy(
          (0, CCA.basicAuthenticationPolicy)({
            authSchemes: I,
            credential: B,
            allowInsecureConnection: E,
          }),
        );
      else if ((0, aJ.isBearerTokenCredential)(B))
        Q.addPolicy(
          (0, gCA.bearerAuthenticationPolicy)({
            authSchemes: I,
            credential: B,
            allowInsecureConnection: E,
          }),
        );
      else if ((0, aJ.isOAuth2TokenCredential)(B))
        Q.addPolicy(
          (0, FCA.oauth2AuthenticationPolicy)({
            authSchemes: I,
            credential: B,
            allowInsecureConnection: E,
          }),
        );
    }
    return Q;
  }
  function YCA() {
    if (!o9) o9 = (0, QCA.createDefaultHttpClient)();
    return o9;
  }
});
var QK = Z((AK) => {
  Object.defineProperty(AK, "__esModule", { value: !0 });
  AK.buildBodyPart = eH;
  AK.buildMultipartBody = wCA;
  var GCA = Yg(),
    UCA = BC(),
    oH = oC(),
    rH = tF();
  function tH(A, Q) {
    if (A.headers) {
      let B = Object.keys(A.headers).find(
        (I) => I.toLowerCase() === Q.toLowerCase(),
      );
      if (B) return A.headers[B];
    }
    return;
  }
  function WCA(A) {
    let Q = tH(A, "content-type");
    if (Q) return Q;
    if (A.contentType === null) return;
    if (A.contentType) return A.contentType;
    let { body: B } = A;
    if (B === null || B === void 0) return;
    if (
      typeof B === "string" ||
      typeof B === "number" ||
      typeof B === "boolean"
    )
      return "text/plain; charset=UTF-8";
    if (B instanceof Blob) return B.type || "application/octet-stream";
    if ((0, rH.isBinaryBody)(B)) return "application/octet-stream";
    return "application/json";
  }
  function sH(A) {
    return JSON.stringify(A);
  }
  function ZCA(A) {
    let Q = tH(A, "content-disposition");
    if (Q) return Q;
    if (
      A.dispositionType === void 0 &&
      A.name === void 0 &&
      A.filename === void 0
    )
      return;
    let I = A.dispositionType ?? "form-data";
    if (A.name) I += `; name=${sH(A.name)}`;
    let E = void 0;
    if (A.filename) E = A.filename;
    else if (typeof File < "u" && A.body instanceof File) {
      let C = A.body.name;
      if (C !== "") E = C;
    }
    if (E) I += `; filename=${sH(E)}`;
    return I;
  }
  function XCA(A, Q) {
    if (A === void 0) return new Uint8Array([]);
    if ((0, rH.isBinaryBody)(A)) return A;
    if (
      typeof A === "string" ||
      typeof A === "number" ||
      typeof A === "boolean"
    )
      return (0, oH.stringToUint8Array)(String(A), "utf-8");
    if (Q && /application\/(.+\+)?json(;.+)?/i.test(String(Q)))
      return (0, oH.stringToUint8Array)(JSON.stringify(A), "utf-8");
    throw new GCA.RestError(
      `Unsupported body/content-type combination: ${A}, ${Q}`,
    );
  }
  function eH(A) {
    let Q = WCA(A),
      B = ZCA(A),
      I = (0, UCA.createHttpHeaders)(A.headers ?? {});
    if (Q) I.set("content-type", Q);
    if (B) I.set("content-disposition", B);
    let E = XCA(A.body, Q);
    return { headers: I, body: E };
  }
  function wCA(A) {
    return { parts: A.map(eH) };
  }
});
var IK = Z((BK) => {
  Object.defineProperty(BK, "__esModule", { value: !0 });
  BK.sendRequest = zCA;
  var r9 = Yg(),
    RCA = BC(),
    VCA = E9(),
    $CA = s9(),
    HCA = tF(),
    KCA = QK();
  async function zCA(A, Q, B, I = {}, E) {
    let C = E ?? (0, $CA.getCachedDefaultHttpsClient)(),
      g = qCA(A, Q, I);
    try {
      let F = await B.sendRequest(C, g),
        D = F.headers.toJSON(),
        J = F.readableStreamBody ?? F.browserStreamBody,
        Y = I.responseAsStream || J !== void 0 ? void 0 : fCA(F),
        N = J ?? Y;
      if (I?.onResponse)
        I.onResponse({ ...F, request: g, rawHeaders: D, parsedBody: Y });
      return { request: g, headers: D, status: `${F.status}`, body: N };
    } catch (F) {
      if ((0, r9.isRestError)(F) && F.response && I.onResponse) {
        let { response: D } = F,
          J = D.headers.toJSON();
        I?.onResponse({ ...D, request: g, rawHeaders: J }, F);
      }
      throw F;
    }
  }
  function TCA(A = {}) {
    return A.contentType ?? A.headers?.["content-type"] ?? OCA(A.body);
  }
  function OCA(A) {
    if (ArrayBuffer.isView(A)) return "application/octet-stream";
    if (typeof A === "string")
      try {
        return JSON.parse(A), "application/json";
      } catch (Q) {
        return;
      }
    return "application/json";
  }
  function qCA(A, Q, B = {}) {
    let I = TCA(B),
      { body: E, multipartBody: C } = jCA(B.body, I),
      g = E !== void 0 || C !== void 0,
      F = (0, RCA.createHttpHeaders)({
        ...(B.headers ? B.headers : {}),
        accept: B.accept ?? B.headers?.accept ?? "application/json",
        ...(g && I && { "content-type": I }),
      });
    return (0, VCA.createPipelineRequest)({
      url: Q,
      method: A,
      body: E,
      multipartBody: C,
      headers: F,
      allowInsecureConnection: B.allowInsecureConnection,
      abortSignal: B.abortSignal,
      onUploadProgress: B.onUploadProgress,
      onDownloadProgress: B.onDownloadProgress,
      timeout: B.timeout,
      enableBrowserStreams: !0,
      streamResponseStatusCodes: B.responseAsStream
        ? new Set([Number.POSITIVE_INFINITY])
        : void 0,
    });
  }
  function jCA(A, Q = "") {
    if (A === void 0) return { body: void 0 };
    if (typeof FormData < "u" && A instanceof FormData) return { body: A };
    if ((0, HCA.isReadableStream)(A)) return { body: A };
    if (ArrayBuffer.isView(A))
      return { body: A instanceof Uint8Array ? A : JSON.stringify(A) };
    switch (Q.split(";")[0]) {
      case "application/json":
        return { body: JSON.stringify(A) };
      case "multipart/form-data":
        if (Array.isArray(A))
          return { multipartBody: (0, KCA.buildMultipartBody)(A) };
        return { body: JSON.stringify(A) };
      case "text/plain":
        return { body: String(A) };
      default:
        if (typeof A === "string") return { body: A };
        return { body: JSON.stringify(A) };
    }
  }
  function fCA(A) {
    let B = (A.headers.get("content-type") ?? "").split(";")[0],
      I = A.bodyAsText ?? "";
    if (B === "text/plain") return String(I);
    try {
      return I ? JSON.parse(I) : void 0;
    } catch (E) {
      if (B === "application/json") throw hCA(A, E);
      return String(I);
    }
  }
  function hCA(A, Q) {
    let B = `Error "${Q}" occurred while parsing the response body - ${A.bodyAsText}.`,
      I = Q.code ?? r9.RestError.PARSE_ERROR;
    return new r9.RestError(B, {
      code: I,
      statusCode: A.status,
      request: A.request,
      response: A,
    });
  }
});
var FK = Z((gK) => {
  Object.defineProperty(gK, "__esModule", { value: !0 });
  gK.buildRequestUrl = vCA;
  gK.buildBaseUrl = EK;
  gK.replaceAll = CK;
  function xCA(A) {
    let Q = A.value;
    return (
      Q !== void 0 && Q.toString !== void 0 && typeof Q.toString === "function"
    );
  }
  function vCA(A, Q, B, I = {}) {
    if (Q.startsWith("https://") || Q.startsWith("http://")) return Q;
    (A = EK(A, I)), (Q = _CA(Q, B, I));
    let E = PCA(`${A}/${Q}`, I);
    return new URL(E).toString().replace(/([^:]\/)\/+/g, "$1");
  }
  function t9(A, Q, B, I) {
    let E;
    if (B === "pipeDelimited") E = "|";
    else if (B === "spaceDelimited") E = "%20";
    else E = ",";
    let C;
    if (Array.isArray(I)) C = I;
    else if (typeof I === "object" && I.toString === Object.prototype.toString)
      C = Object.entries(I).flat();
    else C = [I];
    let g = C.map((F) => {
      if (F === null || F === void 0) return "";
      if (!F.toString || typeof F.toString !== "function")
        throw Error(
          `Query parameters must be able to be represented as string, ${A} can't`,
        );
      let D = F.toISOString !== void 0 ? F.toISOString() : F.toString();
      return Q ? D : encodeURIComponent(D);
    }).join(E);
    return `${Q ? A : encodeURIComponent(A)}=${g}`;
  }
  function PCA(A, Q = {}) {
    if (!Q.queryParameters) return A;
    let B = new URL(A),
      I = Q.queryParameters,
      E = [];
    for (let C of Object.keys(I)) {
      let g = I[C];
      if (g === void 0 || g === null) continue;
      let F = xCA(g),
        D = F ? g.value : g,
        J = F ? (g.explode ?? !1) : !1,
        Y = F && g.style ? g.style : "form";
      if (J)
        if (Array.isArray(D))
          for (let N of D) E.push(t9(C, Q.skipUrlEncoding ?? !1, Y, N));
        else if (typeof D === "object")
          for (let [N, W] of Object.entries(D))
            E.push(t9(N, Q.skipUrlEncoding ?? !1, Y, W));
        else
          throw Error("explode can only be set to true for objects and arrays");
      else E.push(t9(C, Q.skipUrlEncoding ?? !1, Y, D));
    }
    if (B.search !== "") B.search += "&";
    return (B.search += E.join("&")), B.toString();
  }
  function EK(A, Q) {
    if (!Q.pathParameters) return A;
    let B = Q.pathParameters;
    for (let [I, E] of Object.entries(B)) {
      if (E === void 0 || E === null)
        throw Error(`Path parameters ${I} must not be undefined or null`);
      if (!E.toString || typeof E.toString !== "function")
        throw Error(
          `Path parameters must be able to be represented as string, ${I} can't`,
        );
      let C = E.toISOString !== void 0 ? E.toISOString() : String(E);
      if (!Q.skipUrlEncoding) C = encodeURIComponent(E);
      A = CK(A, `{${I}}`, C) ?? "";
    }
    return A;
  }
  function _CA(A, Q, B = {}) {
    for (let I of Q) {
      let E = typeof I === "object" && (I.allowReserved ?? !1),
        C = typeof I === "object" ? I.value : I;
      if (!B.skipUrlEncoding && !E) C = encodeURIComponent(C);
      A = A.replace(/\{[\w-]+\}/, String(C));
    }
    return A;
  }
  function CK(A, Q, B) {
    return !A || !Q ? A : A.split(Q).join(B || "");
  }
});
var JK = Z((YK) => {
  Object.defineProperty(YK, "__esModule", { value: !0 });
  YK.getClient = cCA;
  var mCA = s9(),
    e9 = IK(),
    dCA = FK(),
    DK = oF();
  function cCA(A, Q = {}) {
    let B = Q.pipeline ?? (0, mCA.createDefaultPipeline)(Q);
    if (Q.additionalPolicies?.length)
      for (let { policy: F, position: D } of Q.additionalPolicies) {
        let J = D === "perRetry" ? "Sign" : void 0;
        B.addPolicy(F, { afterPhase: J });
      }
    let { allowInsecureConnection: I, httpClient: E } = Q,
      C = Q.endpoint ?? A,
      g = (F, ...D) => {
        let J = (Y) =>
          (0, dCA.buildRequestUrl)(C, F, D, {
            allowInsecureConnection: I,
            ...Y,
          });
        return {
          get: (Y = {}) => {
            return IC("GET", J(Y), B, Y, I, E);
          },
          post: (Y = {}) => {
            return IC("POST", J(Y), B, Y, I, E);
          },
          put: (Y = {}) => {
            return IC("PUT", J(Y), B, Y, I, E);
          },
          patch: (Y = {}) => {
            return IC("PATCH", J(Y), B, Y, I, E);
          },
          delete: (Y = {}) => {
            return IC("DELETE", J(Y), B, Y, I, E);
          },
          head: (Y = {}) => {
            return IC("HEAD", J(Y), B, Y, I, E);
          },
          options: (Y = {}) => {
            return IC("OPTIONS", J(Y), B, Y, I, E);
          },
          trace: (Y = {}) => {
            return IC("TRACE", J(Y), B, Y, I, E);
          },
        };
      };
    return { path: g, pathUnchecked: g, pipeline: B };
  }
  function IC(A, Q, B, I, E, C) {
    return (
      (E = I.allowInsecureConnection ?? E),
      {
        then: function (g, F) {
          return (0, e9.sendRequest)(
            A,
            Q,
            B,
            { ...I, allowInsecureConnection: E },
            C,
          ).then(g, F);
        },
        async asBrowserStream() {
          if (DK.isNodeLike)
            throw Error(
              "`asBrowserStream` is supported only in the browser environment. Use `asNodeStream` instead to obtain the response body stream. If you require a Web stream of the response in Node, consider using `Readable.toWeb` on the result of `asNodeStream`.",
            );
          else
            return (0, e9.sendRequest)(
              A,
              Q,
              B,
              { ...I, allowInsecureConnection: E, responseAsStream: !0 },
              C,
            );
        },
        async asNodeStream() {
          if (DK.isNodeLike)
            return (0, e9.sendRequest)(
              A,
              Q,
              B,
              { ...I, allowInsecureConnection: E, responseAsStream: !0 },
              C,
            );
          else
            throw Error(
              "`isNodeStream` is not supported in the browser environment. Use `asBrowserStream` to obtain the response body stream.",
            );
        },
      }
    );
  }
});
var GK = Z((NK) => {
  Object.defineProperty(NK, "__esModule", { value: !0 });
  NK.operationOptionsToRequestParameters = lCA;
  function lCA(A) {
    return {
      allowInsecureConnection: A.requestOptions?.allowInsecureConnection,
      timeout: A.requestOptions?.timeout,
      skipUrlEncoding: A.requestOptions?.skipUrlEncoding,
      abortSignal: A.abortSignal,
      onUploadProgress: A.requestOptions?.onUploadProgress,
      onDownloadProgress: A.requestOptions?.onDownloadProgress,
      headers: { ...A.requestOptions?.headers },
      onResponse: A.onResponse,
    };
  }
});
var ZK = Z((WK) => {
  Object.defineProperty(WK, "__esModule", { value: !0 });
  WK.createRestError = aCA;
  var iCA = Yg(),
    nCA = BC();
  function aCA(A, Q) {
    let B = typeof A === "string" ? Q : A,
      I = B.body?.error ?? B.body,
      E =
        typeof A === "string"
          ? A
          : (I?.message ?? `Unexpected status code: ${B.status}`);
    return new iCA.RestError(E, {
      statusCode: UK(B.status),
      code: I?.code,
      request: B.request,
      response: oCA(B),
    });
  }
  function oCA(A) {
    return {
      headers: (0, nCA.createHttpHeaders)(A.headers),
      request: A.request,
      status: UK(A.status) ?? -1,
    };
  }
  function UK(A) {
    let Q = Number.parseInt(A);
    return Number.isNaN(Q) ? void 0 : Q;
  }
});
var Mg = Z(($Q) => {
  Object.defineProperty($Q, "__esModule", { value: !0 });
  $Q.createRestError =
    $Q.operationOptionsToRequestParameters =
    $Q.getClient =
    $Q.createDefaultHttpClient =
    $Q.uint8ArrayToString =
    $Q.stringToUint8Array =
    $Q.isRestError =
    $Q.RestError =
    $Q.createEmptyPipeline =
    $Q.createPipelineRequest =
    $Q.createHttpHeaders =
    $Q.TypeSpecRuntimeLogger =
    $Q.setLogLevel =
    $Q.getLogLevel =
    $Q.createClientLogger =
    $Q.AbortError =
      void 0;
  var XK = BQ(),
    rCA = cF();
  Object.defineProperty($Q, "AbortError", {
    enumerable: !0,
    get: function () {
      return rCA.AbortError;
    },
  });
  var oJ = lF();
  Object.defineProperty($Q, "createClientLogger", {
    enumerable: !0,
    get: function () {
      return oJ.createClientLogger;
    },
  });
  Object.defineProperty($Q, "getLogLevel", {
    enumerable: !0,
    get: function () {
      return oJ.getLogLevel;
    },
  });
  Object.defineProperty($Q, "setLogLevel", {
    enumerable: !0,
    get: function () {
      return oJ.setLogLevel;
    },
  });
  Object.defineProperty($Q, "TypeSpecRuntimeLogger", {
    enumerable: !0,
    get: function () {
      return oJ.TypeSpecRuntimeLogger;
    },
  });
  var tCA = BC();
  Object.defineProperty($Q, "createHttpHeaders", {
    enumerable: !0,
    get: function () {
      return tCA.createHttpHeaders;
    },
  });
  XK.__exportStar(j3(), $Q);
  XK.__exportStar(h3(), $Q);
  var eCA = E9();
  Object.defineProperty($Q, "createPipelineRequest", {
    enumerable: !0,
    get: function () {
      return eCA.createPipelineRequest;
    },
  });
  var A0A = C9();
  Object.defineProperty($Q, "createEmptyPipeline", {
    enumerable: !0,
    get: function () {
      return A0A.createEmptyPipeline;
    },
  });
  var wK = Yg();
  Object.defineProperty($Q, "RestError", {
    enumerable: !0,
    get: function () {
      return wK.RestError;
    },
  });
  Object.defineProperty($Q, "isRestError", {
    enumerable: !0,
    get: function () {
      return wK.isRestError;
    },
  });
  var MK = oC();
  Object.defineProperty($Q, "stringToUint8Array", {
    enumerable: !0,
    get: function () {
      return MK.stringToUint8Array;
    },
  });
  Object.defineProperty($Q, "uint8ArrayToString", {
    enumerable: !0,
    get: function () {
      return MK.uint8ArrayToString;
    },
  });
  var Q0A = G9();
  Object.defineProperty($Q, "createDefaultHttpClient", {
    enumerable: !0,
    get: function () {
      return Q0A.createDefaultHttpClient;
    },
  });
  var B0A = JK();
  Object.defineProperty($Q, "getClient", {
    enumerable: !0,
    get: function () {
      return B0A.getClient;
    },
  });
  var I0A = GK();
  Object.defineProperty($Q, "operationOptionsToRequestParameters", {
    enumerable: !0,
    get: function () {
      return I0A.operationOptionsToRequestParameters;
    },
  });
  var E0A = ZK();
  Object.defineProperty($Q, "createRestError", {
    enumerable: !0,
    get: function () {
      return E0A.createRestError;
    },
  });
});
var A1 = Z((LK) => {
  Object.defineProperty(LK, "__esModule", { value: !0 });
  LK.createEmptyPipeline = F0A;
  var g0A = Mg();
  function F0A() {
    return (0, g0A.createEmptyPipeline)();
  }
});
var RK = Z((Q1) => {
  Object.defineProperty(Q1, "__esModule", { value: !0 });
  Q1.createLoggerContext = void 0;
  var Y0A = lF();
  Object.defineProperty(Q1, "createLoggerContext", {
    enumerable: !0,
    get: function () {
      return Y0A.createLoggerContext;
    },
  });
});
var eC = Z((VK) => {
  Object.defineProperty(VK, "__esModule", { value: !0 });
  VK.AzureLogger = void 0;
  VK.setLogLevel = G0A;
  VK.getLogLevel = U0A;
  VK.createClientLogger = W0A;
  var N0A = RK(),
    sJ = (0, N0A.createLoggerContext)({
      logLevelEnvVarName: "AZURE_LOG_LEVEL",
      namespace: "azure",
    });
  VK.AzureLogger = sJ.logger;
  function G0A(A) {
    sJ.setLogLevel(A);
  }
  function U0A() {
    return sJ.getLogLevel();
  }
  function W0A(A) {
    return sJ.createClientLogger(A);
  }
});
var AD = Z((HK) => {
  Object.defineProperty(HK, "__esModule", { value: !0 });
  HK.logger = void 0;
  var M0A = eC();
  HK.logger = (0, M0A.createClientLogger)("core-rest-pipeline");
});
var OK = Z((zK) => {
  Object.defineProperty(zK, "__esModule", { value: !0 });
  zK.exponentialRetryPolicyName = void 0;
  zK.exponentialRetryPolicy = $0A;
  var L0A = SJ(),
    R0A = Ng(),
    V0A = sC();
  zK.exponentialRetryPolicyName = "exponentialRetryPolicy";
  function $0A(A = {}) {
    return (0, R0A.retryPolicy)(
      [(0, L0A.exponentialRetryStrategy)({ ...A, ignoreSystemErrors: !0 })],
      { maxRetries: A.maxRetries ?? V0A.DEFAULT_RETRY_POLICY_COUNT },
    );
  }
});
var jK = Z((qK) => {
  Object.defineProperty(qK, "__esModule", { value: !0 });
  qK.systemErrorRetryPolicyName = void 0;
  qK.systemErrorRetryPolicy = O0A;
  var K0A = SJ(),
    z0A = Ng(),
    T0A = sC();
  qK.systemErrorRetryPolicyName = "systemErrorRetryPolicy";
  function O0A(A = {}) {
    return {
      name: qK.systemErrorRetryPolicyName,
      sendRequest: (0, z0A.retryPolicy)(
        [
          (0, K0A.exponentialRetryStrategy)({
            ...A,
            ignoreHttpStatusCodes: !0,
          }),
        ],
        { maxRetries: A.maxRetries ?? T0A.DEFAULT_RETRY_POLICY_COUNT },
      ).sendRequest,
    };
  }
});
var hK = Z((fK) => {
  Object.defineProperty(fK, "__esModule", { value: !0 });
  fK.throttlingRetryPolicyName = void 0;
  fK.throttlingRetryPolicy = k0A;
  var j0A = yJ(),
    f0A = Ng(),
    h0A = sC();
  fK.throttlingRetryPolicyName = "throttlingRetryPolicy";
  function k0A(A = {}) {
    return {
      name: fK.throttlingRetryPolicyName,
      sendRequest: (0, f0A.retryPolicy)([(0, j0A.throttlingRetryStrategy)()], {
        maxRetries: A.maxRetries ?? h0A.DEFAULT_RETRY_POLICY_COUNT,
      }).sendRequest,
    };
  }
});
var hB = Z((kA) => {
  Object.defineProperty(kA, "__esModule", { value: !0 });
  kA.userAgentPolicyName =
    kA.userAgentPolicy =
    kA.tlsPolicyName =
    kA.tlsPolicy =
    kA.redirectPolicyName =
    kA.redirectPolicy =
    kA.getDefaultProxySettings =
    kA.proxyPolicyName =
    kA.proxyPolicy =
    kA.multipartPolicyName =
    kA.multipartPolicy =
    kA.logPolicyName =
    kA.logPolicy =
    kA.formDataPolicyName =
    kA.formDataPolicy =
    kA.throttlingRetryPolicyName =
    kA.throttlingRetryPolicy =
    kA.systemErrorRetryPolicyName =
    kA.systemErrorRetryPolicy =
    kA.retryPolicy =
    kA.exponentialRetryPolicyName =
    kA.exponentialRetryPolicy =
    kA.defaultRetryPolicyName =
    kA.defaultRetryPolicy =
    kA.decompressResponsePolicyName =
    kA.decompressResponsePolicy =
    kA.agentPolicyName =
    kA.agentPolicy =
      void 0;
  var kK = S9();
  Object.defineProperty(kA, "agentPolicy", {
    enumerable: !0,
    get: function () {
      return kK.agentPolicy;
    },
  });
  Object.defineProperty(kA, "agentPolicyName", {
    enumerable: !0,
    get: function () {
      return kK.agentPolicyName;
    },
  });
  var xK = $9();
  Object.defineProperty(kA, "decompressResponsePolicy", {
    enumerable: !0,
    get: function () {
      return xK.decompressResponsePolicy;
    },
  });
  Object.defineProperty(kA, "decompressResponsePolicyName", {
    enumerable: !0,
    get: function () {
      return xK.decompressResponsePolicyName;
    },
  });
  var vK = q9();
  Object.defineProperty(kA, "defaultRetryPolicy", {
    enumerable: !0,
    get: function () {
      return vK.defaultRetryPolicy;
    },
  });
  Object.defineProperty(kA, "defaultRetryPolicyName", {
    enumerable: !0,
    get: function () {
      return vK.defaultRetryPolicyName;
    },
  });
  var PK = OK();
  Object.defineProperty(kA, "exponentialRetryPolicy", {
    enumerable: !0,
    get: function () {
      return PK.exponentialRetryPolicy;
    },
  });
  Object.defineProperty(kA, "exponentialRetryPolicyName", {
    enumerable: !0,
    get: function () {
      return PK.exponentialRetryPolicyName;
    },
  });
  var v0A = Ng();
  Object.defineProperty(kA, "retryPolicy", {
    enumerable: !0,
    get: function () {
      return v0A.retryPolicy;
    },
  });
  var _K = jK();
  Object.defineProperty(kA, "systemErrorRetryPolicy", {
    enumerable: !0,
    get: function () {
      return _K.systemErrorRetryPolicy;
    },
  });
  Object.defineProperty(kA, "systemErrorRetryPolicyName", {
    enumerable: !0,
    get: function () {
      return _K.systemErrorRetryPolicyName;
    },
  });
  var yK = hK();
  Object.defineProperty(kA, "throttlingRetryPolicy", {
    enumerable: !0,
    get: function () {
      return yK.throttlingRetryPolicy;
    },
  });
  Object.defineProperty(kA, "throttlingRetryPolicyName", {
    enumerable: !0,
    get: function () {
      return yK.throttlingRetryPolicyName;
    },
  });
  var SK = f9();
  Object.defineProperty(kA, "formDataPolicy", {
    enumerable: !0,
    get: function () {
      return SK.formDataPolicy;
    },
  });
  Object.defineProperty(kA, "formDataPolicyName", {
    enumerable: !0,
    get: function () {
      return SK.formDataPolicyName;
    },
  });
  var bK = W9();
  Object.defineProperty(kA, "logPolicy", {
    enumerable: !0,
    get: function () {
      return bK.logPolicy;
    },
  });
  Object.defineProperty(kA, "logPolicyName", {
    enumerable: !0,
    get: function () {
      return bK.logPolicyName;
    },
  });
  var mK = u9();
  Object.defineProperty(kA, "multipartPolicy", {
    enumerable: !0,
    get: function () {
      return mK.multipartPolicy;
    },
  });
  Object.defineProperty(kA, "multipartPolicyName", {
    enumerable: !0,
    get: function () {
      return mK.multipartPolicyName;
    },
  });
  var E1 = _9();
  Object.defineProperty(kA, "proxyPolicy", {
    enumerable: !0,
    get: function () {
      return E1.proxyPolicy;
    },
  });
  Object.defineProperty(kA, "proxyPolicyName", {
    enumerable: !0,
    get: function () {
      return E1.proxyPolicyName;
    },
  });
  Object.defineProperty(kA, "getDefaultProxySettings", {
    enumerable: !0,
    get: function () {
      return E1.getDefaultProxySettings;
    },
  });
  var dK = X9();
  Object.defineProperty(kA, "redirectPolicy", {
    enumerable: !0,
    get: function () {
      return dK.redirectPolicy;
    },
  });
  Object.defineProperty(kA, "redirectPolicyName", {
    enumerable: !0,
    get: function () {
      return dK.redirectPolicyName;
    },
  });
  var cK = m9();
  Object.defineProperty(kA, "tlsPolicy", {
    enumerable: !0,
    get: function () {
      return cK.tlsPolicy;
    },
  });
  Object.defineProperty(kA, "tlsPolicyName", {
    enumerable: !0,
    get: function () {
      return cK.tlsPolicyName;
    },
  });
  var uK = R9();
  Object.defineProperty(kA, "userAgentPolicy", {
    enumerable: !0,
    get: function () {
      return uK.userAgentPolicy;
    },
  });
  Object.defineProperty(kA, "userAgentPolicyName", {
    enumerable: !0,
    get: function () {
      return uK.userAgentPolicyName;
    },
  });
});
var C1 = Z((pK) => {
  Object.defineProperty(pK, "__esModule", { value: !0 });
  pK.logPolicyName = void 0;
  pK.logPolicy = y0A;
  var _0A = AD(),
    lK = hB();
  pK.logPolicyName = lK.logPolicyName;
  function y0A(A = {}) {
    return (0, lK.logPolicy)({ logger: _0A.logger.info, ...A });
  }
});
var g1 = Z((aK) => {
  Object.defineProperty(aK, "__esModule", { value: !0 });
  aK.redirectPolicyName = void 0;
  aK.redirectPolicy = b0A;
  var nK = hB();
  aK.redirectPolicyName = nK.redirectPolicyName;
  function b0A(A = {}) {
    return (0, nK.redirectPolicy)(A);
  }
});
var tK = Z((rK) => {
  Object.defineProperty(rK, "__esModule", { value: !0 });
  rK.getHeaderName = d0A;
  rK.setPlatformSpecificData = c0A;
  var sK = BQ(),
    F1 = sK.__importDefault($("node:os")),
    D1 = sK.__importDefault($("node:process"));
  function d0A() {
    return "User-Agent";
  }
  async function c0A(A) {
    if (D1.default && D1.default.versions) {
      let Q = D1.default.versions;
      if (Q.bun) A.set("Bun", Q.bun);
      else if (Q.deno) A.set("Deno", Q.deno);
      else if (Q.node) A.set("Node", Q.node);
    }
    A.set(
      "OS",
      `(${F1.default.arch()}-${F1.default.type()}-${F1.default.release()})`,
    );
  }
});
var rJ = Z((eK) => {
  Object.defineProperty(eK, "__esModule", { value: !0 });
  eK.DEFAULT_RETRY_POLICY_COUNT = eK.SDK_VERSION = void 0;
  eK.SDK_VERSION = "1.22.1";
  eK.DEFAULT_RETRY_POLICY_COUNT = 3;
});
var Y1 = Z((Bz) => {
  Object.defineProperty(Bz, "__esModule", { value: !0 });
  Bz.getUserAgentHeaderName = a0A;
  Bz.getUserAgentValue = o0A;
  var Qz = tK(),
    i0A = rJ();
  function n0A(A) {
    let Q = [];
    for (let [B, I] of A) {
      let E = I ? `${B}/${I}` : B;
      Q.push(E);
    }
    return Q.join(" ");
  }
  function a0A() {
    return (0, Qz.getHeaderName)();
  }
  async function o0A(A) {
    let Q = new Map();
    Q.set("core-rest-pipeline", i0A.SDK_VERSION),
      await (0, Qz.setPlatformSpecificData)(Q);
    let B = n0A(Q);
    return A ? `${A} ${B}` : B;
  }
});
var N1 = Z((Cz) => {
  Object.defineProperty(Cz, "__esModule", { value: !0 });
  Cz.userAgentPolicyName = void 0;
  Cz.userAgentPolicy = t0A;
  var Ez = Y1(),
    Iz = (0, Ez.getUserAgentHeaderName)();
  Cz.userAgentPolicyName = "userAgentPolicy";
  function t0A(A = {}) {
    let Q = (0, Ez.getUserAgentValue)(A.userAgentPrefix);
    return {
      name: Cz.userAgentPolicyName,
      async sendRequest(B, I) {
        if (!B.headers.has(Iz)) B.headers.set(Iz, await Q);
        return I(B);
      },
    };
  }
});
var Dz = Z((Fz) => {
  Object.defineProperty(Fz, "__esModule", { value: !0 });
  Fz.computeSha256Hmac = AgA;
  Fz.computeSha256Hash = QgA;
  var gz = $("node:crypto");
  async function AgA(A, Q, B) {
    let I = Buffer.from(A, "base64");
    return (0, gz.createHmac)("sha256", I).update(Q).digest(B);
  }
  async function QgA(A, Q) {
    return (0, gz.createHash)("sha256").update(A).digest(Q);
  }
});
var QD = Z((kQ) => {
  Object.defineProperty(kQ, "__esModule", { value: !0 });
  kQ.Sanitizer =
    kQ.uint8ArrayToString =
    kQ.stringToUint8Array =
    kQ.isWebWorker =
    kQ.isReactNative =
    kQ.isDeno =
    kQ.isNodeRuntime =
    kQ.isNodeLike =
    kQ.isBun =
    kQ.isBrowser =
    kQ.randomUUID =
    kQ.computeSha256Hmac =
    kQ.computeSha256Hash =
    kQ.isError =
    kQ.isObject =
    kQ.getRandomIntegerInclusive =
    kQ.calculateRetryDelay =
      void 0;
  var EgA = K9();
  Object.defineProperty(kQ, "calculateRetryDelay", {
    enumerable: !0,
    get: function () {
      return EgA.calculateRetryDelay;
    },
  });
  var CgA = H9();
  Object.defineProperty(kQ, "getRandomIntegerInclusive", {
    enumerable: !0,
    get: function () {
      return CgA.getRandomIntegerInclusive;
    },
  });
  var ggA = PJ();
  Object.defineProperty(kQ, "isObject", {
    enumerable: !0,
    get: function () {
      return ggA.isObject;
    },
  });
  var FgA = g9();
  Object.defineProperty(kQ, "isError", {
    enumerable: !0,
    get: function () {
      return FgA.isError;
    },
  });
  var Yz = Dz();
  Object.defineProperty(kQ, "computeSha256Hash", {
    enumerable: !0,
    get: function () {
      return Yz.computeSha256Hash;
    },
  });
  Object.defineProperty(kQ, "computeSha256Hmac", {
    enumerable: !0,
    get: function () {
      return Yz.computeSha256Hmac;
    },
  });
  var DgA = xJ();
  Object.defineProperty(kQ, "randomUUID", {
    enumerable: !0,
    get: function () {
      return DgA.randomUUID;
    },
  });
  var A0 = oF();
  Object.defineProperty(kQ, "isBrowser", {
    enumerable: !0,
    get: function () {
      return A0.isBrowser;
    },
  });
  Object.defineProperty(kQ, "isBun", {
    enumerable: !0,
    get: function () {
      return A0.isBun;
    },
  });
  Object.defineProperty(kQ, "isNodeLike", {
    enumerable: !0,
    get: function () {
      return A0.isNodeLike;
    },
  });
  Object.defineProperty(kQ, "isNodeRuntime", {
    enumerable: !0,
    get: function () {
      return A0.isNodeRuntime;
    },
  });
  Object.defineProperty(kQ, "isDeno", {
    enumerable: !0,
    get: function () {
      return A0.isDeno;
    },
  });
  Object.defineProperty(kQ, "isReactNative", {
    enumerable: !0,
    get: function () {
      return A0.isReactNative;
    },
  });
  Object.defineProperty(kQ, "isWebWorker", {
    enumerable: !0,
    get: function () {
      return A0.isWebWorker;
    },
  });
  var Jz = oC();
  Object.defineProperty(kQ, "stringToUint8Array", {
    enumerable: !0,
    get: function () {
      return Jz.stringToUint8Array;
    },
  });
  Object.defineProperty(kQ, "uint8ArrayToString", {
    enumerable: !0,
    get: function () {
      return Jz.uint8ArrayToString;
    },
  });
  var YgA = pF();
  Object.defineProperty(kQ, "Sanitizer", {
    enumerable: !0,
    get: function () {
      return YgA.Sanitizer;
    },
  });
});
var Gz = Z((Nz) => {
  Object.defineProperty(Nz, "__esModule", { value: !0 });
  Nz.cancelablePromiseRace = NgA;
  async function NgA(A, Q) {
    let B = new AbortController();
    function I() {
      B.abort();
    }
    Q?.abortSignal?.addEventListener("abort", I);
    try {
      return await Promise.race(A.map((E) => E({ abortSignal: B.signal })));
    } finally {
      B.abort(), Q?.abortSignal?.removeEventListener("abort", I);
    }
  }
});
var Xz = Z((Wz) => {
  Object.defineProperty(Wz, "__esModule", { value: !0 });
  Wz.AbortError = void 0;
  class Uz extends Error {
    constructor(A) {
      super(A);
      this.name = "AbortError";
    }
  }
  Wz.AbortError = Uz;
});
var wz = Z((G1) => {
  Object.defineProperty(G1, "__esModule", { value: !0 });
  G1.AbortError = void 0;
  var UgA = Xz();
  Object.defineProperty(G1, "AbortError", {
    enumerable: !0,
    get: function () {
      return UgA.AbortError;
    },
  });
});
var U1 = Z((Mz) => {
  Object.defineProperty(Mz, "__esModule", { value: !0 });
  Mz.createAbortablePromise = XgA;
  var ZgA = wz();
  function XgA(A, Q) {
    let { cleanupBeforeAbort: B, abortSignal: I, abortErrorMsg: E } = Q ?? {};
    return new Promise((C, g) => {
      function F() {
        g(new ZgA.AbortError(E ?? "The operation was aborted."));
      }
      function D() {
        I?.removeEventListener("abort", J);
      }
      function J() {
        B?.(), D(), F();
      }
      if (I?.aborted) return F();
      try {
        A(
          (Y) => {
            D(), C(Y);
          },
          (Y) => {
            D(), g(Y);
          },
        );
      } catch (Y) {
        g(Y);
      }
      I?.addEventListener("abort", J);
    });
  }
});
var Rz = Z((Lz) => {
  Object.defineProperty(Lz, "__esModule", { value: !0 });
  Lz.delay = VgA;
  Lz.calculateRetryDelay = $gA;
  var MgA = U1(),
    LgA = QD(),
    RgA = "The delay was aborted.";
  function VgA(A, Q) {
    let B,
      { abortSignal: I, abortErrorMsg: E } = Q ?? {};
    return (0, MgA.createAbortablePromise)(
      (C) => {
        B = setTimeout(C, A);
      },
      {
        cleanupBeforeAbort: () => clearTimeout(B),
        abortSignal: I,
        abortErrorMsg: E ?? RgA,
      },
    );
  }
  function $gA(A, Q) {
    let B = Q.retryDelayInMs * Math.pow(2, A),
      I = Math.min(Q.maxRetryDelayInMs, B);
    return {
      retryAfterInMs: I / 2 + (0, LgA.getRandomIntegerInclusive)(0, I / 2),
    };
  }
});
var $z = Z((Vz) => {
  Object.defineProperty(Vz, "__esModule", { value: !0 });
  Vz.getErrorMessage = TgA;
  var zgA = QD();
  function TgA(A) {
    if ((0, zgA.isError)(A)) return A.message;
    else {
      let Q;
      try {
        if (typeof A === "object" && A) Q = JSON.stringify(A);
        else Q = String(A);
      } catch (B) {
        Q = "[unable to stringify input]";
      }
      return `Unknown error ${Q}`;
    }
  }
});
var zz = Z((Kz) => {
  Object.defineProperty(Kz, "__esModule", { value: !0 });
  Kz.isDefined = W1;
  Kz.isObjectWithProperties = qgA;
  Kz.objectHasProperty = Hz;
  function W1(A) {
    return typeof A < "u" && A !== null;
  }
  function qgA(A, Q) {
    if (!W1(A) || typeof A !== "object") return !1;
    for (let B of Q) if (!Hz(A, B)) return !1;
    return !0;
  }
  function Hz(A, Q) {
    return W1(A) && typeof A === "object" && Q in A;
  }
});
var lA = Z((RE) => {
  Object.defineProperty(RE, "__esModule", { value: !0 });
  RE.isWebWorker =
    RE.isReactNative =
    RE.isNodeRuntime =
    RE.isNodeLike =
    RE.isNode =
    RE.isDeno =
    RE.isBun =
    RE.isBrowser =
    RE.objectHasProperty =
    RE.isObjectWithProperties =
    RE.isDefined =
    RE.getErrorMessage =
    RE.delay =
    RE.createAbortablePromise =
    RE.cancelablePromiseRace =
      void 0;
  RE.calculateRetryDelay = ygA;
  RE.computeSha256Hash = SgA;
  RE.computeSha256Hmac = bgA;
  RE.getRandomIntegerInclusive = mgA;
  RE.isError = dgA;
  RE.isObject = cgA;
  RE.randomUUID = ugA;
  RE.uint8ArrayToString = lgA;
  RE.stringToUint8Array = pgA;
  var kgA = BQ(),
    nQ = kgA.__importStar(QD()),
    xgA = Gz();
  Object.defineProperty(RE, "cancelablePromiseRace", {
    enumerable: !0,
    get: function () {
      return xgA.cancelablePromiseRace;
    },
  });
  var vgA = U1();
  Object.defineProperty(RE, "createAbortablePromise", {
    enumerable: !0,
    get: function () {
      return vgA.createAbortablePromise;
    },
  });
  var PgA = Rz();
  Object.defineProperty(RE, "delay", {
    enumerable: !0,
    get: function () {
      return PgA.delay;
    },
  });
  var _gA = $z();
  Object.defineProperty(RE, "getErrorMessage", {
    enumerable: !0,
    get: function () {
      return _gA.getErrorMessage;
    },
  });
  var Z1 = zz();
  Object.defineProperty(RE, "isDefined", {
    enumerable: !0,
    get: function () {
      return Z1.isDefined;
    },
  });
  Object.defineProperty(RE, "isObjectWithProperties", {
    enumerable: !0,
    get: function () {
      return Z1.isObjectWithProperties;
    },
  });
  Object.defineProperty(RE, "objectHasProperty", {
    enumerable: !0,
    get: function () {
      return Z1.objectHasProperty;
    },
  });
  function ygA(A, Q) {
    return nQ.calculateRetryDelay(A, Q);
  }
  function SgA(A, Q) {
    return nQ.computeSha256Hash(A, Q);
  }
  function bgA(A, Q, B) {
    return nQ.computeSha256Hmac(A, Q, B);
  }
  function mgA(A, Q) {
    return nQ.getRandomIntegerInclusive(A, Q);
  }
  function dgA(A) {
    return nQ.isError(A);
  }
  function cgA(A) {
    return nQ.isObject(A);
  }
  function ugA() {
    return nQ.randomUUID();
  }
  RE.isBrowser = nQ.isBrowser;
  RE.isBun = nQ.isBun;
  RE.isDeno = nQ.isDeno;
  RE.isNode = nQ.isNodeLike;
  RE.isNodeLike = nQ.isNodeLike;
  RE.isNodeRuntime = nQ.isNodeRuntime;
  RE.isReactNative = nQ.isReactNative;
  RE.isWebWorker = nQ.isWebWorker;
  function lgA(A, Q) {
    return nQ.uint8ArrayToString(A, Q);
  }
  function pgA(A, Q) {
    return nQ.stringToUint8Array(A, Q);
  }
});
var X1 = Z((jz) => {
  Object.defineProperty(jz, "__esModule", { value: !0 });
  jz.hasRawContent = qz;
  jz.getRawContent = JFA;
  jz.createFileFromStream = NFA;
  jz.createFile = GFA;
  var DFA = lA();
  function YFA(A) {
    return Boolean(A && typeof A.pipe === "function");
  }
  var Oz = {
      arrayBuffer: () => {
        throw Error("Not implemented");
      },
      bytes: () => {
        throw Error("Not implemented");
      },
      slice: () => {
        throw Error("Not implemented");
      },
      text: () => {
        throw Error("Not implemented");
      },
    },
    tJ = Symbol("rawContent");
  function qz(A) {
    return typeof A[tJ] === "function";
  }
  function JFA(A) {
    if (qz(A)) return A[tJ]();
    else return A;
  }
  function NFA(A, Q, B = {}) {
    return {
      ...Oz,
      type: B.type ?? "",
      lastModified: B.lastModified ?? new Date().getTime(),
      webkitRelativePath: B.webkitRelativePath ?? "",
      size: B.size ?? -1,
      name: Q,
      stream: () => {
        let I = A();
        if (YFA(I))
          throw Error(
            "Not supported: a Node stream was provided as input to createFileFromStream.",
          );
        return I;
      },
      [tJ]: A,
    };
  }
  function GFA(A, Q, B = {}) {
    if (DFA.isNodeLike)
      return {
        ...Oz,
        type: B.type ?? "",
        lastModified: B.lastModified ?? new Date().getTime(),
        webkitRelativePath: B.webkitRelativePath ?? "",
        size: A.byteLength,
        name: Q,
        arrayBuffer: async () => A.buffer,
        stream: () => new Blob([A]).stream(),
        [tJ]: () => A,
      };
    else return new File([A], Q, B);
  }
});
var M1 = Z((kz) => {
  Object.defineProperty(kz, "__esModule", { value: !0 });
  kz.multipartPolicyName = void 0;
  kz.multipartPolicy = wFA;
  var hz = hB(),
    fz = X1();
  kz.multipartPolicyName = hz.multipartPolicyName;
  function wFA() {
    let A = (0, hz.multipartPolicy)();
    return {
      name: kz.multipartPolicyName,
      sendRequest: async (Q, B) => {
        if (Q.multipartBody) {
          for (let I of Q.multipartBody.parts)
            if ((0, fz.hasRawContent)(I.body))
              I.body = (0, fz.getRawContent)(I.body);
        }
        return A.sendRequest(Q, B);
      },
    };
  }
});
var L1 = Z((vz) => {
  Object.defineProperty(vz, "__esModule", { value: !0 });
  vz.decompressResponsePolicyName = void 0;
  vz.decompressResponsePolicy = LFA;
  var xz = hB();
  vz.decompressResponsePolicyName = xz.decompressResponsePolicyName;
  function LFA() {
    return (0, xz.decompressResponsePolicy)();
  }
});
var R1 = Z((yz) => {
  Object.defineProperty(yz, "__esModule", { value: !0 });
  yz.defaultRetryPolicyName = void 0;
  yz.defaultRetryPolicy = VFA;
  var _z = hB();
  yz.defaultRetryPolicyName = _z.defaultRetryPolicyName;
  function VFA(A = {}) {
    return (0, _z.defaultRetryPolicy)(A);
  }
});
var V1 = Z((mz) => {
  Object.defineProperty(mz, "__esModule", { value: !0 });
  mz.formDataPolicyName = void 0;
  mz.formDataPolicy = HFA;
  var bz = hB();
  mz.formDataPolicyName = bz.formDataPolicyName;
  function HFA() {
    return (0, bz.formDataPolicy)();
  }
});
var H1 = Z((cz) => {
  Object.defineProperty(cz, "__esModule", { value: !0 });
  cz.proxyPolicyName = void 0;
  cz.getDefaultProxySettings = zFA;
  cz.proxyPolicy = TFA;
  var $1 = hB();
  cz.proxyPolicyName = $1.proxyPolicyName;
  function zFA(A) {
    return (0, $1.getDefaultProxySettings)(A);
  }
  function TFA(A, Q) {
    return (0, $1.proxyPolicy)(A, Q);
  }
});
var z1 = Z((lz) => {
  Object.defineProperty(lz, "__esModule", { value: !0 });
  lz.setClientRequestIdPolicyName = void 0;
  lz.setClientRequestIdPolicy = jFA;
  lz.setClientRequestIdPolicyName = "setClientRequestIdPolicy";
  function jFA(A = "x-ms-client-request-id") {
    return {
      name: lz.setClientRequestIdPolicyName,
      async sendRequest(Q, B) {
        if (!Q.headers.has(A)) Q.headers.set(A, Q.requestId);
        return B(Q);
      },
    };
  }
});
var T1 = Z((iz) => {
  Object.defineProperty(iz, "__esModule", { value: !0 });
  iz.agentPolicyName = void 0;
  iz.agentPolicy = hFA;
  var pz = hB();
  iz.agentPolicyName = pz.agentPolicyName;
  function hFA(A) {
    return (0, pz.agentPolicy)(A);
  }
});
var O1 = Z((oz) => {
  Object.defineProperty(oz, "__esModule", { value: !0 });
  oz.tlsPolicyName = void 0;
  oz.tlsPolicy = xFA;
  var az = hB();
  oz.tlsPolicyName = az.tlsPolicyName;
  function xFA(A) {
    return (0, az.tlsPolicy)(A);
  }
});
var j1 = Z((rz) => {
  Object.defineProperty(rz, "__esModule", { value: !0 });
  rz.TracingContextImpl = rz.knownContextKeys = void 0;
  rz.createTracingContext = PFA;
  rz.knownContextKeys = {
    span: Symbol.for("@azure/core-tracing span"),
    namespace: Symbol.for("@azure/core-tracing namespace"),
  };
  function PFA(A = {}) {
    let Q = new Lg(A.parentContext);
    if (A.span) Q = Q.setValue(rz.knownContextKeys.span, A.span);
    if (A.namespace) Q = Q.setValue(rz.knownContextKeys.namespace, A.namespace);
    return Q;
  }
  class Lg {
    _contextMap;
    constructor(A) {
      this._contextMap = A instanceof Lg ? new Map(A._contextMap) : new Map();
    }
    setValue(A, Q) {
      let B = new Lg(this);
      return B._contextMap.set(A, Q), B;
    }
    getValue(A) {
      return this._contextMap.get(A);
    }
    deleteValue(A) {
      let Q = new Lg(this);
      return Q._contextMap.delete(A), Q;
    }
  }
  rz.TracingContextImpl = Lg;
});
var QT = Z((ez) => {
  Object.defineProperty(ez, "__esModule", { value: !0 });
  ez.state = void 0;
  ez.state = { instrumenterImplementation: void 0 };
});
var f1 = Z((ET) => {
  Object.defineProperty(ET, "__esModule", { value: !0 });
  ET.createDefaultTracingSpan = BT;
  ET.createDefaultInstrumenter = IT;
  ET.useInstrumenter = SFA;
  ET.getInstrumenter = bFA;
  var yFA = j1(),
    eJ = QT();
  function BT() {
    return {
      end: () => {},
      isRecording: () => !1,
      recordException: () => {},
      setAttribute: () => {},
      setStatus: () => {},
      addEvent: () => {},
    };
  }
  function IT() {
    return {
      createRequestHeaders: () => {
        return {};
      },
      parseTraceparentHeader: () => {
        return;
      },
      startSpan: (A, Q) => {
        return {
          span: BT(),
          tracingContext: (0, yFA.createTracingContext)({
            parentContext: Q.tracingContext,
          }),
        };
      },
      withContext(A, Q, ...B) {
        return Q(...B);
      },
    };
  }
  function SFA(A) {
    eJ.state.instrumenterImplementation = A;
  }
  function bFA() {
    if (!eJ.state.instrumenterImplementation)
      eJ.state.instrumenterImplementation = IT();
    return eJ.state.instrumenterImplementation;
  }
});
var gT = Z((CT) => {
  Object.defineProperty(CT, "__esModule", { value: !0 });
  CT.createTracingClient = lFA;
  var AN = f1(),
    h1 = j1();
  function lFA(A) {
    let { namespace: Q, packageName: B, packageVersion: I } = A;
    function E(J, Y, N) {
      let W = (0, AN.getInstrumenter)().startSpan(J, {
          ...N,
          packageName: B,
          packageVersion: I,
          tracingContext: Y?.tracingOptions?.tracingContext,
        }),
        X = W.tracingContext,
        M = W.span;
      if (!X.getValue(h1.knownContextKeys.namespace))
        X = X.setValue(h1.knownContextKeys.namespace, Q);
      M.setAttribute("az.namespace", X.getValue(h1.knownContextKeys.namespace));
      let L = Object.assign({}, Y, {
        tracingOptions: { ...Y?.tracingOptions, tracingContext: X },
      });
      return { span: M, updatedOptions: L };
    }
    async function C(J, Y, N, W) {
      let { span: X, updatedOptions: M } = E(J, Y, W);
      try {
        let L = await g(M.tracingOptions.tracingContext, () =>
          Promise.resolve(N(M, X)),
        );
        return X.setStatus({ status: "success" }), L;
      } catch (L) {
        throw (X.setStatus({ status: "error", error: L }), L);
      } finally {
        X.end();
      }
    }
    function g(J, Y, ...N) {
      return (0, AN.getInstrumenter)().withContext(J, Y, ...N);
    }
    function F(J) {
      return (0, AN.getInstrumenter)().parseTraceparentHeader(J);
    }
    function D(J) {
      return (0, AN.getInstrumenter)().createRequestHeaders(J);
    }
    return {
      startSpan: E,
      withSpan: C,
      withContext: g,
      parseTraceparentHeader: F,
      createRequestHeaders: D,
    };
  }
});
var k1 = Z((QN) => {
  Object.defineProperty(QN, "__esModule", { value: !0 });
  QN.createTracingClient = QN.useInstrumenter = void 0;
  var iFA = f1();
  Object.defineProperty(QN, "useInstrumenter", {
    enumerable: !0,
    get: function () {
      return iFA.useInstrumenter;
    },
  });
  var nFA = gT();
  Object.defineProperty(QN, "createTracingClient", {
    enumerable: !0,
    get: function () {
      return nFA.createTracingClient;
    },
  });
});
var BN = Z((DT) => {
  Object.defineProperty(DT, "__esModule", { value: !0 });
  DT.RestError = void 0;
  DT.isRestError = oFA;
  var FT = Mg();
  DT.RestError = FT.RestError;
  function oFA(A) {
    return (0, FT.isRestError)(A);
  }
});
var v1 = Z((JT) => {
  Object.defineProperty(JT, "__esModule", { value: !0 });
  JT.tracingPolicyName = void 0;
  JT.tracingPolicy = BDA;
  var rFA = k1(),
    tFA = rJ(),
    eFA = Y1(),
    IN = AD(),
    BD = lA(),
    ADA = BN(),
    QDA = QD();
  JT.tracingPolicyName = "tracingPolicy";
  function BDA(A = {}) {
    let Q = (0, eFA.getUserAgentValue)(A.userAgentPrefix),
      B = new QDA.Sanitizer({
        additionalAllowedQueryParameters: A.additionalAllowedQueryParameters,
      }),
      I = IDA();
    return {
      name: JT.tracingPolicyName,
      async sendRequest(E, C) {
        if (!I) return C(E);
        let g = await Q,
          F = {
            "http.url": B.sanitizeUrl(E.url),
            "http.method": E.method,
            "http.user_agent": g,
            requestId: E.requestId,
          };
        if (g) F["http.user_agent"] = g;
        let { span: D, tracingContext: J } = EDA(I, E, F) ?? {};
        if (!D || !J) return C(E);
        try {
          let Y = await I.withContext(J, C, E);
          return gDA(D, Y), Y;
        } catch (Y) {
          throw (CDA(D, Y), Y);
        }
      },
    };
  }
  function IDA() {
    try {
      return (0, rFA.createTracingClient)({
        namespace: "",
        packageName: "@azure/core-rest-pipeline",
        packageVersion: tFA.SDK_VERSION,
      });
    } catch (A) {
      IN.logger.warning(
        `Error when creating the TracingClient: ${(0, BD.getErrorMessage)(A)}`,
      );
      return;
    }
  }
  function EDA(A, Q, B) {
    try {
      let { span: I, updatedOptions: E } = A.startSpan(
        `HTTP ${Q.method}`,
        { tracingOptions: Q.tracingOptions },
        { spanKind: "client", spanAttributes: B },
      );
      if (!I.isRecording()) {
        I.end();
        return;
      }
      let C = A.createRequestHeaders(E.tracingOptions.tracingContext);
      for (let [g, F] of Object.entries(C)) Q.headers.set(g, F);
      return { span: I, tracingContext: E.tracingOptions.tracingContext };
    } catch (I) {
      IN.logger.warning(
        `Skipping creating a tracing span due to an error: ${(0, BD.getErrorMessage)(I)}`,
      );
      return;
    }
  }
  function CDA(A, Q) {
    try {
      if (
        (A.setStatus({
          status: "error",
          error: (0, BD.isError)(Q) ? Q : void 0,
        }),
        (0, ADA.isRestError)(Q) && Q.statusCode)
      )
        A.setAttribute("http.status_code", Q.statusCode);
      A.end();
    } catch (B) {
      IN.logger.warning(
        `Skipping tracing span processing due to an error: ${(0, BD.getErrorMessage)(B)}`,
      );
    }
  }
  function gDA(A, Q) {
    try {
      A.setAttribute("http.status_code", Q.status);
      let B = Q.headers.get("x-ms-request-id");
      if (B) A.setAttribute("serviceRequestId", B);
      if (Q.status >= 400) A.setStatus({ status: "error" });
      A.end();
    } catch (B) {
      IN.logger.warning(
        `Skipping tracing span processing due to an error: ${(0, BD.getErrorMessage)(B)}`,
      );
    }
  }
});
var P1 = Z((NT) => {
  Object.defineProperty(NT, "__esModule", { value: !0 });
  NT.wrapAbortSignalLike = DDA;
  function DDA(A) {
    if (A instanceof AbortSignal) return { abortSignal: A };
    if (A.aborted) return { abortSignal: AbortSignal.abort(A.reason) };
    let Q = new AbortController(),
      B = !0;
    function I() {
      if (B) A.removeEventListener("abort", E), (B = !1);
    }
    function E() {
      Q.abort(A.reason), I();
    }
    return (
      A.addEventListener("abort", E), { abortSignal: Q.signal, cleanup: I }
    );
  }
});
var UT = Z((GT) => {
  Object.defineProperty(GT, "__esModule", { value: !0 });
  GT.wrapAbortSignalLikePolicyName = void 0;
  GT.wrapAbortSignalLikePolicy = NDA;
  var JDA = P1();
  GT.wrapAbortSignalLikePolicyName = "wrapAbortSignalLikePolicy";
  function NDA() {
    return {
      name: GT.wrapAbortSignalLikePolicyName,
      sendRequest: async (A, Q) => {
        if (!A.abortSignal) return Q(A);
        let { abortSignal: B, cleanup: I } = (0, JDA.wrapAbortSignalLike)(
          A.abortSignal,
        );
        A.abortSignal = B;
        try {
          return await Q(A);
        } finally {
          I?.();
        }
      },
    };
  }
});
var wT = Z((XT) => {
  Object.defineProperty(XT, "__esModule", { value: !0 });
  XT.createPipelineFromOptions = TDA;
  var UDA = C1(),
    WDA = A1(),
    ZDA = g1(),
    XDA = N1(),
    WT = M1(),
    wDA = L1(),
    MDA = R1(),
    LDA = V1(),
    ZT = lA(),
    RDA = H1(),
    VDA = z1(),
    $DA = T1(),
    HDA = O1(),
    KDA = v1(),
    zDA = UT();
  function TDA(A) {
    let Q = (0, WDA.createEmptyPipeline)();
    if (ZT.isNodeLike) {
      if (A.agent) Q.addPolicy((0, $DA.agentPolicy)(A.agent));
      if (A.tlsOptions) Q.addPolicy((0, HDA.tlsPolicy)(A.tlsOptions));
      Q.addPolicy((0, RDA.proxyPolicy)(A.proxyOptions)),
        Q.addPolicy((0, wDA.decompressResponsePolicy)());
    }
    if (
      (Q.addPolicy((0, zDA.wrapAbortSignalLikePolicy)()),
      Q.addPolicy((0, LDA.formDataPolicy)(), {
        beforePolicies: [WT.multipartPolicyName],
      }),
      Q.addPolicy((0, XDA.userAgentPolicy)(A.userAgentOptions)),
      Q.addPolicy(
        (0, VDA.setClientRequestIdPolicy)(
          A.telemetryOptions?.clientRequestIdHeaderName,
        ),
      ),
      Q.addPolicy((0, WT.multipartPolicy)(), { afterPhase: "Deserialize" }),
      Q.addPolicy((0, MDA.defaultRetryPolicy)(A.retryOptions), {
        phase: "Retry",
      }),
      Q.addPolicy(
        (0, KDA.tracingPolicy)({ ...A.userAgentOptions, ...A.loggingOptions }),
        { afterPhase: "Retry" },
      ),
      ZT.isNodeLike)
    )
      Q.addPolicy((0, ZDA.redirectPolicy)(A.redirectOptions), {
        afterPhase: "Retry",
      });
    return (
      Q.addPolicy((0, UDA.logPolicy)(A.loggingOptions), { afterPhase: "Sign" }),
      Q
    );
  }
});
var LT = Z((MT) => {
  Object.defineProperty(MT, "__esModule", { value: !0 });
  MT.createDefaultHttpClient = fDA;
  var qDA = Mg(),
    jDA = P1();
  function fDA() {
    let A = (0, qDA.createDefaultHttpClient)();
    return {
      async sendRequest(Q) {
        let { abortSignal: B, cleanup: I } = Q.abortSignal
          ? (0, jDA.wrapAbortSignalLike)(Q.abortSignal)
          : {};
        try {
          return (Q.abortSignal = B), await A.sendRequest(Q);
        } finally {
          I?.();
        }
      },
    };
  }
});
var VT = Z((RT) => {
  Object.defineProperty(RT, "__esModule", { value: !0 });
  RT.createHttpHeaders = xDA;
  var kDA = Mg();
  function xDA(A) {
    return (0, kDA.createHttpHeaders)(A);
  }
});
var HT = Z(($T) => {
  Object.defineProperty($T, "__esModule", { value: !0 });
  $T.createPipelineRequest = _DA;
  var PDA = Mg();
  function _DA(A) {
    return (0, PDA.createPipelineRequest)(A);
  }
});
var OT = Z((zT) => {
  Object.defineProperty(zT, "__esModule", { value: !0 });
  zT.exponentialRetryPolicyName = void 0;
  zT.exponentialRetryPolicy = SDA;
  var KT = hB();
  zT.exponentialRetryPolicyName = KT.exponentialRetryPolicyName;
  function SDA(A = {}) {
    return (0, KT.exponentialRetryPolicy)(A);
  }
});
var hT = Z((jT) => {
  Object.defineProperty(jT, "__esModule", { value: !0 });
  jT.systemErrorRetryPolicyName = void 0;
  jT.systemErrorRetryPolicy = mDA;
  var qT = hB();
  jT.systemErrorRetryPolicyName = qT.systemErrorRetryPolicyName;
  function mDA(A = {}) {
    return (0, qT.systemErrorRetryPolicy)(A);
  }
});
var PT = Z((xT) => {
  Object.defineProperty(xT, "__esModule", { value: !0 });
  xT.throttlingRetryPolicyName = void 0;
  xT.throttlingRetryPolicy = cDA;
  var kT = hB();
  xT.throttlingRetryPolicyName = kT.throttlingRetryPolicyName;
  function cDA(A = {}) {
    return (0, kT.throttlingRetryPolicy)(A);
  }
});
var yT = Z((_T) => {
  Object.defineProperty(_T, "__esModule", { value: !0 });
  _T.retryPolicy = aDA;
  var lDA = eC(),
    pDA = rJ(),
    iDA = hB(),
    nDA = (0, lDA.createClientLogger)("core-rest-pipeline retryPolicy");
  function aDA(A, Q = { maxRetries: pDA.DEFAULT_RETRY_POLICY_COUNT }) {
    return (0, iDA.retryPolicy)(A, { logger: nDA, ...Q });
  }
});
var S1 = Z((ST) => {
  Object.defineProperty(ST, "__esModule", { value: !0 });
  ST.DEFAULT_CYCLER_OPTIONS = void 0;
  ST.createTokenCycler = tDA;
  var sDA = lA();
  ST.DEFAULT_CYCLER_OPTIONS = {
    forcedRefreshWindowInMs: 1000,
    retryIntervalInMs: 3000,
    refreshWindowInMs: 120000,
  };
  async function rDA(A, Q, B) {
    async function I() {
      if (Date.now() < B)
        try {
          return await A();
        } catch {
          return null;
        }
      else {
        let C = await A();
        if (C === null) throw Error("Failed to refresh access token.");
        return C;
      }
    }
    let E = await I();
    while (E === null) await (0, sDA.delay)(Q), (E = await I());
    return E;
  }
  function tDA(A, Q) {
    let B = null,
      I = null,
      E,
      C = { ...ST.DEFAULT_CYCLER_OPTIONS, ...Q },
      g = {
        get isRefreshing() {
          return B !== null;
        },
        get shouldRefresh() {
          if (g.isRefreshing) return !1;
          if (I?.refreshAfterTimestamp && I.refreshAfterTimestamp < Date.now())
            return !0;
          return (
            (I?.expiresOnTimestamp ?? 0) - C.refreshWindowInMs < Date.now()
          );
        },
        get mustRefresh() {
          return (
            I === null ||
            I.expiresOnTimestamp - C.forcedRefreshWindowInMs < Date.now()
          );
        },
      };
    function F(D, J) {
      if (!g.isRefreshing)
        B = rDA(
          () => A.getToken(D, J),
          C.retryIntervalInMs,
          I?.expiresOnTimestamp ?? Date.now(),
        )
          .then((N) => {
            return (B = null), (I = N), (E = J.tenantId), I;
          })
          .catch((N) => {
            throw ((B = null), (I = null), (E = void 0), N);
          });
      return B;
    }
    return async (D, J) => {
      let Y = Boolean(J.claims),
        N = E !== J.tenantId;
      if (Y) I = null;
      if (N || Y || g.mustRefresh) return F(D, J);
      if (g.shouldRefresh) F(D, J);
      return I;
    };
  }
});
var lT = Z((uT) => {
  Object.defineProperty(uT, "__esModule", { value: !0 });
  uT.bearerTokenAuthenticationPolicyName = void 0;
  uT.bearerTokenAuthenticationPolicy = EYA;
  uT.parseChallenges = cT;
  var AYA = S1(),
    QYA = AD(),
    BYA = BN();
  uT.bearerTokenAuthenticationPolicyName = "bearerTokenAuthenticationPolicy";
  async function EN(A, Q) {
    try {
      return [await Q(A), void 0];
    } catch (B) {
      if ((0, BYA.isRestError)(B) && B.response) return [B.response, B];
      else throw B;
    }
  }
  async function IYA(A) {
    let { scopes: Q, getAccessToken: B, request: I } = A,
      E = {
        abortSignal: I.abortSignal,
        tracingOptions: I.tracingOptions,
        enableCae: !0,
      },
      C = await B(Q, E);
    if (C) A.request.headers.set("Authorization", `Bearer ${C.token}`);
  }
  function bT(A) {
    return A.status === 401 && A.headers.has("WWW-Authenticate");
  }
  async function mT(A, Q) {
    let { scopes: B } = A,
      I = await A.getAccessToken(B, { enableCae: !0, claims: Q });
    if (!I) return !1;
    return (
      A.request.headers.set(
        "Authorization",
        `${I.tokenType ?? "Bearer"} ${I.token}`,
      ),
      !0
    );
  }
  function EYA(A) {
    let { credential: Q, scopes: B, challengeCallbacks: I } = A,
      E = A.logger || QYA.logger,
      C = {
        authorizeRequest: I?.authorizeRequest?.bind(I) ?? IYA,
        authorizeRequestOnChallenge: I?.authorizeRequestOnChallenge?.bind(I),
      },
      g = Q ? (0, AYA.createTokenCycler)(Q) : () => Promise.resolve(null);
    return {
      name: uT.bearerTokenAuthenticationPolicyName,
      async sendRequest(F, D) {
        if (!F.url.toLowerCase().startsWith("https://"))
          throw Error(
            "Bearer token authentication is not permitted for non-TLS protected (non-https) URLs.",
          );
        await C.authorizeRequest({
          scopes: Array.isArray(B) ? B : [B],
          request: F,
          getAccessToken: g,
          logger: E,
        });
        let J, Y, N;
        if ((([J, Y] = await EN(F, D)), bT(J))) {
          let W = dT(J.headers.get("WWW-Authenticate"));
          if (W) {
            let X;
            try {
              X = atob(W);
            } catch (M) {
              return (
                E.warning(
                  `The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${W}`,
                ),
                J
              );
            }
            if (
              ((N = await mT(
                {
                  scopes: Array.isArray(B) ? B : [B],
                  response: J,
                  request: F,
                  getAccessToken: g,
                  logger: E,
                },
                X,
              )),
              N)
            )
              [J, Y] = await EN(F, D);
          } else if (C.authorizeRequestOnChallenge) {
            if (
              ((N = await C.authorizeRequestOnChallenge({
                scopes: Array.isArray(B) ? B : [B],
                request: F,
                response: J,
                getAccessToken: g,
                logger: E,
              })),
              N)
            )
              [J, Y] = await EN(F, D);
            if (bT(J)) {
              if (((W = dT(J.headers.get("WWW-Authenticate"))), W)) {
                let X;
                try {
                  X = atob(W);
                } catch (M) {
                  return (
                    E.warning(
                      `The WWW-Authenticate header contains "claims" that cannot be parsed. Unable to perform the Continuous Access Evaluation authentication flow. Unparsable claims: ${W}`,
                    ),
                    J
                  );
                }
                if (
                  ((N = await mT(
                    {
                      scopes: Array.isArray(B) ? B : [B],
                      response: J,
                      request: F,
                      getAccessToken: g,
                      logger: E,
                    },
                    X,
                  )),
                  N)
                )
                  [J, Y] = await EN(F, D);
              }
            }
          }
        }
        if (Y) throw Y;
        else return J;
      },
    };
  }
  function cT(A) {
    let Q = /(\w+)\s+((?:\w+=(?:"[^"]*"|[^,]*),?\s*)+)/g,
      B = /(\w+)="([^"]*)"/g,
      I = [],
      E;
    while ((E = Q.exec(A)) !== null) {
      let C = E[1],
        g = E[2],
        F = {},
        D;
      while ((D = B.exec(g)) !== null) F[D[1]] = D[2];
      I.push({ scheme: C, params: F });
    }
    return I;
  }
  function dT(A) {
    if (!A) return;
    return cT(A).find(
      (B) =>
        B.scheme === "Bearer" &&
        B.params.claims &&
        B.params.error === "insufficient_claims",
    )?.params.claims;
  }
});
var iT = Z((pT) => {
  Object.defineProperty(pT, "__esModule", { value: !0 });
  pT.ndJsonPolicyName = void 0;
  pT.ndJsonPolicy = FYA;
  pT.ndJsonPolicyName = "ndJsonPolicy";
  function FYA() {
    return {
      name: pT.ndJsonPolicyName,
      async sendRequest(A, Q) {
        if (typeof A.body === "string" && A.body.startsWith("[")) {
          let B = JSON.parse(A.body);
          if (Array.isArray(B))
            A.body = B.map(
              (I) =>
                JSON.stringify(I) +
                `
`,
            ).join("");
        }
        return Q(A);
      },
    };
  }
});
var oT = Z((aT) => {
  Object.defineProperty(aT, "__esModule", { value: !0 });
  aT.auxiliaryAuthenticationHeaderPolicyName = void 0;
  aT.auxiliaryAuthenticationHeaderPolicy = GYA;
  var YYA = S1(),
    JYA = AD();
  aT.auxiliaryAuthenticationHeaderPolicyName =
    "auxiliaryAuthenticationHeaderPolicy";
  var nT = "x-ms-authorization-auxiliary";
  async function NYA(A) {
    let { scopes: Q, getAccessToken: B, request: I } = A,
      E = { abortSignal: I.abortSignal, tracingOptions: I.tracingOptions };
    return (await B(Q, E))?.token ?? "";
  }
  function GYA(A) {
    let { credentials: Q, scopes: B } = A,
      I = A.logger || JYA.logger,
      E = new WeakMap();
    return {
      name: aT.auxiliaryAuthenticationHeaderPolicyName,
      async sendRequest(C, g) {
        if (!C.url.toLowerCase().startsWith("https://"))
          throw Error(
            "Bearer token authentication for auxiliary header is not permitted for non-TLS protected (non-https) URLs.",
          );
        if (!Q || Q.length === 0)
          return (
            I.info(
              `${aT.auxiliaryAuthenticationHeaderPolicyName} header will not be set due to empty credentials.`,
            ),
            g(C)
          );
        let F = [];
        for (let J of Q) {
          let Y = E.get(J);
          if (!Y) (Y = (0, YYA.createTokenCycler)(J)), E.set(J, Y);
          F.push(
            NYA({
              scopes: Array.isArray(B) ? B : [B],
              request: C,
              getAccessToken: Y,
              logger: I,
            }),
          );
        }
        let D = (await Promise.all(F)).filter((J) => Boolean(J));
        if (D.length === 0)
          return (
            I.warning(
              `None of the auxiliary tokens are valid. ${nT} header will not be set.`,
            ),
            g(C)
          );
        return C.headers.set(nT, D.map((J) => `Bearer ${J}`).join(", ")), g(C);
      },
    };
  }
});
var HQ = Z((gA) => {
  Object.defineProperty(gA, "__esModule", { value: !0 });
  gA.createFileFromStream =
    gA.createFile =
    gA.agentPolicyName =
    gA.agentPolicy =
    gA.auxiliaryAuthenticationHeaderPolicyName =
    gA.auxiliaryAuthenticationHeaderPolicy =
    gA.ndJsonPolicyName =
    gA.ndJsonPolicy =
    gA.bearerTokenAuthenticationPolicyName =
    gA.bearerTokenAuthenticationPolicy =
    gA.formDataPolicyName =
    gA.formDataPolicy =
    gA.tlsPolicyName =
    gA.tlsPolicy =
    gA.userAgentPolicyName =
    gA.userAgentPolicy =
    gA.defaultRetryPolicy =
    gA.tracingPolicyName =
    gA.tracingPolicy =
    gA.retryPolicy =
    gA.throttlingRetryPolicyName =
    gA.throttlingRetryPolicy =
    gA.systemErrorRetryPolicyName =
    gA.systemErrorRetryPolicy =
    gA.redirectPolicyName =
    gA.redirectPolicy =
    gA.getDefaultProxySettings =
    gA.proxyPolicyName =
    gA.proxyPolicy =
    gA.multipartPolicyName =
    gA.multipartPolicy =
    gA.logPolicyName =
    gA.logPolicy =
    gA.setClientRequestIdPolicyName =
    gA.setClientRequestIdPolicy =
    gA.exponentialRetryPolicyName =
    gA.exponentialRetryPolicy =
    gA.decompressResponsePolicyName =
    gA.decompressResponsePolicy =
    gA.isRestError =
    gA.RestError =
    gA.createPipelineRequest =
    gA.createHttpHeaders =
    gA.createDefaultHttpClient =
    gA.createPipelineFromOptions =
    gA.createEmptyPipeline =
      void 0;
  var WYA = A1();
  Object.defineProperty(gA, "createEmptyPipeline", {
    enumerable: !0,
    get: function () {
      return WYA.createEmptyPipeline;
    },
  });
  var ZYA = wT();
  Object.defineProperty(gA, "createPipelineFromOptions", {
    enumerable: !0,
    get: function () {
      return ZYA.createPipelineFromOptions;
    },
  });
  var XYA = LT();
  Object.defineProperty(gA, "createDefaultHttpClient", {
    enumerable: !0,
    get: function () {
      return XYA.createDefaultHttpClient;
    },
  });
  var wYA = VT();
  Object.defineProperty(gA, "createHttpHeaders", {
    enumerable: !0,
    get: function () {
      return wYA.createHttpHeaders;
    },
  });
  var MYA = HT();
  Object.defineProperty(gA, "createPipelineRequest", {
    enumerable: !0,
    get: function () {
      return MYA.createPipelineRequest;
    },
  });
  var sT = BN();
  Object.defineProperty(gA, "RestError", {
    enumerable: !0,
    get: function () {
      return sT.RestError;
    },
  });
  Object.defineProperty(gA, "isRestError", {
    enumerable: !0,
    get: function () {
      return sT.isRestError;
    },
  });
  var rT = L1();
  Object.defineProperty(gA, "decompressResponsePolicy", {
    enumerable: !0,
    get: function () {
      return rT.decompressResponsePolicy;
    },
  });
  Object.defineProperty(gA, "decompressResponsePolicyName", {
    enumerable: !0,
    get: function () {
      return rT.decompressResponsePolicyName;
    },
  });
  var tT = OT();
  Object.defineProperty(gA, "exponentialRetryPolicy", {
    enumerable: !0,
    get: function () {
      return tT.exponentialRetryPolicy;
    },
  });
  Object.defineProperty(gA, "exponentialRetryPolicyName", {
    enumerable: !0,
    get: function () {
      return tT.exponentialRetryPolicyName;
    },
  });
  var eT = z1();
  Object.defineProperty(gA, "setClientRequestIdPolicy", {
    enumerable: !0,
    get: function () {
      return eT.setClientRequestIdPolicy;
    },
  });
  Object.defineProperty(gA, "setClientRequestIdPolicyName", {
    enumerable: !0,
    get: function () {
      return eT.setClientRequestIdPolicyName;
    },
  });
  var AO = C1();
  Object.defineProperty(gA, "logPolicy", {
    enumerable: !0,
    get: function () {
      return AO.logPolicy;
    },
  });
  Object.defineProperty(gA, "logPolicyName", {
    enumerable: !0,
    get: function () {
      return AO.logPolicyName;
    },
  });
  var QO = M1();
  Object.defineProperty(gA, "multipartPolicy", {
    enumerable: !0,
    get: function () {
      return QO.multipartPolicy;
    },
  });
  Object.defineProperty(gA, "multipartPolicyName", {
    enumerable: !0,
    get: function () {
      return QO.multipartPolicyName;
    },
  });
  var d1 = H1();
  Object.defineProperty(gA, "proxyPolicy", {
    enumerable: !0,
    get: function () {
      return d1.proxyPolicy;
    },
  });
  Object.defineProperty(gA, "proxyPolicyName", {
    enumerable: !0,
    get: function () {
      return d1.proxyPolicyName;
    },
  });
  Object.defineProperty(gA, "getDefaultProxySettings", {
    enumerable: !0,
    get: function () {
      return d1.getDefaultProxySettings;
    },
  });
  var BO = g1();
  Object.defineProperty(gA, "redirectPolicy", {
    enumerable: !0,
    get: function () {
      return BO.redirectPolicy;
    },
  });
  Object.defineProperty(gA, "redirectPolicyName", {
    enumerable: !0,
    get: function () {
      return BO.redirectPolicyName;
    },
  });
  var IO = hT();
  Object.defineProperty(gA, "systemErrorRetryPolicy", {
    enumerable: !0,
    get: function () {
      return IO.systemErrorRetryPolicy;
    },
  });
  Object.defineProperty(gA, "systemErrorRetryPolicyName", {
    enumerable: !0,
    get: function () {
      return IO.systemErrorRetryPolicyName;
    },
  });
  var EO = PT();
  Object.defineProperty(gA, "throttlingRetryPolicy", {
    enumerable: !0,
    get: function () {
      return EO.throttlingRetryPolicy;
    },
  });
  Object.defineProperty(gA, "throttlingRetryPolicyName", {
    enumerable: !0,
    get: function () {
      return EO.throttlingRetryPolicyName;
    },
  });
  var LYA = yT();
  Object.defineProperty(gA, "retryPolicy", {
    enumerable: !0,
    get: function () {
      return LYA.retryPolicy;
    },
  });
  var CO = v1();
  Object.defineProperty(gA, "tracingPolicy", {
    enumerable: !0,
    get: function () {
      return CO.tracingPolicy;
    },
  });
  Object.defineProperty(gA, "tracingPolicyName", {
    enumerable: !0,
    get: function () {
      return CO.tracingPolicyName;
    },
  });
  var RYA = R1();
  Object.defineProperty(gA, "defaultRetryPolicy", {
    enumerable: !0,
    get: function () {
      return RYA.defaultRetryPolicy;
    },
  });
  var gO = N1();
  Object.defineProperty(gA, "userAgentPolicy", {
    enumerable: !0,
    get: function () {
      return gO.userAgentPolicy;
    },
  });
  Object.defineProperty(gA, "userAgentPolicyName", {
    enumerable: !0,
    get: function () {
      return gO.userAgentPolicyName;
    },
  });
  var FO = O1();
  Object.defineProperty(gA, "tlsPolicy", {
    enumerable: !0,
    get: function () {
      return FO.tlsPolicy;
    },
  });
  Object.defineProperty(gA, "tlsPolicyName", {
    enumerable: !0,
    get: function () {
      return FO.tlsPolicyName;
    },
  });
  var DO = V1();
  Object.defineProperty(gA, "formDataPolicy", {
    enumerable: !0,
    get: function () {
      return DO.formDataPolicy;
    },
  });
  Object.defineProperty(gA, "formDataPolicyName", {
    enumerable: !0,
    get: function () {
      return DO.formDataPolicyName;
    },
  });
  var YO = lT();
  Object.defineProperty(gA, "bearerTokenAuthenticationPolicy", {
    enumerable: !0,
    get: function () {
      return YO.bearerTokenAuthenticationPolicy;
    },
  });
  Object.defineProperty(gA, "bearerTokenAuthenticationPolicyName", {
    enumerable: !0,
    get: function () {
      return YO.bearerTokenAuthenticationPolicyName;
    },
  });
  var JO = iT();
  Object.defineProperty(gA, "ndJsonPolicy", {
    enumerable: !0,
    get: function () {
      return JO.ndJsonPolicy;
    },
  });
  Object.defineProperty(gA, "ndJsonPolicyName", {
    enumerable: !0,
    get: function () {
      return JO.ndJsonPolicyName;
    },
  });
  var NO = oT();
  Object.defineProperty(gA, "auxiliaryAuthenticationHeaderPolicy", {
    enumerable: !0,
    get: function () {
      return NO.auxiliaryAuthenticationHeaderPolicy;
    },
  });
  Object.defineProperty(gA, "auxiliaryAuthenticationHeaderPolicyName", {
    enumerable: !0,
    get: function () {
      return NO.auxiliaryAuthenticationHeaderPolicyName;
    },
  });
  var GO = T1();
  Object.defineProperty(gA, "agentPolicy", {
    enumerable: !0,
    get: function () {
      return GO.agentPolicy;
    },
  });
  Object.defineProperty(gA, "agentPolicyName", {
    enumerable: !0,
    get: function () {
      return GO.agentPolicyName;
    },
  });
  var UO = X1();
  Object.defineProperty(gA, "createFile", {
    enumerable: !0,
    get: function () {
      return UO.createFile;
    },
  });
  Object.defineProperty(gA, "createFileFromStream", {
    enumerable: !0,
    get: function () {
      return UO.createFileFromStream;
    },
  });
});
var wO = Z((ZO) => {
  Object.defineProperty(ZO, "__esModule", { value: !0 });
  ZO.AzureKeyCredential = void 0;
  class WO {
    _key;
    get key() {
      return this._key;
    }
    constructor(A) {
      if (!A) throw Error("key must be a non-empty string");
      this._key = A;
    }
    update(A) {
      this._key = A;
    }
  }
  ZO.AzureKeyCredential = WO;
});
var LO = Z((MO) => {
  Object.defineProperty(MO, "__esModule", { value: !0 });
  MO.isKeyCredential = HYA;
  var $YA = lA();
  function HYA(A) {
    return (
      (0, $YA.isObjectWithProperties)(A, ["key"]) && typeof A.key === "string"
    );
  }
});
var HO = Z((VO) => {
  Object.defineProperty(VO, "__esModule", { value: !0 });
  VO.AzureNamedKeyCredential = void 0;
  VO.isNamedKeyCredential = TYA;
  var zYA = lA();
  class RO {
    _key;
    _name;
    get key() {
      return this._key;
    }
    get name() {
      return this._name;
    }
    constructor(A, Q) {
      if (!A || !Q) throw TypeError("name and key must be non-empty strings");
      (this._name = A), (this._key = Q);
    }
    update(A, Q) {
      if (!A || !Q)
        throw TypeError("newName and newKey must be non-empty strings");
      (this._name = A), (this._key = Q);
    }
  }
  VO.AzureNamedKeyCredential = RO;
  function TYA(A) {
    return (
      (0, zYA.isObjectWithProperties)(A, ["name", "key"]) &&
      typeof A.key === "string" &&
      typeof A.name === "string"
    );
  }
});
var OO = Z((zO) => {
  Object.defineProperty(zO, "__esModule", { value: !0 });
  zO.AzureSASCredential = void 0;
  zO.isSASCredential = jYA;
  var qYA = lA();
  class KO {
    _signature;
    get signature() {
      return this._signature;
    }
    constructor(A) {
      if (!A) throw Error("shared access signature must be a non-empty string");
      this._signature = A;
    }
    update(A) {
      if (!A) throw Error("shared access signature must be a non-empty string");
      this._signature = A;
    }
  }
  zO.AzureSASCredential = KO;
  function jYA(A) {
    return (
      (0, qYA.isObjectWithProperties)(A, ["signature"]) &&
      typeof A.signature === "string"
    );
  }
});
var jO = Z((qO) => {
  Object.defineProperty(qO, "__esModule", { value: !0 });
  qO.isBearerToken = hYA;
  qO.isPopToken = kYA;
  qO.isTokenCredential = xYA;
  function hYA(A) {
    return !A.tokenType || A.tokenType === "Bearer";
  }
  function kYA(A) {
    return A.tokenType === "pop";
  }
  function xYA(A) {
    let Q = A;
    return (
      Q &&
      typeof Q.getToken === "function" &&
      (Q.signRequest === void 0 || Q.getToken.length > 0)
    );
  }
});
var Rg = Z((VE) => {
  Object.defineProperty(VE, "__esModule", { value: !0 });
  VE.isTokenCredential =
    VE.isSASCredential =
    VE.AzureSASCredential =
    VE.isNamedKeyCredential =
    VE.AzureNamedKeyCredential =
    VE.isKeyCredential =
    VE.AzureKeyCredential =
      void 0;
  var yYA = wO();
  Object.defineProperty(VE, "AzureKeyCredential", {
    enumerable: !0,
    get: function () {
      return yYA.AzureKeyCredential;
    },
  });
  var SYA = LO();
  Object.defineProperty(VE, "isKeyCredential", {
    enumerable: !0,
    get: function () {
      return SYA.isKeyCredential;
    },
  });
  var fO = HO();
  Object.defineProperty(VE, "AzureNamedKeyCredential", {
    enumerable: !0,
    get: function () {
      return fO.AzureNamedKeyCredential;
    },
  });
  Object.defineProperty(VE, "isNamedKeyCredential", {
    enumerable: !0,
    get: function () {
      return fO.isNamedKeyCredential;
    },
  });
  var hO = OO();
  Object.defineProperty(VE, "AzureSASCredential", {
    enumerable: !0,
    get: function () {
      return hO.AzureSASCredential;
    },
  });
  Object.defineProperty(VE, "isSASCredential", {
    enumerable: !0,
    get: function () {
      return hO.isSASCredential;
    },
  });
  var bYA = jO();
  Object.defineProperty(VE, "isTokenCredential", {
    enumerable: !0,
    get: function () {
      return bYA.isTokenCredential;
    },
  });
});
var c1 = Z((kO) => {
  Object.defineProperty(kO, "__esModule", { value: !0 });
  kO.disableKeepAlivePolicyName = void 0;
  kO.createDisableKeepAlivePolicy = dYA;
  kO.pipelineContainsDisableKeepAlivePolicy = cYA;
  kO.disableKeepAlivePolicyName = "DisableKeepAlivePolicy";
  function dYA() {
    return {
      name: kO.disableKeepAlivePolicyName,
      async sendRequest(A, Q) {
        return (A.disableKeepAlive = !0), Q(A);
      },
    };
  }
  function cYA(A) {
    return A.getOrderedPolicies().some(
      (Q) => Q.name === kO.disableKeepAlivePolicyName,
    );
  }
});
var u1 = Z((xO) => {
  Object.defineProperty(xO, "__esModule", { value: !0 });
  xO.encodeString = pYA;
  xO.encodeByteArray = iYA;
  xO.decodeString = nYA;
  xO.decodeStringToString = aYA;
  function pYA(A) {
    return Buffer.from(A).toString("base64");
  }
  function iYA(A) {
    return (A instanceof Buffer ? A : Buffer.from(A.buffer)).toString("base64");
  }
  function nYA(A) {
    return Buffer.from(A, "base64");
  }
  function aYA(A) {
    return Buffer.from(A, "base64").toString();
  }
});
var ID = Z((vO) => {
  Object.defineProperty(vO, "__esModule", { value: !0 });
  vO.XML_CHARKEY = vO.XML_ATTRKEY = void 0;
  vO.XML_ATTRKEY = "$";
  vO.XML_CHARKEY = "_";
});
var l1 = Z((yO) => {
  Object.defineProperty(yO, "__esModule", { value: !0 });
  yO.isPrimitiveBody = _O;
  yO.isDuration = QJA;
  yO.isValidUuid = IJA;
  yO.flattenResponse = CJA;
  function _O(A, Q) {
    return (
      Q !== "Composite" &&
      Q !== "Dictionary" &&
      (typeof A === "string" ||
        typeof A === "number" ||
        typeof A === "boolean" ||
        Q?.match(
          /^(Date|DateTime|DateTimeRfc1123|UnixTime|ByteArray|Base64Url)$/i,
        ) !== null ||
        A === void 0 ||
        A === null)
    );
  }
  var AJA =
    /^(-|\+)?P(?:([-+]?[0-9,.]*)Y)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)W)?(?:([-+]?[0-9,.]*)D)?(?:T(?:([-+]?[0-9,.]*)H)?(?:([-+]?[0-9,.]*)M)?(?:([-+]?[0-9,.]*)S)?)?$/;
  function QJA(A) {
    return AJA.test(A);
  }
  var BJA =
    /^[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$/i;
  function IJA(A) {
    return BJA.test(A);
  }
  function EJA(A) {
    let Q = { ...A.headers, ...A.body };
    if (A.hasNullableType && Object.getOwnPropertyNames(Q).length === 0)
      return A.shouldWrapBody ? { body: null } : null;
    else return A.shouldWrapBody ? { ...A.headers, body: A.body } : Q;
  }
  function CJA(A, Q) {
    let B = A.parsedHeaders;
    if (A.request.method === "HEAD") return { ...B, body: A.parsedBody };
    let I = Q && Q.bodyMapper,
      E = Boolean(I?.nullable),
      C = I?.type.name;
    if (C === "Stream")
      return {
        ...B,
        blobBody: A.blobBody,
        readableStreamBody: A.readableStreamBody,
      };
    let g = (C === "Composite" && I.type.modelProperties) || {},
      F = Object.keys(g).some((D) => g[D].serializedName === "");
    if (C === "Sequence" || F) {
      let D = A.parsedBody ?? [];
      for (let J of Object.keys(g))
        if (g[J].serializedName) D[J] = A.parsedBody?.[J];
      if (B) for (let J of Object.keys(B)) D[J] = B[J];
      return E &&
        !A.parsedBody &&
        !B &&
        Object.getOwnPropertyNames(g).length === 0
        ? null
        : D;
    }
    return EJA({
      body: A.parsedBody,
      headers: B,
      hasNullableType: E,
      shouldWrapBody: _O(A.parsedBody, C),
    });
  }
});
var ED = Z((pO) => {
  Object.defineProperty(pO, "__esModule", { value: !0 });
  pO.MapperTypeNames = void 0;
  pO.createSerializer = NJA;
  var JJA = BQ(),
    DN = JJA.__importStar(u1()),
    _Q = ID(),
    bO = l1();
  class mO {
    modelMappers;
    isXML;
    constructor(A = {}, Q = !1) {
      (this.modelMappers = A), (this.isXML = Q);
    }
    validateConstraints(A, Q, B) {
      let I = (E, C) => {
        throw Error(
          `"${B}" with value "${Q}" should satisfy the constraint "${E}": ${C}.`,
        );
      };
      if (A.constraints && Q !== void 0 && Q !== null) {
        let {
          ExclusiveMaximum: E,
          ExclusiveMinimum: C,
          InclusiveMaximum: g,
          InclusiveMinimum: F,
          MaxItems: D,
          MaxLength: J,
          MinItems: Y,
          MinLength: N,
          MultipleOf: W,
          Pattern: X,
          UniqueItems: M,
        } = A.constraints;
        if (E !== void 0 && Q >= E) I("ExclusiveMaximum", E);
        if (C !== void 0 && Q <= C) I("ExclusiveMinimum", C);
        if (g !== void 0 && Q > g) I("InclusiveMaximum", g);
        if (F !== void 0 && Q < F) I("InclusiveMinimum", F);
        if (D !== void 0 && Q.length > D) I("MaxItems", D);
        if (J !== void 0 && Q.length > J) I("MaxLength", J);
        if (Y !== void 0 && Q.length < Y) I("MinItems", Y);
        if (N !== void 0 && Q.length < N) I("MinLength", N);
        if (W !== void 0 && Q % W !== 0) I("MultipleOf", W);
        if (X) {
          let L = typeof X === "string" ? new RegExp(X) : X;
          if (typeof Q !== "string" || Q.match(L) === null) I("Pattern", X);
        }
        if (M && Q.some((L, H, q) => q.indexOf(L) !== H)) I("UniqueItems", M);
      }
    }
    serialize(A, Q, B, I = { xml: {} }) {
      let E = {
          xml: {
            rootName: I.xml.rootName ?? "",
            includeRoot: I.xml.includeRoot ?? !1,
            xmlCharKey: I.xml.xmlCharKey ?? _Q.XML_CHARKEY,
          },
        },
        C = {},
        g = A.type.name;
      if (!B) B = A.serializedName;
      if (g.match(/^Sequence$/i) !== null) C = [];
      if (A.isConstant) Q = A.defaultValue;
      let { required: F, nullable: D } = A;
      if (F && D && Q === void 0) throw Error(`${B} cannot be undefined.`);
      if (F && !D && (Q === void 0 || Q === null))
        throw Error(`${B} cannot be null or undefined.`);
      if (!F && D === !1 && Q === null) throw Error(`${B} cannot be null.`);
      if (Q === void 0 || Q === null) C = Q;
      else if (g.match(/^any$/i) !== null) C = Q;
      else if (
        g.match(/^(Number|String|Boolean|Object|Stream|Uuid)$/i) !== null
      )
        C = wJA(g, B, Q);
      else if (g.match(/^Enum$/i) !== null) C = MJA(B, A.type.allowedValues, Q);
      else if (
        g.match(/^(Date|DateTime|TimeSpan|DateTimeRfc1123|UnixTime)$/i) !== null
      )
        C = VJA(g, Q, B);
      else if (g.match(/^ByteArray$/i) !== null) C = LJA(B, Q);
      else if (g.match(/^Base64Url$/i) !== null) C = RJA(B, Q);
      else if (g.match(/^Sequence$/i) !== null)
        C = $JA(this, A, Q, B, Boolean(this.isXML), E);
      else if (g.match(/^Dictionary$/i) !== null)
        C = HJA(this, A, Q, B, Boolean(this.isXML), E);
      else if (g.match(/^Composite$/i) !== null)
        C = zJA(this, A, Q, B, Boolean(this.isXML), E);
      return C;
    }
    deserialize(A, Q, B, I = { xml: {} }) {
      let E = {
        xml: {
          rootName: I.xml.rootName ?? "",
          includeRoot: I.xml.includeRoot ?? !1,
          xmlCharKey: I.xml.xmlCharKey ?? _Q.XML_CHARKEY,
        },
        ignoreUnknownProperties: I.ignoreUnknownProperties ?? !1,
      };
      if (Q === void 0 || Q === null) {
        if (this.isXML && A.type.name === "Sequence" && !A.xmlIsWrapped) Q = [];
        if (A.defaultValue !== void 0) Q = A.defaultValue;
        return Q;
      }
      let C,
        g = A.type.name;
      if (!B) B = A.serializedName;
      if (g.match(/^Composite$/i) !== null) C = OJA(this, A, Q, B, E);
      else {
        if (this.isXML) {
          let F = E.xml.xmlCharKey;
          if (Q[_Q.XML_ATTRKEY] !== void 0 && Q[F] !== void 0) Q = Q[F];
        }
        if (g.match(/^Number$/i) !== null) {
          if (((C = parseFloat(Q)), isNaN(C))) C = Q;
        } else if (g.match(/^Boolean$/i) !== null)
          if (Q === "true") C = !0;
          else if (Q === "false") C = !1;
          else C = Q;
        else if (
          g.match(/^(String|Enum|Object|Stream|Uuid|TimeSpan|any)$/i) !== null
        )
          C = Q;
        else if (g.match(/^(Date|DateTime|DateTimeRfc1123)$/i) !== null)
          C = new Date(Q);
        else if (g.match(/^UnixTime$/i) !== null) C = XJA(Q);
        else if (g.match(/^ByteArray$/i) !== null) C = DN.decodeString(Q);
        else if (g.match(/^Base64Url$/i) !== null) C = WJA(Q);
        else if (g.match(/^Sequence$/i) !== null) C = jJA(this, A, Q, B, E);
        else if (g.match(/^Dictionary$/i) !== null) C = qJA(this, A, Q, B, E);
      }
      if (A.isConstant) C = A.defaultValue;
      return C;
    }
  }
  function NJA(A = {}, Q = !1) {
    return new mO(A, Q);
  }
  function GJA(A, Q) {
    let B = A.length;
    while (B - 1 >= 0 && A[B - 1] === Q) --B;
    return A.substr(0, B);
  }
  function UJA(A) {
    if (!A) return;
    if (!(A instanceof Uint8Array))
      throw Error(
        "Please provide an input of type Uint8Array for converting to Base64Url.",
      );
    let Q = DN.encodeByteArray(A);
    return GJA(Q, "=").replace(/\+/g, "-").replace(/\//g, "_");
  }
  function WJA(A) {
    if (!A) return;
    if (A && typeof A.valueOf() !== "string")
      throw Error(
        "Please provide an input of type string for converting to Uint8Array",
      );
    return (A = A.replace(/-/g, "+").replace(/_/g, "/")), DN.decodeString(A);
  }
  function p1(A) {
    let Q = [],
      B = "";
    if (A) {
      let I = A.split(".");
      for (let E of I)
        if (E.charAt(E.length - 1) === "\\")
          B += E.substr(0, E.length - 1) + ".";
        else (B += E), Q.push(B), (B = "");
    }
    return Q;
  }
  function ZJA(A) {
    if (!A) return;
    if (typeof A.valueOf() === "string") A = new Date(A);
    return Math.floor(A.getTime() / 1000);
  }
  function XJA(A) {
    if (!A) return;
    return new Date(A * 1000);
  }
  function wJA(A, Q, B) {
    if (B !== null && B !== void 0) {
      if (A.match(/^Number$/i) !== null) {
        if (typeof B !== "number")
          throw Error(`${Q} with value ${B} must be of type number.`);
      } else if (A.match(/^String$/i) !== null) {
        if (typeof B.valueOf() !== "string")
          throw Error(`${Q} with value "${B}" must be of type string.`);
      } else if (A.match(/^Uuid$/i) !== null) {
        if (!(typeof B.valueOf() === "string" && (0, bO.isValidUuid)(B)))
          throw Error(
            `${Q} with value "${B}" must be of type string and a valid uuid.`,
          );
      } else if (A.match(/^Boolean$/i) !== null) {
        if (typeof B !== "boolean")
          throw Error(`${Q} with value ${B} must be of type boolean.`);
      } else if (A.match(/^Stream$/i) !== null) {
        let I = typeof B;
        if (
          I !== "string" &&
          typeof B.pipe !== "function" &&
          typeof B.tee !== "function" &&
          !(B instanceof ArrayBuffer) &&
          !ArrayBuffer.isView(B) &&
          !(
            (typeof Blob === "function" || typeof Blob === "object") &&
            B instanceof Blob
          ) &&
          I !== "function"
        )
          throw Error(
            `${Q} must be a string, Blob, ArrayBuffer, ArrayBufferView, ReadableStream, or () => ReadableStream.`,
          );
      }
    }
    return B;
  }
  function MJA(A, Q, B) {
    if (!Q)
      throw Error(
        `Please provide a set of allowedValues to validate ${A} as an Enum Type.`,
      );
    if (
      !Q.some((E) => {
        if (typeof E.valueOf() === "string")
          return E.toLowerCase() === B.toLowerCase();
        return E === B;
      })
    )
      throw Error(
        `${B} is not a valid value for ${A}. The valid values are: ${JSON.stringify(Q)}.`,
      );
    return B;
  }
  function LJA(A, Q) {
    if (Q !== void 0 && Q !== null) {
      if (!(Q instanceof Uint8Array))
        throw Error(`${A} must be of type Uint8Array.`);
      Q = DN.encodeByteArray(Q);
    }
    return Q;
  }
  function RJA(A, Q) {
    if (Q !== void 0 && Q !== null) {
      if (!(Q instanceof Uint8Array))
        throw Error(`${A} must be of type Uint8Array.`);
      Q = UJA(Q);
    }
    return Q;
  }
  function VJA(A, Q, B) {
    if (Q !== void 0 && Q !== null) {
      if (A.match(/^Date$/i) !== null) {
        if (
          !(
            Q instanceof Date ||
            (typeof Q.valueOf() === "string" && !isNaN(Date.parse(Q)))
          )
        )
          throw Error(
            `${B} must be an instanceof Date or a string in ISO8601 format.`,
          );
        Q =
          Q instanceof Date
            ? Q.toISOString().substring(0, 10)
            : new Date(Q).toISOString().substring(0, 10);
      } else if (A.match(/^DateTime$/i) !== null) {
        if (
          !(
            Q instanceof Date ||
            (typeof Q.valueOf() === "string" && !isNaN(Date.parse(Q)))
          )
        )
          throw Error(
            `${B} must be an instanceof Date or a string in ISO8601 format.`,
          );
        Q = Q instanceof Date ? Q.toISOString() : new Date(Q).toISOString();
      } else if (A.match(/^DateTimeRfc1123$/i) !== null) {
        if (
          !(
            Q instanceof Date ||
            (typeof Q.valueOf() === "string" && !isNaN(Date.parse(Q)))
          )
        )
          throw Error(
            `${B} must be an instanceof Date or a string in RFC-1123 format.`,
          );
        Q = Q instanceof Date ? Q.toUTCString() : new Date(Q).toUTCString();
      } else if (A.match(/^UnixTime$/i) !== null) {
        if (
          !(
            Q instanceof Date ||
            (typeof Q.valueOf() === "string" && !isNaN(Date.parse(Q)))
          )
        )
          throw Error(
            `${B} must be an instanceof Date or a string in RFC-1123/ISO8601 format for it to be serialized in UnixTime/Epoch format.`,
          );
        Q = ZJA(Q);
      } else if (A.match(/^TimeSpan$/i) !== null) {
        if (!(0, bO.isDuration)(Q))
          throw Error(
            `${B} must be a string in ISO 8601 format. Instead was "${Q}".`,
          );
      }
    }
    return Q;
  }
  function $JA(A, Q, B, I, E, C) {
    if (!Array.isArray(B)) throw Error(`${I} must be of type Array.`);
    let g = Q.type.element;
    if (!g || typeof g !== "object")
      throw Error(
        `element" metadata for an Array must be defined in the mapper and it must of type "object" in ${I}.`,
      );
    if (g.type.name === "Composite" && g.type.className)
      g = A.modelMappers[g.type.className] ?? g;
    let F = [];
    for (let D = 0; D < B.length; D++) {
      let J = A.serialize(g, B[D], I, C);
      if (E && g.xmlNamespace) {
        let Y = g.xmlNamespacePrefix
          ? `xmlns:${g.xmlNamespacePrefix}`
          : "xmlns";
        if (g.type.name === "Composite")
          (F[D] = { ...J }), (F[D][_Q.XML_ATTRKEY] = { [Y]: g.xmlNamespace });
        else
          (F[D] = {}),
            (F[D][C.xml.xmlCharKey] = J),
            (F[D][_Q.XML_ATTRKEY] = { [Y]: g.xmlNamespace });
      } else F[D] = J;
    }
    return F;
  }
  function HJA(A, Q, B, I, E, C) {
    if (typeof B !== "object") throw Error(`${I} must be of type object.`);
    let g = Q.type.value;
    if (!g || typeof g !== "object")
      throw Error(
        `"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${I}.`,
      );
    let F = {};
    for (let D of Object.keys(B)) {
      let J = A.serialize(g, B[D], I, C);
      F[D] = uO(g, J, E, C);
    }
    if (E && Q.xmlNamespace) {
      let D = Q.xmlNamespacePrefix ? `xmlns:${Q.xmlNamespacePrefix}` : "xmlns",
        J = F;
      return (J[_Q.XML_ATTRKEY] = { [D]: Q.xmlNamespace }), J;
    }
    return F;
  }
  function KJA(A, Q, B) {
    let I = Q.type.additionalProperties;
    if (!I && Q.type.className) return dO(A, Q, B)?.type.additionalProperties;
    return I;
  }
  function dO(A, Q, B) {
    let I = Q.type.className;
    if (!I)
      throw Error(
        `Class name for model "${B}" is not provided in the mapper "${JSON.stringify(Q, void 0, 2)}".`,
      );
    return A.modelMappers[I];
  }
  function cO(A, Q, B) {
    let I = Q.type.modelProperties;
    if (!I) {
      let E = dO(A, Q, B);
      if (!E)
        throw Error(
          `mapper() cannot be null or undefined for model "${Q.type.className}".`,
        );
      if (((I = E?.type.modelProperties), !I))
        throw Error(
          `modelProperties cannot be null or undefined in the mapper "${JSON.stringify(E)}" of type "${Q.type.className}" for object "${B}".`,
        );
    }
    return I;
  }
  function zJA(A, Q, B, I, E, C) {
    if (FN(A, Q)) Q = lO(A, Q, B, "clientName");
    if (B !== void 0 && B !== null) {
      let g = {},
        F = cO(A, Q, I);
      for (let J of Object.keys(F)) {
        let Y = F[J];
        if (Y.readOnly) continue;
        let N,
          W = g;
        if (A.isXML)
          if (Y.xmlIsWrapped) N = Y.xmlName;
          else N = Y.xmlElementName || Y.xmlName;
        else {
          let X = p1(Y.serializedName);
          N = X.pop();
          for (let M of X) {
            let L = W[M];
            if (
              (L === void 0 || L === null) &&
              ((B[J] !== void 0 && B[J] !== null) || Y.defaultValue !== void 0)
            )
              W[M] = {};
            W = W[M];
          }
        }
        if (W !== void 0 && W !== null) {
          if (E && Q.xmlNamespace) {
            let q = Q.xmlNamespacePrefix
              ? `xmlns:${Q.xmlNamespacePrefix}`
              : "xmlns";
            W[_Q.XML_ATTRKEY] = { ...W[_Q.XML_ATTRKEY], [q]: Q.xmlNamespace };
          }
          let X = Y.serializedName !== "" ? I + "." + Y.serializedName : I,
            M = B[J],
            L = FN(A, Q);
          if (L && L.clientName === J && (M === void 0 || M === null))
            M = Q.serializedName;
          let H = A.serialize(Y, M, X, C);
          if (H !== void 0 && N !== void 0 && N !== null) {
            let q = uO(Y, H, E, C);
            if (E && Y.xmlIsAttribute)
              (W[_Q.XML_ATTRKEY] = W[_Q.XML_ATTRKEY] || {}),
                (W[_Q.XML_ATTRKEY][N] = H);
            else if (E && Y.xmlIsWrapped) W[N] = { [Y.xmlElementName]: q };
            else W[N] = q;
          }
        }
      }
      let D = KJA(A, Q, I);
      if (D) {
        let J = Object.keys(F);
        for (let Y in B)
          if (J.every((W) => W !== Y))
            g[Y] = A.serialize(D, B[Y], I + '["' + Y + '"]', C);
      }
      return g;
    }
    return B;
  }
  function uO(A, Q, B, I) {
    if (!B || !A.xmlNamespace) return Q;
    let C = {
      [A.xmlNamespacePrefix ? `xmlns:${A.xmlNamespacePrefix}` : "xmlns"]:
        A.xmlNamespace,
    };
    if (["Composite"].includes(A.type.name))
      if (Q[_Q.XML_ATTRKEY]) return Q;
      else {
        let F = { ...Q };
        return (F[_Q.XML_ATTRKEY] = C), F;
      }
    let g = {};
    return (g[I.xml.xmlCharKey] = Q), (g[_Q.XML_ATTRKEY] = C), g;
  }
  function TJA(A, Q) {
    return [_Q.XML_ATTRKEY, Q.xml.xmlCharKey].includes(A);
  }
  function OJA(A, Q, B, I, E) {
    let C = E.xml.xmlCharKey ?? _Q.XML_CHARKEY;
    if (FN(A, Q)) Q = lO(A, Q, B, "serializedName");
    let g = cO(A, Q, I),
      F = {},
      D = [];
    for (let Y of Object.keys(g)) {
      let N = g[Y],
        W = p1(g[Y].serializedName);
      D.push(W[0]);
      let { serializedName: X, xmlName: M, xmlElementName: L } = N,
        H = I;
      if (X !== "" && X !== void 0) H = I + "." + X;
      let q = N.headerCollectionPrefix;
      if (q) {
        let O = {};
        for (let f of Object.keys(B)) {
          if (f.startsWith(q))
            O[f.substring(q.length)] = A.deserialize(N.type.value, B[f], H, E);
          D.push(f);
        }
        F[Y] = O;
      } else if (A.isXML)
        if (N.xmlIsAttribute && B[_Q.XML_ATTRKEY])
          F[Y] = A.deserialize(N, B[_Q.XML_ATTRKEY][M], H, E);
        else if (N.xmlIsMsText) {
          if (B[C] !== void 0) F[Y] = B[C];
          else if (typeof B === "string") F[Y] = B;
        } else {
          let O = L || M || X;
          if (N.xmlIsWrapped) {
            let S = B[M]?.[L] ?? [];
            (F[Y] = A.deserialize(N, S, H, E)), D.push(M);
          } else {
            let f = B[O];
            (F[Y] = A.deserialize(N, f, H, E)), D.push(O);
          }
        }
      else {
        let O,
          f = B,
          S = 0;
        for (let IA of W) {
          if (!f) break;
          S++, (f = f[IA]);
        }
        if (f === null && S < W.length) f = void 0;
        O = f;
        let r = Q.type.polymorphicDiscriminator;
        if (r && Y === r.clientName && (O === void 0 || O === null))
          O = Q.serializedName;
        let t;
        if (Array.isArray(B[Y]) && g[Y].serializedName === "") {
          O = B[Y];
          let IA = A.deserialize(N, O, H, E);
          for (let [zA, DA] of Object.entries(F))
            if (!Object.prototype.hasOwnProperty.call(IA, zA)) IA[zA] = DA;
          F = IA;
        } else if (O !== void 0 || N.defaultValue !== void 0)
          (t = A.deserialize(N, O, H, E)), (F[Y] = t);
      }
    }
    let J = Q.type.additionalProperties;
    if (J) {
      let Y = (N) => {
        for (let W in g) if (p1(g[W].serializedName)[0] === N) return !1;
        return !0;
      };
      for (let N in B)
        if (Y(N)) F[N] = A.deserialize(J, B[N], I + '["' + N + '"]', E);
    } else if (B && !E.ignoreUnknownProperties) {
      for (let Y of Object.keys(B))
        if (F[Y] === void 0 && !D.includes(Y) && !TJA(Y, E)) F[Y] = B[Y];
    }
    return F;
  }
  function qJA(A, Q, B, I, E) {
    let C = Q.type.value;
    if (!C || typeof C !== "object")
      throw Error(
        `"value" metadata for a Dictionary must be defined in the mapper and it must of type "object" in ${I}`,
      );
    if (B) {
      let g = {};
      for (let F of Object.keys(B)) g[F] = A.deserialize(C, B[F], I, E);
      return g;
    }
    return B;
  }
  function jJA(A, Q, B, I, E) {
    let C = Q.type.element;
    if (!C || typeof C !== "object")
      throw Error(
        `element" metadata for an Array must be defined in the mapper and it must of type "object" in ${I}`,
      );
    if (B) {
      if (!Array.isArray(B)) B = [B];
      if (C.type.name === "Composite" && C.type.className)
        C = A.modelMappers[C.type.className] ?? C;
      let g = [];
      for (let F = 0; F < B.length; F++)
        g[F] = A.deserialize(C, B[F], `${I}[${F}]`, E);
      return g;
    }
    return B;
  }
  function fJA(A, Q, B) {
    let I = [B];
    while (I.length) {
      let E = I.shift(),
        C = Q === E ? Q : E + "." + Q;
      if (Object.prototype.hasOwnProperty.call(A, C)) return A[C];
      else
        for (let [g, F] of Object.entries(A))
          if (
            g.startsWith(E + ".") &&
            F.type.uberParent === E &&
            F.type.className
          )
            I.push(F.type.className);
    }
    return;
  }
  function lO(A, Q, B, I) {
    let E = FN(A, Q);
    if (E) {
      let C = E[I];
      if (C) {
        if (I === "serializedName") C = C.replace(/\\/gi, "");
        let g = B[C],
          F = Q.type.uberParent ?? Q.type.className;
        if (typeof g === "string" && F) {
          let D = fJA(A.modelMappers.discriminators, g, F);
          if (D) Q = D;
        }
      }
    }
    return Q;
  }
  function FN(A, Q) {
    return (
      Q.type.polymorphicDiscriminator ||
      SO(A, Q.type.uberParent) ||
      SO(A, Q.type.className)
    );
  }
  function SO(A, Q) {
    return (
      Q && A.modelMappers[Q] && A.modelMappers[Q].type.polymorphicDiscriminator
    );
  }
  pO.MapperTypeNames = {
    Base64Url: "Base64Url",
    Boolean: "Boolean",
    ByteArray: "ByteArray",
    Composite: "Composite",
    Date: "Date",
    DateTime: "DateTime",
    DateTimeRfc1123: "DateTimeRfc1123",
    Dictionary: "Dictionary",
    Enum: "Enum",
    Number: "Number",
    Object: "Object",
    Sequence: "Sequence",
    String: "String",
    Stream: "Stream",
    TimeSpan: "TimeSpan",
    UnixTime: "UnixTime",
  };
});
var oO = Z((nO) => {
  Object.defineProperty(nO, "__esModule", { value: !0 });
  nO.state = void 0;
  nO.state = { operationRequestMap: new WeakMap() };
});
var CD = Z((Qq) => {
  Object.defineProperty(Qq, "__esModule", { value: !0 });
  Qq.getOperationArgumentValueFromParameter = tO;
  Qq.getOperationRequestInfo = Aq;
  var sO = oO();
  function tO(A, Q, B) {
    let { parameterPath: I, mapper: E } = Q,
      C;
    if (typeof I === "string") I = [I];
    if (Array.isArray(I)) {
      if (I.length > 0)
        if (E.isConstant) C = E.defaultValue;
        else {
          let g = rO(A, I);
          if (!g.propertyFound && B) g = rO(B, I);
          let F = !1;
          if (!g.propertyFound)
            F = E.required || (I[0] === "options" && I.length === 2);
          C = F ? E.defaultValue : g.propertyValue;
        }
    } else {
      if (E.required) C = {};
      for (let g in I) {
        let F = E.type.modelProperties[g],
          D = I[g],
          J = tO(A, { parameterPath: D, mapper: F }, B);
        if (J !== void 0) {
          if (!C) C = {};
          C[g] = J;
        }
      }
    }
    return C;
  }
  function rO(A, Q) {
    let B = { propertyFound: !1 },
      I = 0;
    for (; I < Q.length; ++I) {
      let E = Q[I];
      if (A && E in A) A = A[E];
      else break;
    }
    if (I === Q.length) (B.propertyValue = A), (B.propertyFound = !0);
    return B;
  }
  var eO = Symbol.for("@azure/core-client original request");
  function kJA(A) {
    return eO in A;
  }
  function Aq(A) {
    if (kJA(A)) return Aq(A[eO]);
    let Q = sO.state.operationRequestMap.get(A);
    if (!Q) (Q = {}), sO.state.operationRequestMap.set(A, Q);
    return Q;
  }
});
var a1 = Z((Iq) => {
  Object.defineProperty(Iq, "__esModule", { value: !0 });
  Iq.deserializationPolicyName = void 0;
  Iq.deserializationPolicy = SJA;
  var PJA = ID(),
    YN = HQ(),
    Bq = ED(),
    i1 = CD(),
    _JA = ["application/json", "text/json"],
    yJA = ["application/xml", "application/atom+xml"];
  Iq.deserializationPolicyName = "deserializationPolicy";
  function SJA(A = {}) {
    let Q = A.expectedContentTypes?.json ?? _JA,
      B = A.expectedContentTypes?.xml ?? yJA,
      I = A.parseXML,
      E = A.serializerOptions,
      C = {
        xml: {
          rootName: E?.xml.rootName ?? "",
          includeRoot: E?.xml.includeRoot ?? !1,
          xmlCharKey: E?.xml.xmlCharKey ?? PJA.XML_CHARKEY,
        },
      };
    return {
      name: Iq.deserializationPolicyName,
      async sendRequest(g, F) {
        let D = await F(g);
        return dJA(Q, B, D, C, I);
      },
    };
  }
  function bJA(A) {
    let Q,
      B = A.request,
      I = (0, i1.getOperationRequestInfo)(B),
      E = I?.operationSpec;
    if (E)
      if (!I?.operationResponseGetter) Q = E.responses[A.status];
      else Q = I?.operationResponseGetter(E, A);
    return Q;
  }
  function mJA(A) {
    let Q = A.request,
      I = (0, i1.getOperationRequestInfo)(Q)?.shouldDeserialize,
      E;
    if (I === void 0) E = !0;
    else if (typeof I === "boolean") E = I;
    else E = I(A);
    return E;
  }
  async function dJA(A, Q, B, I, E) {
    let C = await lJA(A, Q, B, I, E);
    if (!mJA(C)) return C;
    let F = (0, i1.getOperationRequestInfo)(C.request)?.operationSpec;
    if (!F || !F.responses) return C;
    let D = bJA(C),
      { error: J, shouldReturnResponse: Y } = uJA(C, F, D, I);
    if (J) throw J;
    else if (Y) return C;
    if (D) {
      if (D.bodyMapper) {
        let N = C.parsedBody;
        if (F.isXML && D.bodyMapper.type.name === Bq.MapperTypeNames.Sequence)
          N = typeof N === "object" ? N[D.bodyMapper.xmlElementName] : [];
        try {
          C.parsedBody = F.serializer.deserialize(
            D.bodyMapper,
            N,
            "operationRes.parsedBody",
            I,
          );
        } catch (W) {
          throw new YN.RestError(
            `Error ${W} occurred in deserializing the responseBody - ${C.bodyAsText}`,
            { statusCode: C.status, request: C.request, response: C },
          );
        }
      } else if (F.httpMethod === "HEAD")
        C.parsedBody = B.status >= 200 && B.status < 300;
      if (D.headersMapper)
        C.parsedHeaders = F.serializer.deserialize(
          D.headersMapper,
          C.headers.toJSON(),
          "operationRes.parsedHeaders",
          { xml: {}, ignoreUnknownProperties: !0 },
        );
    }
    return C;
  }
  function cJA(A) {
    let Q = Object.keys(A.responses);
    return Q.length === 0 || (Q.length === 1 && Q[0] === "default");
  }
  function uJA(A, Q, B, I) {
    let E = 200 <= A.status && A.status < 300;
    if (cJA(Q) ? E : !!B)
      if (B) {
        if (!B.isError) return { error: null, shouldReturnResponse: !1 };
      } else return { error: null, shouldReturnResponse: !1 };
    let g = B ?? Q.responses.default,
      F = A.request.streamResponseStatusCodes?.has(A.status)
        ? `Unexpected status code: ${A.status}`
        : A.bodyAsText,
      D = new YN.RestError(F, {
        statusCode: A.status,
        request: A.request,
        response: A,
      });
    if (!g && !(A.parsedBody?.error?.code && A.parsedBody?.error?.message))
      throw D;
    let J = g?.bodyMapper,
      Y = g?.headersMapper;
    try {
      if (A.parsedBody) {
        let N = A.parsedBody,
          W;
        if (J) {
          let M = N;
          if (Q.isXML && J.type.name === Bq.MapperTypeNames.Sequence) {
            M = [];
            let L = J.xmlElementName;
            if (typeof N === "object" && L) M = N[L];
          }
          W = Q.serializer.deserialize(J, M, "error.response.parsedBody", I);
        }
        let X = N.error || W || N;
        if (((D.code = X.code), X.message)) D.message = X.message;
        if (J) D.response.parsedBody = W;
      }
      if (A.headers && Y)
        D.response.parsedHeaders = Q.serializer.deserialize(
          Y,
          A.headers.toJSON(),
          "operationRes.parsedHeaders",
        );
    } catch (N) {
      D.message = `Error "${N.message}" occurred in deserializing the responseBody - "${A.bodyAsText}" for the default response.`;
    }
    return { error: D, shouldReturnResponse: !1 };
  }
  async function lJA(A, Q, B, I, E) {
    if (!B.request.streamResponseStatusCodes?.has(B.status) && B.bodyAsText) {
      let C = B.bodyAsText,
        g = B.headers.get("Content-Type") || "",
        F = !g ? [] : g.split(";").map((D) => D.toLowerCase());
      try {
        if (F.length === 0 || F.some((D) => A.indexOf(D) !== -1))
          return (B.parsedBody = JSON.parse(C)), B;
        else if (F.some((D) => Q.indexOf(D) !== -1)) {
          if (!E) throw Error("Parsing XML not supported.");
          let D = await E(C, I.xml);
          return (B.parsedBody = D), B;
        }
      } catch (D) {
        let J = `Error "${D}" occurred while parsing the response body - ${B.bodyAsText}.`,
          Y = D.code || YN.RestError.PARSE_ERROR;
        throw new YN.RestError(J, {
          code: Y,
          statusCode: B.status,
          request: B.request,
          response: B,
        });
      }
    }
    return B;
  }
});
var JN = Z((Eq) => {
  Object.defineProperty(Eq, "__esModule", { value: !0 });
  Eq.getStreamingResponseStatusCodes = nJA;
  Eq.getPathStringFromParameter = aJA;
  var iJA = ED();
  function nJA(A) {
    let Q = new Set();
    for (let B in A.responses) {
      let I = A.responses[B];
      if (I.bodyMapper && I.bodyMapper.type.name === iJA.MapperTypeNames.Stream)
        Q.add(Number(B));
    }
    return Q;
  }
  function aJA(A) {
    let { parameterPath: Q, mapper: B } = A,
      I;
    if (typeof Q === "string") I = Q;
    else if (Array.isArray(Q)) I = Q.join(".");
    else I = B.serializedName;
    return I;
  }
});
var t1 = Z((Fq) => {
  Object.defineProperty(Fq, "__esModule", { value: !0 });
  Fq.serializationPolicyName = void 0;
  Fq.serializationPolicy = rJA;
  Fq.serializeHeaders = Cq;
  Fq.serializeRequestBody = gq;
  var s1 = ID(),
    NN = CD(),
    o1 = ED(),
    gD = JN();
  Fq.serializationPolicyName = "serializationPolicy";
  function rJA(A = {}) {
    let Q = A.stringifyXML;
    return {
      name: Fq.serializationPolicyName,
      async sendRequest(B, I) {
        let E = (0, NN.getOperationRequestInfo)(B),
          C = E?.operationSpec,
          g = E?.operationArguments;
        if (C && g) Cq(B, g, C), gq(B, g, C, Q);
        return I(B);
      },
    };
  }
  function Cq(A, Q, B) {
    if (B.headerParameters)
      for (let E of B.headerParameters) {
        let C = (0, NN.getOperationArgumentValueFromParameter)(Q, E);
        if ((C !== null && C !== void 0) || E.mapper.required) {
          C = B.serializer.serialize(
            E.mapper,
            C,
            (0, gD.getPathStringFromParameter)(E),
          );
          let g = E.mapper.headerCollectionPrefix;
          if (g) for (let F of Object.keys(C)) A.headers.set(g + F, C[F]);
          else
            A.headers.set(
              E.mapper.serializedName || (0, gD.getPathStringFromParameter)(E),
              C,
            );
        }
      }
    let I = Q.options?.requestOptions?.customHeaders;
    if (I) for (let E of Object.keys(I)) A.headers.set(E, I[E]);
  }
  function gq(
    A,
    Q,
    B,
    I = function () {
      throw Error("XML serialization unsupported!");
    },
  ) {
    let E = Q.options?.serializerOptions,
      C = {
        xml: {
          rootName: E?.xml.rootName ?? "",
          includeRoot: E?.xml.includeRoot ?? !1,
          xmlCharKey: E?.xml.xmlCharKey ?? s1.XML_CHARKEY,
        },
      },
      g = C.xml.xmlCharKey;
    if (B.requestBody && B.requestBody.mapper) {
      A.body = (0, NN.getOperationArgumentValueFromParameter)(Q, B.requestBody);
      let F = B.requestBody.mapper,
        {
          required: D,
          serializedName: J,
          xmlName: Y,
          xmlElementName: N,
          xmlNamespace: W,
          xmlNamespacePrefix: X,
          nullable: M,
        } = F,
        L = F.type.name;
      try {
        if (
          (A.body !== void 0 && A.body !== null) ||
          (M && A.body === null) ||
          D
        ) {
          let H = (0, gD.getPathStringFromParameter)(B.requestBody);
          A.body = B.serializer.serialize(F, A.body, H, C);
          let q = L === o1.MapperTypeNames.Stream;
          if (B.isXML) {
            let O = X ? `xmlns:${X}` : "xmlns",
              f = tJA(W, O, L, A.body, C);
            if (L === o1.MapperTypeNames.Sequence)
              A.body = I(eJA(f, N || Y || J, O, W), {
                rootName: Y || J,
                xmlCharKey: g,
              });
            else if (!q) A.body = I(f, { rootName: Y || J, xmlCharKey: g });
          } else if (
            L === o1.MapperTypeNames.String &&
            (B.contentType?.match("text/plain") || B.mediaType === "text")
          )
            return;
          else if (!q) A.body = JSON.stringify(A.body);
        }
      } catch (H) {
        throw Error(
          `Error "${H.message}" occurred in serializing the payload - ${JSON.stringify(J, void 0, "  ")}.`,
        );
      }
    } else if (B.formDataParameters && B.formDataParameters.length > 0) {
      A.formData = {};
      for (let F of B.formDataParameters) {
        let D = (0, NN.getOperationArgumentValueFromParameter)(Q, F);
        if (D !== void 0 && D !== null) {
          let J =
            F.mapper.serializedName || (0, gD.getPathStringFromParameter)(F);
          A.formData[J] = B.serializer.serialize(
            F.mapper,
            D,
            (0, gD.getPathStringFromParameter)(F),
            C,
          );
        }
      }
    }
  }
  function tJA(A, Q, B, I, E) {
    if (A && !["Composite", "Sequence", "Dictionary"].includes(B)) {
      let C = {};
      return (C[E.xml.xmlCharKey] = I), (C[s1.XML_ATTRKEY] = { [Q]: A }), C;
    }
    return I;
  }
  function eJA(A, Q, B, I) {
    if (!Array.isArray(A)) A = [A];
    if (!B || !I) return { [Q]: A };
    let E = { [Q]: A };
    return (E[s1.XML_ATTRKEY] = { [B]: I }), E;
  }
});
var e1 = Z((Yq) => {
  Object.defineProperty(Yq, "__esModule", { value: !0 });
  Yq.createClientPipeline = CNA;
  var INA = a1(),
    Dq = HQ(),
    ENA = t1();
  function CNA(A = {}) {
    let Q = (0, Dq.createPipelineFromOptions)(A ?? {});
    if (A.credentialOptions)
      Q.addPolicy(
        (0, Dq.bearerTokenAuthenticationPolicy)({
          credential: A.credentialOptions.credential,
          scopes: A.credentialOptions.credentialScopes,
        }),
      );
    return (
      Q.addPolicy((0, ENA.serializationPolicy)(A.serializationOptions), {
        phase: "Serialize",
      }),
      Q.addPolicy((0, INA.deserializationPolicy)(A.deserializationOptions), {
        phase: "Deserialize",
      }),
      Q
    );
  }
});
var Nq = Z((Jq) => {
  Object.defineProperty(Jq, "__esModule", { value: !0 });
  Jq.getCachedDefaultHttpClient = DNA;
  var FNA = HQ(),
    AX;
  function DNA() {
    if (!AX) AX = (0, FNA.createDefaultHttpClient)();
    return AX;
  }
});
var Xq = Z((Zq) => {
  Object.defineProperty(Zq, "__esModule", { value: !0 });
  Zq.getRequestUrl = NNA;
  Zq.appendQueryParams = Wq;
  var Uq = CD(),
    QX = JN(),
    JNA = { CSV: ",", SSV: " ", Multi: "Multi", TSV: "\t", Pipes: "|" };
  function NNA(A, Q, B, I) {
    let E = GNA(Q, B, I),
      C = !1,
      g = Gq(A, E);
    if (Q.path) {
      let J = Gq(Q.path, E);
      if (Q.path === "/{nextLink}" && J.startsWith("/")) J = J.substring(1);
      if (UNA(J)) (g = J), (C = !0);
      else g = WNA(g, J);
    }
    let { queryParams: F, sequenceParams: D } = ZNA(Q, B, I);
    return (g = Wq(g, F, D, C)), g;
  }
  function Gq(A, Q) {
    let B = A;
    for (let [I, E] of Q) B = B.split(I).join(E);
    return B;
  }
  function GNA(A, Q, B) {
    let I = new Map();
    if (A.urlParameters?.length)
      for (let E of A.urlParameters) {
        let C = (0, Uq.getOperationArgumentValueFromParameter)(Q, E, B),
          g = (0, QX.getPathStringFromParameter)(E);
        if (((C = A.serializer.serialize(E.mapper, C, g)), !E.skipEncoding))
          C = encodeURIComponent(C);
        I.set(`{${E.mapper.serializedName || g}}`, C);
      }
    return I;
  }
  function UNA(A) {
    return A.includes("://");
  }
  function WNA(A, Q) {
    if (!Q) return A;
    let B = new URL(A),
      I = B.pathname;
    if (!I.endsWith("/")) I = `${I}/`;
    if (Q.startsWith("/")) Q = Q.substring(1);
    let E = Q.indexOf("?");
    if (E !== -1) {
      let C = Q.substring(0, E),
        g = Q.substring(E + 1);
      if (((I = I + C), g)) B.search = B.search ? `${B.search}&${g}` : g;
    } else I = I + Q;
    return (B.pathname = I), B.toString();
  }
  function ZNA(A, Q, B) {
    let I = new Map(),
      E = new Set();
    if (A.queryParameters?.length)
      for (let C of A.queryParameters) {
        if (C.mapper.type.name === "Sequence" && C.mapper.serializedName)
          E.add(C.mapper.serializedName);
        let g = (0, Uq.getOperationArgumentValueFromParameter)(Q, C, B);
        if ((g !== void 0 && g !== null) || C.mapper.required) {
          g = A.serializer.serialize(
            C.mapper,
            g,
            (0, QX.getPathStringFromParameter)(C),
          );
          let F = C.collectionFormat ? JNA[C.collectionFormat] : "";
          if (Array.isArray(g))
            g = g.map((D) => {
              if (D === null || D === void 0) return "";
              return D;
            });
          if (C.collectionFormat === "Multi" && g.length === 0) continue;
          else if (
            Array.isArray(g) &&
            (C.collectionFormat === "SSV" || C.collectionFormat === "TSV")
          )
            g = g.join(F);
          if (!C.skipEncoding)
            if (Array.isArray(g))
              g = g.map((D) => {
                return encodeURIComponent(D);
              });
            else g = encodeURIComponent(g);
          if (
            Array.isArray(g) &&
            (C.collectionFormat === "CSV" || C.collectionFormat === "Pipes")
          )
            g = g.join(F);
          I.set(
            C.mapper.serializedName || (0, QX.getPathStringFromParameter)(C),
            g,
          );
        }
      }
    return { queryParams: I, sequenceParams: E };
  }
  function XNA(A) {
    let Q = new Map();
    if (!A || A[0] !== "?") return Q;
    A = A.slice(1);
    let B = A.split("&");
    for (let I of B) {
      let [E, C] = I.split("=", 2),
        g = Q.get(E);
      if (g)
        if (Array.isArray(g)) g.push(C);
        else Q.set(E, [g, C]);
      else Q.set(E, C);
    }
    return Q;
  }
  function Wq(A, Q, B, I = !1) {
    if (Q.size === 0) return A;
    let E = new URL(A),
      C = XNA(E.search);
    for (let [F, D] of Q) {
      let J = C.get(F);
      if (Array.isArray(J))
        if (Array.isArray(D)) {
          J.push(...D);
          let Y = new Set(J);
          C.set(F, Array.from(Y));
        } else J.push(D);
      else if (J) {
        if (Array.isArray(D)) D.unshift(J);
        else if (B.has(F)) C.set(F, [J, D]);
        if (!I) C.set(F, D);
      } else C.set(F, D);
    }
    let g = [];
    for (let [F, D] of C)
      if (typeof D === "string") g.push(`${F}=${D}`);
      else if (Array.isArray(D)) for (let J of D) g.push(`${F}=${J}`);
      else g.push(`${F}=${D}`);
    return (E.search = g.length ? `?${g.join("&")}` : ""), E.toString();
  }
});
var BX = Z((wq) => {
  Object.defineProperty(wq, "__esModule", { value: !0 });
  wq.logger = void 0;
  var LNA = eC();
  wq.logger = (0, LNA.createClientLogger)("core-client");
});
var Hq = Z((Vq) => {
  Object.defineProperty(Vq, "__esModule", { value: !0 });
  Vq.ServiceClient = void 0;
  var RNA = HQ(),
    VNA = e1(),
    Lq = l1(),
    $NA = Nq(),
    HNA = CD(),
    KNA = Xq(),
    zNA = JN(),
    TNA = BX();
  class Rq {
    _endpoint;
    _requestContentType;
    _allowInsecureConnection;
    _httpClient;
    pipeline;
    constructor(A = {}) {
      if (
        ((this._requestContentType = A.requestContentType),
        (this._endpoint = A.endpoint ?? A.baseUri),
        A.baseUri)
      )
        TNA.logger.warning(
          "The baseUri option for SDK Clients has been deprecated, please use endpoint instead.",
        );
      if (
        ((this._allowInsecureConnection = A.allowInsecureConnection),
        (this._httpClient =
          A.httpClient || (0, $NA.getCachedDefaultHttpClient)()),
        (this.pipeline = A.pipeline || ONA(A)),
        A.additionalPolicies?.length)
      )
        for (let { policy: Q, position: B } of A.additionalPolicies) {
          let I = B === "perRetry" ? "Sign" : void 0;
          this.pipeline.addPolicy(Q, { afterPhase: I });
        }
    }
    async sendRequest(A) {
      return this.pipeline.sendRequest(this._httpClient, A);
    }
    async sendOperationRequest(A, Q) {
      let B = Q.baseUrl || this._endpoint;
      if (!B)
        throw Error(
          "If operationSpec.baseUrl is not specified, then the ServiceClient must have a endpoint string property that contains the base URL to use.",
        );
      let I = (0, KNA.getRequestUrl)(B, Q, A, this),
        E = (0, RNA.createPipelineRequest)({ url: I });
      E.method = Q.httpMethod;
      let C = (0, HNA.getOperationRequestInfo)(E);
      (C.operationSpec = Q), (C.operationArguments = A);
      let g = Q.contentType || this._requestContentType;
      if (g && Q.requestBody) E.headers.set("Content-Type", g);
      let F = A.options;
      if (F) {
        let D = F.requestOptions;
        if (D) {
          if (D.timeout) E.timeout = D.timeout;
          if (D.onUploadProgress) E.onUploadProgress = D.onUploadProgress;
          if (D.onDownloadProgress) E.onDownloadProgress = D.onDownloadProgress;
          if (D.shouldDeserialize !== void 0)
            C.shouldDeserialize = D.shouldDeserialize;
          if (D.allowInsecureConnection) E.allowInsecureConnection = !0;
        }
        if (F.abortSignal) E.abortSignal = F.abortSignal;
        if (F.tracingOptions) E.tracingOptions = F.tracingOptions;
      }
      if (this._allowInsecureConnection) E.allowInsecureConnection = !0;
      if (E.streamResponseStatusCodes === void 0)
        E.streamResponseStatusCodes = (0, zNA.getStreamingResponseStatusCodes)(
          Q,
        );
      try {
        let D = await this.sendRequest(E),
          J = (0, Lq.flattenResponse)(D, Q.responses[D.status]);
        if (F?.onResponse) F.onResponse(D, J);
        return J;
      } catch (D) {
        if (typeof D === "object" && D?.response) {
          let J = D.response,
            Y = (0, Lq.flattenResponse)(
              J,
              Q.responses[D.statusCode] || Q.responses.default,
            );
          if (((D.details = Y), F?.onResponse)) F.onResponse(J, Y, D);
        }
        throw D;
      }
    }
  }
  Vq.ServiceClient = Rq;
  function ONA(A) {
    let Q = qNA(A),
      B =
        A.credential && Q
          ? { credentialScopes: Q, credential: A.credential }
          : void 0;
    return (0, VNA.createClientPipeline)({ ...A, credentialOptions: B });
  }
  function qNA(A) {
    if (A.credentialScopes) return A.credentialScopes;
    if (A.endpoint) return `${A.endpoint}/.default`;
    if (A.baseUri) return `${A.baseUri}/.default`;
    if (A.credential && !A.credentialScopes)
      throw Error(
        "When using credentials, the ServiceClientOptions must contain either a endpoint or a credentialScopes. Unable to create a bearerTokenAuthenticationPolicy",
      );
    return;
  }
});
var Tq = Z((zq) => {
  Object.defineProperty(zq, "__esModule", { value: !0 });
  zq.parseCAEChallenge = Kq;
  zq.authorizeRequestOnClaimChallenge = hNA;
  var jNA = BX(),
    fNA = u1();
  function Kq(A) {
    return `, ${A.trim()}`
      .split(", Bearer ")
      .filter((B) => B)
      .map((B) => {
        return `${B.trim()}, `
          .split('", ')
          .filter((C) => C)
          .map((C) => (([g, F]) => ({ [g]: F }))(C.trim().split('="')))
          .reduce((C, g) => ({ ...C, ...g }), {});
      });
  }
  async function hNA(A) {
    let { scopes: Q, response: B } = A,
      I = A.logger || jNA.logger,
      E = B.headers.get("WWW-Authenticate");
    if (!E)
      return (
        I.info(
          "The WWW-Authenticate header was missing. Failed to perform the Continuous Access Evaluation authentication flow.",
        ),
        !1
      );
    let g = (Kq(E) || []).find((D) => D.claims);
    if (!g)
      return (
        I.info(
          'The WWW-Authenticate header was missing the necessary "claims" to perform the Continuous Access Evaluation authentication flow.',
        ),
        !1
      );
    let F = await A.getAccessToken(g.scope ? [g.scope] : Q, {
      claims: (0, fNA.decodeStringToString)(g.claims),
    });
    if (!F) return !1;
    return (
      A.request.headers.set(
        "Authorization",
        `${F.tokenType ?? "Bearer"} ${F.token}`,
      ),
      !0
    );
  }
});
var fq = Z((qq) => {
  Object.defineProperty(qq, "__esModule", { value: !0 });
  qq.authorizeRequestOnTenantChallenge = void 0;
  var Oq = {
    DefaultScope: "/.default",
    HeaderConstants: { AUTHORIZATION: "authorization" },
  };
  function vNA(A) {
    return /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/.test(
      A,
    );
  }
  var PNA = async (A) => {
    let Q = mNA(A.request),
      B = SNA(A.response);
    if (B) {
      let I = bNA(B),
        E = yNA(A, I),
        C = _NA(I);
      if (!C) return !1;
      let g = await A.getAccessToken(E, { ...Q, tenantId: C });
      if (!g) return !1;
      return (
        A.request.headers.set(
          Oq.HeaderConstants.AUTHORIZATION,
          `${g.tokenType ?? "Bearer"} ${g.token}`,
        ),
        !0
      );
    }
    return !1;
  };
  qq.authorizeRequestOnTenantChallenge = PNA;
  function _NA(A) {
    let I = new URL(A.authorization_uri).pathname.split("/")[1];
    if (I && vNA(I)) return I;
    return;
  }
  function yNA(A, Q) {
    if (!Q.resource_id) return A.scopes;
    let B = new URL(Q.resource_id);
    B.pathname = Oq.DefaultScope;
    let I = B.toString();
    if (I === "https://disk.azure.com/.default")
      I = "https://disk.azure.com//.default";
    return [I];
  }
  function SNA(A) {
    let Q = A.headers.get("WWW-Authenticate");
    if (A.status === 401 && Q) return Q;
    return;
  }
  function bNA(A) {
    return `${A.slice(7).trim()} `
      .split(" ")
      .filter((E) => E)
      .map((E) => (([C, g]) => ({ [C]: g }))(E.trim().split("=")))
      .reduce((E, C) => ({ ...E, ...C }), {});
  }
  function mNA(A) {
    return {
      abortSignal: A.abortSignal,
      requestOptions: { timeout: A.timeout },
      tracingOptions: A.tracingOptions,
    };
  }
});
var oI = Z((kB) => {
  Object.defineProperty(kB, "__esModule", { value: !0 });
  kB.authorizeRequestOnTenantChallenge =
    kB.authorizeRequestOnClaimChallenge =
    kB.serializationPolicyName =
    kB.serializationPolicy =
    kB.deserializationPolicyName =
    kB.deserializationPolicy =
    kB.XML_CHARKEY =
    kB.XML_ATTRKEY =
    kB.createClientPipeline =
    kB.ServiceClient =
    kB.MapperTypeNames =
    kB.createSerializer =
      void 0;
  var hq = ED();
  Object.defineProperty(kB, "createSerializer", {
    enumerable: !0,
    get: function () {
      return hq.createSerializer;
    },
  });
  Object.defineProperty(kB, "MapperTypeNames", {
    enumerable: !0,
    get: function () {
      return hq.MapperTypeNames;
    },
  });
  var dNA = Hq();
  Object.defineProperty(kB, "ServiceClient", {
    enumerable: !0,
    get: function () {
      return dNA.ServiceClient;
    },
  });
  var cNA = e1();
  Object.defineProperty(kB, "createClientPipeline", {
    enumerable: !0,
    get: function () {
      return cNA.createClientPipeline;
    },
  });
  var kq = ID();
  Object.defineProperty(kB, "XML_ATTRKEY", {
    enumerable: !0,
    get: function () {
      return kq.XML_ATTRKEY;
    },
  });
  Object.defineProperty(kB, "XML_CHARKEY", {
    enumerable: !0,
    get: function () {
      return kq.XML_CHARKEY;
    },
  });
  var xq = a1();
  Object.defineProperty(kB, "deserializationPolicy", {
    enumerable: !0,
    get: function () {
      return xq.deserializationPolicy;
    },
  });
  Object.defineProperty(kB, "deserializationPolicyName", {
    enumerable: !0,
    get: function () {
      return xq.deserializationPolicyName;
    },
  });
  var vq = t1();
  Object.defineProperty(kB, "serializationPolicy", {
    enumerable: !0,
    get: function () {
      return vq.serializationPolicy;
    },
  });
  Object.defineProperty(kB, "serializationPolicyName", {
    enumerable: !0,
    get: function () {
      return vq.serializationPolicyName;
    },
  });
  var uNA = Tq();
  Object.defineProperty(kB, "authorizeRequestOnClaimChallenge", {
    enumerable: !0,
    get: function () {
      return uNA.authorizeRequestOnClaimChallenge;
    },
  });
  var lNA = fq();
  Object.defineProperty(kB, "authorizeRequestOnTenantChallenge", {
    enumerable: !0,
    get: function () {
      return lNA.authorizeRequestOnTenantChallenge;
    },
  });
});
var DD = Z((mq) => {
  Object.defineProperty(mq, "__esModule", { value: !0 });
  mq.HttpHeaders = void 0;
  mq.toPipelineRequest = yq;
  mq.toWebResourceLike = Sq;
  mq.toHttpHeadersLike = bq;
  var Pq = HQ(),
    _q = Symbol("Original PipelineRequest"),
    iNA = Symbol.for("@azure/core-client original request");
  function yq(A, Q = {}) {
    let I = A[_q],
      E = (0, Pq.createHttpHeaders)(A.headers.toJson({ preserveCase: !0 }));
    if (I) return (I.headers = E), I;
    else {
      let C = (0, Pq.createPipelineRequest)({
        url: A.url,
        method: A.method,
        headers: E,
        withCredentials: A.withCredentials,
        timeout: A.timeout,
        requestId: A.requestId,
        abortSignal: A.abortSignal,
        body: A.body,
        formData: A.formData,
        disableKeepAlive: !!A.keepAlive,
        onDownloadProgress: A.onDownloadProgress,
        onUploadProgress: A.onUploadProgress,
        proxySettings: A.proxySettings,
        streamResponseStatusCodes: A.streamResponseStatusCodes,
        agent: A.agent,
        requestOverrides: A.requestOverrides,
      });
      if (Q.originalRequest) C[iNA] = Q.originalRequest;
      return C;
    }
  }
  function Sq(A, Q) {
    let B = Q?.originalRequest ?? A,
      I = {
        url: A.url,
        method: A.method,
        headers: bq(A.headers),
        withCredentials: A.withCredentials,
        timeout: A.timeout,
        requestId: A.headers.get("x-ms-client-request-id") || A.requestId,
        abortSignal: A.abortSignal,
        body: A.body,
        formData: A.formData,
        keepAlive: !!A.disableKeepAlive,
        onDownloadProgress: A.onDownloadProgress,
        onUploadProgress: A.onUploadProgress,
        proxySettings: A.proxySettings,
        streamResponseStatusCodes: A.streamResponseStatusCodes,
        agent: A.agent,
        requestOverrides: A.requestOverrides,
        clone() {
          throw Error("Cannot clone a non-proxied WebResourceLike");
        },
        prepare() {
          throw Error(
            "WebResourceLike.prepare() is not supported by @azure/core-http-compat",
          );
        },
        validateRequestProperties() {},
      };
    if (Q?.createProxy)
      return new Proxy(I, {
        get(E, C, g) {
          if (C === _q) return A;
          else if (C === "clone")
            return () => {
              return Sq(yq(I, { originalRequest: B }), {
                createProxy: !0,
                originalRequest: B,
              });
            };
          return Reflect.get(E, C, g);
        },
        set(E, C, g, F) {
          if (C === "keepAlive") A.disableKeepAlive = !g;
          if (
            typeof C === "string" &&
            [
              "url",
              "method",
              "withCredentials",
              "timeout",
              "requestId",
              "abortSignal",
              "body",
              "formData",
              "onDownloadProgress",
              "onUploadProgress",
              "proxySettings",
              "streamResponseStatusCodes",
              "agent",
              "requestOverrides",
            ].includes(C)
          )
            A[C] = g;
          return Reflect.set(E, C, g, F);
        },
      });
    else return I;
  }
  function bq(A) {
    return new GN(A.toJSON({ preserveCase: !0 }));
  }
  function FD(A) {
    return A.toLowerCase();
  }
  class GN {
    _headersMap;
    constructor(A) {
      if (((this._headersMap = {}), A)) for (let Q in A) this.set(Q, A[Q]);
    }
    set(A, Q) {
      this._headersMap[FD(A)] = { name: A, value: Q.toString() };
    }
    get(A) {
      let Q = this._headersMap[FD(A)];
      return !Q ? void 0 : Q.value;
    }
    contains(A) {
      return !!this._headersMap[FD(A)];
    }
    remove(A) {
      let Q = this.contains(A);
      return delete this._headersMap[FD(A)], Q;
    }
    rawHeaders() {
      return this.toJson({ preserveCase: !0 });
    }
    headersArray() {
      let A = [];
      for (let Q in this._headersMap) A.push(this._headersMap[Q]);
      return A;
    }
    headerNames() {
      let A = [],
        Q = this.headersArray();
      for (let B = 0; B < Q.length; ++B) A.push(Q[B].name);
      return A;
    }
    headerValues() {
      let A = [],
        Q = this.headersArray();
      for (let B = 0; B < Q.length; ++B) A.push(Q[B].value);
      return A;
    }
    toJson(A = {}) {
      let Q = {};
      if (A.preserveCase)
        for (let B in this._headersMap) {
          let I = this._headersMap[B];
          Q[I.name] = I.value;
        }
      else
        for (let B in this._headersMap) {
          let I = this._headersMap[B];
          Q[FD(I.name)] = I.value;
        }
      return Q;
    }
    toString() {
      return JSON.stringify(this.toJson({ preserveCase: !0 }));
    }
    clone() {
      let A = {};
      for (let Q in this._headersMap) {
        let B = this._headersMap[Q];
        A[B.name] = B.value;
      }
      return new GN(A);
    }
  }
  mq.HttpHeaders = GN;
});
var UN = Z((uq) => {
  Object.defineProperty(uq, "__esModule", { value: !0 });
  uq.toCompatResponse = rNA;
  uq.toPipelineResponse = tNA;
  var sNA = HQ(),
    IX = DD(),
    cq = Symbol("Original FullOperationResponse");
  function rNA(A, Q) {
    let B = (0, IX.toWebResourceLike)(A.request),
      I = (0, IX.toHttpHeadersLike)(A.headers);
    if (Q?.createProxy)
      return new Proxy(A, {
        get(E, C, g) {
          if (C === "headers") return I;
          else if (C === "request") return B;
          else if (C === cq) return A;
          return Reflect.get(E, C, g);
        },
        set(E, C, g, F) {
          if (C === "headers") I = g;
          else if (C === "request") B = g;
          return Reflect.set(E, C, g, F);
        },
      });
    else return { ...A, request: B, headers: I };
  }
  function tNA(A) {
    let B = A[cq],
      I = (0, sNA.createHttpHeaders)(A.headers.toJson({ preserveCase: !0 }));
    if (B) return (B.headers = I), B;
    else
      return {
        ...A,
        headers: I,
        request: (0, IX.toPipelineRequest)(A.request),
      };
  }
});
var aq = Z((iq) => {
  Object.defineProperty(iq, "__esModule", { value: !0 });
  iq.ExtendedServiceClient = void 0;
  var lq = c1(),
    QGA = HQ(),
    BGA = oI(),
    IGA = UN();
  class pq extends BGA.ServiceClient {
    constructor(A) {
      super(A);
      if (
        A.keepAliveOptions?.enable === !1 &&
        !(0, lq.pipelineContainsDisableKeepAlivePolicy)(this.pipeline)
      )
        this.pipeline.addPolicy((0, lq.createDisableKeepAlivePolicy)());
      if (A.redirectOptions?.handleRedirects === !1)
        this.pipeline.removePolicy({ name: QGA.redirectPolicyName });
    }
    async sendOperationRequest(A, Q) {
      let B = A?.options?.onResponse,
        I;
      function E(g, F, D) {
        if (((I = g), B)) B(g, F, D);
      }
      A.options = { ...A.options, onResponse: E };
      let C = await super.sendOperationRequest(A, Q);
      if (I)
        Object.defineProperty(C, "_response", {
          value: (0, IGA.toCompatResponse)(I),
        });
      return C;
    }
  }
  iq.ExtendedServiceClient = pq;
});
var eq = Z((tq) => {
  Object.defineProperty(tq, "__esModule", { value: !0 });
  tq.requestPolicyFactoryPolicyName = tq.HttpPipelineLogLevel = void 0;
  tq.createRequestPolicyFactoryPolicy = CGA;
  var oq = DD(),
    sq = UN(),
    rq;
  (function (A) {
    (A[(A.ERROR = 1)] = "ERROR"),
      (A[(A.INFO = 3)] = "INFO"),
      (A[(A.OFF = 0)] = "OFF"),
      (A[(A.WARNING = 2)] = "WARNING");
  })(rq || (tq.HttpPipelineLogLevel = rq = {}));
  var EGA = {
    log(A, Q) {},
    shouldLog(A) {
      return !1;
    },
  };
  tq.requestPolicyFactoryPolicyName = "RequestPolicyFactoryPolicy";
  function CGA(A) {
    let Q = A.slice().reverse();
    return {
      name: tq.requestPolicyFactoryPolicyName,
      async sendRequest(B, I) {
        let E = {
          async sendRequest(F) {
            let D = await I((0, oq.toPipelineRequest)(F));
            return (0, sq.toCompatResponse)(D, { createProxy: !0 });
          },
        };
        for (let F of Q) E = F.create(E, EGA);
        let C = (0, oq.toWebResourceLike)(B, { createProxy: !0 }),
          g = await E.sendRequest(C);
        return (0, sq.toPipelineResponse)(g);
      },
    };
  }
});
var Qj = Z((Aj) => {
  Object.defineProperty(Aj, "__esModule", { value: !0 });
  Aj.convertHttpClient = JGA;
  var DGA = UN(),
    YGA = DD();
  function JGA(A) {
    return {
      sendRequest: async (Q) => {
        let B = await A.sendRequest(
          (0, YGA.toWebResourceLike)(Q, { createProxy: !0 }),
        );
        return (0, DGA.toPipelineResponse)(B);
      },
    };
  }
});
var WN = Z(($E) => {
  Object.defineProperty($E, "__esModule", { value: !0 });
  $E.toHttpHeadersLike =
    $E.convertHttpClient =
    $E.disableKeepAlivePolicyName =
    $E.HttpPipelineLogLevel =
    $E.createRequestPolicyFactoryPolicy =
    $E.requestPolicyFactoryPolicyName =
    $E.ExtendedServiceClient =
      void 0;
  var GGA = aq();
  Object.defineProperty($E, "ExtendedServiceClient", {
    enumerable: !0,
    get: function () {
      return GGA.ExtendedServiceClient;
    },
  });
  var CX = eq();
  Object.defineProperty($E, "requestPolicyFactoryPolicyName", {
    enumerable: !0,
    get: function () {
      return CX.requestPolicyFactoryPolicyName;
    },
  });
  Object.defineProperty($E, "createRequestPolicyFactoryPolicy", {
    enumerable: !0,
    get: function () {
      return CX.createRequestPolicyFactoryPolicy;
    },
  });
  Object.defineProperty($E, "HttpPipelineLogLevel", {
    enumerable: !0,
    get: function () {
      return CX.HttpPipelineLogLevel;
    },
  });
  var UGA = c1();
  Object.defineProperty($E, "disableKeepAlivePolicyName", {
    enumerable: !0,
    get: function () {
      return UGA.disableKeepAlivePolicyName;
    },
  });
  var WGA = Qj();
  Object.defineProperty($E, "convertHttpClient", {
    enumerable: !0,
    get: function () {
      return WGA.convertHttpClient;
    },
  });
  var ZGA = DD();
  Object.defineProperty($E, "toHttpHeadersLike", {
    enumerable: !0,
    get: function () {
      return ZGA.toHttpHeadersLike;
    },
  });
});
var Ij = Z((DqA, Bj) => {
  (() => {
    var A = {
        d: (G, U) => {
          for (var R in U)
            A.o(U, R) &&
              !A.o(G, R) &&
              Object.defineProperty(G, R, { enumerable: !0, get: U[R] });
        },
        o: (G, U) => Object.prototype.hasOwnProperty.call(G, U),
        r: (G) => {
          typeof Symbol < "u" &&
            Symbol.toStringTag &&
            Object.defineProperty(G, Symbol.toStringTag, { value: "Module" }),
            Object.defineProperty(G, "__esModule", { value: !0 });
        },
      },
      Q = {};
    A.r(Q),
      A.d(Q, {
        XMLBuilder: () => kE,
        XMLParser: () => r4,
        XMLValidator: () => cy,
      });
    let B =
        ":A-Za-z_\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD",
      I = new RegExp(
        "^[" + B + "][" + B + "\\-.\\d\\u00B7\\u0300-\\u036F\\u203F-\\u2040]*$",
      );
    function E(G, U) {
      let R = [],
        T = U.exec(G);
      for (; T; ) {
        let V = [];
        V.startIndex = U.lastIndex - T[0].length;
        let h = T.length;
        for (let v = 0; v < h; v++) V.push(T[v]);
        R.push(V), (T = U.exec(G));
      }
      return R;
    }
    let C = function (G) {
        return I.exec(G) != null;
      },
      g = { allowBooleanAttributes: !1, unpairedTags: [] };
    function F(G, U) {
      U = Object.assign({}, g, U);
      let R = [],
        T = !1,
        V = !1;
      G[0] === "\uFEFF" && (G = G.substr(1));
      for (let h = 0; h < G.length; h++)
        if (G[h] === "<" && G[h + 1] === "?") {
          if (((h += 2), (h = J(G, h)), h.err)) return h;
        } else {
          if (G[h] !== "<") {
            if (D(G[h])) continue;
            return q(
              "InvalidChar",
              "char '" + G[h] + "' is not expected.",
              f(G, h),
            );
          }
          {
            let v = h;
            if ((h++, G[h] === "!")) {
              h = Y(G, h);
              continue;
            }
            {
              let P = !1;
              G[h] === "/" && ((P = !0), h++);
              let k = "";
              for (
                ;
                h < G.length &&
                G[h] !== ">" &&
                G[h] !== " " &&
                G[h] !== "\t" &&
                G[h] !==
                  `
` &&
                G[h] !== "\r";
                h++
              )
                k += G[h];
              if (
                ((k = k.trim()),
                k[k.length - 1] === "/" &&
                  ((k = k.substring(0, k.length - 1)), h--),
                !C(k))
              ) {
                let a;
                return (
                  (a =
                    k.trim().length === 0
                      ? "Invalid space after '<'."
                      : "Tag '" + k + "' is an invalid name."),
                  q("InvalidTag", a, f(G, h))
                );
              }
              let n = X(G, h);
              if (n === !1)
                return q(
                  "InvalidAttr",
                  "Attributes for '" + k + "' have open quote.",
                  f(G, h),
                );
              let p = n.value;
              if (((h = n.index), p[p.length - 1] === "/")) {
                let a = h - p.length;
                p = p.substring(0, p.length - 1);
                let $A = L(p, U);
                if ($A !== !0)
                  return q($A.err.code, $A.err.msg, f(G, a + $A.err.line));
                T = !0;
              } else if (P) {
                if (!n.tagClosed)
                  return q(
                    "InvalidTag",
                    "Closing tag '" + k + "' doesn't have proper closing.",
                    f(G, h),
                  );
                if (p.trim().length > 0)
                  return q(
                    "InvalidTag",
                    "Closing tag '" +
                      k +
                      "' can't have attributes or invalid starting.",
                    f(G, v),
                  );
                if (R.length === 0)
                  return q(
                    "InvalidTag",
                    "Closing tag '" + k + "' has not been opened.",
                    f(G, v),
                  );
                {
                  let a = R.pop();
                  if (k !== a.tagName) {
                    let $A = f(G, a.tagStartPos);
                    return q(
                      "InvalidTag",
                      "Expected closing tag '" +
                        a.tagName +
                        "' (opened in line " +
                        $A.line +
                        ", col " +
                        $A.col +
                        ") instead of closing tag '" +
                        k +
                        "'.",
                      f(G, v),
                    );
                  }
                  R.length == 0 && (V = !0);
                }
              } else {
                let a = L(p, U);
                if (a !== !0)
                  return q(
                    a.err.code,
                    a.err.msg,
                    f(G, h - p.length + a.err.line),
                  );
                if (V === !0)
                  return q(
                    "InvalidXml",
                    "Multiple possible root nodes found.",
                    f(G, h),
                  );
                U.unpairedTags.indexOf(k) !== -1 ||
                  R.push({ tagName: k, tagStartPos: v }),
                  (T = !0);
              }
              for (h++; h < G.length; h++)
                if (G[h] === "<") {
                  if (G[h + 1] === "!") {
                    h++, (h = Y(G, h));
                    continue;
                  }
                  if (G[h + 1] !== "?") break;
                  if (((h = J(G, ++h)), h.err)) return h;
                } else if (G[h] === "&") {
                  let a = H(G, h);
                  if (a == -1)
                    return q(
                      "InvalidChar",
                      "char '&' is not expected.",
                      f(G, h),
                    );
                  h = a;
                } else if (V === !0 && !D(G[h]))
                  return q("InvalidXml", "Extra text at the end", f(G, h));
              G[h] === "<" && h--;
            }
          }
        }
      return T
        ? R.length == 1
          ? q(
              "InvalidTag",
              "Unclosed tag '" + R[0].tagName + "'.",
              f(G, R[0].tagStartPos),
            )
          : !(R.length > 0) ||
            q(
              "InvalidXml",
              "Invalid '" +
                JSON.stringify(
                  R.map((h) => h.tagName),
                  null,
                  4,
                ).replace(/\r?\n/g, "") +
                "' found.",
              { line: 1, col: 1 },
            )
        : q("InvalidXml", "Start tag expected.", 1);
    }
    function D(G) {
      return (
        G === " " ||
        G === "\t" ||
        G ===
          `
` ||
        G === "\r"
      );
    }
    function J(G, U) {
      let R = U;
      for (; U < G.length; U++)
        if (G[U] != "?" && G[U] != " ");
        else {
          let T = G.substr(R, U - R);
          if (U > 5 && T === "xml")
            return q(
              "InvalidXml",
              "XML declaration allowed only at the start of the document.",
              f(G, U),
            );
          if (G[U] == "?" && G[U + 1] == ">") {
            U++;
            break;
          }
        }
      return U;
    }
    function Y(G, U) {
      if (G.length > U + 5 && G[U + 1] === "-" && G[U + 2] === "-") {
        for (U += 3; U < G.length; U++)
          if (G[U] === "-" && G[U + 1] === "-" && G[U + 2] === ">") {
            U += 2;
            break;
          }
      } else if (
        G.length > U + 8 &&
        G[U + 1] === "D" &&
        G[U + 2] === "O" &&
        G[U + 3] === "C" &&
        G[U + 4] === "T" &&
        G[U + 5] === "Y" &&
        G[U + 6] === "P" &&
        G[U + 7] === "E"
      ) {
        let R = 1;
        for (U += 8; U < G.length; U++)
          if (G[U] === "<") R++;
          else if (G[U] === ">" && (R--, R === 0)) break;
      } else if (
        G.length > U + 9 &&
        G[U + 1] === "[" &&
        G[U + 2] === "C" &&
        G[U + 3] === "D" &&
        G[U + 4] === "A" &&
        G[U + 5] === "T" &&
        G[U + 6] === "A" &&
        G[U + 7] === "["
      ) {
        for (U += 8; U < G.length; U++)
          if (G[U] === "]" && G[U + 1] === "]" && G[U + 2] === ">") {
            U += 2;
            break;
          }
      }
      return U;
    }
    let N = '"',
      W = "'";
    function X(G, U) {
      let R = "",
        T = "",
        V = !1;
      for (; U < G.length; U++) {
        if (G[U] === N || G[U] === W)
          T === "" ? (T = G[U]) : T !== G[U] || (T = "");
        else if (G[U] === ">" && T === "") {
          V = !0;
          break;
        }
        R += G[U];
      }
      return T === "" && { value: R, index: U, tagClosed: V };
    }
    let M = new RegExp(
      `(\\s*)([^\\s=]+)(\\s*=)?(\\s*(['"])(([\\s\\S])*?)\\5)?`,
      "g",
    );
    function L(G, U) {
      let R = E(G, M),
        T = {};
      for (let V = 0; V < R.length; V++) {
        if (R[V][1].length === 0)
          return q(
            "InvalidAttr",
            "Attribute '" + R[V][2] + "' has no space in starting.",
            S(R[V]),
          );
        if (R[V][3] !== void 0 && R[V][4] === void 0)
          return q(
            "InvalidAttr",
            "Attribute '" + R[V][2] + "' is without value.",
            S(R[V]),
          );
        if (R[V][3] === void 0 && !U.allowBooleanAttributes)
          return q(
            "InvalidAttr",
            "boolean attribute '" + R[V][2] + "' is not allowed.",
            S(R[V]),
          );
        let h = R[V][2];
        if (!O(h))
          return q(
            "InvalidAttr",
            "Attribute '" + h + "' is an invalid name.",
            S(R[V]),
          );
        if (T.hasOwnProperty(h))
          return q(
            "InvalidAttr",
            "Attribute '" + h + "' is repeated.",
            S(R[V]),
          );
        T[h] = 1;
      }
      return !0;
    }
    function H(G, U) {
      if (G[++U] === ";") return -1;
      if (G[U] === "#")
        return (function (T, V) {
          let h = /\d/;
          for (T[V] === "x" && (V++, (h = /[\da-fA-F]/)); V < T.length; V++) {
            if (T[V] === ";") return V;
            if (!T[V].match(h)) break;
          }
          return -1;
        })(G, ++U);
      let R = 0;
      for (; U < G.length; U++, R++)
        if (!(G[U].match(/\w/) && R < 20)) {
          if (G[U] === ";") break;
          return -1;
        }
      return U;
    }
    function q(G, U, R) {
      return { err: { code: G, msg: U, line: R.line || R, col: R.col } };
    }
    function O(G) {
      return C(G);
    }
    function f(G, U) {
      let R = G.substring(0, U).split(/\r?\n/);
      return { line: R.length, col: R[R.length - 1].length + 1 };
    }
    function S(G) {
      return G.startIndex + G[1].length;
    }
    let r = {
        preserveOrder: !1,
        attributeNamePrefix: "@_",
        attributesGroupName: !1,
        textNodeName: "#text",
        ignoreAttributes: !0,
        removeNSPrefix: !1,
        allowBooleanAttributes: !1,
        parseTagValue: !0,
        parseAttributeValue: !1,
        trimValues: !0,
        cdataPropName: !1,
        numberParseOptions: { hex: !0, leadingZeros: !0, eNotation: !0 },
        tagValueProcessor: function (G, U) {
          return U;
        },
        attributeValueProcessor: function (G, U) {
          return U;
        },
        stopNodes: [],
        alwaysCreateTextNode: !1,
        isArray: () => !1,
        commentPropName: !1,
        unpairedTags: [],
        processEntities: !0,
        htmlEntities: !1,
        ignoreDeclaration: !1,
        ignorePiTags: !1,
        transformTagName: !1,
        transformAttributeName: !1,
        updateTag: function (G, U, R) {
          return G;
        },
        captureMetaData: !1,
      },
      t;
    t =
      typeof Symbol != "function"
        ? "@@xmlMetadata"
        : Symbol("XML Node Metadata");
    class IA {
      constructor(G) {
        (this.tagname = G), (this.child = []), (this[":@"] = {});
      }
      add(G, U) {
        G === "__proto__" && (G = "#__proto__"), this.child.push({ [G]: U });
      }
      addChild(G, U) {
        G.tagname === "__proto__" && (G.tagname = "#__proto__"),
          G[":@"] && Object.keys(G[":@"]).length > 0
            ? this.child.push({ [G.tagname]: G.child, ":@": G[":@"] })
            : this.child.push({ [G.tagname]: G.child }),
          U !== void 0 &&
            (this.child[this.child.length - 1][t] = { startIndex: U });
      }
      static getMetaDataSymbol() {
        return t;
      }
    }
    class zA {
      constructor(G) {
        this.suppressValidationErr = !G;
      }
      readDocType(G, U) {
        let R = {};
        if (
          G[U + 3] !== "O" ||
          G[U + 4] !== "C" ||
          G[U + 5] !== "T" ||
          G[U + 6] !== "Y" ||
          G[U + 7] !== "P" ||
          G[U + 8] !== "E"
        )
          throw Error("Invalid Tag instead of DOCTYPE");
        {
          U += 9;
          let T = 1,
            V = !1,
            h = !1,
            v = "";
          for (; U < G.length; U++)
            if (G[U] !== "<" || h)
              if (G[U] === ">") {
                if (
                  (h
                    ? G[U - 1] === "-" && G[U - 2] === "-" && ((h = !1), T--)
                    : T--,
                  T === 0)
                )
                  break;
              } else G[U] === "[" ? (V = !0) : (v += G[U]);
            else {
              if (V && MA(G, "!ENTITY", U)) {
                let P, k;
                (U += 7),
                  ([P, k, U] = this.readEntityExp(
                    G,
                    U + 1,
                    this.suppressValidationErr,
                  )),
                  k.indexOf("&") === -1 &&
                    (R[P] = { regx: RegExp(`&${P};`, "g"), val: k });
              } else if (V && MA(G, "!ELEMENT", U)) {
                U += 8;
                let { index: P } = this.readElementExp(G, U + 1);
                U = P;
              } else if (V && MA(G, "!ATTLIST", U)) U += 8;
              else if (V && MA(G, "!NOTATION", U)) {
                U += 9;
                let { index: P } = this.readNotationExp(
                  G,
                  U + 1,
                  this.suppressValidationErr,
                );
                U = P;
              } else {
                if (!MA(G, "!--", U)) throw Error("Invalid DOCTYPE");
                h = !0;
              }
              T++, (v = "");
            }
          if (T !== 0) throw Error("Unclosed DOCTYPE");
        }
        return { entities: R, i: U };
      }
      readEntityExp(G, U) {
        U = DA(G, U);
        let R = "";
        for (
          ;
          U < G.length && !/\s/.test(G[U]) && G[U] !== '"' && G[U] !== "'";

        )
          (R += G[U]), U++;
        if ((LA(R), (U = DA(G, U)), !this.suppressValidationErr)) {
          if (G.substring(U, U + 6).toUpperCase() === "SYSTEM")
            throw Error("External entities are not supported");
          if (G[U] === "%") throw Error("Parameter entities are not supported");
        }
        let T = "";
        return ([U, T] = this.readIdentifierVal(G, U, "entity")), [R, T, --U];
      }
      readNotationExp(G, U) {
        U = DA(G, U);
        let R = "";
        for (; U < G.length && !/\s/.test(G[U]); ) (R += G[U]), U++;
        !this.suppressValidationErr && LA(R), (U = DA(G, U));
        let T = G.substring(U, U + 6).toUpperCase();
        if (!this.suppressValidationErr && T !== "SYSTEM" && T !== "PUBLIC")
          throw Error(`Expected SYSTEM or PUBLIC, found "${T}"`);
        (U += T.length), (U = DA(G, U));
        let V = null,
          h = null;
        if (T === "PUBLIC")
          ([U, V] = this.readIdentifierVal(G, U, "publicIdentifier")),
            (G[(U = DA(G, U))] !== '"' && G[U] !== "'") ||
              ([U, h] = this.readIdentifierVal(G, U, "systemIdentifier"));
        else if (
          T === "SYSTEM" &&
          (([U, h] = this.readIdentifierVal(G, U, "systemIdentifier")),
          !this.suppressValidationErr && !h)
        )
          throw Error(
            "Missing mandatory system identifier for SYSTEM notation",
          );
        return {
          notationName: R,
          publicIdentifier: V,
          systemIdentifier: h,
          index: --U,
        };
      }
      readIdentifierVal(G, U, R) {
        let T = "",
          V = G[U];
        if (V !== '"' && V !== "'")
          throw Error(`Expected quoted string, found "${V}"`);
        for (U++; U < G.length && G[U] !== V; ) (T += G[U]), U++;
        if (G[U] !== V) throw Error(`Unterminated ${R} value`);
        return [++U, T];
      }
      readElementExp(G, U) {
        U = DA(G, U);
        let R = "";
        for (; U < G.length && !/\s/.test(G[U]); ) (R += G[U]), U++;
        if (!this.suppressValidationErr && !C(R))
          throw Error(`Invalid element name: "${R}"`);
        let T = "";
        if (G[(U = DA(G, U))] === "E" && MA(G, "MPTY", U)) U += 4;
        else if (G[U] === "A" && MA(G, "NY", U)) U += 2;
        else if (G[U] === "(") {
          for (U++; U < G.length && G[U] !== ")"; ) (T += G[U]), U++;
          if (G[U] !== ")") throw Error("Unterminated content model");
        } else if (!this.suppressValidationErr)
          throw Error(`Invalid Element Expression, found "${G[U]}"`);
        return { elementName: R, contentModel: T.trim(), index: U };
      }
      readAttlistExp(G, U) {
        U = DA(G, U);
        let R = "";
        for (; U < G.length && !/\s/.test(G[U]); ) (R += G[U]), U++;
        LA(R), (U = DA(G, U));
        let T = "";
        for (; U < G.length && !/\s/.test(G[U]); ) (T += G[U]), U++;
        if (!LA(T)) throw Error(`Invalid attribute name: "${T}"`);
        U = DA(G, U);
        let V = "";
        if (G.substring(U, U + 8).toUpperCase() === "NOTATION") {
          if (((V = "NOTATION"), G[(U = DA(G, (U += 8)))] !== "("))
            throw Error(`Expected '(', found "${G[U]}"`);
          U++;
          let v = [];
          for (; U < G.length && G[U] !== ")"; ) {
            let P = "";
            for (; U < G.length && G[U] !== "|" && G[U] !== ")"; )
              (P += G[U]), U++;
            if (((P = P.trim()), !LA(P)))
              throw Error(`Invalid notation name: "${P}"`);
            v.push(P), G[U] === "|" && (U++, (U = DA(G, U)));
          }
          if (G[U] !== ")") throw Error("Unterminated list of notations");
          U++, (V += " (" + v.join("|") + ")");
        } else {
          for (; U < G.length && !/\s/.test(G[U]); ) (V += G[U]), U++;
          let v = [
            "CDATA",
            "ID",
            "IDREF",
            "IDREFS",
            "ENTITY",
            "ENTITIES",
            "NMTOKEN",
            "NMTOKENS",
          ];
          if (!this.suppressValidationErr && !v.includes(V.toUpperCase()))
            throw Error(`Invalid attribute type: "${V}"`);
        }
        U = DA(G, U);
        let h = "";
        return (
          G.substring(U, U + 8).toUpperCase() === "#REQUIRED"
            ? ((h = "#REQUIRED"), (U += 8))
            : G.substring(U, U + 7).toUpperCase() === "#IMPLIED"
              ? ((h = "#IMPLIED"), (U += 7))
              : ([U, h] = this.readIdentifierVal(G, U, "ATTLIST")),
          {
            elementName: R,
            attributeName: T,
            attributeType: V,
            defaultValue: h,
            index: U,
          }
        );
      }
    }
    let DA = (G, U) => {
      for (; U < G.length && /\s/.test(G[U]); ) U++;
      return U;
    };
    function MA(G, U, R) {
      for (let T = 0; T < U.length; T++) if (U[T] !== G[R + T + 1]) return !1;
      return !0;
    }
    function LA(G) {
      if (C(G)) return G;
      throw Error(`Invalid entity name ${G}`);
    }
    let EA = /^[-+]?0x[a-fA-F0-9]+$/,
      RA = /^([\-\+])?(0*)([0-9]*(\.[0-9]*)?)$/,
      CQ = { hex: !0, leadingZeros: !0, decimalPoint: ".", eNotation: !0 },
      ZB = /^([-+])?(0*)(\d*(\.\d*)?[eE][-\+]?\d+)$/;
    function jQ(G) {
      return typeof G == "function"
        ? G
        : Array.isArray(G)
          ? (U) => {
              for (let R of G) {
                if (typeof R == "string" && U === R) return !0;
                if (R instanceof RegExp && R.test(U)) return !0;
              }
            }
          : () => !1;
    }
    class QE {
      constructor(G) {
        (this.options = G),
          (this.currentNode = null),
          (this.tagsNodeStack = []),
          (this.docTypeEntities = {}),
          (this.lastEntities = {
            apos: { regex: /&(apos|#39|#x27);/g, val: "'" },
            gt: { regex: /&(gt|#62|#x3E);/g, val: ">" },
            lt: { regex: /&(lt|#60|#x3C);/g, val: "<" },
            quot: { regex: /&(quot|#34|#x22);/g, val: '"' },
          }),
          (this.ampEntity = { regex: /&(amp|#38|#x26);/g, val: "&" }),
          (this.htmlEntities = {
            space: { regex: /&(nbsp|#160);/g, val: " " },
            cent: { regex: /&(cent|#162);/g, val: "¢" },
            pound: { regex: /&(pound|#163);/g, val: "£" },
            yen: { regex: /&(yen|#165);/g, val: "¥" },
            euro: { regex: /&(euro|#8364);/g, val: "€" },
            copyright: { regex: /&(copy|#169);/g, val: "©" },
            reg: { regex: /&(reg|#174);/g, val: "®" },
            inr: { regex: /&(inr|#8377);/g, val: "₹" },
            num_dec: {
              regex: /&#([0-9]{1,7});/g,
              val: (U, R) => String.fromCodePoint(Number.parseInt(R, 10)),
            },
            num_hex: {
              regex: /&#x([0-9a-fA-F]{1,6});/g,
              val: (U, R) => String.fromCodePoint(Number.parseInt(R, 16)),
            },
          }),
          (this.addExternalEntities = fE),
          (this.parseXml = MQ),
          (this.parseTextData = LI),
          (this.resolveNameSpace = qI),
          (this.buildAttributesMap = BE),
          (this.isItStopNode = jy),
          (this.replaceEntitiesValue = RI),
          (this.readStopNodeData = fy),
          (this.saveTextToParentTag = HG),
          (this.addChild = sB),
          (this.ignoreAttributesFn = jQ(this.options.ignoreAttributes));
      }
    }
    function fE(G) {
      let U = Object.keys(G);
      for (let R = 0; R < U.length; R++) {
        let T = U[R];
        this.lastEntities[T] = {
          regex: new RegExp("&" + T + ";", "g"),
          val: G[T],
        };
      }
    }
    function LI(G, U, R, T, V, h, v) {
      if (
        G !== void 0 &&
        (this.options.trimValues && !T && (G = G.trim()), G.length > 0)
      ) {
        v || (G = this.replaceEntitiesValue(G));
        let P = this.options.tagValueProcessor(U, G, R, V, h);
        return P == null
          ? G
          : typeof P != typeof G || P !== G
            ? P
            : this.options.trimValues || G.trim() === G
              ? o4(
                  G,
                  this.options.parseTagValue,
                  this.options.numberParseOptions,
                )
              : G;
      }
    }
    function qI(G) {
      if (this.options.removeNSPrefix) {
        let U = G.split(":"),
          R = G.charAt(0) === "/" ? "/" : "";
        if (U[0] === "xmlns") return "";
        U.length === 2 && (G = R + U[1]);
      }
      return G;
    }
    let hE = new RegExp(`([^\\s=]+)\\s*(=\\s*(['"])([\\s\\S]*?)\\3)?`, "gm");
    function BE(G, U, R) {
      if (this.options.ignoreAttributes !== !0 && typeof G == "string") {
        let T = E(G, hE),
          V = T.length,
          h = {};
        for (let v = 0; v < V; v++) {
          let P = this.resolveNameSpace(T[v][1]);
          if (this.ignoreAttributesFn(P, U)) continue;
          let k = T[v][4],
            n = this.options.attributeNamePrefix + P;
          if (P.length)
            if (
              (this.options.transformAttributeName &&
                (n = this.options.transformAttributeName(n)),
              n === "__proto__" && (n = "#__proto__"),
              k !== void 0)
            ) {
              this.options.trimValues && (k = k.trim()),
                (k = this.replaceEntitiesValue(k));
              let p = this.options.attributeValueProcessor(P, k, U);
              h[n] =
                p == null
                  ? k
                  : typeof p != typeof k || p !== k
                    ? p
                    : o4(
                        k,
                        this.options.parseAttributeValue,
                        this.options.numberParseOptions,
                      );
            } else this.options.allowBooleanAttributes && (h[n] = !0);
        }
        if (!Object.keys(h).length) return;
        if (this.options.attributesGroupName) {
          let v = {};
          return (v[this.options.attributesGroupName] = h), v;
        }
        return h;
      }
    }
    let MQ = function (G) {
      G = G.replace(
        /\r\n?/g,
        `
`,
      );
      let U = new IA("!xml"),
        R = U,
        T = "",
        V = "",
        h = new zA(this.options.processEntities);
      for (let v = 0; v < G.length; v++)
        if (G[v] === "<")
          if (G[v + 1] === "/") {
            let P = VC(G, ">", v, "Closing Tag is not closed."),
              k = G.substring(v + 2, P).trim();
            if (this.options.removeNSPrefix) {
              let a = k.indexOf(":");
              a !== -1 && (k = k.substr(a + 1));
            }
            this.options.transformTagName &&
              (k = this.options.transformTagName(k)),
              R && (T = this.saveTextToParentTag(T, R, V));
            let n = V.substring(V.lastIndexOf(".") + 1);
            if (k && this.options.unpairedTags.indexOf(k) !== -1)
              throw Error(
                `Unpaired tag can not be used as closing tag: </${k}>`,
              );
            let p = 0;
            n && this.options.unpairedTags.indexOf(n) !== -1
              ? ((p = V.lastIndexOf(".", V.lastIndexOf(".") - 1)),
                this.tagsNodeStack.pop())
              : (p = V.lastIndexOf(".")),
              (V = V.substring(0, p)),
              (R = this.tagsNodeStack.pop()),
              (T = ""),
              (v = P);
          } else if (G[v + 1] === "?") {
            let P = KG(G, v, !1, "?>");
            if (!P) throw Error("Pi Tag is not closed.");
            if (
              ((T = this.saveTextToParentTag(T, R, V)),
              (this.options.ignoreDeclaration && P.tagName === "?xml") ||
                this.options.ignorePiTags)
            );
            else {
              let k = new IA(P.tagName);
              k.add(this.options.textNodeName, ""),
                P.tagName !== P.tagExp &&
                  P.attrExpPresent &&
                  (k[":@"] = this.buildAttributesMap(P.tagExp, V, P.tagName)),
                this.addChild(R, k, V, v);
            }
            v = P.closeIndex + 1;
          } else if (G.substr(v + 1, 3) === "!--") {
            let P = VC(G, "-->", v + 4, "Comment is not closed.");
            if (this.options.commentPropName) {
              let k = G.substring(v + 4, P - 2);
              (T = this.saveTextToParentTag(T, R, V)),
                R.add(this.options.commentPropName, [
                  { [this.options.textNodeName]: k },
                ]);
            }
            v = P;
          } else if (G.substr(v + 1, 2) === "!D") {
            let P = h.readDocType(G, v);
            (this.docTypeEntities = P.entities), (v = P.i);
          } else if (G.substr(v + 1, 2) === "![") {
            let P = VC(G, "]]>", v, "CDATA is not closed.") - 2,
              k = G.substring(v + 9, P);
            T = this.saveTextToParentTag(T, R, V);
            let n = this.parseTextData(k, R.tagname, V, !0, !1, !0, !0);
            n == null && (n = ""),
              this.options.cdataPropName
                ? R.add(this.options.cdataPropName, [
                    { [this.options.textNodeName]: k },
                  ])
                : R.add(this.options.textNodeName, n),
              (v = P + 2);
          } else {
            let P = KG(G, v, this.options.removeNSPrefix),
              k = P.tagName,
              n = P.rawTagName,
              p = P.tagExp,
              a = P.attrExpPresent,
              $A = P.closeIndex;
            this.options.transformTagName &&
              (k = this.options.transformTagName(k)),
              R &&
                T &&
                R.tagname !== "!xml" &&
                (T = this.saveTextToParentTag(T, R, V, !1));
            let bA = R;
            bA &&
              this.options.unpairedTags.indexOf(bA.tagname) !== -1 &&
              ((R = this.tagsNodeStack.pop()),
              (V = V.substring(0, V.lastIndexOf(".")))),
              k !== U.tagname && (V += V ? "." + k : k);
            let AQ = v;
            if (this.isItStopNode(this.options.stopNodes, V, k)) {
              let PA = "";
              if (p.length > 0 && p.lastIndexOf("/") === p.length - 1)
                k[k.length - 1] === "/"
                  ? ((k = k.substr(0, k.length - 1)),
                    (V = V.substr(0, V.length - 1)),
                    (p = k))
                  : (p = p.substr(0, p.length - 1)),
                  (v = P.closeIndex);
              else if (this.options.unpairedTags.indexOf(k) !== -1)
                v = P.closeIndex;
              else {
                let rB = this.readStopNodeData(G, n, $A + 1);
                if (!rB) throw Error(`Unexpected end of ${n}`);
                (v = rB.i), (PA = rB.tagContent);
              }
              let jI = new IA(k);
              k !== p && a && (jI[":@"] = this.buildAttributesMap(p, V, k)),
                PA && (PA = this.parseTextData(PA, k, V, !0, a, !0, !0)),
                (V = V.substr(0, V.lastIndexOf("."))),
                jI.add(this.options.textNodeName, PA),
                this.addChild(R, jI, V, AQ);
            } else {
              if (p.length > 0 && p.lastIndexOf("/") === p.length - 1) {
                k[k.length - 1] === "/"
                  ? ((k = k.substr(0, k.length - 1)),
                    (V = V.substr(0, V.length - 1)),
                    (p = k))
                  : (p = p.substr(0, p.length - 1)),
                  this.options.transformTagName &&
                    (k = this.options.transformTagName(k));
                let PA = new IA(k);
                k !== p && a && (PA[":@"] = this.buildAttributesMap(p, V, k)),
                  this.addChild(R, PA, V, AQ),
                  (V = V.substr(0, V.lastIndexOf(".")));
              } else {
                let PA = new IA(k);
                this.tagsNodeStack.push(R),
                  k !== p && a && (PA[":@"] = this.buildAttributesMap(p, V, k)),
                  this.addChild(R, PA, V, AQ),
                  (R = PA);
              }
              (T = ""), (v = $A);
            }
          }
        else T += G[v];
      return U.child;
    };
    function sB(G, U, R, T) {
      this.options.captureMetaData || (T = void 0);
      let V = this.options.updateTag(U.tagname, R, U[":@"]);
      V === !1 ||
        (typeof V == "string"
          ? ((U.tagname = V), G.addChild(U, T))
          : G.addChild(U, T));
    }
    let RI = function (G) {
      if (this.options.processEntities) {
        for (let U in this.docTypeEntities) {
          let R = this.docTypeEntities[U];
          G = G.replace(R.regx, R.val);
        }
        for (let U in this.lastEntities) {
          let R = this.lastEntities[U];
          G = G.replace(R.regex, R.val);
        }
        if (this.options.htmlEntities)
          for (let U in this.htmlEntities) {
            let R = this.htmlEntities[U];
            G = G.replace(R.regex, R.val);
          }
        G = G.replace(this.ampEntity.regex, this.ampEntity.val);
      }
      return G;
    };
    function HG(G, U, R, T) {
      return (
        G &&
          (T === void 0 && (T = U.child.length === 0),
          (G = this.parseTextData(
            G,
            U.tagname,
            R,
            !1,
            !!U[":@"] && Object.keys(U[":@"]).length !== 0,
            T,
          )) !== void 0 &&
            G !== "" &&
            U.add(this.options.textNodeName, G),
          (G = "")),
        G
      );
    }
    function jy(G, U, R) {
      let T = "*." + R;
      for (let V in G) {
        let h = G[V];
        if (T === h || U === h) return !0;
      }
      return !1;
    }
    function VC(G, U, R, T) {
      let V = G.indexOf(U, R);
      if (V === -1) throw Error(T);
      return V + U.length - 1;
    }
    function KG(G, U, R, T = ">") {
      let V = (function (a, $A, bA = ">") {
        let AQ,
          PA = "";
        for (let jI = $A; jI < a.length; jI++) {
          let rB = a[jI];
          if (AQ) rB === AQ && (AQ = "");
          else if (rB === '"' || rB === "'") AQ = rB;
          else if (rB === bA[0]) {
            if (!bA[1]) return { data: PA, index: jI };
            if (a[jI + 1] === bA[1]) return { data: PA, index: jI };
          } else rB === "\t" && (rB = " ");
          PA += rB;
        }
      })(G, U + 1, T);
      if (!V) return;
      let { data: h, index: v } = V,
        P = h.search(/\s/),
        k = h,
        n = !0;
      P !== -1 &&
        ((k = h.substring(0, P)), (h = h.substring(P + 1).trimStart()));
      let p = k;
      if (R) {
        let a = k.indexOf(":");
        a !== -1 && ((k = k.substr(a + 1)), (n = k !== V.data.substr(a + 1)));
      }
      return {
        tagName: k,
        tagExp: h,
        closeIndex: v,
        attrExpPresent: n,
        rawTagName: p,
      };
    }
    function fy(G, U, R) {
      let T = R,
        V = 1;
      for (; R < G.length; R++)
        if (G[R] === "<")
          if (G[R + 1] === "/") {
            let h = VC(G, ">", R, `${U} is not closed`);
            if (G.substring(R + 2, h).trim() === U && (V--, V === 0))
              return { tagContent: G.substring(T, R), i: h };
            R = h;
          } else if (G[R + 1] === "?")
            R = VC(G, "?>", R + 1, "StopNode is not closed.");
          else if (G.substr(R + 1, 3) === "!--")
            R = VC(G, "-->", R + 3, "StopNode is not closed.");
          else if (G.substr(R + 1, 2) === "![")
            R = VC(G, "]]>", R, "StopNode is not closed.") - 2;
          else {
            let h = KG(G, R, ">");
            h &&
              ((h && h.tagName) === U &&
                h.tagExp[h.tagExp.length - 1] !== "/" &&
                V++,
              (R = h.closeIndex));
          }
    }
    function o4(G, U, R) {
      if (U && typeof G == "string") {
        let T = G.trim();
        return (
          T === "true" ||
          (T !== "false" &&
            (function (V, h = {}) {
              if (((h = Object.assign({}, CQ, h)), !V || typeof V != "string"))
                return V;
              let v = V.trim();
              if (h.skipLike !== void 0 && h.skipLike.test(v)) return V;
              if (V === "0") return 0;
              if (h.hex && EA.test(v))
                return (function (k) {
                  if (parseInt) return parseInt(k, 16);
                  if (Number.parseInt) return Number.parseInt(k, 16);
                  if (window && window.parseInt) return window.parseInt(k, 16);
                  throw Error(
                    "parseInt, Number.parseInt, window.parseInt are not supported",
                  );
                })(v);
              if (v.search(/.+[eE].+/) !== -1)
                return (function (k, n, p) {
                  if (!p.eNotation) return k;
                  let a = n.match(ZB);
                  if (a) {
                    let $A = a[1] || "",
                      bA = a[3].indexOf("e") === -1 ? "E" : "e",
                      AQ = a[2],
                      PA = $A ? k[AQ.length + 1] === bA : k[AQ.length] === bA;
                    return AQ.length > 1 && PA
                      ? k
                      : AQ.length !== 1 ||
                          (!a[3].startsWith(`.${bA}`) && a[3][0] !== bA)
                        ? p.leadingZeros && !PA
                          ? ((n = (a[1] || "") + a[3]), Number(n))
                          : k
                        : Number(n);
                  }
                  return k;
                })(V, v, h);
              {
                let k = RA.exec(v);
                if (k) {
                  let n = k[1] || "",
                    p = k[2],
                    a =
                      (P = k[3]) && P.indexOf(".") !== -1
                        ? ((P = P.replace(/0+$/, "")) === "."
                            ? (P = "0")
                            : P[0] === "."
                              ? (P = "0" + P)
                              : P[P.length - 1] === "." &&
                                (P = P.substring(0, P.length - 1)),
                          P)
                        : P,
                    $A = n ? V[p.length + 1] === "." : V[p.length] === ".";
                  if (
                    !h.leadingZeros &&
                    (p.length > 1 || (p.length === 1 && !$A))
                  )
                    return V;
                  {
                    let bA = Number(v),
                      AQ = String(bA);
                    if (bA === 0 || bA === -0) return bA;
                    if (AQ.search(/[eE]/) !== -1) return h.eNotation ? bA : V;
                    if (v.indexOf(".") !== -1)
                      return AQ === "0" || AQ === a || AQ === `${n}${a}`
                        ? bA
                        : V;
                    let PA = p ? a : v;
                    return p
                      ? PA === AQ || n + PA === AQ
                        ? bA
                        : V
                      : PA === AQ || PA === n + AQ
                        ? bA
                        : V;
                  }
                }
                return V;
              }
              var P;
            })(G, R))
        );
      }
      return G !== void 0 ? G : "";
    }
    let zG = IA.getMetaDataSymbol();
    function hy(G, U) {
      return s4(G, U);
    }
    function s4(G, U, R) {
      let T,
        V = {};
      for (let h = 0; h < G.length; h++) {
        let v = G[h],
          P = ky(v),
          k = "";
        if (((k = R === void 0 ? P : R + "." + P), P === U.textNodeName))
          T === void 0 ? (T = v[P]) : (T += "" + v[P]);
        else {
          if (P === void 0) continue;
          if (v[P]) {
            let n = s4(v[P], U, k),
              p = vy(n, U);
            v[zG] !== void 0 && (n[zG] = v[zG]),
              v[":@"]
                ? xy(n, v[":@"], k, U)
                : Object.keys(n).length !== 1 ||
                    n[U.textNodeName] === void 0 ||
                    U.alwaysCreateTextNode
                  ? Object.keys(n).length === 0 &&
                    (U.alwaysCreateTextNode
                      ? (n[U.textNodeName] = "")
                      : (n = ""))
                  : (n = n[U.textNodeName]),
              V[P] !== void 0 && V.hasOwnProperty(P)
                ? (Array.isArray(V[P]) || (V[P] = [V[P]]), V[P].push(n))
                : U.isArray(P, k, p)
                  ? (V[P] = [n])
                  : (V[P] = n);
          }
        }
      }
      return (
        typeof T == "string"
          ? T.length > 0 && (V[U.textNodeName] = T)
          : T !== void 0 && (V[U.textNodeName] = T),
        V
      );
    }
    function ky(G) {
      let U = Object.keys(G);
      for (let R = 0; R < U.length; R++) {
        let T = U[R];
        if (T !== ":@") return T;
      }
    }
    function xy(G, U, R, T) {
      if (U) {
        let V = Object.keys(U),
          h = V.length;
        for (let v = 0; v < h; v++) {
          let P = V[v];
          T.isArray(P, R + "." + P, !0, !0) ? (G[P] = [U[P]]) : (G[P] = U[P]);
        }
      }
    }
    function vy(G, U) {
      let { textNodeName: R } = U,
        T = Object.keys(G).length;
      return (
        T === 0 ||
        !(T !== 1 || (!G[R] && typeof G[R] != "boolean" && G[R] !== 0))
      );
    }
    class r4 {
      constructor(G) {
        (this.externalEntities = {}),
          (this.options = (function (U) {
            return Object.assign({}, r, U);
          })(G));
      }
      parse(G, U) {
        if (typeof G != "string" && G.toString) G = G.toString();
        else if (typeof G != "string")
          throw Error("XML data is accepted in String or Bytes[] form.");
        if (U) {
          U === !0 && (U = {});
          let V = F(G, U);
          if (V !== !0) throw Error(`${V.err.msg}:${V.err.line}:${V.err.col}`);
        }
        let R = new QE(this.options);
        R.addExternalEntities(this.externalEntities);
        let T = R.parseXml(G);
        return this.options.preserveOrder || T === void 0
          ? T
          : hy(T, this.options);
      }
      addEntity(G, U) {
        if (U.indexOf("&") !== -1) throw Error("Entity value can't have '&'");
        if (G.indexOf("&") !== -1 || G.indexOf(";") !== -1)
          throw Error(
            "An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'",
          );
        if (U === "&") throw Error("An entity with value '&' is not permitted");
        this.externalEntities[G] = U;
      }
      static getMetaDataSymbol() {
        return IA.getMetaDataSymbol();
      }
    }
    function Py(G, U) {
      let R = "";
      return (
        U.format &&
          U.indentBy.length > 0 &&
          (R = `
`),
        t4(G, U, "", R)
      );
    }
    function t4(G, U, R, T) {
      let V = "",
        h = !1;
      for (let v = 0; v < G.length; v++) {
        let P = G[v],
          k = _y(P);
        if (k === void 0) continue;
        let n = "";
        if (((n = R.length === 0 ? k : `${R}.${k}`), k === U.textNodeName)) {
          let bA = P[k];
          yy(n, U) || ((bA = U.tagValueProcessor(k, bA)), (bA = Aw(bA, U))),
            h && (V += T),
            (V += bA),
            (h = !1);
          continue;
        }
        if (k === U.cdataPropName) {
          h && (V += T),
            (V += `<![CDATA[${P[k][0][U.textNodeName]}]]>`),
            (h = !1);
          continue;
        }
        if (k === U.commentPropName) {
          (V += T + `<!--${P[k][0][U.textNodeName]}-->`), (h = !0);
          continue;
        }
        if (k[0] === "?") {
          let bA = e4(P[":@"], U),
            AQ = k === "?xml" ? "" : T,
            PA = P[k][0][U.textNodeName];
          (PA = PA.length !== 0 ? " " + PA : ""),
            (V += AQ + `<${k}${PA}${bA}?>`),
            (h = !0);
          continue;
        }
        let p = T;
        p !== "" && (p += U.indentBy);
        let a = T + `<${k}${e4(P[":@"], U)}`,
          $A = t4(P[k], U, n, p);
        U.unpairedTags.indexOf(k) !== -1
          ? U.suppressUnpairedNode
            ? (V += a + ">")
            : (V += a + "/>")
          : ($A && $A.length !== 0) || !U.suppressEmptyNode
            ? $A && $A.endsWith(">")
              ? (V += a + `>${$A}${T}</${k}>`)
              : ((V += a + ">"),
                $A && T !== "" && ($A.includes("/>") || $A.includes("</"))
                  ? (V += T + U.indentBy + $A + T)
                  : (V += $A),
                (V += `</${k}>`))
            : (V += a + "/>"),
          (h = !0);
      }
      return V;
    }
    function _y(G) {
      let U = Object.keys(G);
      for (let R = 0; R < U.length; R++) {
        let T = U[R];
        if (G.hasOwnProperty(T) && T !== ":@") return T;
      }
    }
    function e4(G, U) {
      let R = "";
      if (G && !U.ignoreAttributes)
        for (let T in G) {
          if (!G.hasOwnProperty(T)) continue;
          let V = U.attributeValueProcessor(T, G[T]);
          (V = Aw(V, U)),
            V === !0 && U.suppressBooleanAttributes
              ? (R += ` ${T.substr(U.attributeNamePrefix.length)}`)
              : (R += ` ${T.substr(U.attributeNamePrefix.length)}="${V}"`);
        }
      return R;
    }
    function yy(G, U) {
      let R = (G = G.substr(0, G.length - U.textNodeName.length - 1)).substr(
        G.lastIndexOf(".") + 1,
      );
      for (let T in U.stopNodes)
        if (U.stopNodes[T] === G || U.stopNodes[T] === "*." + R) return !0;
      return !1;
    }
    function Aw(G, U) {
      if (G && G.length > 0 && U.processEntities)
        for (let R = 0; R < U.entities.length; R++) {
          let T = U.entities[R];
          G = G.replace(T.regex, T.val);
        }
      return G;
    }
    let Sy = {
      attributeNamePrefix: "@_",
      attributesGroupName: !1,
      textNodeName: "#text",
      ignoreAttributes: !0,
      cdataPropName: !1,
      format: !1,
      indentBy: "  ",
      suppressEmptyNode: !1,
      suppressUnpairedNode: !0,
      suppressBooleanAttributes: !0,
      tagValueProcessor: function (G, U) {
        return U;
      },
      attributeValueProcessor: function (G, U) {
        return U;
      },
      preserveOrder: !1,
      commentPropName: !1,
      unpairedTags: [],
      entities: [
        { regex: new RegExp("&", "g"), val: "&amp;" },
        { regex: new RegExp(">", "g"), val: "&gt;" },
        { regex: new RegExp("<", "g"), val: "&lt;" },
        { regex: new RegExp("'", "g"), val: "&apos;" },
        { regex: new RegExp('"', "g"), val: "&quot;" },
      ],
      processEntities: !0,
      stopNodes: [],
      oneListGroup: !1,
    };
    function kE(G) {
      (this.options = Object.assign({}, Sy, G)),
        this.options.ignoreAttributes === !0 || this.options.attributesGroupName
          ? (this.isAttribute = function () {
              return !1;
            })
          : ((this.ignoreAttributesFn = jQ(this.options.ignoreAttributes)),
            (this.attrPrefixLen = this.options.attributeNamePrefix.length),
            (this.isAttribute = dy)),
        (this.processTextOrObjNode = by),
        this.options.format
          ? ((this.indentate = my),
            (this.tagEndChar = `>
`),
            (this.newLine = `
`))
          : ((this.indentate = function () {
              return "";
            }),
            (this.tagEndChar = ">"),
            (this.newLine = ""));
    }
    function by(G, U, R, T) {
      let V = this.j2x(G, R + 1, T.concat(U));
      return G[this.options.textNodeName] !== void 0 &&
        Object.keys(G).length === 1
        ? this.buildTextValNode(G[this.options.textNodeName], U, V.attrStr, R)
        : this.buildObjectNode(V.val, U, V.attrStr, R);
    }
    function my(G) {
      return this.options.indentBy.repeat(G);
    }
    function dy(G) {
      return (
        !(
          !G.startsWith(this.options.attributeNamePrefix) ||
          G === this.options.textNodeName
        ) && G.substr(this.attrPrefixLen)
      );
    }
    (kE.prototype.build = function (G) {
      return this.options.preserveOrder
        ? Py(G, this.options)
        : (Array.isArray(G) &&
            this.options.arrayNodeName &&
            this.options.arrayNodeName.length > 1 &&
            (G = { [this.options.arrayNodeName]: G }),
          this.j2x(G, 0, []).val);
    }),
      (kE.prototype.j2x = function (G, U, R) {
        let T = "",
          V = "",
          h = R.join(".");
        for (let v in G)
          if (Object.prototype.hasOwnProperty.call(G, v))
            if (G[v] === void 0) this.isAttribute(v) && (V += "");
            else if (G[v] === null)
              this.isAttribute(v) || v === this.options.cdataPropName
                ? (V += "")
                : v[0] === "?"
                  ? (V += this.indentate(U) + "<" + v + "?" + this.tagEndChar)
                  : (V += this.indentate(U) + "<" + v + "/" + this.tagEndChar);
            else if (G[v] instanceof Date)
              V += this.buildTextValNode(G[v], v, "", U);
            else if (typeof G[v] != "object") {
              let P = this.isAttribute(v);
              if (P && !this.ignoreAttributesFn(P, h))
                T += this.buildAttrPairStr(P, "" + G[v]);
              else if (!P)
                if (v === this.options.textNodeName) {
                  let k = this.options.tagValueProcessor(v, "" + G[v]);
                  V += this.replaceEntitiesValue(k);
                } else V += this.buildTextValNode(G[v], v, "", U);
            } else if (Array.isArray(G[v])) {
              let P = G[v].length,
                k = "",
                n = "";
              for (let p = 0; p < P; p++) {
                let a = G[v][p];
                if (a === void 0);
                else if (a === null)
                  v[0] === "?"
                    ? (V += this.indentate(U) + "<" + v + "?" + this.tagEndChar)
                    : (V +=
                        this.indentate(U) + "<" + v + "/" + this.tagEndChar);
                else if (typeof a == "object")
                  if (this.options.oneListGroup) {
                    let $A = this.j2x(a, U + 1, R.concat(v));
                    (k += $A.val),
                      this.options.attributesGroupName &&
                        a.hasOwnProperty(this.options.attributesGroupName) &&
                        (n += $A.attrStr);
                  } else k += this.processTextOrObjNode(a, v, U, R);
                else if (this.options.oneListGroup) {
                  let $A = this.options.tagValueProcessor(v, a);
                  ($A = this.replaceEntitiesValue($A)), (k += $A);
                } else k += this.buildTextValNode(a, v, "", U);
              }
              this.options.oneListGroup &&
                (k = this.buildObjectNode(k, v, n, U)),
                (V += k);
            } else if (
              this.options.attributesGroupName &&
              v === this.options.attributesGroupName
            ) {
              let P = Object.keys(G[v]),
                k = P.length;
              for (let n = 0; n < k; n++)
                T += this.buildAttrPairStr(P[n], "" + G[v][P[n]]);
            } else V += this.processTextOrObjNode(G[v], v, U, R);
        return { attrStr: T, val: V };
      }),
      (kE.prototype.buildAttrPairStr = function (G, U) {
        return (
          (U = this.options.attributeValueProcessor(G, "" + U)),
          (U = this.replaceEntitiesValue(U)),
          this.options.suppressBooleanAttributes && U === "true"
            ? " " + G
            : " " + G + '="' + U + '"'
        );
      }),
      (kE.prototype.buildObjectNode = function (G, U, R, T) {
        if (G === "")
          return U[0] === "?"
            ? this.indentate(T) + "<" + U + R + "?" + this.tagEndChar
            : this.indentate(T) +
                "<" +
                U +
                R +
                this.closeTag(U) +
                this.tagEndChar;
        {
          let V = "</" + U + this.tagEndChar,
            h = "";
          return (
            U[0] === "?" && ((h = "?"), (V = "")),
            (!R && R !== "") || G.indexOf("<") !== -1
              ? this.options.commentPropName !== !1 &&
                U === this.options.commentPropName &&
                h.length === 0
                ? this.indentate(T) + `<!--${G}-->` + this.newLine
                : this.indentate(T) +
                  "<" +
                  U +
                  R +
                  h +
                  this.tagEndChar +
                  G +
                  this.indentate(T) +
                  V
              : this.indentate(T) + "<" + U + R + h + ">" + G + V
          );
        }
      }),
      (kE.prototype.closeTag = function (G) {
        let U = "";
        return (
          this.options.unpairedTags.indexOf(G) !== -1
            ? this.options.suppressUnpairedNode || (U = "/")
            : (U = this.options.suppressEmptyNode ? "/" : `></${G}`),
          U
        );
      }),
      (kE.prototype.buildTextValNode = function (G, U, R, T) {
        if (
          this.options.cdataPropName !== !1 &&
          U === this.options.cdataPropName
        )
          return this.indentate(T) + `<![CDATA[${G}]]>` + this.newLine;
        if (
          this.options.commentPropName !== !1 &&
          U === this.options.commentPropName
        )
          return this.indentate(T) + `<!--${G}-->` + this.newLine;
        if (U[0] === "?")
          return this.indentate(T) + "<" + U + R + "?" + this.tagEndChar;
        {
          let V = this.options.tagValueProcessor(U, G);
          return (
            (V = this.replaceEntitiesValue(V)),
            V === ""
              ? this.indentate(T) +
                "<" +
                U +
                R +
                this.closeTag(U) +
                this.tagEndChar
              : this.indentate(T) +
                "<" +
                U +
                R +
                ">" +
                V +
                "</" +
                U +
                this.tagEndChar
          );
        }
      }),
      (kE.prototype.replaceEntitiesValue = function (G) {
        if (G && G.length > 0 && this.options.processEntities)
          for (let U = 0; U < this.options.entities.length; U++) {
            let R = this.options.entities[U];
            G = G.replace(R.regex, R.val);
          }
        return G;
      });
    let cy = { validate: F };
    Bj.exports = Q;
  })();
});
var gX = Z((Ej) => {
  Object.defineProperty(Ej, "__esModule", { value: !0 });
  Ej.XML_CHARKEY = Ej.XML_ATTRKEY = void 0;
  Ej.XML_ATTRKEY = "$";
  Ej.XML_CHARKEY = "_";
});
var Yj = Z((Dj) => {
  Object.defineProperty(Dj, "__esModule", { value: !0 });
  Dj.stringifyXML = RGA;
  Dj.parseXML = VGA;
  var FX = Ij(),
    gj = gX();
  function Fj(A) {
    var Q;
    return {
      attributesGroupName: gj.XML_ATTRKEY,
      textNodeName:
        (Q = A.xmlCharKey) !== null && Q !== void 0 ? Q : gj.XML_CHARKEY,
      ignoreAttributes: !1,
      suppressBooleanAttributes: !1,
    };
  }
  function MGA(A = {}) {
    var Q, B;
    return Object.assign(Object.assign({}, Fj(A)), {
      attributeNamePrefix: "@_",
      format: !0,
      suppressEmptyNode: !0,
      indentBy: "",
      rootNodeName: (Q = A.rootName) !== null && Q !== void 0 ? Q : "root",
      cdataPropName:
        (B = A.cdataPropName) !== null && B !== void 0 ? B : "__cdata",
    });
  }
  function LGA(A = {}) {
    return Object.assign(Object.assign({}, Fj(A)), {
      parseAttributeValue: !1,
      parseTagValue: !1,
      attributeNamePrefix: "",
      stopNodes: A.stopNodes,
      processEntities: !0,
      trimValues: !1,
    });
  }
  function RGA(A, Q = {}) {
    let B = MGA(Q),
      I = new FX.XMLBuilder(B),
      E = { [B.rootNodeName]: A };
    return `<?xml version="1.0" encoding="UTF-8" standalone="yes"?>${I.build(E)}`.replace(
      /\n/g,
      "",
    );
  }
  async function VGA(A, Q = {}) {
    if (!A) throw Error("Document is empty");
    let B = FX.XMLValidator.validate(A);
    if (B !== !0) throw B;
    let E = new FX.XMLParser(LGA(Q)).parse(A);
    if (E["?xml"]) delete E["?xml"];
    if (!Q.includeRoot)
      for (let C of Object.keys(E)) {
        let g = E[C];
        return typeof g === "object" ? Object.assign({}, g) : g;
      }
    return E;
  }
});
var DX = Z((Vg) => {
  Object.defineProperty(Vg, "__esModule", { value: !0 });
  Vg.XML_CHARKEY = Vg.XML_ATTRKEY = Vg.parseXML = Vg.stringifyXML = void 0;
  var Jj = Yj();
  Object.defineProperty(Vg, "stringifyXML", {
    enumerable: !0,
    get: function () {
      return Jj.stringifyXML;
    },
  });
  Object.defineProperty(Vg, "parseXML", {
    enumerable: !0,
    get: function () {
      return Jj.parseXML;
    },
  });
  var Nj = gX();
  Object.defineProperty(Vg, "XML_ATTRKEY", {
    enumerable: !0,
    get: function () {
      return Nj.XML_ATTRKEY;
    },
  });
  Object.defineProperty(Vg, "XML_CHARKEY", {
    enumerable: !0,
    get: function () {
      return Nj.XML_CHARKEY;
    },
  });
});
var $g = Z((Gj) => {
  Object.defineProperty(Gj, "__esModule", { value: !0 });
  Gj.logger = void 0;
  var zGA = eC();
  Gj.logger = (0, zGA.createClientLogger)("storage-blob");
});
var wj = Z((Zj) => {
  Object.defineProperty(Zj, "__esModule", { value: !0 });
  Zj.AbortError = void 0;
  class Wj extends Error {
    constructor(A) {
      super(A);
      this.name = "AbortError";
    }
  }
  Zj.AbortError = Wj;
});
var YD = Z((YX) => {
  Object.defineProperty(YX, "__esModule", { value: !0 });
  YX.AbortError = void 0;
  var TGA = wj();
  Object.defineProperty(YX, "AbortError", {
    enumerable: !0,
    get: function () {
      return TGA.AbortError;
    },
  });
});
var JD = Z((Lj) => {
  Object.defineProperty(Lj, "__esModule", { value: !0 });
  Lj.BaseRequestPolicy = void 0;
  class Mj {
    _nextPolicy;
    _options;
    constructor(A, Q) {
      (this._nextPolicy = A), (this._options = Q);
    }
    shouldLog(A) {
      return this._options.shouldLog(A);
    }
    log(A, Q) {
      this._options.log(A, Q);
    }
  }
  Lj.BaseRequestPolicy = Mj;
});
var KQ = Z((Vj) => {
  Object.defineProperty(Vj, "__esModule", { value: !0 });
  Vj.PathStylePorts =
    Vj.BlobDoesNotUseCustomerSpecifiedEncryption =
    Vj.BlobUsesCustomerSpecifiedEncryptionMsg =
    Vj.StorageBlobLoggingAllowedQueryParameters =
    Vj.StorageBlobLoggingAllowedHeaderNames =
    Vj.DevelopmentConnectionString =
    Vj.EncryptionAlgorithmAES25 =
    Vj.HTTP_VERSION_1_1 =
    Vj.HTTP_LINE_ENDING =
    Vj.BATCH_MAX_PAYLOAD_IN_BYTES =
    Vj.BATCH_MAX_REQUEST =
    Vj.SIZE_1_MB =
    Vj.ETagAny =
    Vj.ETagNone =
    Vj.HeaderConstants =
    Vj.HTTPURLConnection =
    Vj.URLConstants =
    Vj.StorageOAuthScopes =
    Vj.REQUEST_TIMEOUT =
    Vj.DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS =
    Vj.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES =
    Vj.DEFAULT_BLOCK_BUFFER_SIZE_BYTES =
    Vj.BLOCK_BLOB_MAX_BLOCKS =
    Vj.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES =
    Vj.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES =
    Vj.SERVICE_VERSION =
    Vj.SDK_VERSION =
      void 0;
  Vj.SDK_VERSION = "12.29.1";
  Vj.SERVICE_VERSION = "2025-11-05";
  Vj.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES = 268435456;
  Vj.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES = 4194304000;
  Vj.BLOCK_BLOB_MAX_BLOCKS = 50000;
  Vj.DEFAULT_BLOCK_BUFFER_SIZE_BYTES = 8388608;
  Vj.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES = 4194304;
  Vj.DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS = 5;
  Vj.REQUEST_TIMEOUT = 1e5;
  Vj.StorageOAuthScopes = "https://storage.azure.com/.default";
  Vj.URLConstants = {
    Parameters: {
      FORCE_BROWSER_NO_CACHE: "_",
      SIGNATURE: "sig",
      SNAPSHOT: "snapshot",
      VERSIONID: "versionid",
      TIMEOUT: "timeout",
    },
  };
  Vj.HTTPURLConnection = {
    HTTP_ACCEPTED: 202,
    HTTP_CONFLICT: 409,
    HTTP_NOT_FOUND: 404,
    HTTP_PRECON_FAILED: 412,
    HTTP_RANGE_NOT_SATISFIABLE: 416,
  };
  Vj.HeaderConstants = {
    AUTHORIZATION: "Authorization",
    AUTHORIZATION_SCHEME: "Bearer",
    CONTENT_ENCODING: "Content-Encoding",
    CONTENT_ID: "Content-ID",
    CONTENT_LANGUAGE: "Content-Language",
    CONTENT_LENGTH: "Content-Length",
    CONTENT_MD5: "Content-Md5",
    CONTENT_TRANSFER_ENCODING: "Content-Transfer-Encoding",
    CONTENT_TYPE: "Content-Type",
    COOKIE: "Cookie",
    DATE: "date",
    IF_MATCH: "if-match",
    IF_MODIFIED_SINCE: "if-modified-since",
    IF_NONE_MATCH: "if-none-match",
    IF_UNMODIFIED_SINCE: "if-unmodified-since",
    PREFIX_FOR_STORAGE: "x-ms-",
    RANGE: "Range",
    USER_AGENT: "User-Agent",
    X_MS_CLIENT_REQUEST_ID: "x-ms-client-request-id",
    X_MS_COPY_SOURCE: "x-ms-copy-source",
    X_MS_DATE: "x-ms-date",
    X_MS_ERROR_CODE: "x-ms-error-code",
    X_MS_VERSION: "x-ms-version",
    X_MS_CopySourceErrorCode: "x-ms-copy-source-error-code",
  };
  Vj.ETagNone = "";
  Vj.ETagAny = "*";
  Vj.SIZE_1_MB = 1048576;
  Vj.BATCH_MAX_REQUEST = 256;
  Vj.BATCH_MAX_PAYLOAD_IN_BYTES = 4 * Vj.SIZE_1_MB;
  Vj.HTTP_LINE_ENDING = `\r
`;
  Vj.HTTP_VERSION_1_1 = "HTTP/1.1";
  Vj.EncryptionAlgorithmAES25 = "AES256";
  Vj.DevelopmentConnectionString =
    "DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;";
  Vj.StorageBlobLoggingAllowedHeaderNames = [
    "Access-Control-Allow-Origin",
    "Cache-Control",
    "Content-Length",
    "Content-Type",
    "Date",
    "Request-Id",
    "traceparent",
    "Transfer-Encoding",
    "User-Agent",
    "x-ms-client-request-id",
    "x-ms-date",
    "x-ms-error-code",
    "x-ms-request-id",
    "x-ms-return-client-request-id",
    "x-ms-version",
    "Accept-Ranges",
    "Content-Disposition",
    "Content-Encoding",
    "Content-Language",
    "Content-MD5",
    "Content-Range",
    "ETag",
    "Last-Modified",
    "Server",
    "Vary",
    "x-ms-content-crc64",
    "x-ms-copy-action",
    "x-ms-copy-completion-time",
    "x-ms-copy-id",
    "x-ms-copy-progress",
    "x-ms-copy-status",
    "x-ms-has-immutability-policy",
    "x-ms-has-legal-hold",
    "x-ms-lease-state",
    "x-ms-lease-status",
    "x-ms-range",
    "x-ms-request-server-encrypted",
    "x-ms-server-encrypted",
    "x-ms-snapshot",
    "x-ms-source-range",
    "If-Match",
    "If-Modified-Since",
    "If-None-Match",
    "If-Unmodified-Since",
    "x-ms-access-tier",
    "x-ms-access-tier-change-time",
    "x-ms-access-tier-inferred",
    "x-ms-account-kind",
    "x-ms-archive-status",
    "x-ms-blob-append-offset",
    "x-ms-blob-cache-control",
    "x-ms-blob-committed-block-count",
    "x-ms-blob-condition-appendpos",
    "x-ms-blob-condition-maxsize",
    "x-ms-blob-content-disposition",
    "x-ms-blob-content-encoding",
    "x-ms-blob-content-language",
    "x-ms-blob-content-length",
    "x-ms-blob-content-md5",
    "x-ms-blob-content-type",
    "x-ms-blob-public-access",
    "x-ms-blob-sequence-number",
    "x-ms-blob-type",
    "x-ms-copy-destination-snapshot",
    "x-ms-creation-time",
    "x-ms-default-encryption-scope",
    "x-ms-delete-snapshots",
    "x-ms-delete-type-permanent",
    "x-ms-deny-encryption-scope-override",
    "x-ms-encryption-algorithm",
    "x-ms-if-sequence-number-eq",
    "x-ms-if-sequence-number-le",
    "x-ms-if-sequence-number-lt",
    "x-ms-incremental-copy",
    "x-ms-lease-action",
    "x-ms-lease-break-period",
    "x-ms-lease-duration",
    "x-ms-lease-id",
    "x-ms-lease-time",
    "x-ms-page-write",
    "x-ms-proposed-lease-id",
    "x-ms-range-get-content-md5",
    "x-ms-rehydrate-priority",
    "x-ms-sequence-number-action",
    "x-ms-sku-name",
    "x-ms-source-content-md5",
    "x-ms-source-if-match",
    "x-ms-source-if-modified-since",
    "x-ms-source-if-none-match",
    "x-ms-source-if-unmodified-since",
    "x-ms-tag-count",
    "x-ms-encryption-key-sha256",
    "x-ms-copy-source-error-code",
    "x-ms-copy-source-status-code",
    "x-ms-if-tags",
    "x-ms-source-if-tags",
  ];
  Vj.StorageBlobLoggingAllowedQueryParameters = [
    "comp",
    "maxresults",
    "rscc",
    "rscd",
    "rsce",
    "rscl",
    "rsct",
    "se",
    "si",
    "sip",
    "sp",
    "spr",
    "sr",
    "srt",
    "ss",
    "st",
    "sv",
    "include",
    "marker",
    "prefix",
    "copyid",
    "restype",
    "blockid",
    "blocklisttype",
    "delimiter",
    "prevsnapshot",
    "ske",
    "skoid",
    "sks",
    "skt",
    "sktid",
    "skv",
    "snapshot",
  ];
  Vj.BlobUsesCustomerSpecifiedEncryptionMsg =
    "BlobUsesCustomerSpecifiedEncryption";
  Vj.BlobDoesNotUseCustomerSpecifiedEncryption =
    "BlobDoesNotUseCustomerSpecifiedEncryption";
  Vj.PathStylePorts = [
    "10000",
    "10001",
    "10002",
    "10003",
    "10004",
    "10100",
    "10101",
    "10102",
    "10103",
    "10104",
    "11000",
    "11001",
    "11002",
    "11003",
    "11004",
    "11100",
    "11101",
    "11102",
    "11103",
    "11104",
  ];
});
var yQ = Z((kj) => {
  Object.defineProperty(kj, "__esModule", { value: !0 });
  kj.escapeURLPath = AUA;
  kj.getValueInConnString = EC;
  kj.extractConnectionStringParts = BUA;
  kj.appendToURLPath = EUA;
  kj.setURLParameter = zj;
  kj.getURLParameter = Tj;
  kj.setURLHost = CUA;
  kj.getURLPath = gUA;
  kj.getURLScheme = FUA;
  kj.getURLPathAndQuery = DUA;
  kj.getURLQueries = YUA;
  kj.appendToURLQuery = JUA;
  kj.truncatedISO8061Date = NUA;
  kj.base64encode = Oj;
  kj.base64decode = GUA;
  kj.generateBlockID = UUA;
  kj.delay = WUA;
  kj.padStart = qj;
  kj.sanitizeURL = jj;
  kj.sanitizeHeaders = ZUA;
  kj.iEqual = XUA;
  kj.getAccountNameFromUrl = fj;
  kj.isIpEndpointStyle = hj;
  kj.toBlobTagsString = wUA;
  kj.toBlobTags = MUA;
  kj.toTags = LUA;
  kj.toQuerySerialization = RUA;
  kj.parseObjectReplicationRecord = VUA;
  kj.attachCredential = $UA;
  kj.httpAuthorizationToString = HUA;
  kj.BlobNameToString = ZN;
  kj.ConvertInternalResponseOfListBlobFlat = KUA;
  kj.ConvertInternalResponseOfListBlobHierarchy = zUA;
  kj.ExtractPageRangeInfoItems = TUA;
  kj.EscapePath = OUA;
  kj.assertResponse = qUA;
  var eGA = HQ(),
    Kj = lA(),
    Hg = KQ();
  function AUA(A) {
    let Q = new URL(A),
      B = Q.pathname;
    return (B = B || "/"), (B = IUA(B)), (Q.pathname = B), Q.toString();
  }
  function QUA(A) {
    let Q = "";
    if (A.search("DevelopmentStorageProxyUri=") !== -1) {
      let B = A.split(";");
      for (let I of B)
        if (I.trim().startsWith("DevelopmentStorageProxyUri="))
          Q = I.trim().match("DevelopmentStorageProxyUri=(.*)")[1];
    }
    return Q;
  }
  function EC(A, Q) {
    let B = A.split(";");
    for (let I of B)
      if (I.trim().startsWith(Q)) return I.trim().match(Q + "=(.*)")[1];
    return "";
  }
  function BUA(A) {
    let Q = "";
    if (A.startsWith("UseDevelopmentStorage=true"))
      (Q = QUA(A)), (A = Hg.DevelopmentConnectionString);
    let B = EC(A, "BlobEndpoint");
    if (
      ((B = B.endsWith("/") ? B.slice(0, -1) : B),
      A.search("DefaultEndpointsProtocol=") !== -1 &&
        A.search("AccountKey=") !== -1)
    ) {
      let I = "",
        E = "",
        C = Buffer.from("accountKey", "base64"),
        g = "";
      if (
        ((E = EC(A, "AccountName")),
        (C = Buffer.from(EC(A, "AccountKey"), "base64")),
        !B)
      ) {
        I = EC(A, "DefaultEndpointsProtocol");
        let F = I.toLowerCase();
        if (F !== "https" && F !== "http")
          throw Error(
            "Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'",
          );
        if (((g = EC(A, "EndpointSuffix")), !g))
          throw Error(
            "Invalid EndpointSuffix in the provided Connection String",
          );
        B = `${I}://${E}.blob.${g}`;
      }
      if (!E)
        throw Error("Invalid AccountName in the provided Connection String");
      else if (C.length === 0)
        throw Error("Invalid AccountKey in the provided Connection String");
      return {
        kind: "AccountConnString",
        url: B,
        accountName: E,
        accountKey: C,
        proxyUri: Q,
      };
    } else {
      let I = EC(A, "SharedAccessSignature"),
        E = EC(A, "AccountName");
      if (!E) E = fj(B);
      if (!B)
        throw Error(
          "Invalid BlobEndpoint in the provided SAS Connection String",
        );
      else if (!I)
        throw Error(
          "Invalid SharedAccessSignature in the provided SAS Connection String",
        );
      if (I.startsWith("?")) I = I.substring(1);
      return { kind: "SASConnString", url: B, accountName: E, accountSas: I };
    }
  }
  function IUA(A) {
    return encodeURIComponent(A)
      .replace(/%2F/g, "/")
      .replace(/'/g, "%27")
      .replace(/\+/g, "%20")
      .replace(/%25/g, "%");
  }
  function EUA(A, Q) {
    let B = new URL(A),
      I = B.pathname;
    return (
      (I = I ? (I.endsWith("/") ? `${I}${Q}` : `${I}/${Q}`) : Q),
      (B.pathname = I),
      B.toString()
    );
  }
  function zj(A, Q, B) {
    let I = new URL(A),
      E = encodeURIComponent(Q),
      C = B ? encodeURIComponent(B) : void 0,
      g = I.search === "" ? "?" : I.search,
      F = [];
    for (let D of g.slice(1).split("&"))
      if (D) {
        let [J] = D.split("=", 2);
        if (J !== E) F.push(D);
      }
    if (C) F.push(`${E}=${C}`);
    return (I.search = F.length ? `?${F.join("&")}` : ""), I.toString();
  }
  function Tj(A, Q) {
    return new URL(A).searchParams.get(Q) ?? void 0;
  }
  function CUA(A, Q) {
    let B = new URL(A);
    return (B.hostname = Q), B.toString();
  }
  function gUA(A) {
    try {
      return new URL(A).pathname;
    } catch (Q) {
      return;
    }
  }
  function FUA(A) {
    try {
      let Q = new URL(A);
      return Q.protocol.endsWith(":") ? Q.protocol.slice(0, -1) : Q.protocol;
    } catch (Q) {
      return;
    }
  }
  function DUA(A) {
    let Q = new URL(A),
      B = Q.pathname;
    if (!B) throw RangeError("Invalid url without valid path.");
    let I = Q.search || "";
    if (((I = I.trim()), I !== "")) I = I.startsWith("?") ? I : `?${I}`;
    return `${B}${I}`;
  }
  function YUA(A) {
    let Q = new URL(A).search;
    if (!Q) return {};
    (Q = Q.trim()), (Q = Q.startsWith("?") ? Q.substring(1) : Q);
    let B = Q.split("&");
    B = B.filter((E) => {
      let C = E.indexOf("="),
        g = E.lastIndexOf("=");
      return C > 0 && C === g && g < E.length - 1;
    });
    let I = {};
    for (let E of B) {
      let C = E.split("="),
        g = C[0],
        F = C[1];
      I[g] = F;
    }
    return I;
  }
  function JUA(A, Q) {
    let B = new URL(A),
      I = B.search;
    if (I) I += "&" + Q;
    else I = Q;
    return (B.search = I), B.toString();
  }
  function NUA(A, Q = !0) {
    let B = A.toISOString();
    return Q
      ? B.substring(0, B.length - 1) + "0000Z"
      : B.substring(0, B.length - 5) + "Z";
  }
  function Oj(A) {
    return !Kj.isNodeLike ? btoa(A) : Buffer.from(A).toString("base64");
  }
  function GUA(A) {
    return !Kj.isNodeLike ? atob(A) : Buffer.from(A, "base64").toString();
  }
  function UUA(A, Q) {
    if (A.length > 42) A = A.slice(0, 42);
    let C = A + qj(Q.toString(), 48 - A.length, "0");
    return Oj(C);
  }
  async function WUA(A, Q, B) {
    return new Promise((I, E) => {
      let C,
        g = () => {
          if (C !== void 0) clearTimeout(C);
          E(B);
        };
      if (
        ((C = setTimeout(() => {
          if (Q !== void 0) Q.removeEventListener("abort", g);
          I();
        }, A)),
        Q !== void 0)
      )
        Q.addEventListener("abort", g);
    });
  }
  function qj(A, Q, B = " ") {
    if (String.prototype.padStart) return A.padStart(Q, B);
    if (((B = B || " "), A.length > Q)) return A;
    else {
      if (((Q = Q - A.length), Q > B.length)) B += B.repeat(Q / B.length);
      return B.slice(0, Q) + A;
    }
  }
  function jj(A) {
    let Q = A;
    if (Tj(Q, Hg.URLConstants.Parameters.SIGNATURE))
      Q = zj(Q, Hg.URLConstants.Parameters.SIGNATURE, "*****");
    return Q;
  }
  function ZUA(A) {
    let Q = (0, eGA.createHttpHeaders)();
    for (let [B, I] of A)
      if (B.toLowerCase() === Hg.HeaderConstants.AUTHORIZATION.toLowerCase())
        Q.set(B, "*****");
      else if (B.toLowerCase() === Hg.HeaderConstants.X_MS_COPY_SOURCE)
        Q.set(B, jj(I));
      else Q.set(B, I);
    return Q;
  }
  function XUA(A, Q) {
    return A.toLocaleLowerCase() === Q.toLocaleLowerCase();
  }
  function fj(A) {
    let Q = new URL(A),
      B;
    try {
      if (Q.hostname.split(".")[1] === "blob") B = Q.hostname.split(".")[0];
      else if (hj(Q)) B = Q.pathname.split("/")[1];
      else B = "";
      return B;
    } catch (I) {
      throw Error("Unable to extract accountName with provided information.");
    }
  }
  function hj(A) {
    let Q = A.host;
    return (
      /^.*:.*:.*$|^(localhost|host.docker.internal)(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(
        Q,
      ) ||
      (Boolean(A.port) && Hg.PathStylePorts.includes(A.port))
    );
  }
  function wUA(A) {
    if (A === void 0) return;
    let Q = [];
    for (let B in A)
      if (Object.prototype.hasOwnProperty.call(A, B)) {
        let I = A[B];
        Q.push(`${encodeURIComponent(B)}=${encodeURIComponent(I)}`);
      }
    return Q.join("&");
  }
  function MUA(A) {
    if (A === void 0) return;
    let Q = { blobTagSet: [] };
    for (let B in A)
      if (Object.prototype.hasOwnProperty.call(A, B)) {
        let I = A[B];
        Q.blobTagSet.push({ key: B, value: I });
      }
    return Q;
  }
  function LUA(A) {
    if (A === void 0) return;
    let Q = {};
    for (let B of A.blobTagSet) Q[B.key] = B.value;
    return Q;
  }
  function RUA(A) {
    if (A === void 0) return;
    switch (A.kind) {
      case "csv":
        return {
          format: {
            type: "delimited",
            delimitedTextConfiguration: {
              columnSeparator: A.columnSeparator || ",",
              fieldQuote: A.fieldQuote || "",
              recordSeparator: A.recordSeparator,
              escapeChar: A.escapeCharacter || "",
              headersPresent: A.hasHeaders || !1,
            },
          },
        };
      case "json":
        return {
          format: {
            type: "json",
            jsonTextConfiguration: { recordSeparator: A.recordSeparator },
          },
        };
      case "arrow":
        return {
          format: { type: "arrow", arrowConfiguration: { schema: A.schema } },
        };
      case "parquet":
        return { format: { type: "parquet" } };
      default:
        throw Error("Invalid BlobQueryTextConfiguration.");
    }
  }
  function VUA(A) {
    if (!A) return;
    if ("policy-id" in A) return;
    let Q = [];
    for (let B in A) {
      let I = B.split("_"),
        E = "or-";
      if (I[0].startsWith("or-")) I[0] = I[0].substring(3);
      let C = { ruleId: I[1], replicationStatus: A[B] },
        g = Q.findIndex((F) => F.policyId === I[0]);
      if (g > -1) Q[g].rules.push(C);
      else Q.push({ policyId: I[0], rules: [C] });
    }
    return Q;
  }
  function $UA(A, Q) {
    return (A.credential = Q), A;
  }
  function HUA(A) {
    return A ? A.scheme + " " + A.value : void 0;
  }
  function ZN(A) {
    if (A.encoded) return decodeURIComponent(A.content);
    else return A.content;
  }
  function KUA(A) {
    return {
      ...A,
      segment: {
        blobItems: A.segment.blobItems.map((Q) => {
          return { ...Q, name: ZN(Q.name) };
        }),
      },
    };
  }
  function zUA(A) {
    return {
      ...A,
      segment: {
        blobPrefixes: A.segment.blobPrefixes?.map((Q) => {
          return { ...Q, name: ZN(Q.name) };
        }),
        blobItems: A.segment.blobItems.map((Q) => {
          return { ...Q, name: ZN(Q.name) };
        }),
      },
    };
  }
  function* TUA(A) {
    let Q = [],
      B = [];
    if (A.pageRange) Q = A.pageRange;
    if (A.clearRange) B = A.clearRange;
    let I = 0,
      E = 0;
    while (I < Q.length && E < B.length)
      if (Q[I].start < B[E].start)
        yield { start: Q[I].start, end: Q[I].end, isClear: !1 }, ++I;
      else yield { start: B[E].start, end: B[E].end, isClear: !0 }, ++E;
    for (; I < Q.length; ++I)
      yield { start: Q[I].start, end: Q[I].end, isClear: !1 };
    for (; E < B.length; ++E)
      yield { start: B[E].start, end: B[E].end, isClear: !0 };
  }
  function OUA(A) {
    let Q = A.split("/");
    for (let B = 0; B < Q.length; B++) Q[B] = encodeURIComponent(Q[B]);
    return Q.join("/");
  }
  function qUA(A) {
    if ("_response" in A) return A;
    throw TypeError(`Unexpected response object ${A}`);
  }
});
var JX = Z((vj) => {
  Object.defineProperty(vj, "__esModule", { value: !0 });
  vj.StorageRetryPolicyType = void 0;
  var xj;
  (function (A) {
    (A[(A.EXPONENTIAL = 0)] = "EXPONENTIAL"), (A[(A.FIXED = 1)] = "FIXED");
  })(xj || (vj.StorageRetryPolicyType = xj = {}));
});
var bj = Z((yj) => {
  Object.defineProperty(yj, "__esModule", { value: !0 });
  yj.StorageRetryPolicy = void 0;
  yj.NewRetryPolicyFactory = UWA;
  var NWA = YD(),
    GWA = JD(),
    _j = KQ(),
    NX = yQ(),
    CC = $g(),
    GX = JX();
  function UWA(A) {
    return {
      create: (Q, B) => {
        return new UX(Q, B, A);
      },
    };
  }
  var gC = {
      maxRetryDelayInMs: 120000,
      maxTries: 4,
      retryDelayInMs: 4000,
      retryPolicyType: GX.StorageRetryPolicyType.EXPONENTIAL,
      secondaryHost: "",
      tryTimeoutInMs: void 0,
    },
    WWA = new NWA.AbortError("The operation was aborted.");
  class UX extends GWA.BaseRequestPolicy {
    retryOptions;
    constructor(A, Q, B = gC) {
      super(A, Q);
      this.retryOptions = {
        retryPolicyType: B.retryPolicyType
          ? B.retryPolicyType
          : gC.retryPolicyType,
        maxTries:
          B.maxTries && B.maxTries >= 1 ? Math.floor(B.maxTries) : gC.maxTries,
        tryTimeoutInMs:
          B.tryTimeoutInMs && B.tryTimeoutInMs >= 0
            ? B.tryTimeoutInMs
            : gC.tryTimeoutInMs,
        retryDelayInMs:
          B.retryDelayInMs && B.retryDelayInMs >= 0
            ? Math.min(
                B.retryDelayInMs,
                B.maxRetryDelayInMs
                  ? B.maxRetryDelayInMs
                  : gC.maxRetryDelayInMs,
              )
            : gC.retryDelayInMs,
        maxRetryDelayInMs:
          B.maxRetryDelayInMs && B.maxRetryDelayInMs >= 0
            ? B.maxRetryDelayInMs
            : gC.maxRetryDelayInMs,
        secondaryHost: B.secondaryHost ? B.secondaryHost : gC.secondaryHost,
      };
    }
    async sendRequest(A) {
      return this.attemptSendRequest(A, !1, 1);
    }
    async attemptSendRequest(A, Q, B) {
      let I = A.clone(),
        E =
          Q ||
          !this.retryOptions.secondaryHost ||
          !(
            A.method === "GET" ||
            A.method === "HEAD" ||
            A.method === "OPTIONS"
          ) ||
          B % 2 === 1;
      if (!E)
        I.url = (0, NX.setURLHost)(I.url, this.retryOptions.secondaryHost);
      if (this.retryOptions.tryTimeoutInMs)
        I.url = (0, NX.setURLParameter)(
          I.url,
          _j.URLConstants.Parameters.TIMEOUT,
          Math.floor(this.retryOptions.tryTimeoutInMs / 1000).toString(),
        );
      let C;
      try {
        if (
          (CC.logger.info(
            `RetryPolicy: =====> Try=${B} ${E ? "Primary" : "Secondary"}`,
          ),
          (C = await this._nextPolicy.sendRequest(I)),
          !this.shouldRetry(E, B, C))
        )
          return C;
        Q = Q || (!E && C.status === 404);
      } catch (g) {
        if (
          (CC.logger.error(
            `RetryPolicy: Caught error, message: ${g.message}, code: ${g.code}`,
          ),
          !this.shouldRetry(E, B, C, g))
        )
          throw g;
      }
      return (
        await this.delay(E, B, A.abortSignal),
        this.attemptSendRequest(A, Q, ++B)
      );
    }
    shouldRetry(A, Q, B, I) {
      if (Q >= this.retryOptions.maxTries)
        return (
          CC.logger.info(
            `RetryPolicy: Attempt(s) ${Q} >= maxTries ${this.retryOptions.maxTries}, no further try.`,
          ),
          !1
        );
      let E = [
        "ETIMEDOUT",
        "ESOCKETTIMEDOUT",
        "ECONNREFUSED",
        "ECONNRESET",
        "ENOENT",
        "ENOTFOUND",
        "TIMEOUT",
        "EPIPE",
        "REQUEST_SEND_ERROR",
      ];
      if (I) {
        for (let C of E)
          if (
            I.name.toUpperCase().includes(C) ||
            I.message.toUpperCase().includes(C) ||
            (I.code && I.code.toString().toUpperCase() === C)
          )
            return (
              CC.logger.info(
                `RetryPolicy: Network error ${C} found, will retry.`,
              ),
              !0
            );
      }
      if (B || I) {
        let C = B ? B.status : I ? I.statusCode : 0;
        if (!A && C === 404)
          return (
            CC.logger.info(
              "RetryPolicy: Secondary access with 404, will retry.",
            ),
            !0
          );
        if (C === 503 || C === 500)
          return (
            CC.logger.info(`RetryPolicy: Will retry for status code ${C}.`), !0
          );
      }
      if (B) {
        if (B?.status >= 400) {
          let C = B.headers.get(_j.HeaderConstants.X_MS_CopySourceErrorCode);
          if (C !== void 0)
            switch (C) {
              case "InternalError":
              case "OperationTimedOut":
              case "ServerBusy":
                return !0;
            }
        }
      }
      if (
        I?.code === "PARSE_ERROR" &&
        I?.message.startsWith('Error "Error: Unclosed root tag')
      )
        return (
          CC.logger.info(
            "RetryPolicy: Incomplete XML response likely due to service timeout, will retry.",
          ),
          !0
        );
      return !1;
    }
    async delay(A, Q, B) {
      let I = 0;
      if (A)
        switch (this.retryOptions.retryPolicyType) {
          case GX.StorageRetryPolicyType.EXPONENTIAL:
            I = Math.min(
              (Math.pow(2, Q - 1) - 1) * this.retryOptions.retryDelayInMs,
              this.retryOptions.maxRetryDelayInMs,
            );
            break;
          case GX.StorageRetryPolicyType.FIXED:
            I = this.retryOptions.retryDelayInMs;
            break;
        }
      else I = Math.random() * 1000;
      return (
        CC.logger.info(`RetryPolicy: Delay for ${I}ms`),
        (0, NX.delay)(I, B, WWA)
      );
    }
  }
  yj.StorageRetryPolicy = UX;
});
var ND = Z((XN) => {
  Object.defineProperty(XN, "__esModule", { value: !0 });
  XN.StorageRetryPolicyFactory =
    XN.StorageRetryPolicy =
    XN.StorageRetryPolicyType =
      void 0;
  var mj = bj();
  Object.defineProperty(XN, "StorageRetryPolicy", {
    enumerable: !0,
    get: function () {
      return mj.StorageRetryPolicy;
    },
  });
  var XWA = JX();
  Object.defineProperty(XN, "StorageRetryPolicyType", {
    enumerable: !0,
    get: function () {
      return XWA.StorageRetryPolicyType;
    },
  });
  class dj {
    retryOptions;
    constructor(A) {
      this.retryOptions = A;
    }
    create(A, Q) {
      return new mj.StorageRetryPolicy(A, Q, this.retryOptions);
    }
  }
  XN.StorageRetryPolicyFactory = dj;
});
var wN = Z((lj) => {
  Object.defineProperty(lj, "__esModule", { value: !0 });
  lj.CredentialPolicy = void 0;
  var wWA = JD();
  class uj extends wWA.BaseRequestPolicy {
    sendRequest(A) {
      return this._nextPolicy.sendRequest(this.signRequest(A));
    }
    signRequest(A) {
      return A;
    }
  }
  lj.CredentialPolicy = uj;
});
var WX = Z((ij) => {
  Object.defineProperty(ij, "__esModule", { value: !0 });
  ij.compareHeader = VWA;
  var MWA = new Uint32Array([
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 1820, 0, 1823, 1825, 1827, 1829, 0, 0, 0, 1837,
      2051, 0, 0, 1843, 0, 3331, 3354, 3356, 3358, 3360, 3362, 3364, 3366, 3368,
      3370, 0, 0, 0, 0, 0, 0, 0, 3586, 3593, 3594, 3610, 3617, 3619, 3621, 3628,
      3634, 3637, 3638, 3656, 3665, 3696, 3708, 3710, 3721, 3722, 3729, 3737,
      3743, 3746, 3748, 3750, 3751, 3753, 0, 0, 0, 1859, 1860, 1864, 3586, 3593,
      3594, 3610, 3617, 3619, 3621, 3628, 3634, 3637, 3638, 3656, 3665, 3696,
      3708, 3710, 3721, 3722, 3729, 3737, 3743, 3746, 3748, 3750, 3751, 3753, 0,
      1868, 0, 1872, 0,
    ]),
    LWA = new Uint32Array([
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 18, 18, 18, 18, 18, 18,
      18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
      18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ]),
    RWA = new Uint32Array([
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32786, 0, 0, 0, 0, 0, 33298, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0,
    ]);
  function VWA(A, Q) {
    if ($WA(A, Q)) return -1;
    return 1;
  }
  function $WA(A, Q) {
    let B = [MWA, LWA, RWA],
      I = 0,
      E = 0,
      C = 0;
    while (I < B.length) {
      if (I === B.length - 1 && E !== C) return E > C;
      let g = E < A.length ? B[I][A[E].charCodeAt(0)] : 1,
        F = C < Q.length ? B[I][Q[C].charCodeAt(0)] : 1;
      if (g === 1 && F === 1) (E = 0), (C = 0), ++I;
      else if (g === F) ++E, ++C;
      else if (g === 0) ++E;
      else if (F === 0) ++C;
      else return g < F;
    }
    return !1;
  }
});
var ZX = Z((oj) => {
  Object.defineProperty(oj, "__esModule", { value: !0 });
  oj.StorageSharedKeyCredentialPolicy = void 0;
  var eQ = KQ(),
    nj = yQ(),
    KWA = wN(),
    zWA = WX();
  class aj extends KWA.CredentialPolicy {
    factory;
    constructor(A, Q, B) {
      super(A, Q);
      this.factory = B;
    }
    signRequest(A) {
      if (
        (A.headers.set(eQ.HeaderConstants.X_MS_DATE, new Date().toUTCString()),
        A.body &&
          (typeof A.body === "string" || A.body !== void 0) &&
          A.body.length > 0)
      )
        A.headers.set(
          eQ.HeaderConstants.CONTENT_LENGTH,
          Buffer.byteLength(A.body),
        );
      let Q =
          [
            A.method.toUpperCase(),
            this.getHeaderValueToSign(A, eQ.HeaderConstants.CONTENT_LANGUAGE),
            this.getHeaderValueToSign(A, eQ.HeaderConstants.CONTENT_ENCODING),
            this.getHeaderValueToSign(A, eQ.HeaderConstants.CONTENT_LENGTH),
            this.getHeaderValueToSign(A, eQ.HeaderConstants.CONTENT_MD5),
            this.getHeaderValueToSign(A, eQ.HeaderConstants.CONTENT_TYPE),
            this.getHeaderValueToSign(A, eQ.HeaderConstants.DATE),
            this.getHeaderValueToSign(A, eQ.HeaderConstants.IF_MODIFIED_SINCE),
            this.getHeaderValueToSign(A, eQ.HeaderConstants.IF_MATCH),
            this.getHeaderValueToSign(A, eQ.HeaderConstants.IF_NONE_MATCH),
            this.getHeaderValueToSign(
              A,
              eQ.HeaderConstants.IF_UNMODIFIED_SINCE,
            ),
            this.getHeaderValueToSign(A, eQ.HeaderConstants.RANGE),
          ].join(`
`) +
          `
` +
          this.getCanonicalizedHeadersString(A) +
          this.getCanonicalizedResourceString(A),
        B = this.factory.computeHMACSHA256(Q);
      return (
        A.headers.set(
          eQ.HeaderConstants.AUTHORIZATION,
          `SharedKey ${this.factory.accountName}:${B}`,
        ),
        A
      );
    }
    getHeaderValueToSign(A, Q) {
      let B = A.headers.get(Q);
      if (!B) return "";
      if (Q === eQ.HeaderConstants.CONTENT_LENGTH && B === "0") return "";
      return B;
    }
    getCanonicalizedHeadersString(A) {
      let Q = A.headers.headersArray().filter((I) => {
        return I.name
          .toLowerCase()
          .startsWith(eQ.HeaderConstants.PREFIX_FOR_STORAGE);
      });
      Q.sort((I, E) => {
        return (0, zWA.compareHeader)(
          I.name.toLowerCase(),
          E.name.toLowerCase(),
        );
      }),
        (Q = Q.filter((I, E, C) => {
          if (E > 0 && I.name.toLowerCase() === C[E - 1].name.toLowerCase())
            return !1;
          return !0;
        }));
      let B = "";
      return (
        Q.forEach((I) => {
          B += `${I.name.toLowerCase().trimRight()}:${I.value.trimLeft()}
`;
        }),
        B
      );
    }
    getCanonicalizedResourceString(A) {
      let Q = (0, nj.getURLPath)(A.url) || "/",
        B = "";
      B += `/${this.factory.accountName}${Q}`;
      let I = (0, nj.getURLQueries)(A.url),
        E = {};
      if (I) {
        let C = [];
        for (let g in I)
          if (Object.prototype.hasOwnProperty.call(I, g)) {
            let F = g.toLowerCase();
            (E[F] = I[g]), C.push(F);
          }
        C.sort();
        for (let g of C)
          B += `
${g}:${decodeURIComponent(E[g])}`;
      }
      return B;
    }
  }
  oj.StorageSharedKeyCredentialPolicy = aj;
});
var MN = Z((tj) => {
  Object.defineProperty(tj, "__esModule", { value: !0 });
  tj.Credential = void 0;
  class rj {
    create(A, Q) {
      throw Error("Method should be implemented in children classes.");
    }
  }
  tj.Credential = rj;
});
var FC = Z((Qf) => {
  Object.defineProperty(Qf, "__esModule", { value: !0 });
  Qf.StorageSharedKeyCredential = void 0;
  var TWA = $("node:crypto"),
    OWA = ZX(),
    qWA = MN();
  class Af extends qWA.Credential {
    accountName;
    accountKey;
    constructor(A, Q) {
      super();
      (this.accountName = A), (this.accountKey = Buffer.from(Q, "base64"));
    }
    create(A, Q) {
      return new OWA.StorageSharedKeyCredentialPolicy(A, Q, this);
    }
    computeHMACSHA256(A) {
      return (0, TWA.createHmac)("sha256", this.accountKey)
        .update(A, "utf8")
        .digest("base64");
    }
  }
  Qf.StorageSharedKeyCredential = Af;
});
var XX = Z((Ef) => {
  Object.defineProperty(Ef, "__esModule", { value: !0 });
  Ef.AnonymousCredentialPolicy = void 0;
  var jWA = wN();
  class If extends jWA.CredentialPolicy {
    constructor(A, Q) {
      super(A, Q);
    }
  }
  Ef.AnonymousCredentialPolicy = If;
});
var DC = Z((Ff) => {
  Object.defineProperty(Ff, "__esModule", { value: !0 });
  Ff.AnonymousCredential = void 0;
  var fWA = XX(),
    hWA = MN();
  class gf extends hWA.Credential {
    create(A, Q) {
      return new fWA.AnonymousCredentialPolicy(A, Q);
    }
  }
  Ff.AnonymousCredential = gf;
});
var Gf = Z((Jf) => {
  Object.defineProperty(Jf, "__esModule", { value: !0 });
  Jf.BuffersStream = void 0;
  var kWA = $("node:stream");
  class Yf extends kWA.Readable {
    buffers;
    byteLength;
    byteOffsetInCurrentBuffer;
    bufferIndex;
    pushedBytesLength;
    constructor(A, Q, B) {
      super(B);
      (this.buffers = A),
        (this.byteLength = Q),
        (this.byteOffsetInCurrentBuffer = 0),
        (this.bufferIndex = 0),
        (this.pushedBytesLength = 0);
      let I = 0;
      for (let E of this.buffers) I += E.byteLength;
      if (I < this.byteLength)
        throw Error(
          "Data size shouldn't be larger than the total length of buffers.",
        );
    }
    _read(A) {
      if (this.pushedBytesLength >= this.byteLength) this.push(null);
      if (!A) A = this.readableHighWaterMark;
      let Q = [],
        B = 0;
      while (B < A && this.pushedBytesLength < this.byteLength) {
        let I = this.byteLength - this.pushedBytesLength,
          E =
            this.buffers[this.bufferIndex].byteLength -
            this.byteOffsetInCurrentBuffer,
          C = Math.min(E, I);
        if (C > A - B) {
          let g = this.byteOffsetInCurrentBuffer + A - B;
          Q.push(
            this.buffers[this.bufferIndex].slice(
              this.byteOffsetInCurrentBuffer,
              g,
            ),
          ),
            (this.pushedBytesLength += A - B),
            (this.byteOffsetInCurrentBuffer = g),
            (B = A);
          break;
        } else {
          let g = this.byteOffsetInCurrentBuffer + C;
          if (
            (Q.push(
              this.buffers[this.bufferIndex].slice(
                this.byteOffsetInCurrentBuffer,
                g,
              ),
            ),
            C === E)
          )
            (this.byteOffsetInCurrentBuffer = 0), this.bufferIndex++;
          else this.byteOffsetInCurrentBuffer = g;
          (this.pushedBytesLength += C), (B += C);
        }
      }
      if (Q.length > 1) this.push(Buffer.concat(Q));
      else if (Q.length === 1) this.push(Q[0]);
    }
  }
  Jf.BuffersStream = Yf;
});
var Xf = Z((Wf) => {
  Object.defineProperty(Wf, "__esModule", { value: !0 });
  Wf.PooledBuffer = void 0;
  var xWA = BQ(),
    vWA = Gf(),
    PWA = xWA.__importDefault($("node:buffer")),
    LN = PWA.default.constants.MAX_LENGTH;
  class Uf {
    buffers = [];
    capacity;
    _size;
    get size() {
      return this._size;
    }
    constructor(A, Q, B) {
      (this.capacity = A), (this._size = 0);
      let I = Math.ceil(A / LN);
      for (let E = 0; E < I; E++) {
        let C = E === I - 1 ? A % LN : LN;
        if (C === 0) C = LN;
        this.buffers.push(Buffer.allocUnsafe(C));
      }
      if (Q) this.fill(Q, B);
    }
    fill(A, Q) {
      this._size = Math.min(this.capacity, Q);
      let B = 0,
        I = 0,
        E = 0,
        C = 0,
        g = 0;
      while (g < this._size) {
        let F = A[B],
          D = this.buffers[I],
          J = F.copy(D, E, C);
        if (((g += J), (C += J), (E += J), C === F.length)) B++, (C = 0);
        if (E === D.length) I++, (E = 0);
      }
      if ((A.splice(0, B), A.length > 0)) A[0] = A[0].slice(C);
    }
    getReadableStream() {
      return new vWA.BuffersStream(this.buffers, this.size);
    }
  }
  Wf.PooledBuffer = Uf;
});
var Rf = Z((Mf) => {
  Object.defineProperty(Mf, "__esModule", { value: !0 });
  Mf.BufferScheduler = void 0;
  var _WA = $("events"),
    yWA = Xf();
  class wf {
    bufferSize;
    maxBuffers;
    readable;
    outgoingHandler;
    emitter = new _WA.EventEmitter();
    concurrency;
    offset = 0;
    isStreamEnd = !1;
    isError = !1;
    executingOutgoingHandlers = 0;
    encoding;
    numBuffers = 0;
    unresolvedDataArray = [];
    unresolvedLength = 0;
    incoming = [];
    outgoing = [];
    constructor(A, Q, B, I, E, C) {
      if (Q <= 0)
        throw RangeError(`bufferSize must be larger than 0, current is ${Q}`);
      if (B <= 0)
        throw RangeError(`maxBuffers must be larger than 0, current is ${B}`);
      if (E <= 0)
        throw RangeError(`concurrency must be larger than 0, current is ${E}`);
      (this.bufferSize = Q),
        (this.maxBuffers = B),
        (this.readable = A),
        (this.outgoingHandler = I),
        (this.concurrency = E),
        (this.encoding = C);
    }
    async do() {
      return new Promise((A, Q) => {
        this.readable.on("data", (B) => {
          if (
            ((B = typeof B === "string" ? Buffer.from(B, this.encoding) : B),
            this.appendUnresolvedData(B),
            !this.resolveData())
          )
            this.readable.pause();
        }),
          this.readable.on("error", (B) => {
            this.emitter.emit("error", B);
          }),
          this.readable.on("end", () => {
            (this.isStreamEnd = !0), this.emitter.emit("checkEnd");
          }),
          this.emitter.on("error", (B) => {
            (this.isError = !0), this.readable.pause(), Q(B);
          }),
          this.emitter.on("checkEnd", () => {
            if (this.outgoing.length > 0) {
              this.triggerOutgoingHandlers();
              return;
            }
            if (this.isStreamEnd && this.executingOutgoingHandlers === 0)
              if (
                this.unresolvedLength > 0 &&
                this.unresolvedLength < this.bufferSize
              ) {
                let B = this.shiftBufferFromUnresolvedDataArray();
                this.outgoingHandler(
                  () => B.getReadableStream(),
                  B.size,
                  this.offset,
                )
                  .then(A)
                  .catch(Q);
              } else if (this.unresolvedLength >= this.bufferSize) return;
              else A();
          });
      });
    }
    appendUnresolvedData(A) {
      this.unresolvedDataArray.push(A), (this.unresolvedLength += A.length);
    }
    shiftBufferFromUnresolvedDataArray(A) {
      if (!A)
        A = new yWA.PooledBuffer(
          this.bufferSize,
          this.unresolvedDataArray,
          this.unresolvedLength,
        );
      else A.fill(this.unresolvedDataArray, this.unresolvedLength);
      return (this.unresolvedLength -= A.size), A;
    }
    resolveData() {
      while (this.unresolvedLength >= this.bufferSize) {
        let A;
        if (this.incoming.length > 0)
          (A = this.incoming.shift()),
            this.shiftBufferFromUnresolvedDataArray(A);
        else if (this.numBuffers < this.maxBuffers)
          (A = this.shiftBufferFromUnresolvedDataArray()), this.numBuffers++;
        else return !1;
        this.outgoing.push(A), this.triggerOutgoingHandlers();
      }
      return !0;
    }
    async triggerOutgoingHandlers() {
      let A;
      do {
        if (this.executingOutgoingHandlers >= this.concurrency) return;
        if (((A = this.outgoing.shift()), A)) this.triggerOutgoingHandler(A);
      } while (A);
    }
    async triggerOutgoingHandler(A) {
      let Q = A.size;
      this.executingOutgoingHandlers++, (this.offset += Q);
      try {
        await this.outgoingHandler(
          () => A.getReadableStream(),
          Q,
          this.offset - Q,
        );
      } catch (B) {
        this.emitter.emit("error", B);
        return;
      }
      this.executingOutgoingHandlers--,
        this.reuseBuffer(A),
        this.emitter.emit("checkEnd");
    }
    reuseBuffer(A) {
      if (
        (this.incoming.push(A),
        !this.isError && this.resolveData() && !this.isStreamEnd)
      )
        this.readable.resume();
    }
  }
  Mf.BufferScheduler = wf;
});
var $f = Z((Vf) => {
  Object.defineProperty(Vf, "__esModule", { value: !0 });
  Vf.getCachedDefaultHttpClient = bWA;
  var SWA = HQ(),
    wX;
  function bWA() {
    if (!wX) wX = (0, SWA.createDefaultHttpClient)();
    return wX;
  }
});
var GD = Z((Kf) => {
  Object.defineProperty(Kf, "__esModule", { value: !0 });
  Kf.BaseRequestPolicy = void 0;
  class Hf {
    _nextPolicy;
    _options;
    constructor(A, Q) {
      (this._nextPolicy = A), (this._options = Q);
    }
    shouldLog(A) {
      return this._options.shouldLog(A);
    }
    log(A, Q) {
      this._options.log(A, Q);
    }
  }
  Kf.BaseRequestPolicy = Hf;
});
var HE = Z((Tf) => {
  Object.defineProperty(Tf, "__esModule", { value: !0 });
  Tf.PathStylePorts =
    Tf.DevelopmentConnectionString =
    Tf.HeaderConstants =
    Tf.URLConstants =
    Tf.SDK_VERSION =
      void 0;
  Tf.SDK_VERSION = "1.0.0";
  Tf.URLConstants = {
    Parameters: {
      FORCE_BROWSER_NO_CACHE: "_",
      SIGNATURE: "sig",
      SNAPSHOT: "snapshot",
      VERSIONID: "versionid",
      TIMEOUT: "timeout",
    },
  };
  Tf.HeaderConstants = {
    AUTHORIZATION: "Authorization",
    AUTHORIZATION_SCHEME: "Bearer",
    CONTENT_ENCODING: "Content-Encoding",
    CONTENT_ID: "Content-ID",
    CONTENT_LANGUAGE: "Content-Language",
    CONTENT_LENGTH: "Content-Length",
    CONTENT_MD5: "Content-Md5",
    CONTENT_TRANSFER_ENCODING: "Content-Transfer-Encoding",
    CONTENT_TYPE: "Content-Type",
    COOKIE: "Cookie",
    DATE: "date",
    IF_MATCH: "if-match",
    IF_MODIFIED_SINCE: "if-modified-since",
    IF_NONE_MATCH: "if-none-match",
    IF_UNMODIFIED_SINCE: "if-unmodified-since",
    PREFIX_FOR_STORAGE: "x-ms-",
    RANGE: "Range",
    USER_AGENT: "User-Agent",
    X_MS_CLIENT_REQUEST_ID: "x-ms-client-request-id",
    X_MS_COPY_SOURCE: "x-ms-copy-source",
    X_MS_DATE: "x-ms-date",
    X_MS_ERROR_CODE: "x-ms-error-code",
    X_MS_VERSION: "x-ms-version",
    X_MS_CopySourceErrorCode: "x-ms-copy-source-error-code",
  };
  Tf.DevelopmentConnectionString =
    "DefaultEndpointsProtocol=http;AccountName=devstoreaccount1;AccountKey=Eby8vdM02xNOcqFlqUwJPLlmEtlCDXJ1OUzFT50uSRZ6IFsuFq2UVErCz4I6tq/K1SZFPTOtr/KBHBeksoGMGw==;BlobEndpoint=http://127.0.0.1:10000/devstoreaccount1;";
  Tf.PathStylePorts = [
    "10000",
    "10001",
    "10002",
    "10003",
    "10004",
    "10100",
    "10101",
    "10102",
    "10103",
    "10104",
    "11000",
    "11001",
    "11002",
    "11003",
    "11004",
    "11100",
    "11101",
    "11102",
    "11103",
    "11104",
  ];
});
var Q0 = Z((_f) => {
  Object.defineProperty(_f, "__esModule", { value: !0 });
  _f.escapeURLPath = iWA;
  _f.getValueInConnString = YC;
  _f.extractConnectionStringParts = aWA;
  _f.appendToURLPath = sWA;
  _f.setURLParameter = jf;
  _f.getURLParameter = ff;
  _f.setURLHost = rWA;
  _f.getURLPath = tWA;
  _f.getURLScheme = eWA;
  _f.getURLPathAndQuery = AZA;
  _f.getURLQueries = QZA;
  _f.appendToURLQuery = BZA;
  _f.truncatedISO8061Date = IZA;
  _f.base64encode = hf;
  _f.base64decode = EZA;
  _f.generateBlockID = CZA;
  _f.delay = gZA;
  _f.padStart = kf;
  _f.sanitizeURL = xf;
  _f.sanitizeHeaders = FZA;
  _f.iEqual = DZA;
  _f.getAccountNameFromUrl = vf;
  _f.isIpEndpointStyle = Pf;
  _f.attachCredential = YZA;
  _f.httpAuthorizationToString = JZA;
  _f.EscapePath = NZA;
  _f.assertResponse = GZA;
  var pWA = HQ(),
    qf = lA(),
    Kg = HE();
  function iWA(A) {
    let Q = new URL(A),
      B = Q.pathname;
    return (B = B || "/"), (B = oWA(B)), (Q.pathname = B), Q.toString();
  }
  function nWA(A) {
    let Q = "";
    if (A.search("DevelopmentStorageProxyUri=") !== -1) {
      let B = A.split(";");
      for (let I of B)
        if (I.trim().startsWith("DevelopmentStorageProxyUri="))
          Q = I.trim().match("DevelopmentStorageProxyUri=(.*)")[1];
    }
    return Q;
  }
  function YC(A, Q) {
    let B = A.split(";");
    for (let I of B)
      if (I.trim().startsWith(Q)) return I.trim().match(Q + "=(.*)")[1];
    return "";
  }
  function aWA(A) {
    let Q = "";
    if (A.startsWith("UseDevelopmentStorage=true"))
      (Q = nWA(A)), (A = Kg.DevelopmentConnectionString);
    let B = YC(A, "BlobEndpoint");
    if (
      ((B = B.endsWith("/") ? B.slice(0, -1) : B),
      A.search("DefaultEndpointsProtocol=") !== -1 &&
        A.search("AccountKey=") !== -1)
    ) {
      let I = "",
        E = "",
        C = Buffer.from("accountKey", "base64"),
        g = "";
      if (
        ((E = YC(A, "AccountName")),
        (C = Buffer.from(YC(A, "AccountKey"), "base64")),
        !B)
      ) {
        I = YC(A, "DefaultEndpointsProtocol");
        let F = I.toLowerCase();
        if (F !== "https" && F !== "http")
          throw Error(
            "Invalid DefaultEndpointsProtocol in the provided Connection String. Expecting 'https' or 'http'",
          );
        if (((g = YC(A, "EndpointSuffix")), !g))
          throw Error(
            "Invalid EndpointSuffix in the provided Connection String",
          );
        B = `${I}://${E}.blob.${g}`;
      }
      if (!E)
        throw Error("Invalid AccountName in the provided Connection String");
      else if (C.length === 0)
        throw Error("Invalid AccountKey in the provided Connection String");
      return {
        kind: "AccountConnString",
        url: B,
        accountName: E,
        accountKey: C,
        proxyUri: Q,
      };
    } else {
      let I = YC(A, "SharedAccessSignature"),
        E = YC(A, "AccountName");
      if (!E) E = vf(B);
      if (!B)
        throw Error(
          "Invalid BlobEndpoint in the provided SAS Connection String",
        );
      else if (!I)
        throw Error(
          "Invalid SharedAccessSignature in the provided SAS Connection String",
        );
      if (I.startsWith("?")) I = I.substring(1);
      return { kind: "SASConnString", url: B, accountName: E, accountSas: I };
    }
  }
  function oWA(A) {
    return encodeURIComponent(A)
      .replace(/%2F/g, "/")
      .replace(/'/g, "%27")
      .replace(/\+/g, "%20")
      .replace(/%25/g, "%");
  }
  function sWA(A, Q) {
    let B = new URL(A),
      I = B.pathname;
    return (
      (I = I ? (I.endsWith("/") ? `${I}${Q}` : `${I}/${Q}`) : Q),
      (B.pathname = I),
      B.toString()
    );
  }
  function jf(A, Q, B) {
    let I = new URL(A),
      E = encodeURIComponent(Q),
      C = B ? encodeURIComponent(B) : void 0,
      g = I.search === "" ? "?" : I.search,
      F = [];
    for (let D of g.slice(1).split("&"))
      if (D) {
        let [J] = D.split("=", 2);
        if (J !== E) F.push(D);
      }
    if (C) F.push(`${E}=${C}`);
    return (I.search = F.length ? `?${F.join("&")}` : ""), I.toString();
  }
  function ff(A, Q) {
    return new URL(A).searchParams.get(Q) ?? void 0;
  }
  function rWA(A, Q) {
    let B = new URL(A);
    return (B.hostname = Q), B.toString();
  }
  function tWA(A) {
    try {
      return new URL(A).pathname;
    } catch (Q) {
      return;
    }
  }
  function eWA(A) {
    try {
      let Q = new URL(A);
      return Q.protocol.endsWith(":") ? Q.protocol.slice(0, -1) : Q.protocol;
    } catch (Q) {
      return;
    }
  }
  function AZA(A) {
    let Q = new URL(A),
      B = Q.pathname;
    if (!B) throw RangeError("Invalid url without valid path.");
    let I = Q.search || "";
    if (((I = I.trim()), I !== "")) I = I.startsWith("?") ? I : `?${I}`;
    return `${B}${I}`;
  }
  function QZA(A) {
    let Q = new URL(A).search;
    if (!Q) return {};
    (Q = Q.trim()), (Q = Q.startsWith("?") ? Q.substring(1) : Q);
    let B = Q.split("&");
    B = B.filter((E) => {
      let C = E.indexOf("="),
        g = E.lastIndexOf("=");
      return C > 0 && C === g && g < E.length - 1;
    });
    let I = {};
    for (let E of B) {
      let C = E.split("="),
        g = C[0],
        F = C[1];
      I[g] = F;
    }
    return I;
  }
  function BZA(A, Q) {
    let B = new URL(A),
      I = B.search;
    if (I) I += "&" + Q;
    else I = Q;
    return (B.search = I), B.toString();
  }
  function IZA(A, Q = !0) {
    let B = A.toISOString();
    return Q
      ? B.substring(0, B.length - 1) + "0000Z"
      : B.substring(0, B.length - 5) + "Z";
  }
  function hf(A) {
    return !qf.isNodeLike ? btoa(A) : Buffer.from(A).toString("base64");
  }
  function EZA(A) {
    return !qf.isNodeLike ? atob(A) : Buffer.from(A, "base64").toString();
  }
  function CZA(A, Q) {
    if (A.length > 42) A = A.slice(0, 42);
    let C = A + kf(Q.toString(), 48 - A.length, "0");
    return hf(C);
  }
  async function gZA(A, Q, B) {
    return new Promise((I, E) => {
      let C,
        g = () => {
          if (C !== void 0) clearTimeout(C);
          E(B);
        };
      if (
        ((C = setTimeout(() => {
          if (Q !== void 0) Q.removeEventListener("abort", g);
          I();
        }, A)),
        Q !== void 0)
      )
        Q.addEventListener("abort", g);
    });
  }
  function kf(A, Q, B = " ") {
    if (String.prototype.padStart) return A.padStart(Q, B);
    if (((B = B || " "), A.length > Q)) return A;
    else {
      if (((Q = Q - A.length), Q > B.length)) B += B.repeat(Q / B.length);
      return B.slice(0, Q) + A;
    }
  }
  function xf(A) {
    let Q = A;
    if (ff(Q, Kg.URLConstants.Parameters.SIGNATURE))
      Q = jf(Q, Kg.URLConstants.Parameters.SIGNATURE, "*****");
    return Q;
  }
  function FZA(A) {
    let Q = (0, pWA.createHttpHeaders)();
    for (let [B, I] of A)
      if (B.toLowerCase() === Kg.HeaderConstants.AUTHORIZATION.toLowerCase())
        Q.set(B, "*****");
      else if (B.toLowerCase() === Kg.HeaderConstants.X_MS_COPY_SOURCE)
        Q.set(B, xf(I));
      else Q.set(B, I);
    return Q;
  }
  function DZA(A, Q) {
    return A.toLocaleLowerCase() === Q.toLocaleLowerCase();
  }
  function vf(A) {
    let Q = new URL(A),
      B;
    try {
      if (Q.hostname.split(".")[1] === "blob") B = Q.hostname.split(".")[0];
      else if (Pf(Q)) B = Q.pathname.split("/")[1];
      else B = "";
      return B;
    } catch (I) {
      throw Error("Unable to extract accountName with provided information.");
    }
  }
  function Pf(A) {
    let Q = A.host;
    return (
      /^.*:.*:.*$|^(localhost|host.docker.internal)(:[0-9]+)?$|^(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])(\.(\d|[1-9]\d|1\d\d|2[0-4]\d|25[0-5])){3}(:[0-9]+)?$/.test(
        Q,
      ) ||
      (Boolean(A.port) && Kg.PathStylePorts.includes(A.port))
    );
  }
  function YZA(A, Q) {
    return (A.credential = Q), A;
  }
  function JZA(A) {
    return A ? A.scheme + " " + A.value : void 0;
  }
  function NZA(A) {
    let Q = A.split("/");
    for (let B = 0; B < Q.length; B++) Q[B] = encodeURIComponent(Q[B]);
    return Q.join("/");
  }
  function GZA(A) {
    if ("_response" in A) return A;
    throw TypeError(`Unexpected response object ${A}`);
  }
});
var LX = Z((Sf) => {
  Object.defineProperty(Sf, "__esModule", { value: !0 });
  Sf.StorageBrowserPolicy = void 0;
  var mZA = GD(),
    dZA = lA(),
    MX = HE(),
    cZA = Q0();
  class yf extends mZA.BaseRequestPolicy {
    constructor(A, Q) {
      super(A, Q);
    }
    async sendRequest(A) {
      if (dZA.isNodeLike) return this._nextPolicy.sendRequest(A);
      if (A.method.toUpperCase() === "GET" || A.method.toUpperCase() === "HEAD")
        A.url = (0, cZA.setURLParameter)(
          A.url,
          MX.URLConstants.Parameters.FORCE_BROWSER_NO_CACHE,
          new Date().getTime().toString(),
        );
      return (
        A.headers.remove(MX.HeaderConstants.COOKIE),
        A.headers.remove(MX.HeaderConstants.CONTENT_LENGTH),
        this._nextPolicy.sendRequest(A)
      );
    }
  }
  Sf.StorageBrowserPolicy = yf;
});
var uf = Z((RX) => {
  Object.defineProperty(RX, "__esModule", { value: !0 });
  RX.StorageBrowserPolicyFactory = RX.StorageBrowserPolicy = void 0;
  var mf = LX();
  Object.defineProperty(RX, "StorageBrowserPolicy", {
    enumerable: !0,
    get: function () {
      return mf.StorageBrowserPolicy;
    },
  });
  class df {
    create(A, Q) {
      return new mf.StorageBrowserPolicy(A, Q);
    }
  }
  RX.StorageBrowserPolicyFactory = df;
});
var RN = Z((pf) => {
  Object.defineProperty(pf, "__esModule", { value: !0 });
  pf.CredentialPolicy = void 0;
  var uZA = GD();
  class lf extends uZA.BaseRequestPolicy {
    sendRequest(A) {
      return this._nextPolicy.sendRequest(this.signRequest(A));
    }
    signRequest(A) {
      return A;
    }
  }
  pf.CredentialPolicy = lf;
});
var VX = Z((of) => {
  Object.defineProperty(of, "__esModule", { value: !0 });
  of.AnonymousCredentialPolicy = void 0;
  var lZA = RN();
  class af extends lZA.CredentialPolicy {
    constructor(A, Q) {
      super(A, Q);
    }
  }
  of.AnonymousCredentialPolicy = af;
});
var VN = Z((tf) => {
  Object.defineProperty(tf, "__esModule", { value: !0 });
  tf.Credential = void 0;
  class rf {
    create(A, Q) {
      throw Error("Method should be implemented in children classes.");
    }
  }
  tf.Credential = rf;
});
var Ih = Z((Qh) => {
  Object.defineProperty(Qh, "__esModule", { value: !0 });
  Qh.AnonymousCredential = void 0;
  var pZA = VX(),
    iZA = VN();
  class Ah extends iZA.Credential {
    create(A, Q) {
      return new pZA.AnonymousCredentialPolicy(A, Q);
    }
  }
  Qh.AnonymousCredential = Ah;
});
var $X = Z((Eh) => {
  Object.defineProperty(Eh, "__esModule", { value: !0 });
  Eh.compareHeader = sZA;
  var nZA = new Uint32Array([
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 1820, 0, 1823, 1825, 1827, 1829, 0, 0, 0, 1837,
      2051, 0, 0, 1843, 0, 3331, 3354, 3356, 3358, 3360, 3362, 3364, 3366, 3368,
      3370, 0, 0, 0, 0, 0, 0, 0, 3586, 3593, 3594, 3610, 3617, 3619, 3621, 3628,
      3634, 3637, 3638, 3656, 3665, 3696, 3708, 3710, 3721, 3722, 3729, 3737,
      3743, 3746, 3748, 3750, 3751, 3753, 0, 0, 0, 1859, 1860, 1864, 3586, 3593,
      3594, 3610, 3617, 3619, 3621, 3628, 3634, 3637, 3638, 3656, 3665, 3696,
      3708, 3710, 3721, 3722, 3729, 3737, 3743, 3746, 3748, 3750, 3751, 3753, 0,
      1868, 0, 1872, 0,
    ]),
    aZA = new Uint32Array([
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, 18, 18, 18, 18, 18, 18,
      18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18, 18,
      18, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    ]),
    oZA = new Uint32Array([
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 32786, 0, 0, 0, 0, 0, 33298, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0,
    ]);
  function sZA(A, Q) {
    if (rZA(A, Q)) return -1;
    return 1;
  }
  function rZA(A, Q) {
    let B = [nZA, aZA, oZA],
      I = 0,
      E = 0,
      C = 0;
    while (I < B.length) {
      if (I === B.length - 1 && E !== C) return E > C;
      let g = E < A.length ? B[I][A[E].charCodeAt(0)] : 1,
        F = C < Q.length ? B[I][Q[C].charCodeAt(0)] : 1;
      if (g === 1 && F === 1) (E = 0), (C = 0), ++I;
      else if (g === F) ++E, ++C;
      else if (g === 0) ++E;
      else if (F === 0) ++C;
      else return g < F;
    }
    return !1;
  }
});
var HX = Z((Fh) => {
  Object.defineProperty(Fh, "__esModule", { value: !0 });
  Fh.StorageSharedKeyCredentialPolicy = void 0;
  var AB = HE(),
    Ch = Q0(),
    eZA = RN(),
    A9A = $X();
  class gh extends eZA.CredentialPolicy {
    factory;
    constructor(A, Q, B) {
      super(A, Q);
      this.factory = B;
    }
    signRequest(A) {
      if (
        (A.headers.set(AB.HeaderConstants.X_MS_DATE, new Date().toUTCString()),
        A.body &&
          (typeof A.body === "string" || A.body !== void 0) &&
          A.body.length > 0)
      )
        A.headers.set(
          AB.HeaderConstants.CONTENT_LENGTH,
          Buffer.byteLength(A.body),
        );
      let Q =
          [
            A.method.toUpperCase(),
            this.getHeaderValueToSign(A, AB.HeaderConstants.CONTENT_LANGUAGE),
            this.getHeaderValueToSign(A, AB.HeaderConstants.CONTENT_ENCODING),
            this.getHeaderValueToSign(A, AB.HeaderConstants.CONTENT_LENGTH),
            this.getHeaderValueToSign(A, AB.HeaderConstants.CONTENT_MD5),
            this.getHeaderValueToSign(A, AB.HeaderConstants.CONTENT_TYPE),
            this.getHeaderValueToSign(A, AB.HeaderConstants.DATE),
            this.getHeaderValueToSign(A, AB.HeaderConstants.IF_MODIFIED_SINCE),
            this.getHeaderValueToSign(A, AB.HeaderConstants.IF_MATCH),
            this.getHeaderValueToSign(A, AB.HeaderConstants.IF_NONE_MATCH),
            this.getHeaderValueToSign(
              A,
              AB.HeaderConstants.IF_UNMODIFIED_SINCE,
            ),
            this.getHeaderValueToSign(A, AB.HeaderConstants.RANGE),
          ].join(`
`) +
          `
` +
          this.getCanonicalizedHeadersString(A) +
          this.getCanonicalizedResourceString(A),
        B = this.factory.computeHMACSHA256(Q);
      return (
        A.headers.set(
          AB.HeaderConstants.AUTHORIZATION,
          `SharedKey ${this.factory.accountName}:${B}`,
        ),
        A
      );
    }
    getHeaderValueToSign(A, Q) {
      let B = A.headers.get(Q);
      if (!B) return "";
      if (Q === AB.HeaderConstants.CONTENT_LENGTH && B === "0") return "";
      return B;
    }
    getCanonicalizedHeadersString(A) {
      let Q = A.headers.headersArray().filter((I) => {
        return I.name
          .toLowerCase()
          .startsWith(AB.HeaderConstants.PREFIX_FOR_STORAGE);
      });
      Q.sort((I, E) => {
        return (0, A9A.compareHeader)(
          I.name.toLowerCase(),
          E.name.toLowerCase(),
        );
      }),
        (Q = Q.filter((I, E, C) => {
          if (E > 0 && I.name.toLowerCase() === C[E - 1].name.toLowerCase())
            return !1;
          return !0;
        }));
      let B = "";
      return (
        Q.forEach((I) => {
          B += `${I.name.toLowerCase().trimRight()}:${I.value.trimLeft()}
`;
        }),
        B
      );
    }
    getCanonicalizedResourceString(A) {
      let Q = (0, Ch.getURLPath)(A.url) || "/",
        B = "";
      B += `/${this.factory.accountName}${Q}`;
      let I = (0, Ch.getURLQueries)(A.url),
        E = {};
      if (I) {
        let C = [];
        for (let g in I)
          if (Object.prototype.hasOwnProperty.call(I, g)) {
            let F = g.toLowerCase();
            (E[F] = I[g]), C.push(F);
          }
        C.sort();
        for (let g of C)
          B += `
${g}:${decodeURIComponent(E[g])}`;
      }
      return B;
    }
  }
  Fh.StorageSharedKeyCredentialPolicy = gh;
});
var Gh = Z((Jh) => {
  Object.defineProperty(Jh, "__esModule", { value: !0 });
  Jh.StorageSharedKeyCredential = void 0;
  var Q9A = $("node:crypto"),
    B9A = HX(),
    I9A = VN();
  class Yh extends I9A.Credential {
    accountName;
    accountKey;
    constructor(A, Q) {
      super();
      (this.accountName = A), (this.accountKey = Buffer.from(Q, "base64"));
    }
    create(A, Q) {
      return new B9A.StorageSharedKeyCredentialPolicy(A, Q, this);
    }
    computeHMACSHA256(A) {
      return (0, Q9A.createHmac)("sha256", this.accountKey)
        .update(A, "utf8")
        .digest("base64");
    }
  }
  Jh.StorageSharedKeyCredential = Yh;
});
var Xh = Z((Wh) => {
  Object.defineProperty(Wh, "__esModule", { value: !0 });
  Wh.AbortError = void 0;
  class Uh extends Error {
    constructor(A) {
      super(A);
      this.name = "AbortError";
    }
  }
  Wh.AbortError = Uh;
});
var zX = Z((KX) => {
  Object.defineProperty(KX, "__esModule", { value: !0 });
  KX.AbortError = void 0;
  var E9A = Xh();
  Object.defineProperty(KX, "AbortError", {
    enumerable: !0,
    get: function () {
      return E9A.AbortError;
    },
  });
});
var TX = Z((wh) => {
  Object.defineProperty(wh, "__esModule", { value: !0 });
  wh.logger = void 0;
  var g9A = eC();
  wh.logger = (0, g9A.createClientLogger)("storage-common");
});
var $N = Z((Rh) => {
  Object.defineProperty(Rh, "__esModule", { value: !0 });
  Rh.StorageRetryPolicyType = void 0;
  var Lh;
  (function (A) {
    (A[(A.EXPONENTIAL = 0)] = "EXPONENTIAL"), (A[(A.FIXED = 1)] = "FIXED");
  })(Lh || (Rh.StorageRetryPolicyType = Lh = {}));
});
var fX = Z((Hh) => {
  Object.defineProperty(Hh, "__esModule", { value: !0 });
  Hh.StorageRetryPolicy = void 0;
  Hh.NewRetryPolicyFactory = Y9A;
  var F9A = zX(),
    D9A = GD(),
    $h = HE(),
    OX = Q0(),
    JC = TX(),
    qX = $N();
  function Y9A(A) {
    return {
      create: (Q, B) => {
        return new jX(Q, B, A);
      },
    };
  }
  var NC = {
      maxRetryDelayInMs: 120000,
      maxTries: 4,
      retryDelayInMs: 4000,
      retryPolicyType: qX.StorageRetryPolicyType.EXPONENTIAL,
      secondaryHost: "",
      tryTimeoutInMs: void 0,
    },
    J9A = new F9A.AbortError("The operation was aborted.");
  class jX extends D9A.BaseRequestPolicy {
    retryOptions;
    constructor(A, Q, B = NC) {
      super(A, Q);
      this.retryOptions = {
        retryPolicyType: B.retryPolicyType
          ? B.retryPolicyType
          : NC.retryPolicyType,
        maxTries:
          B.maxTries && B.maxTries >= 1 ? Math.floor(B.maxTries) : NC.maxTries,
        tryTimeoutInMs:
          B.tryTimeoutInMs && B.tryTimeoutInMs >= 0
            ? B.tryTimeoutInMs
            : NC.tryTimeoutInMs,
        retryDelayInMs:
          B.retryDelayInMs && B.retryDelayInMs >= 0
            ? Math.min(
                B.retryDelayInMs,
                B.maxRetryDelayInMs
                  ? B.maxRetryDelayInMs
                  : NC.maxRetryDelayInMs,
              )
            : NC.retryDelayInMs,
        maxRetryDelayInMs:
          B.maxRetryDelayInMs && B.maxRetryDelayInMs >= 0
            ? B.maxRetryDelayInMs
            : NC.maxRetryDelayInMs,
        secondaryHost: B.secondaryHost ? B.secondaryHost : NC.secondaryHost,
      };
    }
    async sendRequest(A) {
      return this.attemptSendRequest(A, !1, 1);
    }
    async attemptSendRequest(A, Q, B) {
      let I = A.clone(),
        E =
          Q ||
          !this.retryOptions.secondaryHost ||
          !(
            A.method === "GET" ||
            A.method === "HEAD" ||
            A.method === "OPTIONS"
          ) ||
          B % 2 === 1;
      if (!E)
        I.url = (0, OX.setURLHost)(I.url, this.retryOptions.secondaryHost);
      if (this.retryOptions.tryTimeoutInMs)
        I.url = (0, OX.setURLParameter)(
          I.url,
          $h.URLConstants.Parameters.TIMEOUT,
          Math.floor(this.retryOptions.tryTimeoutInMs / 1000).toString(),
        );
      let C;
      try {
        if (
          (JC.logger.info(
            `RetryPolicy: =====> Try=${B} ${E ? "Primary" : "Secondary"}`,
          ),
          (C = await this._nextPolicy.sendRequest(I)),
          !this.shouldRetry(E, B, C))
        )
          return C;
        Q = Q || (!E && C.status === 404);
      } catch (g) {
        if (
          (JC.logger.error(
            `RetryPolicy: Caught error, message: ${g.message}, code: ${g.code}`,
          ),
          !this.shouldRetry(E, B, C, g))
        )
          throw g;
      }
      return (
        await this.delay(E, B, A.abortSignal),
        this.attemptSendRequest(A, Q, ++B)
      );
    }
    shouldRetry(A, Q, B, I) {
      if (Q >= this.retryOptions.maxTries)
        return (
          JC.logger.info(
            `RetryPolicy: Attempt(s) ${Q} >= maxTries ${this.retryOptions.maxTries}, no further try.`,
          ),
          !1
        );
      let E = [
        "ETIMEDOUT",
        "ESOCKETTIMEDOUT",
        "ECONNREFUSED",
        "ECONNRESET",
        "ENOENT",
        "ENOTFOUND",
        "TIMEOUT",
        "EPIPE",
        "REQUEST_SEND_ERROR",
      ];
      if (I) {
        for (let C of E)
          if (
            I.name.toUpperCase().includes(C) ||
            I.message.toUpperCase().includes(C) ||
            (I.code && I.code.toString().toUpperCase() === C)
          )
            return (
              JC.logger.info(
                `RetryPolicy: Network error ${C} found, will retry.`,
              ),
              !0
            );
      }
      if (B || I) {
        let C = B ? B.status : I ? I.statusCode : 0;
        if (!A && C === 404)
          return (
            JC.logger.info(
              "RetryPolicy: Secondary access with 404, will retry.",
            ),
            !0
          );
        if (C === 503 || C === 500)
          return (
            JC.logger.info(`RetryPolicy: Will retry for status code ${C}.`), !0
          );
      }
      if (B) {
        if (B?.status >= 400) {
          let C = B.headers.get($h.HeaderConstants.X_MS_CopySourceErrorCode);
          if (C !== void 0)
            switch (C) {
              case "InternalError":
              case "OperationTimedOut":
              case "ServerBusy":
                return !0;
            }
        }
      }
      if (
        I?.code === "PARSE_ERROR" &&
        I?.message.startsWith('Error "Error: Unclosed root tag')
      )
        return (
          JC.logger.info(
            "RetryPolicy: Incomplete XML response likely due to service timeout, will retry.",
          ),
          !0
        );
      return !1;
    }
    async delay(A, Q, B) {
      let I = 0;
      if (A)
        switch (this.retryOptions.retryPolicyType) {
          case qX.StorageRetryPolicyType.EXPONENTIAL:
            I = Math.min(
              (Math.pow(2, Q - 1) - 1) * this.retryOptions.retryDelayInMs,
              this.retryOptions.maxRetryDelayInMs,
            );
            break;
          case qX.StorageRetryPolicyType.FIXED:
            I = this.retryOptions.retryDelayInMs;
            break;
        }
      else I = Math.random() * 1000;
      return (
        JC.logger.info(`RetryPolicy: Delay for ${I}ms`),
        (0, OX.delay)(I, B, J9A)
      );
    }
  }
  Hh.StorageRetryPolicy = jX;
});
var KN = Z((HN) => {
  Object.defineProperty(HN, "__esModule", { value: !0 });
  HN.StorageRetryPolicyFactory =
    HN.StorageRetryPolicy =
    HN.StorageRetryPolicyType =
      void 0;
  var zh = fX();
  Object.defineProperty(HN, "StorageRetryPolicy", {
    enumerable: !0,
    get: function () {
      return zh.StorageRetryPolicy;
    },
  });
  var G9A = $N();
  Object.defineProperty(HN, "StorageRetryPolicyType", {
    enumerable: !0,
    get: function () {
      return G9A.StorageRetryPolicyType;
    },
  });
  class Th {
    retryOptions;
    constructor(A) {
      this.retryOptions = A;
    }
    create(A, Q) {
      return new zh.StorageRetryPolicy(A, Q, this.retryOptions);
    }
  }
  HN.StorageRetryPolicyFactory = Th;
});
var jh = Z((qh) => {
  Object.defineProperty(qh, "__esModule", { value: !0 });
  qh.storageBrowserPolicyName = void 0;
  qh.storageBrowserPolicy = Z9A;
  var U9A = lA(),
    hX = HE(),
    W9A = Q0();
  qh.storageBrowserPolicyName = "storageBrowserPolicy";
  function Z9A() {
    return {
      name: qh.storageBrowserPolicyName,
      async sendRequest(A, Q) {
        if (U9A.isNodeLike) return Q(A);
        if (A.method === "GET" || A.method === "HEAD")
          A.url = (0, W9A.setURLParameter)(
            A.url,
            hX.URLConstants.Parameters.FORCE_BROWSER_NO_CACHE,
            new Date().getTime().toString(),
          );
        return (
          A.headers.delete(hX.HeaderConstants.COOKIE),
          A.headers.delete(hX.HeaderConstants.CONTENT_LENGTH),
          Q(A)
        );
      },
    };
  }
});
var hh = Z((fh) => {
  Object.defineProperty(fh, "__esModule", { value: !0 });
  fh.storageCorrectContentLengthPolicyName = void 0;
  fh.storageCorrectContentLengthPolicy = M9A;
  var w9A = HE();
  fh.storageCorrectContentLengthPolicyName =
    "StorageCorrectContentLengthPolicy";
  function M9A() {
    function A(Q) {
      if (
        Q.body &&
        (typeof Q.body === "string" || Buffer.isBuffer(Q.body)) &&
        Q.body.length > 0
      )
        Q.headers.set(
          w9A.HeaderConstants.CONTENT_LENGTH,
          Buffer.byteLength(Q.body),
        );
    }
    return {
      name: fh.storageCorrectContentLengthPolicyName,
      async sendRequest(Q, B) {
        return A(Q), B(Q);
      },
    };
  }
});
var Ph = Z((vh) => {
  Object.defineProperty(vh, "__esModule", { value: !0 });
  vh.storageRetryPolicyName = void 0;
  vh.storageRetryPolicy = K9A;
  var R9A = zX(),
    kh = HQ(),
    V9A = lA(),
    PX = KN(),
    xh = HE(),
    vX = Q0(),
    KE = TX();
  vh.storageRetryPolicyName = "storageRetryPolicy";
  var zg = {
      maxRetryDelayInMs: 120000,
      maxTries: 4,
      retryDelayInMs: 4000,
      retryPolicyType: PX.StorageRetryPolicyType.EXPONENTIAL,
      secondaryHost: "",
      tryTimeoutInMs: void 0,
    },
    $9A = [
      "ETIMEDOUT",
      "ESOCKETTIMEDOUT",
      "ECONNREFUSED",
      "ECONNRESET",
      "ENOENT",
      "ENOTFOUND",
      "TIMEOUT",
      "EPIPE",
      "REQUEST_SEND_ERROR",
    ],
    H9A = new R9A.AbortError("The operation was aborted.");
  function K9A(A = {}) {
    let Q = A.retryPolicyType ?? zg.retryPolicyType,
      B = A.maxTries ?? zg.maxTries,
      I = A.retryDelayInMs ?? zg.retryDelayInMs,
      E = A.maxRetryDelayInMs ?? zg.maxRetryDelayInMs,
      C = A.secondaryHost ?? zg.secondaryHost,
      g = A.tryTimeoutInMs ?? zg.tryTimeoutInMs;
    function F({ isPrimaryRetry: J, attempt: Y, response: N, error: W }) {
      if (Y >= B)
        return (
          KE.logger.info(
            `RetryPolicy: Attempt(s) ${Y} >= maxTries ${B}, no further try.`,
          ),
          !1
        );
      if (W) {
        for (let X of $9A)
          if (
            W.name.toUpperCase().includes(X) ||
            W.message.toUpperCase().includes(X) ||
            (W.code && W.code.toString().toUpperCase() === X)
          )
            return (
              KE.logger.info(
                `RetryPolicy: Network error ${X} found, will retry.`,
              ),
              !0
            );
        if (
          W?.code === "PARSE_ERROR" &&
          W?.message.startsWith('Error "Error: Unclosed root tag')
        )
          return (
            KE.logger.info(
              "RetryPolicy: Incomplete XML response likely due to service timeout, will retry.",
            ),
            !0
          );
      }
      if (N || W) {
        let X = N?.status ?? W?.statusCode ?? 0;
        if (!J && X === 404)
          return (
            KE.logger.info(
              "RetryPolicy: Secondary access with 404, will retry.",
            ),
            !0
          );
        if (X === 503 || X === 500)
          return (
            KE.logger.info(`RetryPolicy: Will retry for status code ${X}.`), !0
          );
      }
      if (N) {
        if (N?.status >= 400) {
          let X = N.headers.get(xh.HeaderConstants.X_MS_CopySourceErrorCode);
          if (X !== void 0)
            switch (X) {
              case "InternalError":
              case "OperationTimedOut":
              case "ServerBusy":
                return !0;
            }
        }
      }
      return !1;
    }
    function D(J, Y) {
      let N = 0;
      if (J)
        switch (Q) {
          case PX.StorageRetryPolicyType.EXPONENTIAL:
            N = Math.min((Math.pow(2, Y - 1) - 1) * I, E);
            break;
          case PX.StorageRetryPolicyType.FIXED:
            N = I;
            break;
        }
      else N = Math.random() * 1000;
      return KE.logger.info(`RetryPolicy: Delay for ${N}ms`), N;
    }
    return {
      name: vh.storageRetryPolicyName,
      async sendRequest(J, Y) {
        if (g)
          J.url = (0, vX.setURLParameter)(
            J.url,
            xh.URLConstants.Parameters.TIMEOUT,
            String(Math.floor(g / 1000)),
          );
        let N = J.url,
          W = C ? (0, vX.setURLHost)(J.url, C) : void 0,
          X = !1,
          M = 1,
          L = !0,
          H,
          q;
        while (L) {
          let O =
            X ||
            !W ||
            !["GET", "HEAD", "OPTIONS"].includes(J.method) ||
            M % 2 === 1;
          (J.url = O ? N : W), (H = void 0), (q = void 0);
          try {
            KE.logger.info(
              `RetryPolicy: =====> Try=${M} ${O ? "Primary" : "Secondary"}`,
            ),
              (H = await Y(J)),
              (X = X || (!O && H.status === 404));
          } catch (f) {
            if ((0, kh.isRestError)(f))
              KE.logger.error(
                `RetryPolicy: Caught error, message: ${f.message}, code: ${f.code}`,
              ),
                (q = f);
            else
              throw (
                (KE.logger.error(
                  `RetryPolicy: Caught error, message: ${(0, V9A.getErrorMessage)(f)}`,
                ),
                f)
              );
          }
          if (
            ((L = F({ isPrimaryRetry: O, attempt: M, response: H, error: q })),
            L)
          )
            await (0, vX.delay)(D(O, M), J.abortSignal, H9A);
          M++;
        }
        if (H) return H;
        throw q ?? new kh.RestError("RetryPolicy failed without known error.");
      },
    };
  }
});
var Sh = Z((yh) => {
  Object.defineProperty(yh, "__esModule", { value: !0 });
  yh.storageSharedKeyCredentialPolicyName = void 0;
  yh.storageSharedKeyCredentialPolicy = q9A;
  var T9A = $("node:crypto"),
    QB = HE(),
    _h = Q0(),
    O9A = $X();
  yh.storageSharedKeyCredentialPolicyName = "storageSharedKeyCredentialPolicy";
  function q9A(A) {
    function Q(C) {
      if (
        (C.headers.set(QB.HeaderConstants.X_MS_DATE, new Date().toUTCString()),
        C.body &&
          (typeof C.body === "string" || Buffer.isBuffer(C.body)) &&
          C.body.length > 0)
      )
        C.headers.set(
          QB.HeaderConstants.CONTENT_LENGTH,
          Buffer.byteLength(C.body),
        );
      let g =
          [
            C.method.toUpperCase(),
            B(C, QB.HeaderConstants.CONTENT_LANGUAGE),
            B(C, QB.HeaderConstants.CONTENT_ENCODING),
            B(C, QB.HeaderConstants.CONTENT_LENGTH),
            B(C, QB.HeaderConstants.CONTENT_MD5),
            B(C, QB.HeaderConstants.CONTENT_TYPE),
            B(C, QB.HeaderConstants.DATE),
            B(C, QB.HeaderConstants.IF_MODIFIED_SINCE),
            B(C, QB.HeaderConstants.IF_MATCH),
            B(C, QB.HeaderConstants.IF_NONE_MATCH),
            B(C, QB.HeaderConstants.IF_UNMODIFIED_SINCE),
            B(C, QB.HeaderConstants.RANGE),
          ].join(`
`) +
          `
` +
          I(C) +
          E(C),
        F = (0, T9A.createHmac)("sha256", A.accountKey)
          .update(g, "utf8")
          .digest("base64");
      C.headers.set(
        QB.HeaderConstants.AUTHORIZATION,
        `SharedKey ${A.accountName}:${F}`,
      );
    }
    function B(C, g) {
      let F = C.headers.get(g);
      if (!F) return "";
      if (g === QB.HeaderConstants.CONTENT_LENGTH && F === "0") return "";
      return F;
    }
    function I(C) {
      let g = [];
      for (let [D, J] of C.headers)
        if (D.toLowerCase().startsWith(QB.HeaderConstants.PREFIX_FOR_STORAGE))
          g.push({ name: D, value: J });
      g.sort((D, J) => {
        return (0, O9A.compareHeader)(
          D.name.toLowerCase(),
          J.name.toLowerCase(),
        );
      }),
        (g = g.filter((D, J, Y) => {
          if (J > 0 && D.name.toLowerCase() === Y[J - 1].name.toLowerCase())
            return !1;
          return !0;
        }));
      let F = "";
      return (
        g.forEach((D) => {
          F += `${D.name.toLowerCase().trimRight()}:${D.value.trimLeft()}
`;
        }),
        F
      );
    }
    function E(C) {
      let g = (0, _h.getURLPath)(C.url) || "/",
        F = "";
      F += `/${A.accountName}${g}`;
      let D = (0, _h.getURLQueries)(C.url),
        J = {};
      if (D) {
        let Y = [];
        for (let N in D)
          if (Object.prototype.hasOwnProperty.call(D, N)) {
            let W = N.toLowerCase();
            (J[W] = D[N]), Y.push(W);
          }
        Y.sort();
        for (let N of Y)
          F += `
${N}:${decodeURIComponent(J[N])}`;
      }
      return F;
    }
    return {
      name: yh.storageSharedKeyCredentialPolicyName,
      async sendRequest(C, g) {
        return Q(C), g(C);
      },
    };
  }
});
var mh = Z((bh) => {
  Object.defineProperty(bh, "__esModule", { value: !0 });
  bh.storageRequestFailureDetailsParserPolicyName = void 0;
  bh.storageRequestFailureDetailsParserPolicy = f9A;
  bh.storageRequestFailureDetailsParserPolicyName =
    "storageRequestFailureDetailsParserPolicy";
  function f9A() {
    return {
      name: bh.storageRequestFailureDetailsParserPolicyName,
      async sendRequest(A, Q) {
        try {
          return await Q(A);
        } catch (B) {
          if (
            typeof B === "object" &&
            B !== null &&
            B.response &&
            B.response.parsedBody
          ) {
            if (
              B.response.parsedBody.code === "InvalidHeaderValue" &&
              B.response.parsedBody.HeaderName === "x-ms-version"
            )
              B.message = `The provided service version is not enabled on this storage account. Please see https://learn.microsoft.com/rest/api/storageservices/versioning-for-the-azure-storage-services for additional information.
`;
          }
          throw B;
        }
      },
    };
  }
});
var bX = Z((UQ) => {
  Object.defineProperty(UQ, "__esModule", { value: !0 });
  UQ.BaseRequestPolicy = UQ.getCachedDefaultHttpClient = void 0;
  var SQ = BQ();
  SQ.__exportStar(Rf(), UQ);
  var k9A = $f();
  Object.defineProperty(UQ, "getCachedDefaultHttpClient", {
    enumerable: !0,
    get: function () {
      return k9A.getCachedDefaultHttpClient;
    },
  });
  SQ.__exportStar(uf(), UQ);
  SQ.__exportStar(Ih(), UQ);
  SQ.__exportStar(VN(), UQ);
  SQ.__exportStar(Gh(), UQ);
  SQ.__exportStar(KN(), UQ);
  var x9A = GD();
  Object.defineProperty(UQ, "BaseRequestPolicy", {
    enumerable: !0,
    get: function () {
      return x9A.BaseRequestPolicy;
    },
  });
  SQ.__exportStar(VX(), UQ);
  SQ.__exportStar(RN(), UQ);
  SQ.__exportStar(LX(), UQ);
  SQ.__exportStar(jh(), UQ);
  SQ.__exportStar(hh(), UQ);
  SQ.__exportStar($N(), UQ);
  SQ.__exportStar(fX(), UQ);
  SQ.__exportStar(Ph(), UQ);
  SQ.__exportStar(HX(), UQ);
  SQ.__exportStar(Sh(), UQ);
  SQ.__exportStar(KN(), UQ);
  SQ.__exportStar(mh(), UQ);
});
var ch = Z((dh) => {
  Object.defineProperty(dh, "__esModule", { value: !0 });
  dh.storageBrowserPolicyName = void 0;
  dh.storageBrowserPolicy = y9A;
  var P9A = lA(),
    mX = KQ(),
    _9A = yQ();
  dh.storageBrowserPolicyName = "storageBrowserPolicy";
  function y9A() {
    return {
      name: dh.storageBrowserPolicyName,
      async sendRequest(A, Q) {
        if (P9A.isNodeLike) return Q(A);
        if (A.method === "GET" || A.method === "HEAD")
          A.url = (0, _9A.setURLParameter)(
            A.url,
            mX.URLConstants.Parameters.FORCE_BROWSER_NO_CACHE,
            new Date().getTime().toString(),
          );
        return (
          A.headers.delete(mX.HeaderConstants.COOKIE),
          A.headers.delete(mX.HeaderConstants.CONTENT_LENGTH),
          Q(A)
        );
      },
    };
  }
});
var ih = Z((ph) => {
  Object.defineProperty(ph, "__esModule", { value: !0 });
  ph.storageRetryPolicyName = void 0;
  ph.storageRetryPolicy = u9A;
  var b9A = YD(),
    uh = HQ(),
    m9A = lA(),
    uX = ND(),
    lh = KQ(),
    cX = yQ(),
    zE = $g();
  ph.storageRetryPolicyName = "storageRetryPolicy";
  var Tg = {
      maxRetryDelayInMs: 120000,
      maxTries: 4,
      retryDelayInMs: 4000,
      retryPolicyType: uX.StorageRetryPolicyType.EXPONENTIAL,
      secondaryHost: "",
      tryTimeoutInMs: void 0,
    },
    d9A = [
      "ETIMEDOUT",
      "ESOCKETTIMEDOUT",
      "ECONNREFUSED",
      "ECONNRESET",
      "ENOENT",
      "ENOTFOUND",
      "TIMEOUT",
      "EPIPE",
      "REQUEST_SEND_ERROR",
    ],
    c9A = new b9A.AbortError("The operation was aborted.");
  function u9A(A = {}) {
    let Q = A.retryPolicyType ?? Tg.retryPolicyType,
      B = A.maxTries ?? Tg.maxTries,
      I = A.retryDelayInMs ?? Tg.retryDelayInMs,
      E = A.maxRetryDelayInMs ?? Tg.maxRetryDelayInMs,
      C = A.secondaryHost ?? Tg.secondaryHost,
      g = A.tryTimeoutInMs ?? Tg.tryTimeoutInMs;
    function F({ isPrimaryRetry: J, attempt: Y, response: N, error: W }) {
      if (Y >= B)
        return (
          zE.logger.info(
            `RetryPolicy: Attempt(s) ${Y} >= maxTries ${B}, no further try.`,
          ),
          !1
        );
      if (W) {
        for (let X of d9A)
          if (
            W.name.toUpperCase().includes(X) ||
            W.message.toUpperCase().includes(X) ||
            (W.code && W.code.toString().toUpperCase() === X)
          )
            return (
              zE.logger.info(
                `RetryPolicy: Network error ${X} found, will retry.`,
              ),
              !0
            );
        if (
          W?.code === "PARSE_ERROR" &&
          W?.message.startsWith('Error "Error: Unclosed root tag')
        )
          return (
            zE.logger.info(
              "RetryPolicy: Incomplete XML response likely due to service timeout, will retry.",
            ),
            !0
          );
      }
      if (N || W) {
        let X = N?.status ?? W?.statusCode ?? 0;
        if (!J && X === 404)
          return (
            zE.logger.info(
              "RetryPolicy: Secondary access with 404, will retry.",
            ),
            !0
          );
        if (X === 503 || X === 500)
          return (
            zE.logger.info(`RetryPolicy: Will retry for status code ${X}.`), !0
          );
      }
      if (N) {
        if (N?.status >= 400) {
          let X = N.headers.get(lh.HeaderConstants.X_MS_CopySourceErrorCode);
          if (X !== void 0)
            switch (X) {
              case "InternalError":
              case "OperationTimedOut":
              case "ServerBusy":
                return !0;
            }
        }
      }
      return !1;
    }
    function D(J, Y) {
      let N = 0;
      if (J)
        switch (Q) {
          case uX.StorageRetryPolicyType.EXPONENTIAL:
            N = Math.min((Math.pow(2, Y - 1) - 1) * I, E);
            break;
          case uX.StorageRetryPolicyType.FIXED:
            N = I;
            break;
        }
      else N = Math.random() * 1000;
      return zE.logger.info(`RetryPolicy: Delay for ${N}ms`), N;
    }
    return {
      name: ph.storageRetryPolicyName,
      async sendRequest(J, Y) {
        if (g)
          J.url = (0, cX.setURLParameter)(
            J.url,
            lh.URLConstants.Parameters.TIMEOUT,
            String(Math.floor(g / 1000)),
          );
        let N = J.url,
          W = C ? (0, cX.setURLHost)(J.url, C) : void 0,
          X = !1,
          M = 1,
          L = !0,
          H,
          q;
        while (L) {
          let O =
            X ||
            !W ||
            !["GET", "HEAD", "OPTIONS"].includes(J.method) ||
            M % 2 === 1;
          (J.url = O ? N : W), (H = void 0), (q = void 0);
          try {
            zE.logger.info(
              `RetryPolicy: =====> Try=${M} ${O ? "Primary" : "Secondary"}`,
            ),
              (H = await Y(J)),
              (X = X || (!O && H.status === 404));
          } catch (f) {
            if ((0, uh.isRestError)(f))
              zE.logger.error(
                `RetryPolicy: Caught error, message: ${f.message}, code: ${f.code}`,
              ),
                (q = f);
            else
              throw (
                (zE.logger.error(
                  `RetryPolicy: Caught error, message: ${(0, m9A.getErrorMessage)(f)}`,
                ),
                f)
              );
          }
          if (
            ((L = F({ isPrimaryRetry: O, attempt: M, response: H, error: q })),
            L)
          )
            await (0, cX.delay)(D(O, M), J.abortSignal, c9A);
          M++;
        }
        if (H) return H;
        throw q ?? new uh.RestError("RetryPolicy failed without known error.");
      },
    };
  }
});
var iX = Z((ah) => {
  Object.defineProperty(ah, "__esModule", { value: !0 });
  ah.storageSharedKeyCredentialPolicyName = void 0;
  ah.storageSharedKeyCredentialPolicy = n9A;
  var p9A = $("node:crypto"),
    BB = KQ(),
    nh = yQ(),
    i9A = WX();
  ah.storageSharedKeyCredentialPolicyName = "storageSharedKeyCredentialPolicy";
  function n9A(A) {
    function Q(C) {
      if (
        (C.headers.set(BB.HeaderConstants.X_MS_DATE, new Date().toUTCString()),
        C.body &&
          (typeof C.body === "string" || Buffer.isBuffer(C.body)) &&
          C.body.length > 0)
      )
        C.headers.set(
          BB.HeaderConstants.CONTENT_LENGTH,
          Buffer.byteLength(C.body),
        );
      let g =
          [
            C.method.toUpperCase(),
            B(C, BB.HeaderConstants.CONTENT_LANGUAGE),
            B(C, BB.HeaderConstants.CONTENT_ENCODING),
            B(C, BB.HeaderConstants.CONTENT_LENGTH),
            B(C, BB.HeaderConstants.CONTENT_MD5),
            B(C, BB.HeaderConstants.CONTENT_TYPE),
            B(C, BB.HeaderConstants.DATE),
            B(C, BB.HeaderConstants.IF_MODIFIED_SINCE),
            B(C, BB.HeaderConstants.IF_MATCH),
            B(C, BB.HeaderConstants.IF_NONE_MATCH),
            B(C, BB.HeaderConstants.IF_UNMODIFIED_SINCE),
            B(C, BB.HeaderConstants.RANGE),
          ].join(`
`) +
          `
` +
          I(C) +
          E(C),
        F = (0, p9A.createHmac)("sha256", A.accountKey)
          .update(g, "utf8")
          .digest("base64");
      C.headers.set(
        BB.HeaderConstants.AUTHORIZATION,
        `SharedKey ${A.accountName}:${F}`,
      );
    }
    function B(C, g) {
      let F = C.headers.get(g);
      if (!F) return "";
      if (g === BB.HeaderConstants.CONTENT_LENGTH && F === "0") return "";
      return F;
    }
    function I(C) {
      let g = [];
      for (let [D, J] of C.headers)
        if (D.toLowerCase().startsWith(BB.HeaderConstants.PREFIX_FOR_STORAGE))
          g.push({ name: D, value: J });
      g.sort((D, J) => {
        return (0, i9A.compareHeader)(
          D.name.toLowerCase(),
          J.name.toLowerCase(),
        );
      }),
        (g = g.filter((D, J, Y) => {
          if (J > 0 && D.name.toLowerCase() === Y[J - 1].name.toLowerCase())
            return !1;
          return !0;
        }));
      let F = "";
      return (
        g.forEach((D) => {
          F += `${D.name.toLowerCase().trimRight()}:${D.value.trimLeft()}
`;
        }),
        F
      );
    }
    function E(C) {
      let g = (0, nh.getURLPath)(C.url) || "/",
        F = "";
      F += `/${A.accountName}${g}`;
      let D = (0, nh.getURLQueries)(C.url),
        J = {};
      if (D) {
        let Y = [];
        for (let N in D)
          if (Object.prototype.hasOwnProperty.call(D, N)) {
            let W = N.toLowerCase();
            (J[W] = D[N]), Y.push(W);
          }
        Y.sort();
        for (let N of Y)
          F += `
${N}:${decodeURIComponent(J[N])}`;
      }
      return F;
    }
    return {
      name: ah.storageSharedKeyCredentialPolicyName,
      async sendRequest(C, g) {
        return Q(C), g(C);
      },
    };
  }
});
var th = Z((sh) => {
  Object.defineProperty(sh, "__esModule", { value: !0 });
  sh.StorageBrowserPolicy = void 0;
  var o9A = JD(),
    s9A = lA(),
    nX = KQ(),
    r9A = yQ();
  class oh extends o9A.BaseRequestPolicy {
    constructor(A, Q) {
      super(A, Q);
    }
    async sendRequest(A) {
      if (s9A.isNodeLike) return this._nextPolicy.sendRequest(A);
      if (A.method.toUpperCase() === "GET" || A.method.toUpperCase() === "HEAD")
        A.url = (0, r9A.setURLParameter)(
          A.url,
          nX.URLConstants.Parameters.FORCE_BROWSER_NO_CACHE,
          new Date().getTime().toString(),
        );
      return (
        A.headers.remove(nX.HeaderConstants.COOKIE),
        A.headers.remove(nX.HeaderConstants.CONTENT_LENGTH),
        this._nextPolicy.sendRequest(A)
      );
    }
  }
  sh.StorageBrowserPolicy = oh;
});
var oX = Z((aX) => {
  Object.defineProperty(aX, "__esModule", { value: !0 });
  aX.StorageBrowserPolicyFactory = aX.StorageBrowserPolicy = void 0;
  var eh = th();
  Object.defineProperty(aX, "StorageBrowserPolicy", {
    enumerable: !0,
    get: function () {
      return eh.StorageBrowserPolicy;
    },
  });
  class Ak {
    create(A, Q) {
      return new eh.StorageBrowserPolicy(A, Q);
    }
  }
  aX.StorageBrowserPolicyFactory = Ak;
});
var Ik = Z((Bk) => {
  Object.defineProperty(Bk, "__esModule", { value: !0 });
  Bk.storageCorrectContentLengthPolicyName = void 0;
  Bk.storageCorrectContentLengthPolicy = e9A;
  var t9A = KQ();
  Bk.storageCorrectContentLengthPolicyName =
    "StorageCorrectContentLengthPolicy";
  function e9A() {
    function A(Q) {
      if (
        Q.body &&
        (typeof Q.body === "string" || Buffer.isBuffer(Q.body)) &&
        Q.body.length > 0
      )
        Q.headers.set(
          t9A.HeaderConstants.CONTENT_LENGTH,
          Buffer.byteLength(Q.body),
        );
    }
    return {
      name: Bk.storageCorrectContentLengthPolicyName,
      async sendRequest(Q, B) {
        return A(Q), B(Q);
      },
    };
  }
});
var GC = Z((A4) => {
  Object.defineProperty(A4, "__esModule", { value: !0 });
  A4.Pipeline = A4.StorageOAuthScopes = void 0;
  A4.isPipelineLike = D1A;
  A4.newPipeline = Y1A;
  A4.getCoreClientOptions = N1A;
  A4.getCredentialFromPipeline = Jk;
  var Dk = WN(),
    Ek = HQ(),
    Ck = oI(),
    gk = DX(),
    rX = Rg(),
    Q1A = $g(),
    B1A = ND(),
    Yk = FC(),
    tX = DC(),
    UD = KQ();
  Object.defineProperty(A4, "StorageOAuthScopes", {
    enumerable: !0,
    get: function () {
      return UD.StorageOAuthScopes;
    },
  });
  var Fk = bX(),
    I1A = ch(),
    E1A = ih(),
    C1A = iX(),
    g1A = oX(),
    F1A = Ik();
  function D1A(A) {
    if (!A || typeof A !== "object") return !1;
    let Q = A;
    return (
      Array.isArray(Q.factories) &&
      typeof Q.options === "object" &&
      typeof Q.toServiceClientOptions === "function"
    );
  }
  class eX {
    factories;
    options;
    constructor(A, Q = {}) {
      (this.factories = A), (this.options = Q);
    }
    toServiceClientOptions() {
      return {
        httpClient: this.options.httpClient,
        requestPolicyFactories: this.factories,
      };
    }
  }
  A4.Pipeline = eX;
  function Y1A(A, Q = {}) {
    if (!A) A = new tX.AnonymousCredential();
    let B = new eX([], Q);
    return (B._credential = A), B;
  }
  function J1A(A) {
    let Q = [G1A, Nk, U1A, W1A, Z1A, X1A, M1A];
    if (A.factories.length) {
      let B = A.factories.filter((I) => {
        return !Q.some((E) => E(I));
      });
      if (B.length) {
        let I = B.some((E) => w1A(E));
        return {
          wrappedPolicies: (0, Dk.createRequestPolicyFactoryPolicy)(B),
          afterRetry: I,
        };
      }
    }
    return;
  }
  function N1A(A) {
    let { httpClient: Q, ...B } = A.options,
      I = A._coreHttpClient;
    if (!I)
      (I = Q
        ? (0, Dk.convertHttpClient)(Q)
        : (0, Fk.getCachedDefaultHttpClient)()),
        (A._coreHttpClient = I);
    let E = A._corePipeline;
    if (!E) {
      let C = `azsdk-js-azure-storage-blob/${UD.SDK_VERSION}`,
        g =
          B.userAgentOptions && B.userAgentOptions.userAgentPrefix
            ? `${B.userAgentOptions.userAgentPrefix} ${C}`
            : `${C}`;
      (E = (0, Ck.createClientPipeline)({
        ...B,
        loggingOptions: {
          additionalAllowedHeaderNames: UD.StorageBlobLoggingAllowedHeaderNames,
          additionalAllowedQueryParameters:
            UD.StorageBlobLoggingAllowedQueryParameters,
          logger: Q1A.logger.info,
        },
        userAgentOptions: { userAgentPrefix: g },
        serializationOptions: {
          stringifyXML: gk.stringifyXML,
          serializerOptions: { xml: { xmlCharKey: "#" } },
        },
        deserializationOptions: {
          parseXML: gk.parseXML,
          serializerOptions: { xml: { xmlCharKey: "#" } },
        },
      })),
        E.removePolicy({ phase: "Retry" }),
        E.removePolicy({ name: Ek.decompressResponsePolicyName }),
        E.addPolicy((0, F1A.storageCorrectContentLengthPolicy)()),
        E.addPolicy((0, E1A.storageRetryPolicy)(B.retryOptions), {
          phase: "Retry",
        }),
        E.addPolicy((0, Fk.storageRequestFailureDetailsParserPolicy)()),
        E.addPolicy((0, I1A.storageBrowserPolicy)());
      let F = J1A(A);
      if (F)
        E.addPolicy(
          F.wrappedPolicies,
          F.afterRetry ? { afterPhase: "Retry" } : void 0,
        );
      let D = Jk(A);
      if ((0, rX.isTokenCredential)(D))
        E.addPolicy(
          (0, Ek.bearerTokenAuthenticationPolicy)({
            credential: D,
            scopes: B.audience ?? UD.StorageOAuthScopes,
            challengeCallbacks: {
              authorizeRequestOnChallenge: Ck.authorizeRequestOnTenantChallenge,
            },
          }),
          { phase: "Sign" },
        );
      else if (D instanceof Yk.StorageSharedKeyCredential)
        E.addPolicy(
          (0, C1A.storageSharedKeyCredentialPolicy)({
            accountName: D.accountName,
            accountKey: D.accountKey,
          }),
          { phase: "Sign" },
        );
      A._corePipeline = E;
    }
    return { ...B, allowInsecureConnection: !0, httpClient: I, pipeline: E };
  }
  function Jk(A) {
    if (A._credential) return A._credential;
    let Q = new tX.AnonymousCredential();
    for (let B of A.factories)
      if ((0, rX.isTokenCredential)(B.credential)) Q = B.credential;
      else if (Nk(B)) return B;
    return Q;
  }
  function Nk(A) {
    if (A instanceof Yk.StorageSharedKeyCredential) return !0;
    return A.constructor.name === "StorageSharedKeyCredential";
  }
  function G1A(A) {
    if (A instanceof tX.AnonymousCredential) return !0;
    return A.constructor.name === "AnonymousCredential";
  }
  function U1A(A) {
    return (0, rX.isTokenCredential)(A.credential);
  }
  function W1A(A) {
    if (A instanceof g1A.StorageBrowserPolicyFactory) return !0;
    return A.constructor.name === "StorageBrowserPolicyFactory";
  }
  function Z1A(A) {
    if (A instanceof B1A.StorageRetryPolicyFactory) return !0;
    return A.constructor.name === "StorageRetryPolicyFactory";
  }
  function X1A(A) {
    return A.constructor.name === "TelemetryPolicyFactory";
  }
  function w1A(A) {
    return A.constructor.name === "InjectorPolicyFactory";
  }
  function M1A(A) {
    let Q = [
        "GenerateClientRequestIdPolicy",
        "TracingPolicy",
        "LogPolicy",
        "ProxyPolicy",
        "DisableResponseDecompressionPolicy",
        "KeepAlivePolicy",
        "DeserializationPolicy",
      ],
      B = {
        sendRequest: async (g) => {
          return { request: g, headers: g.headers.clone(), status: 500 };
        },
      },
      I = {
        log(g, F) {},
        shouldLog(g) {
          return !1;
        },
      },
      C = A.create(B, I).constructor.name;
    return Q.some((g) => {
      return C.startsWith(g);
    });
  }
});
var Lk = Z((wk) => {
  Object.defineProperty(wk, "__esModule", { value: !0 });
  wk.KnownStorageErrorCode =
    wk.KnownBlobExpiryOptions =
    wk.KnownFileShareTokenIntent =
    wk.KnownEncryptionAlgorithmType =
      void 0;
  var Uk;
  (function (A) {
    A.AES256 = "AES256";
  })(Uk || (wk.KnownEncryptionAlgorithmType = Uk = {}));
  var Wk;
  (function (A) {
    A.Backup = "backup";
  })(Wk || (wk.KnownFileShareTokenIntent = Wk = {}));
  var Zk;
  (function (A) {
    (A.NeverExpire = "NeverExpire"),
      (A.RelativeToCreation = "RelativeToCreation"),
      (A.RelativeToNow = "RelativeToNow"),
      (A.Absolute = "Absolute");
  })(Zk || (wk.KnownBlobExpiryOptions = Zk = {}));
  var Xk;
  (function (A) {
    (A.AccountAlreadyExists = "AccountAlreadyExists"),
      (A.AccountBeingCreated = "AccountBeingCreated"),
      (A.AccountIsDisabled = "AccountIsDisabled"),
      (A.AuthenticationFailed = "AuthenticationFailed"),
      (A.AuthorizationFailure = "AuthorizationFailure"),
      (A.ConditionHeadersNotSupported = "ConditionHeadersNotSupported"),
      (A.ConditionNotMet = "ConditionNotMet"),
      (A.EmptyMetadataKey = "EmptyMetadataKey"),
      (A.InsufficientAccountPermissions = "InsufficientAccountPermissions"),
      (A.InternalError = "InternalError"),
      (A.InvalidAuthenticationInfo = "InvalidAuthenticationInfo"),
      (A.InvalidHeaderValue = "InvalidHeaderValue"),
      (A.InvalidHttpVerb = "InvalidHttpVerb"),
      (A.InvalidInput = "InvalidInput"),
      (A.InvalidMd5 = "InvalidMd5"),
      (A.InvalidMetadata = "InvalidMetadata"),
      (A.InvalidQueryParameterValue = "InvalidQueryParameterValue"),
      (A.InvalidRange = "InvalidRange"),
      (A.InvalidResourceName = "InvalidResourceName"),
      (A.InvalidUri = "InvalidUri"),
      (A.InvalidXmlDocument = "InvalidXmlDocument"),
      (A.InvalidXmlNodeValue = "InvalidXmlNodeValue"),
      (A.Md5Mismatch = "Md5Mismatch"),
      (A.MetadataTooLarge = "MetadataTooLarge"),
      (A.MissingContentLengthHeader = "MissingContentLengthHeader"),
      (A.MissingRequiredQueryParameter = "MissingRequiredQueryParameter"),
      (A.MissingRequiredHeader = "MissingRequiredHeader"),
      (A.MissingRequiredXmlNode = "MissingRequiredXmlNode"),
      (A.MultipleConditionHeadersNotSupported =
        "MultipleConditionHeadersNotSupported"),
      (A.OperationTimedOut = "OperationTimedOut"),
      (A.OutOfRangeInput = "OutOfRangeInput"),
      (A.OutOfRangeQueryParameterValue = "OutOfRangeQueryParameterValue"),
      (A.RequestBodyTooLarge = "RequestBodyTooLarge"),
      (A.ResourceTypeMismatch = "ResourceTypeMismatch"),
      (A.RequestUrlFailedToParse = "RequestUrlFailedToParse"),
      (A.ResourceAlreadyExists = "ResourceAlreadyExists"),
      (A.ResourceNotFound = "ResourceNotFound"),
      (A.ServerBusy = "ServerBusy"),
      (A.UnsupportedHeader = "UnsupportedHeader"),
      (A.UnsupportedXmlNode = "UnsupportedXmlNode"),
      (A.UnsupportedQueryParameter = "UnsupportedQueryParameter"),
      (A.UnsupportedHttpVerb = "UnsupportedHttpVerb"),
      (A.AppendPositionConditionNotMet = "AppendPositionConditionNotMet"),
      (A.BlobAlreadyExists = "BlobAlreadyExists"),
      (A.BlobImmutableDueToPolicy = "BlobImmutableDueToPolicy"),
      (A.BlobNotFound = "BlobNotFound"),
      (A.BlobOverwritten = "BlobOverwritten"),
      (A.BlobTierInadequateForContentLength =
        "BlobTierInadequateForContentLength"),
      (A.BlobUsesCustomerSpecifiedEncryption =
        "BlobUsesCustomerSpecifiedEncryption"),
      (A.BlockCountExceedsLimit = "BlockCountExceedsLimit"),
      (A.BlockListTooLong = "BlockListTooLong"),
      (A.CannotChangeToLowerTier = "CannotChangeToLowerTier"),
      (A.CannotVerifyCopySource = "CannotVerifyCopySource"),
      (A.ContainerAlreadyExists = "ContainerAlreadyExists"),
      (A.ContainerBeingDeleted = "ContainerBeingDeleted"),
      (A.ContainerDisabled = "ContainerDisabled"),
      (A.ContainerNotFound = "ContainerNotFound"),
      (A.ContentLengthLargerThanTierLimit = "ContentLengthLargerThanTierLimit"),
      (A.CopyAcrossAccountsNotSupported = "CopyAcrossAccountsNotSupported"),
      (A.CopyIdMismatch = "CopyIdMismatch"),
      (A.FeatureVersionMismatch = "FeatureVersionMismatch"),
      (A.IncrementalCopyBlobMismatch = "IncrementalCopyBlobMismatch"),
      (A.IncrementalCopyOfEarlierVersionSnapshotNotAllowed =
        "IncrementalCopyOfEarlierVersionSnapshotNotAllowed"),
      (A.IncrementalCopySourceMustBeSnapshot =
        "IncrementalCopySourceMustBeSnapshot"),
      (A.InfiniteLeaseDurationRequired = "InfiniteLeaseDurationRequired"),
      (A.InvalidBlobOrBlock = "InvalidBlobOrBlock"),
      (A.InvalidBlobTier = "InvalidBlobTier"),
      (A.InvalidBlobType = "InvalidBlobType"),
      (A.InvalidBlockId = "InvalidBlockId"),
      (A.InvalidBlockList = "InvalidBlockList"),
      (A.InvalidOperation = "InvalidOperation"),
      (A.InvalidPageRange = "InvalidPageRange"),
      (A.InvalidSourceBlobType = "InvalidSourceBlobType"),
      (A.InvalidSourceBlobUrl = "InvalidSourceBlobUrl"),
      (A.InvalidVersionForPageBlobOperation =
        "InvalidVersionForPageBlobOperation"),
      (A.LeaseAlreadyPresent = "LeaseAlreadyPresent"),
      (A.LeaseAlreadyBroken = "LeaseAlreadyBroken"),
      (A.LeaseIdMismatchWithBlobOperation = "LeaseIdMismatchWithBlobOperation"),
      (A.LeaseIdMismatchWithContainerOperation =
        "LeaseIdMismatchWithContainerOperation"),
      (A.LeaseIdMismatchWithLeaseOperation =
        "LeaseIdMismatchWithLeaseOperation"),
      (A.LeaseIdMissing = "LeaseIdMissing"),
      (A.LeaseIsBreakingAndCannotBeAcquired =
        "LeaseIsBreakingAndCannotBeAcquired"),
      (A.LeaseIsBreakingAndCannotBeChanged =
        "LeaseIsBreakingAndCannotBeChanged"),
      (A.LeaseIsBrokenAndCannotBeRenewed = "LeaseIsBrokenAndCannotBeRenewed"),
      (A.LeaseLost = "LeaseLost"),
      (A.LeaseNotPresentWithBlobOperation = "LeaseNotPresentWithBlobOperation"),
      (A.LeaseNotPresentWithContainerOperation =
        "LeaseNotPresentWithContainerOperation"),
      (A.LeaseNotPresentWithLeaseOperation =
        "LeaseNotPresentWithLeaseOperation"),
      (A.MaxBlobSizeConditionNotMet = "MaxBlobSizeConditionNotMet"),
      (A.NoAuthenticationInformation = "NoAuthenticationInformation"),
      (A.NoPendingCopyOperation = "NoPendingCopyOperation"),
      (A.OperationNotAllowedOnIncrementalCopyBlob =
        "OperationNotAllowedOnIncrementalCopyBlob"),
      (A.PendingCopyOperation = "PendingCopyOperation"),
      (A.PreviousSnapshotCannotBeNewer = "PreviousSnapshotCannotBeNewer"),
      (A.PreviousSnapshotNotFound = "PreviousSnapshotNotFound"),
      (A.PreviousSnapshotOperationNotSupported =
        "PreviousSnapshotOperationNotSupported"),
      (A.SequenceNumberConditionNotMet = "SequenceNumberConditionNotMet"),
      (A.SequenceNumberIncrementTooLarge = "SequenceNumberIncrementTooLarge"),
      (A.SnapshotCountExceeded = "SnapshotCountExceeded"),
      (A.SnapshotOperationRateExceeded = "SnapshotOperationRateExceeded"),
      (A.SnapshotsPresent = "SnapshotsPresent"),
      (A.SourceConditionNotMet = "SourceConditionNotMet"),
      (A.SystemInUse = "SystemInUse"),
      (A.TargetConditionNotMet = "TargetConditionNotMet"),
      (A.UnauthorizedBlobOverwrite = "UnauthorizedBlobOverwrite"),
      (A.BlobBeingRehydrated = "BlobBeingRehydrated"),
      (A.BlobArchived = "BlobArchived"),
      (A.BlobNotArchived = "BlobNotArchived"),
      (A.AuthorizationSourceIPMismatch = "AuthorizationSourceIPMismatch"),
      (A.AuthorizationProtocolMismatch = "AuthorizationProtocolMismatch"),
      (A.AuthorizationPermissionMismatch = "AuthorizationPermissionMismatch"),
      (A.AuthorizationServiceMismatch = "AuthorizationServiceMismatch"),
      (A.AuthorizationResourceTypeMismatch =
        "AuthorizationResourceTypeMismatch"),
      (A.BlobAccessTierNotSupportedForAccountType =
        "BlobAccessTierNotSupportedForAccountType");
  })(Xk || (wk.KnownStorageErrorCode = Xk = {}));
});
var UC = Z((Rk) => {
  Object.defineProperty(Rk, "__esModule", { value: !0 });
  Rk.ServiceGetUserDelegationKeyHeaders =
    Rk.ServiceListContainersSegmentExceptionHeaders =
    Rk.ServiceListContainersSegmentHeaders =
    Rk.ServiceGetStatisticsExceptionHeaders =
    Rk.ServiceGetStatisticsHeaders =
    Rk.ServiceGetPropertiesExceptionHeaders =
    Rk.ServiceGetPropertiesHeaders =
    Rk.ServiceSetPropertiesExceptionHeaders =
    Rk.ServiceSetPropertiesHeaders =
    Rk.ArrowField =
    Rk.ArrowConfiguration =
    Rk.JsonTextConfiguration =
    Rk.DelimitedTextConfiguration =
    Rk.QueryFormat =
    Rk.QuerySerialization =
    Rk.QueryRequest =
    Rk.ClearRange =
    Rk.PageRange =
    Rk.PageList =
    Rk.Block =
    Rk.BlockList =
    Rk.BlockLookupList =
    Rk.BlobPrefix =
    Rk.BlobHierarchyListSegment =
    Rk.ListBlobsHierarchySegmentResponse =
    Rk.BlobPropertiesInternal =
    Rk.BlobName =
    Rk.BlobItemInternal =
    Rk.BlobFlatListSegment =
    Rk.ListBlobsFlatSegmentResponse =
    Rk.AccessPolicy =
    Rk.SignedIdentifier =
    Rk.BlobTag =
    Rk.BlobTags =
    Rk.FilterBlobItem =
    Rk.FilterBlobSegment =
    Rk.UserDelegationKey =
    Rk.KeyInfo =
    Rk.ContainerProperties =
    Rk.ContainerItem =
    Rk.ListContainersSegmentResponse =
    Rk.GeoReplication =
    Rk.BlobServiceStatistics =
    Rk.StorageError =
    Rk.StaticWebsite =
    Rk.CorsRule =
    Rk.Metrics =
    Rk.RetentionPolicy =
    Rk.Logging =
    Rk.BlobServiceProperties =
      void 0;
  Rk.BlobUndeleteHeaders =
    Rk.BlobDeleteExceptionHeaders =
    Rk.BlobDeleteHeaders =
    Rk.BlobGetPropertiesExceptionHeaders =
    Rk.BlobGetPropertiesHeaders =
    Rk.BlobDownloadExceptionHeaders =
    Rk.BlobDownloadHeaders =
    Rk.ContainerGetAccountInfoExceptionHeaders =
    Rk.ContainerGetAccountInfoHeaders =
    Rk.ContainerListBlobHierarchySegmentExceptionHeaders =
    Rk.ContainerListBlobHierarchySegmentHeaders =
    Rk.ContainerListBlobFlatSegmentExceptionHeaders =
    Rk.ContainerListBlobFlatSegmentHeaders =
    Rk.ContainerChangeLeaseExceptionHeaders =
    Rk.ContainerChangeLeaseHeaders =
    Rk.ContainerBreakLeaseExceptionHeaders =
    Rk.ContainerBreakLeaseHeaders =
    Rk.ContainerRenewLeaseExceptionHeaders =
    Rk.ContainerRenewLeaseHeaders =
    Rk.ContainerReleaseLeaseExceptionHeaders =
    Rk.ContainerReleaseLeaseHeaders =
    Rk.ContainerAcquireLeaseExceptionHeaders =
    Rk.ContainerAcquireLeaseHeaders =
    Rk.ContainerFilterBlobsExceptionHeaders =
    Rk.ContainerFilterBlobsHeaders =
    Rk.ContainerSubmitBatchExceptionHeaders =
    Rk.ContainerSubmitBatchHeaders =
    Rk.ContainerRenameExceptionHeaders =
    Rk.ContainerRenameHeaders =
    Rk.ContainerRestoreExceptionHeaders =
    Rk.ContainerRestoreHeaders =
    Rk.ContainerSetAccessPolicyExceptionHeaders =
    Rk.ContainerSetAccessPolicyHeaders =
    Rk.ContainerGetAccessPolicyExceptionHeaders =
    Rk.ContainerGetAccessPolicyHeaders =
    Rk.ContainerSetMetadataExceptionHeaders =
    Rk.ContainerSetMetadataHeaders =
    Rk.ContainerDeleteExceptionHeaders =
    Rk.ContainerDeleteHeaders =
    Rk.ContainerGetPropertiesExceptionHeaders =
    Rk.ContainerGetPropertiesHeaders =
    Rk.ContainerCreateExceptionHeaders =
    Rk.ContainerCreateHeaders =
    Rk.ServiceFilterBlobsExceptionHeaders =
    Rk.ServiceFilterBlobsHeaders =
    Rk.ServiceSubmitBatchExceptionHeaders =
    Rk.ServiceSubmitBatchHeaders =
    Rk.ServiceGetAccountInfoExceptionHeaders =
    Rk.ServiceGetAccountInfoHeaders =
    Rk.ServiceGetUserDelegationKeyExceptionHeaders =
      void 0;
  Rk.PageBlobGetPageRangesHeaders =
    Rk.PageBlobUploadPagesFromURLExceptionHeaders =
    Rk.PageBlobUploadPagesFromURLHeaders =
    Rk.PageBlobClearPagesExceptionHeaders =
    Rk.PageBlobClearPagesHeaders =
    Rk.PageBlobUploadPagesExceptionHeaders =
    Rk.PageBlobUploadPagesHeaders =
    Rk.PageBlobCreateExceptionHeaders =
    Rk.PageBlobCreateHeaders =
    Rk.BlobSetTagsExceptionHeaders =
    Rk.BlobSetTagsHeaders =
    Rk.BlobGetTagsExceptionHeaders =
    Rk.BlobGetTagsHeaders =
    Rk.BlobQueryExceptionHeaders =
    Rk.BlobQueryHeaders =
    Rk.BlobGetAccountInfoExceptionHeaders =
    Rk.BlobGetAccountInfoHeaders =
    Rk.BlobSetTierExceptionHeaders =
    Rk.BlobSetTierHeaders =
    Rk.BlobAbortCopyFromURLExceptionHeaders =
    Rk.BlobAbortCopyFromURLHeaders =
    Rk.BlobCopyFromURLExceptionHeaders =
    Rk.BlobCopyFromURLHeaders =
    Rk.BlobStartCopyFromURLExceptionHeaders =
    Rk.BlobStartCopyFromURLHeaders =
    Rk.BlobCreateSnapshotExceptionHeaders =
    Rk.BlobCreateSnapshotHeaders =
    Rk.BlobBreakLeaseExceptionHeaders =
    Rk.BlobBreakLeaseHeaders =
    Rk.BlobChangeLeaseExceptionHeaders =
    Rk.BlobChangeLeaseHeaders =
    Rk.BlobRenewLeaseExceptionHeaders =
    Rk.BlobRenewLeaseHeaders =
    Rk.BlobReleaseLeaseExceptionHeaders =
    Rk.BlobReleaseLeaseHeaders =
    Rk.BlobAcquireLeaseExceptionHeaders =
    Rk.BlobAcquireLeaseHeaders =
    Rk.BlobSetMetadataExceptionHeaders =
    Rk.BlobSetMetadataHeaders =
    Rk.BlobSetLegalHoldExceptionHeaders =
    Rk.BlobSetLegalHoldHeaders =
    Rk.BlobDeleteImmutabilityPolicyExceptionHeaders =
    Rk.BlobDeleteImmutabilityPolicyHeaders =
    Rk.BlobSetImmutabilityPolicyExceptionHeaders =
    Rk.BlobSetImmutabilityPolicyHeaders =
    Rk.BlobSetHttpHeadersExceptionHeaders =
    Rk.BlobSetHttpHeadersHeaders =
    Rk.BlobSetExpiryExceptionHeaders =
    Rk.BlobSetExpiryHeaders =
    Rk.BlobUndeleteExceptionHeaders =
      void 0;
  Rk.BlockBlobGetBlockListExceptionHeaders =
    Rk.BlockBlobGetBlockListHeaders =
    Rk.BlockBlobCommitBlockListExceptionHeaders =
    Rk.BlockBlobCommitBlockListHeaders =
    Rk.BlockBlobStageBlockFromURLExceptionHeaders =
    Rk.BlockBlobStageBlockFromURLHeaders =
    Rk.BlockBlobStageBlockExceptionHeaders =
    Rk.BlockBlobStageBlockHeaders =
    Rk.BlockBlobPutBlobFromUrlExceptionHeaders =
    Rk.BlockBlobPutBlobFromUrlHeaders =
    Rk.BlockBlobUploadExceptionHeaders =
    Rk.BlockBlobUploadHeaders =
    Rk.AppendBlobSealExceptionHeaders =
    Rk.AppendBlobSealHeaders =
    Rk.AppendBlobAppendBlockFromUrlExceptionHeaders =
    Rk.AppendBlobAppendBlockFromUrlHeaders =
    Rk.AppendBlobAppendBlockExceptionHeaders =
    Rk.AppendBlobAppendBlockHeaders =
    Rk.AppendBlobCreateExceptionHeaders =
    Rk.AppendBlobCreateHeaders =
    Rk.PageBlobCopyIncrementalExceptionHeaders =
    Rk.PageBlobCopyIncrementalHeaders =
    Rk.PageBlobUpdateSequenceNumberExceptionHeaders =
    Rk.PageBlobUpdateSequenceNumberHeaders =
    Rk.PageBlobResizeExceptionHeaders =
    Rk.PageBlobResizeHeaders =
    Rk.PageBlobGetPageRangesDiffExceptionHeaders =
    Rk.PageBlobGetPageRangesDiffHeaders =
    Rk.PageBlobGetPageRangesExceptionHeaders =
      void 0;
  Rk.BlobServiceProperties = {
    serializedName: "BlobServiceProperties",
    xmlName: "StorageServiceProperties",
    type: {
      name: "Composite",
      className: "BlobServiceProperties",
      modelProperties: {
        blobAnalyticsLogging: {
          serializedName: "Logging",
          xmlName: "Logging",
          type: { name: "Composite", className: "Logging" },
        },
        hourMetrics: {
          serializedName: "HourMetrics",
          xmlName: "HourMetrics",
          type: { name: "Composite", className: "Metrics" },
        },
        minuteMetrics: {
          serializedName: "MinuteMetrics",
          xmlName: "MinuteMetrics",
          type: { name: "Composite", className: "Metrics" },
        },
        cors: {
          serializedName: "Cors",
          xmlName: "Cors",
          xmlIsWrapped: !0,
          xmlElementName: "CorsRule",
          type: {
            name: "Sequence",
            element: { type: { name: "Composite", className: "CorsRule" } },
          },
        },
        defaultServiceVersion: {
          serializedName: "DefaultServiceVersion",
          xmlName: "DefaultServiceVersion",
          type: { name: "String" },
        },
        deleteRetentionPolicy: {
          serializedName: "DeleteRetentionPolicy",
          xmlName: "DeleteRetentionPolicy",
          type: { name: "Composite", className: "RetentionPolicy" },
        },
        staticWebsite: {
          serializedName: "StaticWebsite",
          xmlName: "StaticWebsite",
          type: { name: "Composite", className: "StaticWebsite" },
        },
      },
    },
  };
  Rk.Logging = {
    serializedName: "Logging",
    type: {
      name: "Composite",
      className: "Logging",
      modelProperties: {
        version: {
          serializedName: "Version",
          required: !0,
          xmlName: "Version",
          type: { name: "String" },
        },
        deleteProperty: {
          serializedName: "Delete",
          required: !0,
          xmlName: "Delete",
          type: { name: "Boolean" },
        },
        read: {
          serializedName: "Read",
          required: !0,
          xmlName: "Read",
          type: { name: "Boolean" },
        },
        write: {
          serializedName: "Write",
          required: !0,
          xmlName: "Write",
          type: { name: "Boolean" },
        },
        retentionPolicy: {
          serializedName: "RetentionPolicy",
          xmlName: "RetentionPolicy",
          type: { name: "Composite", className: "RetentionPolicy" },
        },
      },
    },
  };
  Rk.RetentionPolicy = {
    serializedName: "RetentionPolicy",
    type: {
      name: "Composite",
      className: "RetentionPolicy",
      modelProperties: {
        enabled: {
          serializedName: "Enabled",
          required: !0,
          xmlName: "Enabled",
          type: { name: "Boolean" },
        },
        days: {
          constraints: { InclusiveMinimum: 1 },
          serializedName: "Days",
          xmlName: "Days",
          type: { name: "Number" },
        },
      },
    },
  };
  Rk.Metrics = {
    serializedName: "Metrics",
    type: {
      name: "Composite",
      className: "Metrics",
      modelProperties: {
        version: {
          serializedName: "Version",
          xmlName: "Version",
          type: { name: "String" },
        },
        enabled: {
          serializedName: "Enabled",
          required: !0,
          xmlName: "Enabled",
          type: { name: "Boolean" },
        },
        includeAPIs: {
          serializedName: "IncludeAPIs",
          xmlName: "IncludeAPIs",
          type: { name: "Boolean" },
        },
        retentionPolicy: {
          serializedName: "RetentionPolicy",
          xmlName: "RetentionPolicy",
          type: { name: "Composite", className: "RetentionPolicy" },
        },
      },
    },
  };
  Rk.CorsRule = {
    serializedName: "CorsRule",
    type: {
      name: "Composite",
      className: "CorsRule",
      modelProperties: {
        allowedOrigins: {
          serializedName: "AllowedOrigins",
          required: !0,
          xmlName: "AllowedOrigins",
          type: { name: "String" },
        },
        allowedMethods: {
          serializedName: "AllowedMethods",
          required: !0,
          xmlName: "AllowedMethods",
          type: { name: "String" },
        },
        allowedHeaders: {
          serializedName: "AllowedHeaders",
          required: !0,
          xmlName: "AllowedHeaders",
          type: { name: "String" },
        },
        exposedHeaders: {
          serializedName: "ExposedHeaders",
          required: !0,
          xmlName: "ExposedHeaders",
          type: { name: "String" },
        },
        maxAgeInSeconds: {
          constraints: { InclusiveMinimum: 0 },
          serializedName: "MaxAgeInSeconds",
          required: !0,
          xmlName: "MaxAgeInSeconds",
          type: { name: "Number" },
        },
      },
    },
  };
  Rk.StaticWebsite = {
    serializedName: "StaticWebsite",
    type: {
      name: "Composite",
      className: "StaticWebsite",
      modelProperties: {
        enabled: {
          serializedName: "Enabled",
          required: !0,
          xmlName: "Enabled",
          type: { name: "Boolean" },
        },
        indexDocument: {
          serializedName: "IndexDocument",
          xmlName: "IndexDocument",
          type: { name: "String" },
        },
        errorDocument404Path: {
          serializedName: "ErrorDocument404Path",
          xmlName: "ErrorDocument404Path",
          type: { name: "String" },
        },
        defaultIndexDocumentPath: {
          serializedName: "DefaultIndexDocumentPath",
          xmlName: "DefaultIndexDocumentPath",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.StorageError = {
    serializedName: "StorageError",
    type: {
      name: "Composite",
      className: "StorageError",
      modelProperties: {
        message: {
          serializedName: "Message",
          xmlName: "Message",
          type: { name: "String" },
        },
        copySourceStatusCode: {
          serializedName: "CopySourceStatusCode",
          xmlName: "CopySourceStatusCode",
          type: { name: "Number" },
        },
        copySourceErrorCode: {
          serializedName: "CopySourceErrorCode",
          xmlName: "CopySourceErrorCode",
          type: { name: "String" },
        },
        copySourceErrorMessage: {
          serializedName: "CopySourceErrorMessage",
          xmlName: "CopySourceErrorMessage",
          type: { name: "String" },
        },
        code: {
          serializedName: "Code",
          xmlName: "Code",
          type: { name: "String" },
        },
        authenticationErrorDetail: {
          serializedName: "AuthenticationErrorDetail",
          xmlName: "AuthenticationErrorDetail",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobServiceStatistics = {
    serializedName: "BlobServiceStatistics",
    xmlName: "StorageServiceStats",
    type: {
      name: "Composite",
      className: "BlobServiceStatistics",
      modelProperties: {
        geoReplication: {
          serializedName: "GeoReplication",
          xmlName: "GeoReplication",
          type: { name: "Composite", className: "GeoReplication" },
        },
      },
    },
  };
  Rk.GeoReplication = {
    serializedName: "GeoReplication",
    type: {
      name: "Composite",
      className: "GeoReplication",
      modelProperties: {
        status: {
          serializedName: "Status",
          required: !0,
          xmlName: "Status",
          type: {
            name: "Enum",
            allowedValues: ["live", "bootstrap", "unavailable"],
          },
        },
        lastSyncOn: {
          serializedName: "LastSyncTime",
          required: !0,
          xmlName: "LastSyncTime",
          type: { name: "DateTimeRfc1123" },
        },
      },
    },
  };
  Rk.ListContainersSegmentResponse = {
    serializedName: "ListContainersSegmentResponse",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "ListContainersSegmentResponse",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: !0,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: !0,
          type: { name: "String" },
        },
        prefix: {
          serializedName: "Prefix",
          xmlName: "Prefix",
          type: { name: "String" },
        },
        marker: {
          serializedName: "Marker",
          xmlName: "Marker",
          type: { name: "String" },
        },
        maxPageSize: {
          serializedName: "MaxResults",
          xmlName: "MaxResults",
          type: { name: "Number" },
        },
        containerItems: {
          serializedName: "ContainerItems",
          required: !0,
          xmlName: "Containers",
          xmlIsWrapped: !0,
          xmlElementName: "Container",
          type: {
            name: "Sequence",
            element: {
              type: { name: "Composite", className: "ContainerItem" },
            },
          },
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerItem = {
    serializedName: "ContainerItem",
    xmlName: "Container",
    type: {
      name: "Composite",
      className: "ContainerItem",
      modelProperties: {
        name: {
          serializedName: "Name",
          required: !0,
          xmlName: "Name",
          type: { name: "String" },
        },
        deleted: {
          serializedName: "Deleted",
          xmlName: "Deleted",
          type: { name: "Boolean" },
        },
        version: {
          serializedName: "Version",
          xmlName: "Version",
          type: { name: "String" },
        },
        properties: {
          serializedName: "Properties",
          xmlName: "Properties",
          type: { name: "Composite", className: "ContainerProperties" },
        },
        metadata: {
          serializedName: "Metadata",
          xmlName: "Metadata",
          type: { name: "Dictionary", value: { type: { name: "String" } } },
        },
      },
    },
  };
  Rk.ContainerProperties = {
    serializedName: "ContainerProperties",
    type: {
      name: "Composite",
      className: "ContainerProperties",
      modelProperties: {
        lastModified: {
          serializedName: "Last-Modified",
          required: !0,
          xmlName: "Last-Modified",
          type: { name: "DateTimeRfc1123" },
        },
        etag: {
          serializedName: "Etag",
          required: !0,
          xmlName: "Etag",
          type: { name: "String" },
        },
        leaseStatus: {
          serializedName: "LeaseStatus",
          xmlName: "LeaseStatus",
          type: { name: "Enum", allowedValues: ["locked", "unlocked"] },
        },
        leaseState: {
          serializedName: "LeaseState",
          xmlName: "LeaseState",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken",
            ],
          },
        },
        leaseDuration: {
          serializedName: "LeaseDuration",
          xmlName: "LeaseDuration",
          type: { name: "Enum", allowedValues: ["infinite", "fixed"] },
        },
        publicAccess: {
          serializedName: "PublicAccess",
          xmlName: "PublicAccess",
          type: { name: "Enum", allowedValues: ["container", "blob"] },
        },
        hasImmutabilityPolicy: {
          serializedName: "HasImmutabilityPolicy",
          xmlName: "HasImmutabilityPolicy",
          type: { name: "Boolean" },
        },
        hasLegalHold: {
          serializedName: "HasLegalHold",
          xmlName: "HasLegalHold",
          type: { name: "Boolean" },
        },
        defaultEncryptionScope: {
          serializedName: "DefaultEncryptionScope",
          xmlName: "DefaultEncryptionScope",
          type: { name: "String" },
        },
        preventEncryptionScopeOverride: {
          serializedName: "DenyEncryptionScopeOverride",
          xmlName: "DenyEncryptionScopeOverride",
          type: { name: "Boolean" },
        },
        deletedOn: {
          serializedName: "DeletedTime",
          xmlName: "DeletedTime",
          type: { name: "DateTimeRfc1123" },
        },
        remainingRetentionDays: {
          serializedName: "RemainingRetentionDays",
          xmlName: "RemainingRetentionDays",
          type: { name: "Number" },
        },
        isImmutableStorageWithVersioningEnabled: {
          serializedName: "ImmutableStorageWithVersioningEnabled",
          xmlName: "ImmutableStorageWithVersioningEnabled",
          type: { name: "Boolean" },
        },
      },
    },
  };
  Rk.KeyInfo = {
    serializedName: "KeyInfo",
    type: {
      name: "Composite",
      className: "KeyInfo",
      modelProperties: {
        startsOn: {
          serializedName: "Start",
          required: !0,
          xmlName: "Start",
          type: { name: "String" },
        },
        expiresOn: {
          serializedName: "Expiry",
          required: !0,
          xmlName: "Expiry",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.UserDelegationKey = {
    serializedName: "UserDelegationKey",
    type: {
      name: "Composite",
      className: "UserDelegationKey",
      modelProperties: {
        signedObjectId: {
          serializedName: "SignedOid",
          required: !0,
          xmlName: "SignedOid",
          type: { name: "String" },
        },
        signedTenantId: {
          serializedName: "SignedTid",
          required: !0,
          xmlName: "SignedTid",
          type: { name: "String" },
        },
        signedStartsOn: {
          serializedName: "SignedStart",
          required: !0,
          xmlName: "SignedStart",
          type: { name: "String" },
        },
        signedExpiresOn: {
          serializedName: "SignedExpiry",
          required: !0,
          xmlName: "SignedExpiry",
          type: { name: "String" },
        },
        signedService: {
          serializedName: "SignedService",
          required: !0,
          xmlName: "SignedService",
          type: { name: "String" },
        },
        signedVersion: {
          serializedName: "SignedVersion",
          required: !0,
          xmlName: "SignedVersion",
          type: { name: "String" },
        },
        value: {
          serializedName: "Value",
          required: !0,
          xmlName: "Value",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.FilterBlobSegment = {
    serializedName: "FilterBlobSegment",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "FilterBlobSegment",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: !0,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: !0,
          type: { name: "String" },
        },
        where: {
          serializedName: "Where",
          required: !0,
          xmlName: "Where",
          type: { name: "String" },
        },
        blobs: {
          serializedName: "Blobs",
          required: !0,
          xmlName: "Blobs",
          xmlIsWrapped: !0,
          xmlElementName: "Blob",
          type: {
            name: "Sequence",
            element: {
              type: { name: "Composite", className: "FilterBlobItem" },
            },
          },
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.FilterBlobItem = {
    serializedName: "FilterBlobItem",
    xmlName: "Blob",
    type: {
      name: "Composite",
      className: "FilterBlobItem",
      modelProperties: {
        name: {
          serializedName: "Name",
          required: !0,
          xmlName: "Name",
          type: { name: "String" },
        },
        containerName: {
          serializedName: "ContainerName",
          required: !0,
          xmlName: "ContainerName",
          type: { name: "String" },
        },
        tags: {
          serializedName: "Tags",
          xmlName: "Tags",
          type: { name: "Composite", className: "BlobTags" },
        },
      },
    },
  };
  Rk.BlobTags = {
    serializedName: "BlobTags",
    xmlName: "Tags",
    type: {
      name: "Composite",
      className: "BlobTags",
      modelProperties: {
        blobTagSet: {
          serializedName: "BlobTagSet",
          required: !0,
          xmlName: "TagSet",
          xmlIsWrapped: !0,
          xmlElementName: "Tag",
          type: {
            name: "Sequence",
            element: { type: { name: "Composite", className: "BlobTag" } },
          },
        },
      },
    },
  };
  Rk.BlobTag = {
    serializedName: "BlobTag",
    xmlName: "Tag",
    type: {
      name: "Composite",
      className: "BlobTag",
      modelProperties: {
        key: {
          serializedName: "Key",
          required: !0,
          xmlName: "Key",
          type: { name: "String" },
        },
        value: {
          serializedName: "Value",
          required: !0,
          xmlName: "Value",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.SignedIdentifier = {
    serializedName: "SignedIdentifier",
    xmlName: "SignedIdentifier",
    type: {
      name: "Composite",
      className: "SignedIdentifier",
      modelProperties: {
        id: {
          serializedName: "Id",
          required: !0,
          xmlName: "Id",
          type: { name: "String" },
        },
        accessPolicy: {
          serializedName: "AccessPolicy",
          xmlName: "AccessPolicy",
          type: { name: "Composite", className: "AccessPolicy" },
        },
      },
    },
  };
  Rk.AccessPolicy = {
    serializedName: "AccessPolicy",
    type: {
      name: "Composite",
      className: "AccessPolicy",
      modelProperties: {
        startsOn: {
          serializedName: "Start",
          xmlName: "Start",
          type: { name: "String" },
        },
        expiresOn: {
          serializedName: "Expiry",
          xmlName: "Expiry",
          type: { name: "String" },
        },
        permissions: {
          serializedName: "Permission",
          xmlName: "Permission",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ListBlobsFlatSegmentResponse = {
    serializedName: "ListBlobsFlatSegmentResponse",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "ListBlobsFlatSegmentResponse",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: !0,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: !0,
          type: { name: "String" },
        },
        containerName: {
          serializedName: "ContainerName",
          required: !0,
          xmlName: "ContainerName",
          xmlIsAttribute: !0,
          type: { name: "String" },
        },
        prefix: {
          serializedName: "Prefix",
          xmlName: "Prefix",
          type: { name: "String" },
        },
        marker: {
          serializedName: "Marker",
          xmlName: "Marker",
          type: { name: "String" },
        },
        maxPageSize: {
          serializedName: "MaxResults",
          xmlName: "MaxResults",
          type: { name: "Number" },
        },
        segment: {
          serializedName: "Segment",
          xmlName: "Blobs",
          type: { name: "Composite", className: "BlobFlatListSegment" },
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobFlatListSegment = {
    serializedName: "BlobFlatListSegment",
    xmlName: "Blobs",
    type: {
      name: "Composite",
      className: "BlobFlatListSegment",
      modelProperties: {
        blobItems: {
          serializedName: "BlobItems",
          required: !0,
          xmlName: "BlobItems",
          xmlElementName: "Blob",
          type: {
            name: "Sequence",
            element: {
              type: { name: "Composite", className: "BlobItemInternal" },
            },
          },
        },
      },
    },
  };
  Rk.BlobItemInternal = {
    serializedName: "BlobItemInternal",
    xmlName: "Blob",
    type: {
      name: "Composite",
      className: "BlobItemInternal",
      modelProperties: {
        name: {
          serializedName: "Name",
          xmlName: "Name",
          type: { name: "Composite", className: "BlobName" },
        },
        deleted: {
          serializedName: "Deleted",
          required: !0,
          xmlName: "Deleted",
          type: { name: "Boolean" },
        },
        snapshot: {
          serializedName: "Snapshot",
          required: !0,
          xmlName: "Snapshot",
          type: { name: "String" },
        },
        versionId: {
          serializedName: "VersionId",
          xmlName: "VersionId",
          type: { name: "String" },
        },
        isCurrentVersion: {
          serializedName: "IsCurrentVersion",
          xmlName: "IsCurrentVersion",
          type: { name: "Boolean" },
        },
        properties: {
          serializedName: "Properties",
          xmlName: "Properties",
          type: { name: "Composite", className: "BlobPropertiesInternal" },
        },
        metadata: {
          serializedName: "Metadata",
          xmlName: "Metadata",
          type: { name: "Dictionary", value: { type: { name: "String" } } },
        },
        blobTags: {
          serializedName: "BlobTags",
          xmlName: "Tags",
          type: { name: "Composite", className: "BlobTags" },
        },
        objectReplicationMetadata: {
          serializedName: "ObjectReplicationMetadata",
          xmlName: "OrMetadata",
          type: { name: "Dictionary", value: { type: { name: "String" } } },
        },
        hasVersionsOnly: {
          serializedName: "HasVersionsOnly",
          xmlName: "HasVersionsOnly",
          type: { name: "Boolean" },
        },
      },
    },
  };
  Rk.BlobName = {
    serializedName: "BlobName",
    type: {
      name: "Composite",
      className: "BlobName",
      modelProperties: {
        encoded: {
          serializedName: "Encoded",
          xmlName: "Encoded",
          xmlIsAttribute: !0,
          type: { name: "Boolean" },
        },
        content: {
          serializedName: "content",
          xmlName: "content",
          xmlIsMsText: !0,
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobPropertiesInternal = {
    serializedName: "BlobPropertiesInternal",
    xmlName: "Properties",
    type: {
      name: "Composite",
      className: "BlobPropertiesInternal",
      modelProperties: {
        createdOn: {
          serializedName: "Creation-Time",
          xmlName: "Creation-Time",
          type: { name: "DateTimeRfc1123" },
        },
        lastModified: {
          serializedName: "Last-Modified",
          required: !0,
          xmlName: "Last-Modified",
          type: { name: "DateTimeRfc1123" },
        },
        etag: {
          serializedName: "Etag",
          required: !0,
          xmlName: "Etag",
          type: { name: "String" },
        },
        contentLength: {
          serializedName: "Content-Length",
          xmlName: "Content-Length",
          type: { name: "Number" },
        },
        contentType: {
          serializedName: "Content-Type",
          xmlName: "Content-Type",
          type: { name: "String" },
        },
        contentEncoding: {
          serializedName: "Content-Encoding",
          xmlName: "Content-Encoding",
          type: { name: "String" },
        },
        contentLanguage: {
          serializedName: "Content-Language",
          xmlName: "Content-Language",
          type: { name: "String" },
        },
        contentMD5: {
          serializedName: "Content-MD5",
          xmlName: "Content-MD5",
          type: { name: "ByteArray" },
        },
        contentDisposition: {
          serializedName: "Content-Disposition",
          xmlName: "Content-Disposition",
          type: { name: "String" },
        },
        cacheControl: {
          serializedName: "Cache-Control",
          xmlName: "Cache-Control",
          type: { name: "String" },
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: { name: "Number" },
        },
        blobType: {
          serializedName: "BlobType",
          xmlName: "BlobType",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"],
          },
        },
        leaseStatus: {
          serializedName: "LeaseStatus",
          xmlName: "LeaseStatus",
          type: { name: "Enum", allowedValues: ["locked", "unlocked"] },
        },
        leaseState: {
          serializedName: "LeaseState",
          xmlName: "LeaseState",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken",
            ],
          },
        },
        leaseDuration: {
          serializedName: "LeaseDuration",
          xmlName: "LeaseDuration",
          type: { name: "Enum", allowedValues: ["infinite", "fixed"] },
        },
        copyId: {
          serializedName: "CopyId",
          xmlName: "CopyId",
          type: { name: "String" },
        },
        copyStatus: {
          serializedName: "CopyStatus",
          xmlName: "CopyStatus",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"],
          },
        },
        copySource: {
          serializedName: "CopySource",
          xmlName: "CopySource",
          type: { name: "String" },
        },
        copyProgress: {
          serializedName: "CopyProgress",
          xmlName: "CopyProgress",
          type: { name: "String" },
        },
        copyCompletedOn: {
          serializedName: "CopyCompletionTime",
          xmlName: "CopyCompletionTime",
          type: { name: "DateTimeRfc1123" },
        },
        copyStatusDescription: {
          serializedName: "CopyStatusDescription",
          xmlName: "CopyStatusDescription",
          type: { name: "String" },
        },
        serverEncrypted: {
          serializedName: "ServerEncrypted",
          xmlName: "ServerEncrypted",
          type: { name: "Boolean" },
        },
        incrementalCopy: {
          serializedName: "IncrementalCopy",
          xmlName: "IncrementalCopy",
          type: { name: "Boolean" },
        },
        destinationSnapshot: {
          serializedName: "DestinationSnapshot",
          xmlName: "DestinationSnapshot",
          type: { name: "String" },
        },
        deletedOn: {
          serializedName: "DeletedTime",
          xmlName: "DeletedTime",
          type: { name: "DateTimeRfc1123" },
        },
        remainingRetentionDays: {
          serializedName: "RemainingRetentionDays",
          xmlName: "RemainingRetentionDays",
          type: { name: "Number" },
        },
        accessTier: {
          serializedName: "AccessTier",
          xmlName: "AccessTier",
          type: {
            name: "Enum",
            allowedValues: [
              "P4",
              "P6",
              "P10",
              "P15",
              "P20",
              "P30",
              "P40",
              "P50",
              "P60",
              "P70",
              "P80",
              "Hot",
              "Cool",
              "Archive",
              "Cold",
            ],
          },
        },
        accessTierInferred: {
          serializedName: "AccessTierInferred",
          xmlName: "AccessTierInferred",
          type: { name: "Boolean" },
        },
        archiveStatus: {
          serializedName: "ArchiveStatus",
          xmlName: "ArchiveStatus",
          type: {
            name: "Enum",
            allowedValues: [
              "rehydrate-pending-to-hot",
              "rehydrate-pending-to-cool",
              "rehydrate-pending-to-cold",
            ],
          },
        },
        customerProvidedKeySha256: {
          serializedName: "CustomerProvidedKeySha256",
          xmlName: "CustomerProvidedKeySha256",
          type: { name: "String" },
        },
        encryptionScope: {
          serializedName: "EncryptionScope",
          xmlName: "EncryptionScope",
          type: { name: "String" },
        },
        accessTierChangedOn: {
          serializedName: "AccessTierChangeTime",
          xmlName: "AccessTierChangeTime",
          type: { name: "DateTimeRfc1123" },
        },
        tagCount: {
          serializedName: "TagCount",
          xmlName: "TagCount",
          type: { name: "Number" },
        },
        expiresOn: {
          serializedName: "Expiry-Time",
          xmlName: "Expiry-Time",
          type: { name: "DateTimeRfc1123" },
        },
        isSealed: {
          serializedName: "Sealed",
          xmlName: "Sealed",
          type: { name: "Boolean" },
        },
        rehydratePriority: {
          serializedName: "RehydratePriority",
          xmlName: "RehydratePriority",
          type: { name: "Enum", allowedValues: ["High", "Standard"] },
        },
        lastAccessedOn: {
          serializedName: "LastAccessTime",
          xmlName: "LastAccessTime",
          type: { name: "DateTimeRfc1123" },
        },
        immutabilityPolicyExpiresOn: {
          serializedName: "ImmutabilityPolicyUntilDate",
          xmlName: "ImmutabilityPolicyUntilDate",
          type: { name: "DateTimeRfc1123" },
        },
        immutabilityPolicyMode: {
          serializedName: "ImmutabilityPolicyMode",
          xmlName: "ImmutabilityPolicyMode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"],
          },
        },
        legalHold: {
          serializedName: "LegalHold",
          xmlName: "LegalHold",
          type: { name: "Boolean" },
        },
      },
    },
  };
  Rk.ListBlobsHierarchySegmentResponse = {
    serializedName: "ListBlobsHierarchySegmentResponse",
    xmlName: "EnumerationResults",
    type: {
      name: "Composite",
      className: "ListBlobsHierarchySegmentResponse",
      modelProperties: {
        serviceEndpoint: {
          serializedName: "ServiceEndpoint",
          required: !0,
          xmlName: "ServiceEndpoint",
          xmlIsAttribute: !0,
          type: { name: "String" },
        },
        containerName: {
          serializedName: "ContainerName",
          required: !0,
          xmlName: "ContainerName",
          xmlIsAttribute: !0,
          type: { name: "String" },
        },
        prefix: {
          serializedName: "Prefix",
          xmlName: "Prefix",
          type: { name: "String" },
        },
        marker: {
          serializedName: "Marker",
          xmlName: "Marker",
          type: { name: "String" },
        },
        maxPageSize: {
          serializedName: "MaxResults",
          xmlName: "MaxResults",
          type: { name: "Number" },
        },
        delimiter: {
          serializedName: "Delimiter",
          xmlName: "Delimiter",
          type: { name: "String" },
        },
        segment: {
          serializedName: "Segment",
          xmlName: "Blobs",
          type: { name: "Composite", className: "BlobHierarchyListSegment" },
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobHierarchyListSegment = {
    serializedName: "BlobHierarchyListSegment",
    xmlName: "Blobs",
    type: {
      name: "Composite",
      className: "BlobHierarchyListSegment",
      modelProperties: {
        blobPrefixes: {
          serializedName: "BlobPrefixes",
          xmlName: "BlobPrefixes",
          xmlElementName: "BlobPrefix",
          type: {
            name: "Sequence",
            element: { type: { name: "Composite", className: "BlobPrefix" } },
          },
        },
        blobItems: {
          serializedName: "BlobItems",
          required: !0,
          xmlName: "BlobItems",
          xmlElementName: "Blob",
          type: {
            name: "Sequence",
            element: {
              type: { name: "Composite", className: "BlobItemInternal" },
            },
          },
        },
      },
    },
  };
  Rk.BlobPrefix = {
    serializedName: "BlobPrefix",
    type: {
      name: "Composite",
      className: "BlobPrefix",
      modelProperties: {
        name: {
          serializedName: "Name",
          xmlName: "Name",
          type: { name: "Composite", className: "BlobName" },
        },
      },
    },
  };
  Rk.BlockLookupList = {
    serializedName: "BlockLookupList",
    xmlName: "BlockList",
    type: {
      name: "Composite",
      className: "BlockLookupList",
      modelProperties: {
        committed: {
          serializedName: "Committed",
          xmlName: "Committed",
          xmlElementName: "Committed",
          type: { name: "Sequence", element: { type: { name: "String" } } },
        },
        uncommitted: {
          serializedName: "Uncommitted",
          xmlName: "Uncommitted",
          xmlElementName: "Uncommitted",
          type: { name: "Sequence", element: { type: { name: "String" } } },
        },
        latest: {
          serializedName: "Latest",
          xmlName: "Latest",
          xmlElementName: "Latest",
          type: { name: "Sequence", element: { type: { name: "String" } } },
        },
      },
    },
  };
  Rk.BlockList = {
    serializedName: "BlockList",
    type: {
      name: "Composite",
      className: "BlockList",
      modelProperties: {
        committedBlocks: {
          serializedName: "CommittedBlocks",
          xmlName: "CommittedBlocks",
          xmlIsWrapped: !0,
          xmlElementName: "Block",
          type: {
            name: "Sequence",
            element: { type: { name: "Composite", className: "Block" } },
          },
        },
        uncommittedBlocks: {
          serializedName: "UncommittedBlocks",
          xmlName: "UncommittedBlocks",
          xmlIsWrapped: !0,
          xmlElementName: "Block",
          type: {
            name: "Sequence",
            element: { type: { name: "Composite", className: "Block" } },
          },
        },
      },
    },
  };
  Rk.Block = {
    serializedName: "Block",
    type: {
      name: "Composite",
      className: "Block",
      modelProperties: {
        name: {
          serializedName: "Name",
          required: !0,
          xmlName: "Name",
          type: { name: "String" },
        },
        size: {
          serializedName: "Size",
          required: !0,
          xmlName: "Size",
          type: { name: "Number" },
        },
      },
    },
  };
  Rk.PageList = {
    serializedName: "PageList",
    type: {
      name: "Composite",
      className: "PageList",
      modelProperties: {
        pageRange: {
          serializedName: "PageRange",
          xmlName: "PageRange",
          xmlElementName: "PageRange",
          type: {
            name: "Sequence",
            element: { type: { name: "Composite", className: "PageRange" } },
          },
        },
        clearRange: {
          serializedName: "ClearRange",
          xmlName: "ClearRange",
          xmlElementName: "ClearRange",
          type: {
            name: "Sequence",
            element: { type: { name: "Composite", className: "ClearRange" } },
          },
        },
        continuationToken: {
          serializedName: "NextMarker",
          xmlName: "NextMarker",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.PageRange = {
    serializedName: "PageRange",
    xmlName: "PageRange",
    type: {
      name: "Composite",
      className: "PageRange",
      modelProperties: {
        start: {
          serializedName: "Start",
          required: !0,
          xmlName: "Start",
          type: { name: "Number" },
        },
        end: {
          serializedName: "End",
          required: !0,
          xmlName: "End",
          type: { name: "Number" },
        },
      },
    },
  };
  Rk.ClearRange = {
    serializedName: "ClearRange",
    xmlName: "ClearRange",
    type: {
      name: "Composite",
      className: "ClearRange",
      modelProperties: {
        start: {
          serializedName: "Start",
          required: !0,
          xmlName: "Start",
          type: { name: "Number" },
        },
        end: {
          serializedName: "End",
          required: !0,
          xmlName: "End",
          type: { name: "Number" },
        },
      },
    },
  };
  Rk.QueryRequest = {
    serializedName: "QueryRequest",
    xmlName: "QueryRequest",
    type: {
      name: "Composite",
      className: "QueryRequest",
      modelProperties: {
        queryType: {
          serializedName: "QueryType",
          required: !0,
          xmlName: "QueryType",
          type: { name: "String" },
        },
        expression: {
          serializedName: "Expression",
          required: !0,
          xmlName: "Expression",
          type: { name: "String" },
        },
        inputSerialization: {
          serializedName: "InputSerialization",
          xmlName: "InputSerialization",
          type: { name: "Composite", className: "QuerySerialization" },
        },
        outputSerialization: {
          serializedName: "OutputSerialization",
          xmlName: "OutputSerialization",
          type: { name: "Composite", className: "QuerySerialization" },
        },
      },
    },
  };
  Rk.QuerySerialization = {
    serializedName: "QuerySerialization",
    type: {
      name: "Composite",
      className: "QuerySerialization",
      modelProperties: {
        format: {
          serializedName: "Format",
          xmlName: "Format",
          type: { name: "Composite", className: "QueryFormat" },
        },
      },
    },
  };
  Rk.QueryFormat = {
    serializedName: "QueryFormat",
    type: {
      name: "Composite",
      className: "QueryFormat",
      modelProperties: {
        type: {
          serializedName: "Type",
          required: !0,
          xmlName: "Type",
          type: {
            name: "Enum",
            allowedValues: ["delimited", "json", "arrow", "parquet"],
          },
        },
        delimitedTextConfiguration: {
          serializedName: "DelimitedTextConfiguration",
          xmlName: "DelimitedTextConfiguration",
          type: { name: "Composite", className: "DelimitedTextConfiguration" },
        },
        jsonTextConfiguration: {
          serializedName: "JsonTextConfiguration",
          xmlName: "JsonTextConfiguration",
          type: { name: "Composite", className: "JsonTextConfiguration" },
        },
        arrowConfiguration: {
          serializedName: "ArrowConfiguration",
          xmlName: "ArrowConfiguration",
          type: { name: "Composite", className: "ArrowConfiguration" },
        },
        parquetTextConfiguration: {
          serializedName: "ParquetTextConfiguration",
          xmlName: "ParquetTextConfiguration",
          type: { name: "Dictionary", value: { type: { name: "any" } } },
        },
      },
    },
  };
  Rk.DelimitedTextConfiguration = {
    serializedName: "DelimitedTextConfiguration",
    xmlName: "DelimitedTextConfiguration",
    type: {
      name: "Composite",
      className: "DelimitedTextConfiguration",
      modelProperties: {
        columnSeparator: {
          serializedName: "ColumnSeparator",
          xmlName: "ColumnSeparator",
          type: { name: "String" },
        },
        fieldQuote: {
          serializedName: "FieldQuote",
          xmlName: "FieldQuote",
          type: { name: "String" },
        },
        recordSeparator: {
          serializedName: "RecordSeparator",
          xmlName: "RecordSeparator",
          type: { name: "String" },
        },
        escapeChar: {
          serializedName: "EscapeChar",
          xmlName: "EscapeChar",
          type: { name: "String" },
        },
        headersPresent: {
          serializedName: "HeadersPresent",
          xmlName: "HasHeaders",
          type: { name: "Boolean" },
        },
      },
    },
  };
  Rk.JsonTextConfiguration = {
    serializedName: "JsonTextConfiguration",
    xmlName: "JsonTextConfiguration",
    type: {
      name: "Composite",
      className: "JsonTextConfiguration",
      modelProperties: {
        recordSeparator: {
          serializedName: "RecordSeparator",
          xmlName: "RecordSeparator",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ArrowConfiguration = {
    serializedName: "ArrowConfiguration",
    xmlName: "ArrowConfiguration",
    type: {
      name: "Composite",
      className: "ArrowConfiguration",
      modelProperties: {
        schema: {
          serializedName: "Schema",
          required: !0,
          xmlName: "Schema",
          xmlIsWrapped: !0,
          xmlElementName: "Field",
          type: {
            name: "Sequence",
            element: { type: { name: "Composite", className: "ArrowField" } },
          },
        },
      },
    },
  };
  Rk.ArrowField = {
    serializedName: "ArrowField",
    xmlName: "Field",
    type: {
      name: "Composite",
      className: "ArrowField",
      modelProperties: {
        type: {
          serializedName: "Type",
          required: !0,
          xmlName: "Type",
          type: { name: "String" },
        },
        name: {
          serializedName: "Name",
          xmlName: "Name",
          type: { name: "String" },
        },
        precision: {
          serializedName: "Precision",
          xmlName: "Precision",
          type: { name: "Number" },
        },
        scale: {
          serializedName: "Scale",
          xmlName: "Scale",
          type: { name: "Number" },
        },
      },
    },
  };
  Rk.ServiceSetPropertiesHeaders = {
    serializedName: "Service_setPropertiesHeaders",
    type: {
      name: "Composite",
      className: "ServiceSetPropertiesHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ServiceSetPropertiesExceptionHeaders = {
    serializedName: "Service_setPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceSetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ServiceGetPropertiesHeaders = {
    serializedName: "Service_getPropertiesHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetPropertiesHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ServiceGetPropertiesExceptionHeaders = {
    serializedName: "Service_getPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ServiceGetStatisticsHeaders = {
    serializedName: "Service_getStatisticsHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetStatisticsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ServiceGetStatisticsExceptionHeaders = {
    serializedName: "Service_getStatisticsExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetStatisticsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ServiceListContainersSegmentHeaders = {
    serializedName: "Service_listContainersSegmentHeaders",
    type: {
      name: "Composite",
      className: "ServiceListContainersSegmentHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ServiceListContainersSegmentExceptionHeaders = {
    serializedName: "Service_listContainersSegmentExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceListContainersSegmentExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ServiceGetUserDelegationKeyHeaders = {
    serializedName: "Service_getUserDelegationKeyHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetUserDelegationKeyHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ServiceGetUserDelegationKeyExceptionHeaders = {
    serializedName: "Service_getUserDelegationKeyExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetUserDelegationKeyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ServiceGetAccountInfoHeaders = {
    serializedName: "Service_getAccountInfoHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetAccountInfoHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        skuName: {
          serializedName: "x-ms-sku-name",
          xmlName: "x-ms-sku-name",
          type: {
            name: "Enum",
            allowedValues: [
              "Standard_LRS",
              "Standard_GRS",
              "Standard_RAGRS",
              "Standard_ZRS",
              "Premium_LRS",
            ],
          },
        },
        accountKind: {
          serializedName: "x-ms-account-kind",
          xmlName: "x-ms-account-kind",
          type: {
            name: "Enum",
            allowedValues: [
              "Storage",
              "BlobStorage",
              "StorageV2",
              "FileStorage",
              "BlockBlobStorage",
            ],
          },
        },
        isHierarchicalNamespaceEnabled: {
          serializedName: "x-ms-is-hns-enabled",
          xmlName: "x-ms-is-hns-enabled",
          type: { name: "Boolean" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ServiceGetAccountInfoExceptionHeaders = {
    serializedName: "Service_getAccountInfoExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceGetAccountInfoExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ServiceSubmitBatchHeaders = {
    serializedName: "Service_submitBatchHeaders",
    type: {
      name: "Composite",
      className: "ServiceSubmitBatchHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ServiceSubmitBatchExceptionHeaders = {
    serializedName: "Service_submitBatchExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceSubmitBatchExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ServiceFilterBlobsHeaders = {
    serializedName: "Service_filterBlobsHeaders",
    type: {
      name: "Composite",
      className: "ServiceFilterBlobsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ServiceFilterBlobsExceptionHeaders = {
    serializedName: "Service_filterBlobsExceptionHeaders",
    type: {
      name: "Composite",
      className: "ServiceFilterBlobsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerCreateHeaders = {
    serializedName: "Container_createHeaders",
    type: {
      name: "Composite",
      className: "ContainerCreateHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerCreateExceptionHeaders = {
    serializedName: "Container_createExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerCreateExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerGetPropertiesHeaders = {
    serializedName: "Container_getPropertiesHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetPropertiesHeaders",
      modelProperties: {
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: { name: "Dictionary", value: { type: { name: "String" } } },
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: { name: "Enum", allowedValues: ["infinite", "fixed"] },
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken",
            ],
          },
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: { name: "Enum", allowedValues: ["locked", "unlocked"] },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        blobPublicAccess: {
          serializedName: "x-ms-blob-public-access",
          xmlName: "x-ms-blob-public-access",
          type: { name: "Enum", allowedValues: ["container", "blob"] },
        },
        hasImmutabilityPolicy: {
          serializedName: "x-ms-has-immutability-policy",
          xmlName: "x-ms-has-immutability-policy",
          type: { name: "Boolean" },
        },
        hasLegalHold: {
          serializedName: "x-ms-has-legal-hold",
          xmlName: "x-ms-has-legal-hold",
          type: { name: "Boolean" },
        },
        defaultEncryptionScope: {
          serializedName: "x-ms-default-encryption-scope",
          xmlName: "x-ms-default-encryption-scope",
          type: { name: "String" },
        },
        denyEncryptionScopeOverride: {
          serializedName: "x-ms-deny-encryption-scope-override",
          xmlName: "x-ms-deny-encryption-scope-override",
          type: { name: "Boolean" },
        },
        isImmutableStorageWithVersioningEnabled: {
          serializedName: "x-ms-immutable-storage-with-versioning-enabled",
          xmlName: "x-ms-immutable-storage-with-versioning-enabled",
          type: { name: "Boolean" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerGetPropertiesExceptionHeaders = {
    serializedName: "Container_getPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerDeleteHeaders = {
    serializedName: "Container_deleteHeaders",
    type: {
      name: "Composite",
      className: "ContainerDeleteHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerDeleteExceptionHeaders = {
    serializedName: "Container_deleteExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerDeleteExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerSetMetadataHeaders = {
    serializedName: "Container_setMetadataHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetMetadataHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerSetMetadataExceptionHeaders = {
    serializedName: "Container_setMetadataExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetMetadataExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerGetAccessPolicyHeaders = {
    serializedName: "Container_getAccessPolicyHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccessPolicyHeaders",
      modelProperties: {
        blobPublicAccess: {
          serializedName: "x-ms-blob-public-access",
          xmlName: "x-ms-blob-public-access",
          type: { name: "Enum", allowedValues: ["container", "blob"] },
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerGetAccessPolicyExceptionHeaders = {
    serializedName: "Container_getAccessPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccessPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerSetAccessPolicyHeaders = {
    serializedName: "Container_setAccessPolicyHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetAccessPolicyHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerSetAccessPolicyExceptionHeaders = {
    serializedName: "Container_setAccessPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerSetAccessPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerRestoreHeaders = {
    serializedName: "Container_restoreHeaders",
    type: {
      name: "Composite",
      className: "ContainerRestoreHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerRestoreExceptionHeaders = {
    serializedName: "Container_restoreExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerRestoreExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerRenameHeaders = {
    serializedName: "Container_renameHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenameHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerRenameExceptionHeaders = {
    serializedName: "Container_renameExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenameExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerSubmitBatchHeaders = {
    serializedName: "Container_submitBatchHeaders",
    type: {
      name: "Composite",
      className: "ContainerSubmitBatchHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerSubmitBatchExceptionHeaders = {
    serializedName: "Container_submitBatchExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerSubmitBatchExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerFilterBlobsHeaders = {
    serializedName: "Container_filterBlobsHeaders",
    type: {
      name: "Composite",
      className: "ContainerFilterBlobsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
      },
    },
  };
  Rk.ContainerFilterBlobsExceptionHeaders = {
    serializedName: "Container_filterBlobsExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerFilterBlobsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerAcquireLeaseHeaders = {
    serializedName: "Container_acquireLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerAcquireLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: { name: "String" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
      },
    },
  };
  Rk.ContainerAcquireLeaseExceptionHeaders = {
    serializedName: "Container_acquireLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerAcquireLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerReleaseLeaseHeaders = {
    serializedName: "Container_releaseLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerReleaseLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
      },
    },
  };
  Rk.ContainerReleaseLeaseExceptionHeaders = {
    serializedName: "Container_releaseLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerReleaseLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerRenewLeaseHeaders = {
    serializedName: "Container_renewLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenewLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: { name: "String" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
      },
    },
  };
  Rk.ContainerRenewLeaseExceptionHeaders = {
    serializedName: "Container_renewLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerRenewLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerBreakLeaseHeaders = {
    serializedName: "Container_breakLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerBreakLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        leaseTime: {
          serializedName: "x-ms-lease-time",
          xmlName: "x-ms-lease-time",
          type: { name: "Number" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
      },
    },
  };
  Rk.ContainerBreakLeaseExceptionHeaders = {
    serializedName: "Container_breakLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerBreakLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerChangeLeaseHeaders = {
    serializedName: "Container_changeLeaseHeaders",
    type: {
      name: "Composite",
      className: "ContainerChangeLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: { name: "String" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
      },
    },
  };
  Rk.ContainerChangeLeaseExceptionHeaders = {
    serializedName: "Container_changeLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerChangeLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerListBlobFlatSegmentHeaders = {
    serializedName: "Container_listBlobFlatSegmentHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobFlatSegmentHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: { name: "String" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerListBlobFlatSegmentExceptionHeaders = {
    serializedName: "Container_listBlobFlatSegmentExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobFlatSegmentExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerListBlobHierarchySegmentHeaders = {
    serializedName: "Container_listBlobHierarchySegmentHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobHierarchySegmentHeaders",
      modelProperties: {
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: { name: "String" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerListBlobHierarchySegmentExceptionHeaders = {
    serializedName: "Container_listBlobHierarchySegmentExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerListBlobHierarchySegmentExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.ContainerGetAccountInfoHeaders = {
    serializedName: "Container_getAccountInfoHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccountInfoHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        skuName: {
          serializedName: "x-ms-sku-name",
          xmlName: "x-ms-sku-name",
          type: {
            name: "Enum",
            allowedValues: [
              "Standard_LRS",
              "Standard_GRS",
              "Standard_RAGRS",
              "Standard_ZRS",
              "Premium_LRS",
            ],
          },
        },
        accountKind: {
          serializedName: "x-ms-account-kind",
          xmlName: "x-ms-account-kind",
          type: {
            name: "Enum",
            allowedValues: [
              "Storage",
              "BlobStorage",
              "StorageV2",
              "FileStorage",
              "BlockBlobStorage",
            ],
          },
        },
        isHierarchicalNamespaceEnabled: {
          serializedName: "x-ms-is-hns-enabled",
          xmlName: "x-ms-is-hns-enabled",
          type: { name: "Boolean" },
        },
      },
    },
  };
  Rk.ContainerGetAccountInfoExceptionHeaders = {
    serializedName: "Container_getAccountInfoExceptionHeaders",
    type: {
      name: "Composite",
      className: "ContainerGetAccountInfoExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobDownloadHeaders = {
    serializedName: "Blob_downloadHeaders",
    type: {
      name: "Composite",
      className: "BlobDownloadHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        createdOn: {
          serializedName: "x-ms-creation-time",
          xmlName: "x-ms-creation-time",
          type: { name: "DateTimeRfc1123" },
        },
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: { name: "Dictionary", value: { type: { name: "String" } } },
        },
        objectReplicationPolicyId: {
          serializedName: "x-ms-or-policy-id",
          xmlName: "x-ms-or-policy-id",
          type: { name: "String" },
        },
        objectReplicationRules: {
          serializedName: "x-ms-or",
          headerCollectionPrefix: "x-ms-or-",
          xmlName: "x-ms-or",
          type: { name: "Dictionary", value: { type: { name: "String" } } },
        },
        contentLength: {
          serializedName: "content-length",
          xmlName: "content-length",
          type: { name: "Number" },
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: { name: "String" },
        },
        contentRange: {
          serializedName: "content-range",
          xmlName: "content-range",
          type: { name: "String" },
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: { name: "ByteArray" },
        },
        contentEncoding: {
          serializedName: "content-encoding",
          xmlName: "content-encoding",
          type: { name: "String" },
        },
        cacheControl: {
          serializedName: "cache-control",
          xmlName: "cache-control",
          type: { name: "String" },
        },
        contentDisposition: {
          serializedName: "content-disposition",
          xmlName: "content-disposition",
          type: { name: "String" },
        },
        contentLanguage: {
          serializedName: "content-language",
          xmlName: "content-language",
          type: { name: "String" },
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: { name: "Number" },
        },
        blobType: {
          serializedName: "x-ms-blob-type",
          xmlName: "x-ms-blob-type",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"],
          },
        },
        copyCompletedOn: {
          serializedName: "x-ms-copy-completion-time",
          xmlName: "x-ms-copy-completion-time",
          type: { name: "DateTimeRfc1123" },
        },
        copyStatusDescription: {
          serializedName: "x-ms-copy-status-description",
          xmlName: "x-ms-copy-status-description",
          type: { name: "String" },
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: { name: "String" },
        },
        copyProgress: {
          serializedName: "x-ms-copy-progress",
          xmlName: "x-ms-copy-progress",
          type: { name: "String" },
        },
        copySource: {
          serializedName: "x-ms-copy-source",
          xmlName: "x-ms-copy-source",
          type: { name: "String" },
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"],
          },
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: { name: "Enum", allowedValues: ["infinite", "fixed"] },
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken",
            ],
          },
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: { name: "Enum", allowedValues: ["locked", "unlocked"] },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: { name: "String" },
        },
        isCurrentVersion: {
          serializedName: "x-ms-is-current-version",
          xmlName: "x-ms-is-current-version",
          type: { name: "Boolean" },
        },
        acceptRanges: {
          serializedName: "accept-ranges",
          xmlName: "accept-ranges",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: { name: "Number" },
        },
        isServerEncrypted: {
          serializedName: "x-ms-server-encrypted",
          xmlName: "x-ms-server-encrypted",
          type: { name: "Boolean" },
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: { name: "String" },
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: { name: "String" },
        },
        blobContentMD5: {
          serializedName: "x-ms-blob-content-md5",
          xmlName: "x-ms-blob-content-md5",
          type: { name: "ByteArray" },
        },
        tagCount: {
          serializedName: "x-ms-tag-count",
          xmlName: "x-ms-tag-count",
          type: { name: "Number" },
        },
        isSealed: {
          serializedName: "x-ms-blob-sealed",
          xmlName: "x-ms-blob-sealed",
          type: { name: "Boolean" },
        },
        lastAccessed: {
          serializedName: "x-ms-last-access-time",
          xmlName: "x-ms-last-access-time",
          type: { name: "DateTimeRfc1123" },
        },
        immutabilityPolicyExpiresOn: {
          serializedName: "x-ms-immutability-policy-until-date",
          xmlName: "x-ms-immutability-policy-until-date",
          type: { name: "DateTimeRfc1123" },
        },
        immutabilityPolicyMode: {
          serializedName: "x-ms-immutability-policy-mode",
          xmlName: "x-ms-immutability-policy-mode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"],
          },
        },
        legalHold: {
          serializedName: "x-ms-legal-hold",
          xmlName: "x-ms-legal-hold",
          type: { name: "Boolean" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
        contentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: { name: "ByteArray" },
        },
      },
    },
  };
  Rk.BlobDownloadExceptionHeaders = {
    serializedName: "Blob_downloadExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobDownloadExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobGetPropertiesHeaders = {
    serializedName: "Blob_getPropertiesHeaders",
    type: {
      name: "Composite",
      className: "BlobGetPropertiesHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        createdOn: {
          serializedName: "x-ms-creation-time",
          xmlName: "x-ms-creation-time",
          type: { name: "DateTimeRfc1123" },
        },
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: { name: "Dictionary", value: { type: { name: "String" } } },
        },
        objectReplicationPolicyId: {
          serializedName: "x-ms-or-policy-id",
          xmlName: "x-ms-or-policy-id",
          type: { name: "String" },
        },
        objectReplicationRules: {
          serializedName: "x-ms-or",
          headerCollectionPrefix: "x-ms-or-",
          xmlName: "x-ms-or",
          type: { name: "Dictionary", value: { type: { name: "String" } } },
        },
        blobType: {
          serializedName: "x-ms-blob-type",
          xmlName: "x-ms-blob-type",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"],
          },
        },
        copyCompletedOn: {
          serializedName: "x-ms-copy-completion-time",
          xmlName: "x-ms-copy-completion-time",
          type: { name: "DateTimeRfc1123" },
        },
        copyStatusDescription: {
          serializedName: "x-ms-copy-status-description",
          xmlName: "x-ms-copy-status-description",
          type: { name: "String" },
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: { name: "String" },
        },
        copyProgress: {
          serializedName: "x-ms-copy-progress",
          xmlName: "x-ms-copy-progress",
          type: { name: "String" },
        },
        copySource: {
          serializedName: "x-ms-copy-source",
          xmlName: "x-ms-copy-source",
          type: { name: "String" },
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"],
          },
        },
        isIncrementalCopy: {
          serializedName: "x-ms-incremental-copy",
          xmlName: "x-ms-incremental-copy",
          type: { name: "Boolean" },
        },
        destinationSnapshot: {
          serializedName: "x-ms-copy-destination-snapshot",
          xmlName: "x-ms-copy-destination-snapshot",
          type: { name: "String" },
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: { name: "Enum", allowedValues: ["infinite", "fixed"] },
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken",
            ],
          },
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: { name: "Enum", allowedValues: ["locked", "unlocked"] },
        },
        contentLength: {
          serializedName: "content-length",
          xmlName: "content-length",
          type: { name: "Number" },
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: { name: "String" },
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: { name: "ByteArray" },
        },
        contentEncoding: {
          serializedName: "content-encoding",
          xmlName: "content-encoding",
          type: { name: "String" },
        },
        contentDisposition: {
          serializedName: "content-disposition",
          xmlName: "content-disposition",
          type: { name: "String" },
        },
        contentLanguage: {
          serializedName: "content-language",
          xmlName: "content-language",
          type: { name: "String" },
        },
        cacheControl: {
          serializedName: "cache-control",
          xmlName: "cache-control",
          type: { name: "String" },
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: { name: "Number" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        acceptRanges: {
          serializedName: "accept-ranges",
          xmlName: "accept-ranges",
          type: { name: "String" },
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: { name: "Number" },
        },
        isServerEncrypted: {
          serializedName: "x-ms-server-encrypted",
          xmlName: "x-ms-server-encrypted",
          type: { name: "Boolean" },
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: { name: "String" },
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: { name: "String" },
        },
        accessTier: {
          serializedName: "x-ms-access-tier",
          xmlName: "x-ms-access-tier",
          type: { name: "String" },
        },
        accessTierInferred: {
          serializedName: "x-ms-access-tier-inferred",
          xmlName: "x-ms-access-tier-inferred",
          type: { name: "Boolean" },
        },
        archiveStatus: {
          serializedName: "x-ms-archive-status",
          xmlName: "x-ms-archive-status",
          type: { name: "String" },
        },
        accessTierChangedOn: {
          serializedName: "x-ms-access-tier-change-time",
          xmlName: "x-ms-access-tier-change-time",
          type: { name: "DateTimeRfc1123" },
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: { name: "String" },
        },
        isCurrentVersion: {
          serializedName: "x-ms-is-current-version",
          xmlName: "x-ms-is-current-version",
          type: { name: "Boolean" },
        },
        tagCount: {
          serializedName: "x-ms-tag-count",
          xmlName: "x-ms-tag-count",
          type: { name: "Number" },
        },
        expiresOn: {
          serializedName: "x-ms-expiry-time",
          xmlName: "x-ms-expiry-time",
          type: { name: "DateTimeRfc1123" },
        },
        isSealed: {
          serializedName: "x-ms-blob-sealed",
          xmlName: "x-ms-blob-sealed",
          type: { name: "Boolean" },
        },
        rehydratePriority: {
          serializedName: "x-ms-rehydrate-priority",
          xmlName: "x-ms-rehydrate-priority",
          type: { name: "Enum", allowedValues: ["High", "Standard"] },
        },
        lastAccessed: {
          serializedName: "x-ms-last-access-time",
          xmlName: "x-ms-last-access-time",
          type: { name: "DateTimeRfc1123" },
        },
        immutabilityPolicyExpiresOn: {
          serializedName: "x-ms-immutability-policy-until-date",
          xmlName: "x-ms-immutability-policy-until-date",
          type: { name: "DateTimeRfc1123" },
        },
        immutabilityPolicyMode: {
          serializedName: "x-ms-immutability-policy-mode",
          xmlName: "x-ms-immutability-policy-mode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"],
          },
        },
        legalHold: {
          serializedName: "x-ms-legal-hold",
          xmlName: "x-ms-legal-hold",
          type: { name: "Boolean" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobGetPropertiesExceptionHeaders = {
    serializedName: "Blob_getPropertiesExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobGetPropertiesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobDeleteHeaders = {
    serializedName: "Blob_deleteHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobDeleteExceptionHeaders = {
    serializedName: "Blob_deleteExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobUndeleteHeaders = {
    serializedName: "Blob_undeleteHeaders",
    type: {
      name: "Composite",
      className: "BlobUndeleteHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobUndeleteExceptionHeaders = {
    serializedName: "Blob_undeleteExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobUndeleteExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobSetExpiryHeaders = {
    serializedName: "Blob_setExpiryHeaders",
    type: {
      name: "Composite",
      className: "BlobSetExpiryHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
      },
    },
  };
  Rk.BlobSetExpiryExceptionHeaders = {
    serializedName: "Blob_setExpiryExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetExpiryExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobSetHttpHeadersHeaders = {
    serializedName: "Blob_setHttpHeadersHeaders",
    type: {
      name: "Composite",
      className: "BlobSetHttpHeadersHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: { name: "Number" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobSetHttpHeadersExceptionHeaders = {
    serializedName: "Blob_setHttpHeadersExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetHttpHeadersExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobSetImmutabilityPolicyHeaders = {
    serializedName: "Blob_setImmutabilityPolicyHeaders",
    type: {
      name: "Composite",
      className: "BlobSetImmutabilityPolicyHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        immutabilityPolicyExpiry: {
          serializedName: "x-ms-immutability-policy-until-date",
          xmlName: "x-ms-immutability-policy-until-date",
          type: { name: "DateTimeRfc1123" },
        },
        immutabilityPolicyMode: {
          serializedName: "x-ms-immutability-policy-mode",
          xmlName: "x-ms-immutability-policy-mode",
          type: {
            name: "Enum",
            allowedValues: ["Mutable", "Unlocked", "Locked"],
          },
        },
      },
    },
  };
  Rk.BlobSetImmutabilityPolicyExceptionHeaders = {
    serializedName: "Blob_setImmutabilityPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetImmutabilityPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobDeleteImmutabilityPolicyHeaders = {
    serializedName: "Blob_deleteImmutabilityPolicyHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteImmutabilityPolicyHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
      },
    },
  };
  Rk.BlobDeleteImmutabilityPolicyExceptionHeaders = {
    serializedName: "Blob_deleteImmutabilityPolicyExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobDeleteImmutabilityPolicyExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobSetLegalHoldHeaders = {
    serializedName: "Blob_setLegalHoldHeaders",
    type: {
      name: "Composite",
      className: "BlobSetLegalHoldHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        legalHold: {
          serializedName: "x-ms-legal-hold",
          xmlName: "x-ms-legal-hold",
          type: { name: "Boolean" },
        },
      },
    },
  };
  Rk.BlobSetLegalHoldExceptionHeaders = {
    serializedName: "Blob_setLegalHoldExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetLegalHoldExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobSetMetadataHeaders = {
    serializedName: "Blob_setMetadataHeaders",
    type: {
      name: "Composite",
      className: "BlobSetMetadataHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: { name: "Boolean" },
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: { name: "String" },
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: { name: "String" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobSetMetadataExceptionHeaders = {
    serializedName: "Blob_setMetadataExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetMetadataExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobAcquireLeaseHeaders = {
    serializedName: "Blob_acquireLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobAcquireLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: { name: "String" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
      },
    },
  };
  Rk.BlobAcquireLeaseExceptionHeaders = {
    serializedName: "Blob_acquireLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobAcquireLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobReleaseLeaseHeaders = {
    serializedName: "Blob_releaseLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobReleaseLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
      },
    },
  };
  Rk.BlobReleaseLeaseExceptionHeaders = {
    serializedName: "Blob_releaseLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobReleaseLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobRenewLeaseHeaders = {
    serializedName: "Blob_renewLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobRenewLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: { name: "String" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
      },
    },
  };
  Rk.BlobRenewLeaseExceptionHeaders = {
    serializedName: "Blob_renewLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobRenewLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobChangeLeaseHeaders = {
    serializedName: "Blob_changeLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobChangeLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        leaseId: {
          serializedName: "x-ms-lease-id",
          xmlName: "x-ms-lease-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
      },
    },
  };
  Rk.BlobChangeLeaseExceptionHeaders = {
    serializedName: "Blob_changeLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobChangeLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobBreakLeaseHeaders = {
    serializedName: "Blob_breakLeaseHeaders",
    type: {
      name: "Composite",
      className: "BlobBreakLeaseHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        leaseTime: {
          serializedName: "x-ms-lease-time",
          xmlName: "x-ms-lease-time",
          type: { name: "Number" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
      },
    },
  };
  Rk.BlobBreakLeaseExceptionHeaders = {
    serializedName: "Blob_breakLeaseExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobBreakLeaseExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobCreateSnapshotHeaders = {
    serializedName: "Blob_createSnapshotHeaders",
    type: {
      name: "Composite",
      className: "BlobCreateSnapshotHeaders",
      modelProperties: {
        snapshot: {
          serializedName: "x-ms-snapshot",
          xmlName: "x-ms-snapshot",
          type: { name: "String" },
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: { name: "Boolean" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobCreateSnapshotExceptionHeaders = {
    serializedName: "Blob_createSnapshotExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobCreateSnapshotExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobStartCopyFromURLHeaders = {
    serializedName: "Blob_startCopyFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlobStartCopyFromURLHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: { name: "String" },
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"],
          },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobStartCopyFromURLExceptionHeaders = {
    serializedName: "Blob_startCopyFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobStartCopyFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: { name: "String" },
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: { name: "Number" },
        },
      },
    },
  };
  Rk.BlobCopyFromURLHeaders = {
    serializedName: "Blob_copyFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlobCopyFromURLHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: { name: "String" },
        },
        copyStatus: {
          defaultValue: "success",
          isConstant: !0,
          serializedName: "x-ms-copy-status",
          type: { name: "String" },
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: { name: "ByteArray" },
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: { name: "ByteArray" },
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: { name: "String" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobCopyFromURLExceptionHeaders = {
    serializedName: "Blob_copyFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobCopyFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: { name: "String" },
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: { name: "Number" },
        },
      },
    },
  };
  Rk.BlobAbortCopyFromURLHeaders = {
    serializedName: "Blob_abortCopyFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlobAbortCopyFromURLHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobAbortCopyFromURLExceptionHeaders = {
    serializedName: "Blob_abortCopyFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobAbortCopyFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobSetTierHeaders = {
    serializedName: "Blob_setTierHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTierHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobSetTierExceptionHeaders = {
    serializedName: "Blob_setTierExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTierExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobGetAccountInfoHeaders = {
    serializedName: "Blob_getAccountInfoHeaders",
    type: {
      name: "Composite",
      className: "BlobGetAccountInfoHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        skuName: {
          serializedName: "x-ms-sku-name",
          xmlName: "x-ms-sku-name",
          type: {
            name: "Enum",
            allowedValues: [
              "Standard_LRS",
              "Standard_GRS",
              "Standard_RAGRS",
              "Standard_ZRS",
              "Premium_LRS",
            ],
          },
        },
        accountKind: {
          serializedName: "x-ms-account-kind",
          xmlName: "x-ms-account-kind",
          type: {
            name: "Enum",
            allowedValues: [
              "Storage",
              "BlobStorage",
              "StorageV2",
              "FileStorage",
              "BlockBlobStorage",
            ],
          },
        },
        isHierarchicalNamespaceEnabled: {
          serializedName: "x-ms-is-hns-enabled",
          xmlName: "x-ms-is-hns-enabled",
          type: { name: "Boolean" },
        },
      },
    },
  };
  Rk.BlobGetAccountInfoExceptionHeaders = {
    serializedName: "Blob_getAccountInfoExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobGetAccountInfoExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobQueryHeaders = {
    serializedName: "Blob_queryHeaders",
    type: {
      name: "Composite",
      className: "BlobQueryHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        metadata: {
          serializedName: "x-ms-meta",
          headerCollectionPrefix: "x-ms-meta-",
          xmlName: "x-ms-meta",
          type: { name: "Dictionary", value: { type: { name: "String" } } },
        },
        contentLength: {
          serializedName: "content-length",
          xmlName: "content-length",
          type: { name: "Number" },
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: { name: "String" },
        },
        contentRange: {
          serializedName: "content-range",
          xmlName: "content-range",
          type: { name: "String" },
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: { name: "ByteArray" },
        },
        contentEncoding: {
          serializedName: "content-encoding",
          xmlName: "content-encoding",
          type: { name: "String" },
        },
        cacheControl: {
          serializedName: "cache-control",
          xmlName: "cache-control",
          type: { name: "String" },
        },
        contentDisposition: {
          serializedName: "content-disposition",
          xmlName: "content-disposition",
          type: { name: "String" },
        },
        contentLanguage: {
          serializedName: "content-language",
          xmlName: "content-language",
          type: { name: "String" },
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: { name: "Number" },
        },
        blobType: {
          serializedName: "x-ms-blob-type",
          xmlName: "x-ms-blob-type",
          type: {
            name: "Enum",
            allowedValues: ["BlockBlob", "PageBlob", "AppendBlob"],
          },
        },
        copyCompletionTime: {
          serializedName: "x-ms-copy-completion-time",
          xmlName: "x-ms-copy-completion-time",
          type: { name: "DateTimeRfc1123" },
        },
        copyStatusDescription: {
          serializedName: "x-ms-copy-status-description",
          xmlName: "x-ms-copy-status-description",
          type: { name: "String" },
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: { name: "String" },
        },
        copyProgress: {
          serializedName: "x-ms-copy-progress",
          xmlName: "x-ms-copy-progress",
          type: { name: "String" },
        },
        copySource: {
          serializedName: "x-ms-copy-source",
          xmlName: "x-ms-copy-source",
          type: { name: "String" },
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"],
          },
        },
        leaseDuration: {
          serializedName: "x-ms-lease-duration",
          xmlName: "x-ms-lease-duration",
          type: { name: "Enum", allowedValues: ["infinite", "fixed"] },
        },
        leaseState: {
          serializedName: "x-ms-lease-state",
          xmlName: "x-ms-lease-state",
          type: {
            name: "Enum",
            allowedValues: [
              "available",
              "leased",
              "expired",
              "breaking",
              "broken",
            ],
          },
        },
        leaseStatus: {
          serializedName: "x-ms-lease-status",
          xmlName: "x-ms-lease-status",
          type: { name: "Enum", allowedValues: ["locked", "unlocked"] },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        acceptRanges: {
          serializedName: "accept-ranges",
          xmlName: "accept-ranges",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: { name: "Number" },
        },
        isServerEncrypted: {
          serializedName: "x-ms-server-encrypted",
          xmlName: "x-ms-server-encrypted",
          type: { name: "Boolean" },
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: { name: "String" },
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: { name: "String" },
        },
        blobContentMD5: {
          serializedName: "x-ms-blob-content-md5",
          xmlName: "x-ms-blob-content-md5",
          type: { name: "ByteArray" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
        contentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: { name: "ByteArray" },
        },
      },
    },
  };
  Rk.BlobQueryExceptionHeaders = {
    serializedName: "Blob_queryExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobQueryExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobGetTagsHeaders = {
    serializedName: "Blob_getTagsHeaders",
    type: {
      name: "Composite",
      className: "BlobGetTagsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobGetTagsExceptionHeaders = {
    serializedName: "Blob_getTagsExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobGetTagsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobSetTagsHeaders = {
    serializedName: "Blob_setTagsHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTagsHeaders",
      modelProperties: {
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlobSetTagsExceptionHeaders = {
    serializedName: "Blob_setTagsExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlobSetTagsExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.PageBlobCreateHeaders = {
    serializedName: "PageBlob_createHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCreateHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: { name: "ByteArray" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: { name: "Boolean" },
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: { name: "String" },
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: { name: "String" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.PageBlobCreateExceptionHeaders = {
    serializedName: "PageBlob_createExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCreateExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.PageBlobUploadPagesHeaders = {
    serializedName: "PageBlob_uploadPagesHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: { name: "ByteArray" },
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: { name: "ByteArray" },
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: { name: "Number" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: { name: "Boolean" },
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: { name: "String" },
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: { name: "String" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.PageBlobUploadPagesExceptionHeaders = {
    serializedName: "PageBlob_uploadPagesExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.PageBlobClearPagesHeaders = {
    serializedName: "PageBlob_clearPagesHeaders",
    type: {
      name: "Composite",
      className: "PageBlobClearPagesHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: { name: "ByteArray" },
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: { name: "ByteArray" },
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: { name: "Number" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.PageBlobClearPagesExceptionHeaders = {
    serializedName: "PageBlob_clearPagesExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobClearPagesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.PageBlobUploadPagesFromURLHeaders = {
    serializedName: "PageBlob_uploadPagesFromURLHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesFromURLHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: { name: "ByteArray" },
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: { name: "ByteArray" },
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: { name: "Number" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: { name: "Boolean" },
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: { name: "String" },
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: { name: "String" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.PageBlobUploadPagesFromURLExceptionHeaders = {
    serializedName: "PageBlob_uploadPagesFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUploadPagesFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: { name: "String" },
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: { name: "Number" },
        },
      },
    },
  };
  Rk.PageBlobGetPageRangesHeaders = {
    serializedName: "PageBlob_getPageRangesHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        blobContentLength: {
          serializedName: "x-ms-blob-content-length",
          xmlName: "x-ms-blob-content-length",
          type: { name: "Number" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.PageBlobGetPageRangesExceptionHeaders = {
    serializedName: "PageBlob_getPageRangesExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.PageBlobGetPageRangesDiffHeaders = {
    serializedName: "PageBlob_getPageRangesDiffHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesDiffHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        blobContentLength: {
          serializedName: "x-ms-blob-content-length",
          xmlName: "x-ms-blob-content-length",
          type: { name: "Number" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.PageBlobGetPageRangesDiffExceptionHeaders = {
    serializedName: "PageBlob_getPageRangesDiffExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobGetPageRangesDiffExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.PageBlobResizeHeaders = {
    serializedName: "PageBlob_resizeHeaders",
    type: {
      name: "Composite",
      className: "PageBlobResizeHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: { name: "Number" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.PageBlobResizeExceptionHeaders = {
    serializedName: "PageBlob_resizeExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobResizeExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.PageBlobUpdateSequenceNumberHeaders = {
    serializedName: "PageBlob_updateSequenceNumberHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUpdateSequenceNumberHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        blobSequenceNumber: {
          serializedName: "x-ms-blob-sequence-number",
          xmlName: "x-ms-blob-sequence-number",
          type: { name: "Number" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.PageBlobUpdateSequenceNumberExceptionHeaders = {
    serializedName: "PageBlob_updateSequenceNumberExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobUpdateSequenceNumberExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.PageBlobCopyIncrementalHeaders = {
    serializedName: "PageBlob_copyIncrementalHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCopyIncrementalHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        copyId: {
          serializedName: "x-ms-copy-id",
          xmlName: "x-ms-copy-id",
          type: { name: "String" },
        },
        copyStatus: {
          serializedName: "x-ms-copy-status",
          xmlName: "x-ms-copy-status",
          type: {
            name: "Enum",
            allowedValues: ["pending", "success", "aborted", "failed"],
          },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.PageBlobCopyIncrementalExceptionHeaders = {
    serializedName: "PageBlob_copyIncrementalExceptionHeaders",
    type: {
      name: "Composite",
      className: "PageBlobCopyIncrementalExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.AppendBlobCreateHeaders = {
    serializedName: "AppendBlob_createHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobCreateHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: { name: "ByteArray" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: { name: "Boolean" },
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: { name: "String" },
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: { name: "String" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.AppendBlobCreateExceptionHeaders = {
    serializedName: "AppendBlob_createExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobCreateExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.AppendBlobAppendBlockHeaders = {
    serializedName: "AppendBlob_appendBlockHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: { name: "ByteArray" },
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: { name: "ByteArray" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        blobAppendOffset: {
          serializedName: "x-ms-blob-append-offset",
          xmlName: "x-ms-blob-append-offset",
          type: { name: "String" },
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: { name: "Number" },
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: { name: "Boolean" },
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: { name: "String" },
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: { name: "String" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.AppendBlobAppendBlockExceptionHeaders = {
    serializedName: "AppendBlob_appendBlockExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.AppendBlobAppendBlockFromUrlHeaders = {
    serializedName: "AppendBlob_appendBlockFromUrlHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockFromUrlHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: { name: "ByteArray" },
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: { name: "ByteArray" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        blobAppendOffset: {
          serializedName: "x-ms-blob-append-offset",
          xmlName: "x-ms-blob-append-offset",
          type: { name: "String" },
        },
        blobCommittedBlockCount: {
          serializedName: "x-ms-blob-committed-block-count",
          xmlName: "x-ms-blob-committed-block-count",
          type: { name: "Number" },
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: { name: "String" },
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: { name: "String" },
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: { name: "Boolean" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.AppendBlobAppendBlockFromUrlExceptionHeaders = {
    serializedName: "AppendBlob_appendBlockFromUrlExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobAppendBlockFromUrlExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: { name: "String" },
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: { name: "Number" },
        },
      },
    },
  };
  Rk.AppendBlobSealHeaders = {
    serializedName: "AppendBlob_sealHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobSealHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        isSealed: {
          serializedName: "x-ms-blob-sealed",
          xmlName: "x-ms-blob-sealed",
          type: { name: "Boolean" },
        },
      },
    },
  };
  Rk.AppendBlobSealExceptionHeaders = {
    serializedName: "AppendBlob_sealExceptionHeaders",
    type: {
      name: "Composite",
      className: "AppendBlobSealExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlockBlobUploadHeaders = {
    serializedName: "BlockBlob_uploadHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobUploadHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: { name: "ByteArray" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: { name: "Boolean" },
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: { name: "String" },
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: { name: "String" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlockBlobUploadExceptionHeaders = {
    serializedName: "BlockBlob_uploadExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobUploadExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlockBlobPutBlobFromUrlHeaders = {
    serializedName: "BlockBlob_putBlobFromUrlHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobPutBlobFromUrlHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: { name: "ByteArray" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: { name: "Boolean" },
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: { name: "String" },
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: { name: "String" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlockBlobPutBlobFromUrlExceptionHeaders = {
    serializedName: "BlockBlob_putBlobFromUrlExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobPutBlobFromUrlExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: { name: "String" },
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: { name: "Number" },
        },
      },
    },
  };
  Rk.BlockBlobStageBlockHeaders = {
    serializedName: "BlockBlob_stageBlockHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockHeaders",
      modelProperties: {
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: { name: "ByteArray" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: { name: "ByteArray" },
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: { name: "Boolean" },
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: { name: "String" },
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: { name: "String" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlockBlobStageBlockExceptionHeaders = {
    serializedName: "BlockBlob_stageBlockExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlockBlobStageBlockFromURLHeaders = {
    serializedName: "BlockBlob_stageBlockFromURLHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockFromURLHeaders",
      modelProperties: {
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: { name: "ByteArray" },
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: { name: "ByteArray" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: { name: "Boolean" },
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: { name: "String" },
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: { name: "String" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlockBlobStageBlockFromURLExceptionHeaders = {
    serializedName: "BlockBlob_stageBlockFromURLExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobStageBlockFromURLExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
        copySourceErrorCode: {
          serializedName: "x-ms-copy-source-error-code",
          xmlName: "x-ms-copy-source-error-code",
          type: { name: "String" },
        },
        copySourceStatusCode: {
          serializedName: "x-ms-copy-source-status-code",
          xmlName: "x-ms-copy-source-status-code",
          type: { name: "Number" },
        },
      },
    },
  };
  Rk.BlockBlobCommitBlockListHeaders = {
    serializedName: "BlockBlob_commitBlockListHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobCommitBlockListHeaders",
      modelProperties: {
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        contentMD5: {
          serializedName: "content-md5",
          xmlName: "content-md5",
          type: { name: "ByteArray" },
        },
        xMsContentCrc64: {
          serializedName: "x-ms-content-crc64",
          xmlName: "x-ms-content-crc64",
          type: { name: "ByteArray" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        versionId: {
          serializedName: "x-ms-version-id",
          xmlName: "x-ms-version-id",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        isServerEncrypted: {
          serializedName: "x-ms-request-server-encrypted",
          xmlName: "x-ms-request-server-encrypted",
          type: { name: "Boolean" },
        },
        encryptionKeySha256: {
          serializedName: "x-ms-encryption-key-sha256",
          xmlName: "x-ms-encryption-key-sha256",
          type: { name: "String" },
        },
        encryptionScope: {
          serializedName: "x-ms-encryption-scope",
          xmlName: "x-ms-encryption-scope",
          type: { name: "String" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlockBlobCommitBlockListExceptionHeaders = {
    serializedName: "BlockBlob_commitBlockListExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobCommitBlockListExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlockBlobGetBlockListHeaders = {
    serializedName: "BlockBlob_getBlockListHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobGetBlockListHeaders",
      modelProperties: {
        lastModified: {
          serializedName: "last-modified",
          xmlName: "last-modified",
          type: { name: "DateTimeRfc1123" },
        },
        etag: {
          serializedName: "etag",
          xmlName: "etag",
          type: { name: "String" },
        },
        contentType: {
          serializedName: "content-type",
          xmlName: "content-type",
          type: { name: "String" },
        },
        blobContentLength: {
          serializedName: "x-ms-blob-content-length",
          xmlName: "x-ms-blob-content-length",
          type: { name: "Number" },
        },
        clientRequestId: {
          serializedName: "x-ms-client-request-id",
          xmlName: "x-ms-client-request-id",
          type: { name: "String" },
        },
        requestId: {
          serializedName: "x-ms-request-id",
          xmlName: "x-ms-request-id",
          type: { name: "String" },
        },
        version: {
          serializedName: "x-ms-version",
          xmlName: "x-ms-version",
          type: { name: "String" },
        },
        date: {
          serializedName: "date",
          xmlName: "date",
          type: { name: "DateTimeRfc1123" },
        },
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
  Rk.BlockBlobGetBlockListExceptionHeaders = {
    serializedName: "BlockBlob_getBlockListExceptionHeaders",
    type: {
      name: "Composite",
      className: "BlockBlobGetBlockListExceptionHeaders",
      modelProperties: {
        errorCode: {
          serializedName: "x-ms-error-code",
          xmlName: "x-ms-error-code",
          type: { name: "String" },
        },
      },
    },
  };
});
var B0 = Z((zk) => {
  Object.defineProperty(zk, "__esModule", { value: !0 });
  zk.action3 =
    zk.action2 =
    zk.leaseId1 =
    zk.action1 =
    zk.proposedLeaseId =
    zk.duration =
    zk.action =
    zk.comp10 =
    zk.sourceLeaseId =
    zk.sourceContainerName =
    zk.comp9 =
    zk.deletedContainerVersion =
    zk.deletedContainerName =
    zk.comp8 =
    zk.containerAcl =
    zk.comp7 =
    zk.comp6 =
    zk.ifUnmodifiedSince =
    zk.ifModifiedSince =
    zk.leaseId =
    zk.preventEncryptionScopeOverride =
    zk.defaultEncryptionScope =
    zk.access =
    zk.metadata =
    zk.restype2 =
    zk.where =
    zk.comp5 =
    zk.multipartContentType =
    zk.contentLength =
    zk.comp4 =
    zk.body =
    zk.restype1 =
    zk.comp3 =
    zk.keyInfo =
    zk.include =
    zk.maxPageSize =
    zk.marker =
    zk.prefix =
    zk.comp2 =
    zk.comp1 =
    zk.accept1 =
    zk.requestId =
    zk.version =
    zk.timeoutInSeconds =
    zk.comp =
    zk.restype =
    zk.url =
    zk.accept =
    zk.blobServiceProperties =
    zk.contentType =
      void 0;
  zk.fileRequestIntent =
    zk.copySourceTags =
    zk.copySourceAuthorization =
    zk.sourceContentMD5 =
    zk.xMsRequiresSync =
    zk.legalHold1 =
    zk.sealBlob =
    zk.blobTagsString =
    zk.copySource =
    zk.sourceIfTags =
    zk.sourceIfNoneMatch =
    zk.sourceIfMatch =
    zk.sourceIfUnmodifiedSince =
    zk.sourceIfModifiedSince =
    zk.rehydratePriority =
    zk.tier =
    zk.comp14 =
    zk.encryptionScope =
    zk.legalHold =
    zk.comp13 =
    zk.immutabilityPolicyMode =
    zk.immutabilityPolicyExpiry =
    zk.comp12 =
    zk.blobContentDisposition =
    zk.blobContentLanguage =
    zk.blobContentEncoding =
    zk.blobContentMD5 =
    zk.blobContentType =
    zk.blobCacheControl =
    zk.expiresOn =
    zk.expiryOptions =
    zk.comp11 =
    zk.blobDeleteType =
    zk.deleteSnapshots =
    zk.ifTags =
    zk.ifNoneMatch =
    zk.ifMatch =
    zk.encryptionAlgorithm =
    zk.encryptionKeySha256 =
    zk.encryptionKey =
    zk.rangeGetContentCRC64 =
    zk.rangeGetContentMD5 =
    zk.range =
    zk.versionId =
    zk.snapshot =
    zk.delimiter =
    zk.include1 =
    zk.proposedLeaseId1 =
    zk.action4 =
    zk.breakPeriod =
      void 0;
  zk.listType =
    zk.comp25 =
    zk.blocks =
    zk.blockId =
    zk.comp24 =
    zk.copySourceBlobProperties =
    zk.blobType2 =
    zk.comp23 =
    zk.sourceRange1 =
    zk.appendPosition =
    zk.maxSize =
    zk.comp22 =
    zk.blobType1 =
    zk.comp21 =
    zk.sequenceNumberAction =
    zk.prevSnapshotUrl =
    zk.prevsnapshot =
    zk.comp20 =
    zk.range1 =
    zk.sourceContentCrc64 =
    zk.sourceRange =
    zk.sourceUrl =
    zk.pageWrite1 =
    zk.ifSequenceNumberEqualTo =
    zk.ifSequenceNumberLessThan =
    zk.ifSequenceNumberLessThanOrEqualTo =
    zk.pageWrite =
    zk.comp19 =
    zk.accept2 =
    zk.body1 =
    zk.contentType1 =
    zk.blobSequenceNumber =
    zk.blobContentLength =
    zk.blobType =
    zk.transactionalContentCrc64 =
    zk.transactionalContentMD5 =
    zk.tags =
    zk.comp18 =
    zk.comp17 =
    zk.queryRequest =
    zk.tier1 =
    zk.comp16 =
    zk.copyId =
    zk.copyActionAbortConstant =
    zk.comp15 =
      void 0;
  var WD = UC();
  zk.contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
      defaultValue: "application/xml",
      isConstant: !0,
      serializedName: "Content-Type",
      type: { name: "String" },
    },
  };
  zk.blobServiceProperties = {
    parameterPath: "blobServiceProperties",
    mapper: WD.BlobServiceProperties,
  };
  zk.accept = {
    parameterPath: "accept",
    mapper: {
      defaultValue: "application/xml",
      isConstant: !0,
      serializedName: "Accept",
      type: { name: "String" },
    },
  };
  zk.url = {
    parameterPath: "url",
    mapper: {
      serializedName: "url",
      required: !0,
      xmlName: "url",
      type: { name: "String" },
    },
    skipEncoding: !0,
  };
  zk.restype = {
    parameterPath: "restype",
    mapper: {
      defaultValue: "service",
      isConstant: !0,
      serializedName: "restype",
      type: { name: "String" },
    },
  };
  zk.comp = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "properties",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.timeoutInSeconds = {
    parameterPath: ["options", "timeoutInSeconds"],
    mapper: {
      constraints: { InclusiveMinimum: 0 },
      serializedName: "timeout",
      xmlName: "timeout",
      type: { name: "Number" },
    },
  };
  zk.version = {
    parameterPath: "version",
    mapper: {
      defaultValue: "2025-11-05",
      isConstant: !0,
      serializedName: "x-ms-version",
      type: { name: "String" },
    },
  };
  zk.requestId = {
    parameterPath: ["options", "requestId"],
    mapper: {
      serializedName: "x-ms-client-request-id",
      xmlName: "x-ms-client-request-id",
      type: { name: "String" },
    },
  };
  zk.accept1 = {
    parameterPath: "accept",
    mapper: {
      defaultValue: "application/xml",
      isConstant: !0,
      serializedName: "Accept",
      type: { name: "String" },
    },
  };
  zk.comp1 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "stats",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.comp2 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "list",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.prefix = {
    parameterPath: ["options", "prefix"],
    mapper: {
      serializedName: "prefix",
      xmlName: "prefix",
      type: { name: "String" },
    },
  };
  zk.marker = {
    parameterPath: ["options", "marker"],
    mapper: {
      serializedName: "marker",
      xmlName: "marker",
      type: { name: "String" },
    },
  };
  zk.maxPageSize = {
    parameterPath: ["options", "maxPageSize"],
    mapper: {
      constraints: { InclusiveMinimum: 1 },
      serializedName: "maxresults",
      xmlName: "maxresults",
      type: { name: "Number" },
    },
  };
  zk.include = {
    parameterPath: ["options", "include"],
    mapper: {
      serializedName: "include",
      xmlName: "include",
      xmlElementName: "ListContainersIncludeType",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Enum",
            allowedValues: ["metadata", "deleted", "system"],
          },
        },
      },
    },
    collectionFormat: "CSV",
  };
  zk.keyInfo = { parameterPath: "keyInfo", mapper: WD.KeyInfo };
  zk.comp3 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "userdelegationkey",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.restype1 = {
    parameterPath: "restype",
    mapper: {
      defaultValue: "account",
      isConstant: !0,
      serializedName: "restype",
      type: { name: "String" },
    },
  };
  zk.body = {
    parameterPath: "body",
    mapper: {
      serializedName: "body",
      required: !0,
      xmlName: "body",
      type: { name: "Stream" },
    },
  };
  zk.comp4 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "batch",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.contentLength = {
    parameterPath: "contentLength",
    mapper: {
      serializedName: "Content-Length",
      required: !0,
      xmlName: "Content-Length",
      type: { name: "Number" },
    },
  };
  zk.multipartContentType = {
    parameterPath: "multipartContentType",
    mapper: {
      serializedName: "Content-Type",
      required: !0,
      xmlName: "Content-Type",
      type: { name: "String" },
    },
  };
  zk.comp5 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "blobs",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.where = {
    parameterPath: ["options", "where"],
    mapper: {
      serializedName: "where",
      xmlName: "where",
      type: { name: "String" },
    },
  };
  zk.restype2 = {
    parameterPath: "restype",
    mapper: {
      defaultValue: "container",
      isConstant: !0,
      serializedName: "restype",
      type: { name: "String" },
    },
  };
  zk.metadata = {
    parameterPath: ["options", "metadata"],
    mapper: {
      serializedName: "x-ms-meta",
      xmlName: "x-ms-meta",
      headerCollectionPrefix: "x-ms-meta-",
      type: { name: "Dictionary", value: { type: { name: "String" } } },
    },
  };
  zk.access = {
    parameterPath: ["options", "access"],
    mapper: {
      serializedName: "x-ms-blob-public-access",
      xmlName: "x-ms-blob-public-access",
      type: { name: "Enum", allowedValues: ["container", "blob"] },
    },
  };
  zk.defaultEncryptionScope = {
    parameterPath: [
      "options",
      "containerEncryptionScope",
      "defaultEncryptionScope",
    ],
    mapper: {
      serializedName: "x-ms-default-encryption-scope",
      xmlName: "x-ms-default-encryption-scope",
      type: { name: "String" },
    },
  };
  zk.preventEncryptionScopeOverride = {
    parameterPath: [
      "options",
      "containerEncryptionScope",
      "preventEncryptionScopeOverride",
    ],
    mapper: {
      serializedName: "x-ms-deny-encryption-scope-override",
      xmlName: "x-ms-deny-encryption-scope-override",
      type: { name: "Boolean" },
    },
  };
  zk.leaseId = {
    parameterPath: ["options", "leaseAccessConditions", "leaseId"],
    mapper: {
      serializedName: "x-ms-lease-id",
      xmlName: "x-ms-lease-id",
      type: { name: "String" },
    },
  };
  zk.ifModifiedSince = {
    parameterPath: ["options", "modifiedAccessConditions", "ifModifiedSince"],
    mapper: {
      serializedName: "If-Modified-Since",
      xmlName: "If-Modified-Since",
      type: { name: "DateTimeRfc1123" },
    },
  };
  zk.ifUnmodifiedSince = {
    parameterPath: ["options", "modifiedAccessConditions", "ifUnmodifiedSince"],
    mapper: {
      serializedName: "If-Unmodified-Since",
      xmlName: "If-Unmodified-Since",
      type: { name: "DateTimeRfc1123" },
    },
  };
  zk.comp6 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "metadata",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.comp7 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "acl",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.containerAcl = {
    parameterPath: ["options", "containerAcl"],
    mapper: {
      serializedName: "containerAcl",
      xmlName: "SignedIdentifiers",
      xmlIsWrapped: !0,
      xmlElementName: "SignedIdentifier",
      type: {
        name: "Sequence",
        element: { type: { name: "Composite", className: "SignedIdentifier" } },
      },
    },
  };
  zk.comp8 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "undelete",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.deletedContainerName = {
    parameterPath: ["options", "deletedContainerName"],
    mapper: {
      serializedName: "x-ms-deleted-container-name",
      xmlName: "x-ms-deleted-container-name",
      type: { name: "String" },
    },
  };
  zk.deletedContainerVersion = {
    parameterPath: ["options", "deletedContainerVersion"],
    mapper: {
      serializedName: "x-ms-deleted-container-version",
      xmlName: "x-ms-deleted-container-version",
      type: { name: "String" },
    },
  };
  zk.comp9 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "rename",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.sourceContainerName = {
    parameterPath: "sourceContainerName",
    mapper: {
      serializedName: "x-ms-source-container-name",
      required: !0,
      xmlName: "x-ms-source-container-name",
      type: { name: "String" },
    },
  };
  zk.sourceLeaseId = {
    parameterPath: ["options", "sourceLeaseId"],
    mapper: {
      serializedName: "x-ms-source-lease-id",
      xmlName: "x-ms-source-lease-id",
      type: { name: "String" },
    },
  };
  zk.comp10 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "lease",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.action = {
    parameterPath: "action",
    mapper: {
      defaultValue: "acquire",
      isConstant: !0,
      serializedName: "x-ms-lease-action",
      type: { name: "String" },
    },
  };
  zk.duration = {
    parameterPath: ["options", "duration"],
    mapper: {
      serializedName: "x-ms-lease-duration",
      xmlName: "x-ms-lease-duration",
      type: { name: "Number" },
    },
  };
  zk.proposedLeaseId = {
    parameterPath: ["options", "proposedLeaseId"],
    mapper: {
      serializedName: "x-ms-proposed-lease-id",
      xmlName: "x-ms-proposed-lease-id",
      type: { name: "String" },
    },
  };
  zk.action1 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "release",
      isConstant: !0,
      serializedName: "x-ms-lease-action",
      type: { name: "String" },
    },
  };
  zk.leaseId1 = {
    parameterPath: "leaseId",
    mapper: {
      serializedName: "x-ms-lease-id",
      required: !0,
      xmlName: "x-ms-lease-id",
      type: { name: "String" },
    },
  };
  zk.action2 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "renew",
      isConstant: !0,
      serializedName: "x-ms-lease-action",
      type: { name: "String" },
    },
  };
  zk.action3 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "break",
      isConstant: !0,
      serializedName: "x-ms-lease-action",
      type: { name: "String" },
    },
  };
  zk.breakPeriod = {
    parameterPath: ["options", "breakPeriod"],
    mapper: {
      serializedName: "x-ms-lease-break-period",
      xmlName: "x-ms-lease-break-period",
      type: { name: "Number" },
    },
  };
  zk.action4 = {
    parameterPath: "action",
    mapper: {
      defaultValue: "change",
      isConstant: !0,
      serializedName: "x-ms-lease-action",
      type: { name: "String" },
    },
  };
  zk.proposedLeaseId1 = {
    parameterPath: "proposedLeaseId",
    mapper: {
      serializedName: "x-ms-proposed-lease-id",
      required: !0,
      xmlName: "x-ms-proposed-lease-id",
      type: { name: "String" },
    },
  };
  zk.include1 = {
    parameterPath: ["options", "include"],
    mapper: {
      serializedName: "include",
      xmlName: "include",
      xmlElementName: "ListBlobsIncludeItem",
      type: {
        name: "Sequence",
        element: {
          type: {
            name: "Enum",
            allowedValues: [
              "copy",
              "deleted",
              "metadata",
              "snapshots",
              "uncommittedblobs",
              "versions",
              "tags",
              "immutabilitypolicy",
              "legalhold",
              "deletedwithversions",
            ],
          },
        },
      },
    },
    collectionFormat: "CSV",
  };
  zk.delimiter = {
    parameterPath: "delimiter",
    mapper: {
      serializedName: "delimiter",
      required: !0,
      xmlName: "delimiter",
      type: { name: "String" },
    },
  };
  zk.snapshot = {
    parameterPath: ["options", "snapshot"],
    mapper: {
      serializedName: "snapshot",
      xmlName: "snapshot",
      type: { name: "String" },
    },
  };
  zk.versionId = {
    parameterPath: ["options", "versionId"],
    mapper: {
      serializedName: "versionid",
      xmlName: "versionid",
      type: { name: "String" },
    },
  };
  zk.range = {
    parameterPath: ["options", "range"],
    mapper: {
      serializedName: "x-ms-range",
      xmlName: "x-ms-range",
      type: { name: "String" },
    },
  };
  zk.rangeGetContentMD5 = {
    parameterPath: ["options", "rangeGetContentMD5"],
    mapper: {
      serializedName: "x-ms-range-get-content-md5",
      xmlName: "x-ms-range-get-content-md5",
      type: { name: "Boolean" },
    },
  };
  zk.rangeGetContentCRC64 = {
    parameterPath: ["options", "rangeGetContentCRC64"],
    mapper: {
      serializedName: "x-ms-range-get-content-crc64",
      xmlName: "x-ms-range-get-content-crc64",
      type: { name: "Boolean" },
    },
  };
  zk.encryptionKey = {
    parameterPath: ["options", "cpkInfo", "encryptionKey"],
    mapper: {
      serializedName: "x-ms-encryption-key",
      xmlName: "x-ms-encryption-key",
      type: { name: "String" },
    },
  };
  zk.encryptionKeySha256 = {
    parameterPath: ["options", "cpkInfo", "encryptionKeySha256"],
    mapper: {
      serializedName: "x-ms-encryption-key-sha256",
      xmlName: "x-ms-encryption-key-sha256",
      type: { name: "String" },
    },
  };
  zk.encryptionAlgorithm = {
    parameterPath: ["options", "cpkInfo", "encryptionAlgorithm"],
    mapper: {
      serializedName: "x-ms-encryption-algorithm",
      xmlName: "x-ms-encryption-algorithm",
      type: { name: "String" },
    },
  };
  zk.ifMatch = {
    parameterPath: ["options", "modifiedAccessConditions", "ifMatch"],
    mapper: {
      serializedName: "If-Match",
      xmlName: "If-Match",
      type: { name: "String" },
    },
  };
  zk.ifNoneMatch = {
    parameterPath: ["options", "modifiedAccessConditions", "ifNoneMatch"],
    mapper: {
      serializedName: "If-None-Match",
      xmlName: "If-None-Match",
      type: { name: "String" },
    },
  };
  zk.ifTags = {
    parameterPath: ["options", "modifiedAccessConditions", "ifTags"],
    mapper: {
      serializedName: "x-ms-if-tags",
      xmlName: "x-ms-if-tags",
      type: { name: "String" },
    },
  };
  zk.deleteSnapshots = {
    parameterPath: ["options", "deleteSnapshots"],
    mapper: {
      serializedName: "x-ms-delete-snapshots",
      xmlName: "x-ms-delete-snapshots",
      type: { name: "Enum", allowedValues: ["include", "only"] },
    },
  };
  zk.blobDeleteType = {
    parameterPath: ["options", "blobDeleteType"],
    mapper: {
      serializedName: "deletetype",
      xmlName: "deletetype",
      type: { name: "String" },
    },
  };
  zk.comp11 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "expiry",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.expiryOptions = {
    parameterPath: "expiryOptions",
    mapper: {
      serializedName: "x-ms-expiry-option",
      required: !0,
      xmlName: "x-ms-expiry-option",
      type: { name: "String" },
    },
  };
  zk.expiresOn = {
    parameterPath: ["options", "expiresOn"],
    mapper: {
      serializedName: "x-ms-expiry-time",
      xmlName: "x-ms-expiry-time",
      type: { name: "String" },
    },
  };
  zk.blobCacheControl = {
    parameterPath: ["options", "blobHttpHeaders", "blobCacheControl"],
    mapper: {
      serializedName: "x-ms-blob-cache-control",
      xmlName: "x-ms-blob-cache-control",
      type: { name: "String" },
    },
  };
  zk.blobContentType = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentType"],
    mapper: {
      serializedName: "x-ms-blob-content-type",
      xmlName: "x-ms-blob-content-type",
      type: { name: "String" },
    },
  };
  zk.blobContentMD5 = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentMD5"],
    mapper: {
      serializedName: "x-ms-blob-content-md5",
      xmlName: "x-ms-blob-content-md5",
      type: { name: "ByteArray" },
    },
  };
  zk.blobContentEncoding = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentEncoding"],
    mapper: {
      serializedName: "x-ms-blob-content-encoding",
      xmlName: "x-ms-blob-content-encoding",
      type: { name: "String" },
    },
  };
  zk.blobContentLanguage = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentLanguage"],
    mapper: {
      serializedName: "x-ms-blob-content-language",
      xmlName: "x-ms-blob-content-language",
      type: { name: "String" },
    },
  };
  zk.blobContentDisposition = {
    parameterPath: ["options", "blobHttpHeaders", "blobContentDisposition"],
    mapper: {
      serializedName: "x-ms-blob-content-disposition",
      xmlName: "x-ms-blob-content-disposition",
      type: { name: "String" },
    },
  };
  zk.comp12 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "immutabilityPolicies",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.immutabilityPolicyExpiry = {
    parameterPath: ["options", "immutabilityPolicyExpiry"],
    mapper: {
      serializedName: "x-ms-immutability-policy-until-date",
      xmlName: "x-ms-immutability-policy-until-date",
      type: { name: "DateTimeRfc1123" },
    },
  };
  zk.immutabilityPolicyMode = {
    parameterPath: ["options", "immutabilityPolicyMode"],
    mapper: {
      serializedName: "x-ms-immutability-policy-mode",
      xmlName: "x-ms-immutability-policy-mode",
      type: { name: "Enum", allowedValues: ["Mutable", "Unlocked", "Locked"] },
    },
  };
  zk.comp13 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "legalhold",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.legalHold = {
    parameterPath: "legalHold",
    mapper: {
      serializedName: "x-ms-legal-hold",
      required: !0,
      xmlName: "x-ms-legal-hold",
      type: { name: "Boolean" },
    },
  };
  zk.encryptionScope = {
    parameterPath: ["options", "encryptionScope"],
    mapper: {
      serializedName: "x-ms-encryption-scope",
      xmlName: "x-ms-encryption-scope",
      type: { name: "String" },
    },
  };
  zk.comp14 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "snapshot",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.tier = {
    parameterPath: ["options", "tier"],
    mapper: {
      serializedName: "x-ms-access-tier",
      xmlName: "x-ms-access-tier",
      type: {
        name: "Enum",
        allowedValues: [
          "P4",
          "P6",
          "P10",
          "P15",
          "P20",
          "P30",
          "P40",
          "P50",
          "P60",
          "P70",
          "P80",
          "Hot",
          "Cool",
          "Archive",
          "Cold",
        ],
      },
    },
  };
  zk.rehydratePriority = {
    parameterPath: ["options", "rehydratePriority"],
    mapper: {
      serializedName: "x-ms-rehydrate-priority",
      xmlName: "x-ms-rehydrate-priority",
      type: { name: "Enum", allowedValues: ["High", "Standard"] },
    },
  };
  zk.sourceIfModifiedSince = {
    parameterPath: [
      "options",
      "sourceModifiedAccessConditions",
      "sourceIfModifiedSince",
    ],
    mapper: {
      serializedName: "x-ms-source-if-modified-since",
      xmlName: "x-ms-source-if-modified-since",
      type: { name: "DateTimeRfc1123" },
    },
  };
  zk.sourceIfUnmodifiedSince = {
    parameterPath: [
      "options",
      "sourceModifiedAccessConditions",
      "sourceIfUnmodifiedSince",
    ],
    mapper: {
      serializedName: "x-ms-source-if-unmodified-since",
      xmlName: "x-ms-source-if-unmodified-since",
      type: { name: "DateTimeRfc1123" },
    },
  };
  zk.sourceIfMatch = {
    parameterPath: [
      "options",
      "sourceModifiedAccessConditions",
      "sourceIfMatch",
    ],
    mapper: {
      serializedName: "x-ms-source-if-match",
      xmlName: "x-ms-source-if-match",
      type: { name: "String" },
    },
  };
  zk.sourceIfNoneMatch = {
    parameterPath: [
      "options",
      "sourceModifiedAccessConditions",
      "sourceIfNoneMatch",
    ],
    mapper: {
      serializedName: "x-ms-source-if-none-match",
      xmlName: "x-ms-source-if-none-match",
      type: { name: "String" },
    },
  };
  zk.sourceIfTags = {
    parameterPath: [
      "options",
      "sourceModifiedAccessConditions",
      "sourceIfTags",
    ],
    mapper: {
      serializedName: "x-ms-source-if-tags",
      xmlName: "x-ms-source-if-tags",
      type: { name: "String" },
    },
  };
  zk.copySource = {
    parameterPath: "copySource",
    mapper: {
      serializedName: "x-ms-copy-source",
      required: !0,
      xmlName: "x-ms-copy-source",
      type: { name: "String" },
    },
  };
  zk.blobTagsString = {
    parameterPath: ["options", "blobTagsString"],
    mapper: {
      serializedName: "x-ms-tags",
      xmlName: "x-ms-tags",
      type: { name: "String" },
    },
  };
  zk.sealBlob = {
    parameterPath: ["options", "sealBlob"],
    mapper: {
      serializedName: "x-ms-seal-blob",
      xmlName: "x-ms-seal-blob",
      type: { name: "Boolean" },
    },
  };
  zk.legalHold1 = {
    parameterPath: ["options", "legalHold"],
    mapper: {
      serializedName: "x-ms-legal-hold",
      xmlName: "x-ms-legal-hold",
      type: { name: "Boolean" },
    },
  };
  zk.xMsRequiresSync = {
    parameterPath: "xMsRequiresSync",
    mapper: {
      defaultValue: "true",
      isConstant: !0,
      serializedName: "x-ms-requires-sync",
      type: { name: "String" },
    },
  };
  zk.sourceContentMD5 = {
    parameterPath: ["options", "sourceContentMD5"],
    mapper: {
      serializedName: "x-ms-source-content-md5",
      xmlName: "x-ms-source-content-md5",
      type: { name: "ByteArray" },
    },
  };
  zk.copySourceAuthorization = {
    parameterPath: ["options", "copySourceAuthorization"],
    mapper: {
      serializedName: "x-ms-copy-source-authorization",
      xmlName: "x-ms-copy-source-authorization",
      type: { name: "String" },
    },
  };
  zk.copySourceTags = {
    parameterPath: ["options", "copySourceTags"],
    mapper: {
      serializedName: "x-ms-copy-source-tag-option",
      xmlName: "x-ms-copy-source-tag-option",
      type: { name: "Enum", allowedValues: ["REPLACE", "COPY"] },
    },
  };
  zk.fileRequestIntent = {
    parameterPath: ["options", "fileRequestIntent"],
    mapper: {
      serializedName: "x-ms-file-request-intent",
      xmlName: "x-ms-file-request-intent",
      type: { name: "String" },
    },
  };
  zk.comp15 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "copy",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.copyActionAbortConstant = {
    parameterPath: "copyActionAbortConstant",
    mapper: {
      defaultValue: "abort",
      isConstant: !0,
      serializedName: "x-ms-copy-action",
      type: { name: "String" },
    },
  };
  zk.copyId = {
    parameterPath: "copyId",
    mapper: {
      serializedName: "copyid",
      required: !0,
      xmlName: "copyid",
      type: { name: "String" },
    },
  };
  zk.comp16 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "tier",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.tier1 = {
    parameterPath: "tier",
    mapper: {
      serializedName: "x-ms-access-tier",
      required: !0,
      xmlName: "x-ms-access-tier",
      type: {
        name: "Enum",
        allowedValues: [
          "P4",
          "P6",
          "P10",
          "P15",
          "P20",
          "P30",
          "P40",
          "P50",
          "P60",
          "P70",
          "P80",
          "Hot",
          "Cool",
          "Archive",
          "Cold",
        ],
      },
    },
  };
  zk.queryRequest = {
    parameterPath: ["options", "queryRequest"],
    mapper: WD.QueryRequest,
  };
  zk.comp17 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "query",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.comp18 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "tags",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.tags = { parameterPath: ["options", "tags"], mapper: WD.BlobTags };
  zk.transactionalContentMD5 = {
    parameterPath: ["options", "transactionalContentMD5"],
    mapper: {
      serializedName: "Content-MD5",
      xmlName: "Content-MD5",
      type: { name: "ByteArray" },
    },
  };
  zk.transactionalContentCrc64 = {
    parameterPath: ["options", "transactionalContentCrc64"],
    mapper: {
      serializedName: "x-ms-content-crc64",
      xmlName: "x-ms-content-crc64",
      type: { name: "ByteArray" },
    },
  };
  zk.blobType = {
    parameterPath: "blobType",
    mapper: {
      defaultValue: "PageBlob",
      isConstant: !0,
      serializedName: "x-ms-blob-type",
      type: { name: "String" },
    },
  };
  zk.blobContentLength = {
    parameterPath: "blobContentLength",
    mapper: {
      serializedName: "x-ms-blob-content-length",
      required: !0,
      xmlName: "x-ms-blob-content-length",
      type: { name: "Number" },
    },
  };
  zk.blobSequenceNumber = {
    parameterPath: ["options", "blobSequenceNumber"],
    mapper: {
      defaultValue: 0,
      serializedName: "x-ms-blob-sequence-number",
      xmlName: "x-ms-blob-sequence-number",
      type: { name: "Number" },
    },
  };
  zk.contentType1 = {
    parameterPath: ["options", "contentType"],
    mapper: {
      defaultValue: "application/octet-stream",
      isConstant: !0,
      serializedName: "Content-Type",
      type: { name: "String" },
    },
  };
  zk.body1 = {
    parameterPath: "body",
    mapper: {
      serializedName: "body",
      required: !0,
      xmlName: "body",
      type: { name: "Stream" },
    },
  };
  zk.accept2 = {
    parameterPath: "accept",
    mapper: {
      defaultValue: "application/xml",
      isConstant: !0,
      serializedName: "Accept",
      type: { name: "String" },
    },
  };
  zk.comp19 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "page",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.pageWrite = {
    parameterPath: "pageWrite",
    mapper: {
      defaultValue: "update",
      isConstant: !0,
      serializedName: "x-ms-page-write",
      type: { name: "String" },
    },
  };
  zk.ifSequenceNumberLessThanOrEqualTo = {
    parameterPath: [
      "options",
      "sequenceNumberAccessConditions",
      "ifSequenceNumberLessThanOrEqualTo",
    ],
    mapper: {
      serializedName: "x-ms-if-sequence-number-le",
      xmlName: "x-ms-if-sequence-number-le",
      type: { name: "Number" },
    },
  };
  zk.ifSequenceNumberLessThan = {
    parameterPath: [
      "options",
      "sequenceNumberAccessConditions",
      "ifSequenceNumberLessThan",
    ],
    mapper: {
      serializedName: "x-ms-if-sequence-number-lt",
      xmlName: "x-ms-if-sequence-number-lt",
      type: { name: "Number" },
    },
  };
  zk.ifSequenceNumberEqualTo = {
    parameterPath: [
      "options",
      "sequenceNumberAccessConditions",
      "ifSequenceNumberEqualTo",
    ],
    mapper: {
      serializedName: "x-ms-if-sequence-number-eq",
      xmlName: "x-ms-if-sequence-number-eq",
      type: { name: "Number" },
    },
  };
  zk.pageWrite1 = {
    parameterPath: "pageWrite",
    mapper: {
      defaultValue: "clear",
      isConstant: !0,
      serializedName: "x-ms-page-write",
      type: { name: "String" },
    },
  };
  zk.sourceUrl = {
    parameterPath: "sourceUrl",
    mapper: {
      serializedName: "x-ms-copy-source",
      required: !0,
      xmlName: "x-ms-copy-source",
      type: { name: "String" },
    },
  };
  zk.sourceRange = {
    parameterPath: "sourceRange",
    mapper: {
      serializedName: "x-ms-source-range",
      required: !0,
      xmlName: "x-ms-source-range",
      type: { name: "String" },
    },
  };
  zk.sourceContentCrc64 = {
    parameterPath: ["options", "sourceContentCrc64"],
    mapper: {
      serializedName: "x-ms-source-content-crc64",
      xmlName: "x-ms-source-content-crc64",
      type: { name: "ByteArray" },
    },
  };
  zk.range1 = {
    parameterPath: "range",
    mapper: {
      serializedName: "x-ms-range",
      required: !0,
      xmlName: "x-ms-range",
      type: { name: "String" },
    },
  };
  zk.comp20 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "pagelist",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.prevsnapshot = {
    parameterPath: ["options", "prevsnapshot"],
    mapper: {
      serializedName: "prevsnapshot",
      xmlName: "prevsnapshot",
      type: { name: "String" },
    },
  };
  zk.prevSnapshotUrl = {
    parameterPath: ["options", "prevSnapshotUrl"],
    mapper: {
      serializedName: "x-ms-previous-snapshot-url",
      xmlName: "x-ms-previous-snapshot-url",
      type: { name: "String" },
    },
  };
  zk.sequenceNumberAction = {
    parameterPath: "sequenceNumberAction",
    mapper: {
      serializedName: "x-ms-sequence-number-action",
      required: !0,
      xmlName: "x-ms-sequence-number-action",
      type: { name: "Enum", allowedValues: ["max", "update", "increment"] },
    },
  };
  zk.comp21 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "incrementalcopy",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.blobType1 = {
    parameterPath: "blobType",
    mapper: {
      defaultValue: "AppendBlob",
      isConstant: !0,
      serializedName: "x-ms-blob-type",
      type: { name: "String" },
    },
  };
  zk.comp22 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "appendblock",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.maxSize = {
    parameterPath: ["options", "appendPositionAccessConditions", "maxSize"],
    mapper: {
      serializedName: "x-ms-blob-condition-maxsize",
      xmlName: "x-ms-blob-condition-maxsize",
      type: { name: "Number" },
    },
  };
  zk.appendPosition = {
    parameterPath: [
      "options",
      "appendPositionAccessConditions",
      "appendPosition",
    ],
    mapper: {
      serializedName: "x-ms-blob-condition-appendpos",
      xmlName: "x-ms-blob-condition-appendpos",
      type: { name: "Number" },
    },
  };
  zk.sourceRange1 = {
    parameterPath: ["options", "sourceRange"],
    mapper: {
      serializedName: "x-ms-source-range",
      xmlName: "x-ms-source-range",
      type: { name: "String" },
    },
  };
  zk.comp23 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "seal",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.blobType2 = {
    parameterPath: "blobType",
    mapper: {
      defaultValue: "BlockBlob",
      isConstant: !0,
      serializedName: "x-ms-blob-type",
      type: { name: "String" },
    },
  };
  zk.copySourceBlobProperties = {
    parameterPath: ["options", "copySourceBlobProperties"],
    mapper: {
      serializedName: "x-ms-copy-source-blob-properties",
      xmlName: "x-ms-copy-source-blob-properties",
      type: { name: "Boolean" },
    },
  };
  zk.comp24 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "block",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.blockId = {
    parameterPath: "blockId",
    mapper: {
      serializedName: "blockid",
      required: !0,
      xmlName: "blockid",
      type: { name: "String" },
    },
  };
  zk.blocks = { parameterPath: "blocks", mapper: WD.BlockLookupList };
  zk.comp25 = {
    parameterPath: "comp",
    mapper: {
      defaultValue: "blocklist",
      isConstant: !0,
      serializedName: "comp",
      type: { name: "String" },
    },
  };
  zk.listType = {
    parameterPath: "listType",
    mapper: {
      defaultValue: "committed",
      serializedName: "blocklisttype",
      required: !0,
      xmlName: "blocklisttype",
      type: {
        name: "Enum",
        allowedValues: ["committed", "uncommitted", "all"],
      },
    },
  };
});
var kk = Z((fk) => {
  Object.defineProperty(fk, "__esModule", { value: !0 });
  fk.ServiceImpl = void 0;
  var Q4 = BQ(),
    L5A = Q4.__importStar(oI()),
    xA = Q4.__importStar(UC()),
    c = Q4.__importStar(B0());
  class jk {
    client;
    constructor(A) {
      this.client = A;
    }
    setProperties(A, Q) {
      return this.client.sendOperationRequest(
        { blobServiceProperties: A, options: Q },
        R5A,
      );
    }
    getProperties(A) {
      return this.client.sendOperationRequest({ options: A }, V5A);
    }
    getStatistics(A) {
      return this.client.sendOperationRequest({ options: A }, $5A);
    }
    listContainersSegment(A) {
      return this.client.sendOperationRequest({ options: A }, H5A);
    }
    getUserDelegationKey(A, Q) {
      return this.client.sendOperationRequest({ keyInfo: A, options: Q }, K5A);
    }
    getAccountInfo(A) {
      return this.client.sendOperationRequest({ options: A }, z5A);
    }
    submitBatch(A, Q, B, I) {
      return this.client.sendOperationRequest(
        { contentLength: A, multipartContentType: Q, body: B, options: I },
        T5A,
      );
    }
    filterBlobs(A) {
      return this.client.sendOperationRequest({ options: A }, O5A);
    }
  }
  fk.ServiceImpl = jk;
  var WC = L5A.createSerializer(xA, !0),
    R5A = {
      path: "/",
      httpMethod: "PUT",
      responses: {
        202: { headersMapper: xA.ServiceSetPropertiesHeaders },
        default: {
          bodyMapper: xA.StorageError,
          headersMapper: xA.ServiceSetPropertiesExceptionHeaders,
        },
      },
      requestBody: c.blobServiceProperties,
      queryParameters: [c.restype, c.comp, c.timeoutInSeconds],
      urlParameters: [c.url],
      headerParameters: [c.contentType, c.accept, c.version, c.requestId],
      isXML: !0,
      contentType: "application/xml; charset=utf-8",
      mediaType: "xml",
      serializer: WC,
    },
    V5A = {
      path: "/",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: xA.BlobServiceProperties,
          headersMapper: xA.ServiceGetPropertiesHeaders,
        },
        default: {
          bodyMapper: xA.StorageError,
          headersMapper: xA.ServiceGetPropertiesExceptionHeaders,
        },
      },
      queryParameters: [c.restype, c.comp, c.timeoutInSeconds],
      urlParameters: [c.url],
      headerParameters: [c.version, c.requestId, c.accept1],
      isXML: !0,
      serializer: WC,
    },
    $5A = {
      path: "/",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: xA.BlobServiceStatistics,
          headersMapper: xA.ServiceGetStatisticsHeaders,
        },
        default: {
          bodyMapper: xA.StorageError,
          headersMapper: xA.ServiceGetStatisticsExceptionHeaders,
        },
      },
      queryParameters: [c.restype, c.timeoutInSeconds, c.comp1],
      urlParameters: [c.url],
      headerParameters: [c.version, c.requestId, c.accept1],
      isXML: !0,
      serializer: WC,
    },
    H5A = {
      path: "/",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: xA.ListContainersSegmentResponse,
          headersMapper: xA.ServiceListContainersSegmentHeaders,
        },
        default: {
          bodyMapper: xA.StorageError,
          headersMapper: xA.ServiceListContainersSegmentExceptionHeaders,
        },
      },
      queryParameters: [
        c.timeoutInSeconds,
        c.comp2,
        c.prefix,
        c.marker,
        c.maxPageSize,
        c.include,
      ],
      urlParameters: [c.url],
      headerParameters: [c.version, c.requestId, c.accept1],
      isXML: !0,
      serializer: WC,
    },
    K5A = {
      path: "/",
      httpMethod: "POST",
      responses: {
        200: {
          bodyMapper: xA.UserDelegationKey,
          headersMapper: xA.ServiceGetUserDelegationKeyHeaders,
        },
        default: {
          bodyMapper: xA.StorageError,
          headersMapper: xA.ServiceGetUserDelegationKeyExceptionHeaders,
        },
      },
      requestBody: c.keyInfo,
      queryParameters: [c.restype, c.timeoutInSeconds, c.comp3],
      urlParameters: [c.url],
      headerParameters: [c.contentType, c.accept, c.version, c.requestId],
      isXML: !0,
      contentType: "application/xml; charset=utf-8",
      mediaType: "xml",
      serializer: WC,
    },
    z5A = {
      path: "/",
      httpMethod: "GET",
      responses: {
        200: { headersMapper: xA.ServiceGetAccountInfoHeaders },
        default: {
          bodyMapper: xA.StorageError,
          headersMapper: xA.ServiceGetAccountInfoExceptionHeaders,
        },
      },
      queryParameters: [c.comp, c.timeoutInSeconds, c.restype1],
      urlParameters: [c.url],
      headerParameters: [c.version, c.requestId, c.accept1],
      isXML: !0,
      serializer: WC,
    },
    T5A = {
      path: "/",
      httpMethod: "POST",
      responses: {
        202: {
          bodyMapper: {
            type: { name: "Stream" },
            serializedName: "parsedResponse",
          },
          headersMapper: xA.ServiceSubmitBatchHeaders,
        },
        default: {
          bodyMapper: xA.StorageError,
          headersMapper: xA.ServiceSubmitBatchExceptionHeaders,
        },
      },
      requestBody: c.body,
      queryParameters: [c.timeoutInSeconds, c.comp4],
      urlParameters: [c.url],
      headerParameters: [
        c.accept,
        c.version,
        c.requestId,
        c.contentLength,
        c.multipartContentType,
      ],
      isXML: !0,
      contentType: "application/xml; charset=utf-8",
      mediaType: "xml",
      serializer: WC,
    },
    O5A = {
      path: "/",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: xA.FilterBlobSegment,
          headersMapper: xA.ServiceFilterBlobsHeaders,
        },
        default: {
          bodyMapper: xA.StorageError,
          headersMapper: xA.ServiceFilterBlobsExceptionHeaders,
        },
      },
      queryParameters: [
        c.timeoutInSeconds,
        c.marker,
        c.maxPageSize,
        c.comp5,
        c.where,
      ],
      urlParameters: [c.url],
      headerParameters: [c.version, c.requestId, c.accept1],
      isXML: !0,
      serializer: WC,
    };
});
var _k = Z((vk) => {
  Object.defineProperty(vk, "__esModule", { value: !0 });
  vk.ContainerImpl = void 0;
  var B4 = BQ(),
    q5A = B4.__importStar(oI()),
    o = B4.__importStar(UC()),
    z = B4.__importStar(B0());
  class xk {
    client;
    constructor(A) {
      this.client = A;
    }
    create(A) {
      return this.client.sendOperationRequest({ options: A }, j5A);
    }
    getProperties(A) {
      return this.client.sendOperationRequest({ options: A }, f5A);
    }
    delete(A) {
      return this.client.sendOperationRequest({ options: A }, h5A);
    }
    setMetadata(A) {
      return this.client.sendOperationRequest({ options: A }, k5A);
    }
    getAccessPolicy(A) {
      return this.client.sendOperationRequest({ options: A }, x5A);
    }
    setAccessPolicy(A) {
      return this.client.sendOperationRequest({ options: A }, v5A);
    }
    restore(A) {
      return this.client.sendOperationRequest({ options: A }, P5A);
    }
    rename(A, Q) {
      return this.client.sendOperationRequest(
        { sourceContainerName: A, options: Q },
        _5A,
      );
    }
    submitBatch(A, Q, B, I) {
      return this.client.sendOperationRequest(
        { contentLength: A, multipartContentType: Q, body: B, options: I },
        y5A,
      );
    }
    filterBlobs(A) {
      return this.client.sendOperationRequest({ options: A }, S5A);
    }
    acquireLease(A) {
      return this.client.sendOperationRequest({ options: A }, b5A);
    }
    releaseLease(A, Q) {
      return this.client.sendOperationRequest({ leaseId: A, options: Q }, m5A);
    }
    renewLease(A, Q) {
      return this.client.sendOperationRequest({ leaseId: A, options: Q }, d5A);
    }
    breakLease(A) {
      return this.client.sendOperationRequest({ options: A }, c5A);
    }
    changeLease(A, Q, B) {
      return this.client.sendOperationRequest(
        { leaseId: A, proposedLeaseId: Q, options: B },
        u5A,
      );
    }
    listBlobFlatSegment(A) {
      return this.client.sendOperationRequest({ options: A }, l5A);
    }
    listBlobHierarchySegment(A, Q) {
      return this.client.sendOperationRequest(
        { delimiter: A, options: Q },
        p5A,
      );
    }
    getAccountInfo(A) {
      return this.client.sendOperationRequest({ options: A }, i5A);
    }
  }
  vk.ContainerImpl = xk;
  var bQ = q5A.createSerializer(o, !0),
    j5A = {
      path: "/{containerName}",
      httpMethod: "PUT",
      responses: {
        201: { headersMapper: o.ContainerCreateHeaders },
        default: {
          bodyMapper: o.StorageError,
          headersMapper: o.ContainerCreateExceptionHeaders,
        },
      },
      queryParameters: [z.timeoutInSeconds, z.restype2],
      urlParameters: [z.url],
      headerParameters: [
        z.version,
        z.requestId,
        z.accept1,
        z.metadata,
        z.access,
        z.defaultEncryptionScope,
        z.preventEncryptionScopeOverride,
      ],
      isXML: !0,
      serializer: bQ,
    },
    f5A = {
      path: "/{containerName}",
      httpMethod: "GET",
      responses: {
        200: { headersMapper: o.ContainerGetPropertiesHeaders },
        default: {
          bodyMapper: o.StorageError,
          headersMapper: o.ContainerGetPropertiesExceptionHeaders,
        },
      },
      queryParameters: [z.timeoutInSeconds, z.restype2],
      urlParameters: [z.url],
      headerParameters: [z.version, z.requestId, z.accept1, z.leaseId],
      isXML: !0,
      serializer: bQ,
    },
    h5A = {
      path: "/{containerName}",
      httpMethod: "DELETE",
      responses: {
        202: { headersMapper: o.ContainerDeleteHeaders },
        default: {
          bodyMapper: o.StorageError,
          headersMapper: o.ContainerDeleteExceptionHeaders,
        },
      },
      queryParameters: [z.timeoutInSeconds, z.restype2],
      urlParameters: [z.url],
      headerParameters: [
        z.version,
        z.requestId,
        z.accept1,
        z.leaseId,
        z.ifModifiedSince,
        z.ifUnmodifiedSince,
      ],
      isXML: !0,
      serializer: bQ,
    },
    k5A = {
      path: "/{containerName}",
      httpMethod: "PUT",
      responses: {
        200: { headersMapper: o.ContainerSetMetadataHeaders },
        default: {
          bodyMapper: o.StorageError,
          headersMapper: o.ContainerSetMetadataExceptionHeaders,
        },
      },
      queryParameters: [z.timeoutInSeconds, z.restype2, z.comp6],
      urlParameters: [z.url],
      headerParameters: [
        z.version,
        z.requestId,
        z.accept1,
        z.metadata,
        z.leaseId,
        z.ifModifiedSince,
      ],
      isXML: !0,
      serializer: bQ,
    },
    x5A = {
      path: "/{containerName}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: {
            type: {
              name: "Sequence",
              element: {
                type: { name: "Composite", className: "SignedIdentifier" },
              },
            },
            serializedName: "SignedIdentifiers",
            xmlName: "SignedIdentifiers",
            xmlIsWrapped: !0,
            xmlElementName: "SignedIdentifier",
          },
          headersMapper: o.ContainerGetAccessPolicyHeaders,
        },
        default: {
          bodyMapper: o.StorageError,
          headersMapper: o.ContainerGetAccessPolicyExceptionHeaders,
        },
      },
      queryParameters: [z.timeoutInSeconds, z.restype2, z.comp7],
      urlParameters: [z.url],
      headerParameters: [z.version, z.requestId, z.accept1, z.leaseId],
      isXML: !0,
      serializer: bQ,
    },
    v5A = {
      path: "/{containerName}",
      httpMethod: "PUT",
      responses: {
        200: { headersMapper: o.ContainerSetAccessPolicyHeaders },
        default: {
          bodyMapper: o.StorageError,
          headersMapper: o.ContainerSetAccessPolicyExceptionHeaders,
        },
      },
      requestBody: z.containerAcl,
      queryParameters: [z.timeoutInSeconds, z.restype2, z.comp7],
      urlParameters: [z.url],
      headerParameters: [
        z.contentType,
        z.accept,
        z.version,
        z.requestId,
        z.access,
        z.leaseId,
        z.ifModifiedSince,
        z.ifUnmodifiedSince,
      ],
      isXML: !0,
      contentType: "application/xml; charset=utf-8",
      mediaType: "xml",
      serializer: bQ,
    },
    P5A = {
      path: "/{containerName}",
      httpMethod: "PUT",
      responses: {
        201: { headersMapper: o.ContainerRestoreHeaders },
        default: {
          bodyMapper: o.StorageError,
          headersMapper: o.ContainerRestoreExceptionHeaders,
        },
      },
      queryParameters: [z.timeoutInSeconds, z.restype2, z.comp8],
      urlParameters: [z.url],
      headerParameters: [
        z.version,
        z.requestId,
        z.accept1,
        z.deletedContainerName,
        z.deletedContainerVersion,
      ],
      isXML: !0,
      serializer: bQ,
    },
    _5A = {
      path: "/{containerName}",
      httpMethod: "PUT",
      responses: {
        200: { headersMapper: o.ContainerRenameHeaders },
        default: {
          bodyMapper: o.StorageError,
          headersMapper: o.ContainerRenameExceptionHeaders,
        },
      },
      queryParameters: [z.timeoutInSeconds, z.restype2, z.comp9],
      urlParameters: [z.url],
      headerParameters: [
        z.version,
        z.requestId,
        z.accept1,
        z.sourceContainerName,
        z.sourceLeaseId,
      ],
      isXML: !0,
      serializer: bQ,
    },
    y5A = {
      path: "/{containerName}",
      httpMethod: "POST",
      responses: {
        202: {
          bodyMapper: {
            type: { name: "Stream" },
            serializedName: "parsedResponse",
          },
          headersMapper: o.ContainerSubmitBatchHeaders,
        },
        default: {
          bodyMapper: o.StorageError,
          headersMapper: o.ContainerSubmitBatchExceptionHeaders,
        },
      },
      requestBody: z.body,
      queryParameters: [z.timeoutInSeconds, z.comp4, z.restype2],
      urlParameters: [z.url],
      headerParameters: [
        z.accept,
        z.version,
        z.requestId,
        z.contentLength,
        z.multipartContentType,
      ],
      isXML: !0,
      contentType: "application/xml; charset=utf-8",
      mediaType: "xml",
      serializer: bQ,
    },
    S5A = {
      path: "/{containerName}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: o.FilterBlobSegment,
          headersMapper: o.ContainerFilterBlobsHeaders,
        },
        default: {
          bodyMapper: o.StorageError,
          headersMapper: o.ContainerFilterBlobsExceptionHeaders,
        },
      },
      queryParameters: [
        z.timeoutInSeconds,
        z.marker,
        z.maxPageSize,
        z.comp5,
        z.where,
        z.restype2,
      ],
      urlParameters: [z.url],
      headerParameters: [z.version, z.requestId, z.accept1],
      isXML: !0,
      serializer: bQ,
    },
    b5A = {
      path: "/{containerName}",
      httpMethod: "PUT",
      responses: {
        201: { headersMapper: o.ContainerAcquireLeaseHeaders },
        default: {
          bodyMapper: o.StorageError,
          headersMapper: o.ContainerAcquireLeaseExceptionHeaders,
        },
      },
      queryParameters: [z.timeoutInSeconds, z.restype2, z.comp10],
      urlParameters: [z.url],
      headerParameters: [
        z.version,
        z.requestId,
        z.accept1,
        z.ifModifiedSince,
        z.ifUnmodifiedSince,
        z.action,
        z.duration,
        z.proposedLeaseId,
      ],
      isXML: !0,
      serializer: bQ,
    },
    m5A = {
      path: "/{containerName}",
      httpMethod: "PUT",
      responses: {
        200: { headersMapper: o.ContainerReleaseLeaseHeaders },
        default: {
          bodyMapper: o.StorageError,
          headersMapper: o.ContainerReleaseLeaseExceptionHeaders,
        },
      },
      queryParameters: [z.timeoutInSeconds, z.restype2, z.comp10],
      urlParameters: [z.url],
      headerParameters: [
        z.version,
        z.requestId,
        z.accept1,
        z.ifModifiedSince,
        z.ifUnmodifiedSince,
        z.action1,
        z.leaseId1,
      ],
      isXML: !0,
      serializer: bQ,
    },
    d5A = {
      path: "/{containerName}",
      httpMethod: "PUT",
      responses: {
        200: { headersMapper: o.ContainerRenewLeaseHeaders },
        default: {
          bodyMapper: o.StorageError,
          headersMapper: o.ContainerRenewLeaseExceptionHeaders,
        },
      },
      queryParameters: [z.timeoutInSeconds, z.restype2, z.comp10],
      urlParameters: [z.url],
      headerParameters: [
        z.version,
        z.requestId,
        z.accept1,
        z.ifModifiedSince,
        z.ifUnmodifiedSince,
        z.leaseId1,
        z.action2,
      ],
      isXML: !0,
      serializer: bQ,
    },
    c5A = {
      path: "/{containerName}",
      httpMethod: "PUT",
      responses: {
        202: { headersMapper: o.ContainerBreakLeaseHeaders },
        default: {
          bodyMapper: o.StorageError,
          headersMapper: o.ContainerBreakLeaseExceptionHeaders,
        },
      },
      queryParameters: [z.timeoutInSeconds, z.restype2, z.comp10],
      urlParameters: [z.url],
      headerParameters: [
        z.version,
        z.requestId,
        z.accept1,
        z.ifModifiedSince,
        z.ifUnmodifiedSince,
        z.action3,
        z.breakPeriod,
      ],
      isXML: !0,
      serializer: bQ,
    },
    u5A = {
      path: "/{containerName}",
      httpMethod: "PUT",
      responses: {
        200: { headersMapper: o.ContainerChangeLeaseHeaders },
        default: {
          bodyMapper: o.StorageError,
          headersMapper: o.ContainerChangeLeaseExceptionHeaders,
        },
      },
      queryParameters: [z.timeoutInSeconds, z.restype2, z.comp10],
      urlParameters: [z.url],
      headerParameters: [
        z.version,
        z.requestId,
        z.accept1,
        z.ifModifiedSince,
        z.ifUnmodifiedSince,
        z.leaseId1,
        z.action4,
        z.proposedLeaseId1,
      ],
      isXML: !0,
      serializer: bQ,
    },
    l5A = {
      path: "/{containerName}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: o.ListBlobsFlatSegmentResponse,
          headersMapper: o.ContainerListBlobFlatSegmentHeaders,
        },
        default: {
          bodyMapper: o.StorageError,
          headersMapper: o.ContainerListBlobFlatSegmentExceptionHeaders,
        },
      },
      queryParameters: [
        z.timeoutInSeconds,
        z.comp2,
        z.prefix,
        z.marker,
        z.maxPageSize,
        z.restype2,
        z.include1,
      ],
      urlParameters: [z.url],
      headerParameters: [z.version, z.requestId, z.accept1],
      isXML: !0,
      serializer: bQ,
    },
    p5A = {
      path: "/{containerName}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: o.ListBlobsHierarchySegmentResponse,
          headersMapper: o.ContainerListBlobHierarchySegmentHeaders,
        },
        default: {
          bodyMapper: o.StorageError,
          headersMapper: o.ContainerListBlobHierarchySegmentExceptionHeaders,
        },
      },
      queryParameters: [
        z.timeoutInSeconds,
        z.comp2,
        z.prefix,
        z.marker,
        z.maxPageSize,
        z.restype2,
        z.include1,
        z.delimiter,
      ],
      urlParameters: [z.url],
      headerParameters: [z.version, z.requestId, z.accept1],
      isXML: !0,
      serializer: bQ,
    },
    i5A = {
      path: "/{containerName}",
      httpMethod: "GET",
      responses: {
        200: { headersMapper: o.ContainerGetAccountInfoHeaders },
        default: {
          bodyMapper: o.StorageError,
          headersMapper: o.ContainerGetAccountInfoExceptionHeaders,
        },
      },
      queryParameters: [z.comp, z.timeoutInSeconds, z.restype1],
      urlParameters: [z.url],
      headerParameters: [z.version, z.requestId, z.accept1],
      isXML: !0,
      serializer: bQ,
    };
});
var mk = Z((Sk) => {
  Object.defineProperty(Sk, "__esModule", { value: !0 });
  Sk.BlobImpl = void 0;
  var I4 = BQ(),
    n5A = I4.__importStar(oI()),
    d = I4.__importStar(UC()),
    w = I4.__importStar(B0());
  class yk {
    client;
    constructor(A) {
      this.client = A;
    }
    download(A) {
      return this.client.sendOperationRequest({ options: A }, a5A);
    }
    getProperties(A) {
      return this.client.sendOperationRequest({ options: A }, o5A);
    }
    delete(A) {
      return this.client.sendOperationRequest({ options: A }, s5A);
    }
    undelete(A) {
      return this.client.sendOperationRequest({ options: A }, r5A);
    }
    setExpiry(A, Q) {
      return this.client.sendOperationRequest(
        { expiryOptions: A, options: Q },
        t5A,
      );
    }
    setHttpHeaders(A) {
      return this.client.sendOperationRequest({ options: A }, e5A);
    }
    setImmutabilityPolicy(A) {
      return this.client.sendOperationRequest({ options: A }, AMA);
    }
    deleteImmutabilityPolicy(A) {
      return this.client.sendOperationRequest({ options: A }, QMA);
    }
    setLegalHold(A, Q) {
      return this.client.sendOperationRequest(
        { legalHold: A, options: Q },
        BMA,
      );
    }
    setMetadata(A) {
      return this.client.sendOperationRequest({ options: A }, IMA);
    }
    acquireLease(A) {
      return this.client.sendOperationRequest({ options: A }, EMA);
    }
    releaseLease(A, Q) {
      return this.client.sendOperationRequest({ leaseId: A, options: Q }, CMA);
    }
    renewLease(A, Q) {
      return this.client.sendOperationRequest({ leaseId: A, options: Q }, gMA);
    }
    changeLease(A, Q, B) {
      return this.client.sendOperationRequest(
        { leaseId: A, proposedLeaseId: Q, options: B },
        FMA,
      );
    }
    breakLease(A) {
      return this.client.sendOperationRequest({ options: A }, DMA);
    }
    createSnapshot(A) {
      return this.client.sendOperationRequest({ options: A }, YMA);
    }
    startCopyFromURL(A, Q) {
      return this.client.sendOperationRequest(
        { copySource: A, options: Q },
        JMA,
      );
    }
    copyFromURL(A, Q) {
      return this.client.sendOperationRequest(
        { copySource: A, options: Q },
        NMA,
      );
    }
    abortCopyFromURL(A, Q) {
      return this.client.sendOperationRequest({ copyId: A, options: Q }, GMA);
    }
    setTier(A, Q) {
      return this.client.sendOperationRequest({ tier: A, options: Q }, UMA);
    }
    getAccountInfo(A) {
      return this.client.sendOperationRequest({ options: A }, WMA);
    }
    query(A) {
      return this.client.sendOperationRequest({ options: A }, ZMA);
    }
    getTags(A) {
      return this.client.sendOperationRequest({ options: A }, XMA);
    }
    setTags(A) {
      return this.client.sendOperationRequest({ options: A }, wMA);
    }
  }
  Sk.BlobImpl = yk;
  var IQ = n5A.createSerializer(d, !0),
    a5A = {
      path: "/{containerName}/{blob}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: {
            type: { name: "Stream" },
            serializedName: "parsedResponse",
          },
          headersMapper: d.BlobDownloadHeaders,
        },
        206: {
          bodyMapper: {
            type: { name: "Stream" },
            serializedName: "parsedResponse",
          },
          headersMapper: d.BlobDownloadHeaders,
        },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobDownloadExceptionHeaders,
        },
      },
      queryParameters: [w.timeoutInSeconds, w.snapshot, w.versionId],
      urlParameters: [w.url],
      headerParameters: [
        w.version,
        w.requestId,
        w.accept1,
        w.leaseId,
        w.ifModifiedSince,
        w.ifUnmodifiedSince,
        w.range,
        w.rangeGetContentMD5,
        w.rangeGetContentCRC64,
        w.encryptionKey,
        w.encryptionKeySha256,
        w.encryptionAlgorithm,
        w.ifMatch,
        w.ifNoneMatch,
        w.ifTags,
      ],
      isXML: !0,
      serializer: IQ,
    },
    o5A = {
      path: "/{containerName}/{blob}",
      httpMethod: "HEAD",
      responses: {
        200: { headersMapper: d.BlobGetPropertiesHeaders },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobGetPropertiesExceptionHeaders,
        },
      },
      queryParameters: [w.timeoutInSeconds, w.snapshot, w.versionId],
      urlParameters: [w.url],
      headerParameters: [
        w.version,
        w.requestId,
        w.accept1,
        w.leaseId,
        w.ifModifiedSince,
        w.ifUnmodifiedSince,
        w.encryptionKey,
        w.encryptionKeySha256,
        w.encryptionAlgorithm,
        w.ifMatch,
        w.ifNoneMatch,
        w.ifTags,
      ],
      isXML: !0,
      serializer: IQ,
    },
    s5A = {
      path: "/{containerName}/{blob}",
      httpMethod: "DELETE",
      responses: {
        202: { headersMapper: d.BlobDeleteHeaders },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobDeleteExceptionHeaders,
        },
      },
      queryParameters: [
        w.timeoutInSeconds,
        w.snapshot,
        w.versionId,
        w.blobDeleteType,
      ],
      urlParameters: [w.url],
      headerParameters: [
        w.version,
        w.requestId,
        w.accept1,
        w.leaseId,
        w.ifModifiedSince,
        w.ifUnmodifiedSince,
        w.ifMatch,
        w.ifNoneMatch,
        w.ifTags,
        w.deleteSnapshots,
      ],
      isXML: !0,
      serializer: IQ,
    },
    r5A = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: { headersMapper: d.BlobUndeleteHeaders },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobUndeleteExceptionHeaders,
        },
      },
      queryParameters: [w.timeoutInSeconds, w.comp8],
      urlParameters: [w.url],
      headerParameters: [w.version, w.requestId, w.accept1],
      isXML: !0,
      serializer: IQ,
    },
    t5A = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: { headersMapper: d.BlobSetExpiryHeaders },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobSetExpiryExceptionHeaders,
        },
      },
      queryParameters: [w.timeoutInSeconds, w.comp11],
      urlParameters: [w.url],
      headerParameters: [
        w.version,
        w.requestId,
        w.accept1,
        w.expiryOptions,
        w.expiresOn,
      ],
      isXML: !0,
      serializer: IQ,
    },
    e5A = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: { headersMapper: d.BlobSetHttpHeadersHeaders },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobSetHttpHeadersExceptionHeaders,
        },
      },
      queryParameters: [w.comp, w.timeoutInSeconds],
      urlParameters: [w.url],
      headerParameters: [
        w.version,
        w.requestId,
        w.accept1,
        w.leaseId,
        w.ifModifiedSince,
        w.ifUnmodifiedSince,
        w.ifMatch,
        w.ifNoneMatch,
        w.ifTags,
        w.blobCacheControl,
        w.blobContentType,
        w.blobContentMD5,
        w.blobContentEncoding,
        w.blobContentLanguage,
        w.blobContentDisposition,
      ],
      isXML: !0,
      serializer: IQ,
    },
    AMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: { headersMapper: d.BlobSetImmutabilityPolicyHeaders },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobSetImmutabilityPolicyExceptionHeaders,
        },
      },
      queryParameters: [w.timeoutInSeconds, w.snapshot, w.versionId, w.comp12],
      urlParameters: [w.url],
      headerParameters: [
        w.version,
        w.requestId,
        w.accept1,
        w.ifUnmodifiedSince,
        w.immutabilityPolicyExpiry,
        w.immutabilityPolicyMode,
      ],
      isXML: !0,
      serializer: IQ,
    },
    QMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "DELETE",
      responses: {
        200: { headersMapper: d.BlobDeleteImmutabilityPolicyHeaders },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobDeleteImmutabilityPolicyExceptionHeaders,
        },
      },
      queryParameters: [w.timeoutInSeconds, w.snapshot, w.versionId, w.comp12],
      urlParameters: [w.url],
      headerParameters: [w.version, w.requestId, w.accept1],
      isXML: !0,
      serializer: IQ,
    },
    BMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: { headersMapper: d.BlobSetLegalHoldHeaders },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobSetLegalHoldExceptionHeaders,
        },
      },
      queryParameters: [w.timeoutInSeconds, w.snapshot, w.versionId, w.comp13],
      urlParameters: [w.url],
      headerParameters: [w.version, w.requestId, w.accept1, w.legalHold],
      isXML: !0,
      serializer: IQ,
    },
    IMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: { headersMapper: d.BlobSetMetadataHeaders },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobSetMetadataExceptionHeaders,
        },
      },
      queryParameters: [w.timeoutInSeconds, w.comp6],
      urlParameters: [w.url],
      headerParameters: [
        w.version,
        w.requestId,
        w.accept1,
        w.metadata,
        w.leaseId,
        w.ifModifiedSince,
        w.ifUnmodifiedSince,
        w.encryptionKey,
        w.encryptionKeySha256,
        w.encryptionAlgorithm,
        w.ifMatch,
        w.ifNoneMatch,
        w.ifTags,
        w.encryptionScope,
      ],
      isXML: !0,
      serializer: IQ,
    },
    EMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: { headersMapper: d.BlobAcquireLeaseHeaders },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobAcquireLeaseExceptionHeaders,
        },
      },
      queryParameters: [w.timeoutInSeconds, w.comp10],
      urlParameters: [w.url],
      headerParameters: [
        w.version,
        w.requestId,
        w.accept1,
        w.ifModifiedSince,
        w.ifUnmodifiedSince,
        w.action,
        w.duration,
        w.proposedLeaseId,
        w.ifMatch,
        w.ifNoneMatch,
        w.ifTags,
      ],
      isXML: !0,
      serializer: IQ,
    },
    CMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: { headersMapper: d.BlobReleaseLeaseHeaders },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobReleaseLeaseExceptionHeaders,
        },
      },
      queryParameters: [w.timeoutInSeconds, w.comp10],
      urlParameters: [w.url],
      headerParameters: [
        w.version,
        w.requestId,
        w.accept1,
        w.ifModifiedSince,
        w.ifUnmodifiedSince,
        w.action1,
        w.leaseId1,
        w.ifMatch,
        w.ifNoneMatch,
        w.ifTags,
      ],
      isXML: !0,
      serializer: IQ,
    },
    gMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: { headersMapper: d.BlobRenewLeaseHeaders },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobRenewLeaseExceptionHeaders,
        },
      },
      queryParameters: [w.timeoutInSeconds, w.comp10],
      urlParameters: [w.url],
      headerParameters: [
        w.version,
        w.requestId,
        w.accept1,
        w.ifModifiedSince,
        w.ifUnmodifiedSince,
        w.leaseId1,
        w.action2,
        w.ifMatch,
        w.ifNoneMatch,
        w.ifTags,
      ],
      isXML: !0,
      serializer: IQ,
    },
    FMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: { headersMapper: d.BlobChangeLeaseHeaders },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobChangeLeaseExceptionHeaders,
        },
      },
      queryParameters: [w.timeoutInSeconds, w.comp10],
      urlParameters: [w.url],
      headerParameters: [
        w.version,
        w.requestId,
        w.accept1,
        w.ifModifiedSince,
        w.ifUnmodifiedSince,
        w.leaseId1,
        w.action4,
        w.proposedLeaseId1,
        w.ifMatch,
        w.ifNoneMatch,
        w.ifTags,
      ],
      isXML: !0,
      serializer: IQ,
    },
    DMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        202: { headersMapper: d.BlobBreakLeaseHeaders },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobBreakLeaseExceptionHeaders,
        },
      },
      queryParameters: [w.timeoutInSeconds, w.comp10],
      urlParameters: [w.url],
      headerParameters: [
        w.version,
        w.requestId,
        w.accept1,
        w.ifModifiedSince,
        w.ifUnmodifiedSince,
        w.action3,
        w.breakPeriod,
        w.ifMatch,
        w.ifNoneMatch,
        w.ifTags,
      ],
      isXML: !0,
      serializer: IQ,
    },
    YMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: { headersMapper: d.BlobCreateSnapshotHeaders },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobCreateSnapshotExceptionHeaders,
        },
      },
      queryParameters: [w.timeoutInSeconds, w.comp14],
      urlParameters: [w.url],
      headerParameters: [
        w.version,
        w.requestId,
        w.accept1,
        w.metadata,
        w.leaseId,
        w.ifModifiedSince,
        w.ifUnmodifiedSince,
        w.encryptionKey,
        w.encryptionKeySha256,
        w.encryptionAlgorithm,
        w.ifMatch,
        w.ifNoneMatch,
        w.ifTags,
        w.encryptionScope,
      ],
      isXML: !0,
      serializer: IQ,
    },
    JMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        202: { headersMapper: d.BlobStartCopyFromURLHeaders },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobStartCopyFromURLExceptionHeaders,
        },
      },
      queryParameters: [w.timeoutInSeconds],
      urlParameters: [w.url],
      headerParameters: [
        w.version,
        w.requestId,
        w.accept1,
        w.metadata,
        w.leaseId,
        w.ifModifiedSince,
        w.ifUnmodifiedSince,
        w.ifMatch,
        w.ifNoneMatch,
        w.ifTags,
        w.immutabilityPolicyExpiry,
        w.immutabilityPolicyMode,
        w.tier,
        w.rehydratePriority,
        w.sourceIfModifiedSince,
        w.sourceIfUnmodifiedSince,
        w.sourceIfMatch,
        w.sourceIfNoneMatch,
        w.sourceIfTags,
        w.copySource,
        w.blobTagsString,
        w.sealBlob,
        w.legalHold1,
      ],
      isXML: !0,
      serializer: IQ,
    },
    NMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        202: { headersMapper: d.BlobCopyFromURLHeaders },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobCopyFromURLExceptionHeaders,
        },
      },
      queryParameters: [w.timeoutInSeconds],
      urlParameters: [w.url],
      headerParameters: [
        w.version,
        w.requestId,
        w.accept1,
        w.metadata,
        w.leaseId,
        w.ifModifiedSince,
        w.ifUnmodifiedSince,
        w.ifMatch,
        w.ifNoneMatch,
        w.ifTags,
        w.immutabilityPolicyExpiry,
        w.immutabilityPolicyMode,
        w.encryptionScope,
        w.tier,
        w.sourceIfModifiedSince,
        w.sourceIfUnmodifiedSince,
        w.sourceIfMatch,
        w.sourceIfNoneMatch,
        w.copySource,
        w.blobTagsString,
        w.legalHold1,
        w.xMsRequiresSync,
        w.sourceContentMD5,
        w.copySourceAuthorization,
        w.copySourceTags,
        w.fileRequestIntent,
      ],
      isXML: !0,
      serializer: IQ,
    },
    GMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        204: { headersMapper: d.BlobAbortCopyFromURLHeaders },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobAbortCopyFromURLExceptionHeaders,
        },
      },
      queryParameters: [w.timeoutInSeconds, w.comp15, w.copyId],
      urlParameters: [w.url],
      headerParameters: [
        w.version,
        w.requestId,
        w.accept1,
        w.leaseId,
        w.copyActionAbortConstant,
      ],
      isXML: !0,
      serializer: IQ,
    },
    UMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: { headersMapper: d.BlobSetTierHeaders },
        202: { headersMapper: d.BlobSetTierHeaders },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobSetTierExceptionHeaders,
        },
      },
      queryParameters: [w.timeoutInSeconds, w.snapshot, w.versionId, w.comp16],
      urlParameters: [w.url],
      headerParameters: [
        w.version,
        w.requestId,
        w.accept1,
        w.leaseId,
        w.ifTags,
        w.rehydratePriority,
        w.tier1,
      ],
      isXML: !0,
      serializer: IQ,
    },
    WMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "GET",
      responses: {
        200: { headersMapper: d.BlobGetAccountInfoHeaders },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobGetAccountInfoExceptionHeaders,
        },
      },
      queryParameters: [w.comp, w.timeoutInSeconds, w.restype1],
      urlParameters: [w.url],
      headerParameters: [w.version, w.requestId, w.accept1],
      isXML: !0,
      serializer: IQ,
    },
    ZMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "POST",
      responses: {
        200: {
          bodyMapper: {
            type: { name: "Stream" },
            serializedName: "parsedResponse",
          },
          headersMapper: d.BlobQueryHeaders,
        },
        206: {
          bodyMapper: {
            type: { name: "Stream" },
            serializedName: "parsedResponse",
          },
          headersMapper: d.BlobQueryHeaders,
        },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobQueryExceptionHeaders,
        },
      },
      requestBody: w.queryRequest,
      queryParameters: [w.timeoutInSeconds, w.snapshot, w.comp17],
      urlParameters: [w.url],
      headerParameters: [
        w.contentType,
        w.accept,
        w.version,
        w.requestId,
        w.leaseId,
        w.ifModifiedSince,
        w.ifUnmodifiedSince,
        w.encryptionKey,
        w.encryptionKeySha256,
        w.encryptionAlgorithm,
        w.ifMatch,
        w.ifNoneMatch,
        w.ifTags,
      ],
      isXML: !0,
      contentType: "application/xml; charset=utf-8",
      mediaType: "xml",
      serializer: IQ,
    },
    XMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "GET",
      responses: {
        200: { bodyMapper: d.BlobTags, headersMapper: d.BlobGetTagsHeaders },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobGetTagsExceptionHeaders,
        },
      },
      queryParameters: [w.timeoutInSeconds, w.snapshot, w.versionId, w.comp18],
      urlParameters: [w.url],
      headerParameters: [
        w.version,
        w.requestId,
        w.accept1,
        w.leaseId,
        w.ifTags,
      ],
      isXML: !0,
      serializer: IQ,
    },
    wMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        204: { headersMapper: d.BlobSetTagsHeaders },
        default: {
          bodyMapper: d.StorageError,
          headersMapper: d.BlobSetTagsExceptionHeaders,
        },
      },
      requestBody: w.tags,
      queryParameters: [w.timeoutInSeconds, w.versionId, w.comp18],
      urlParameters: [w.url],
      headerParameters: [
        w.contentType,
        w.accept,
        w.version,
        w.requestId,
        w.leaseId,
        w.ifTags,
        w.transactionalContentMD5,
        w.transactionalContentCrc64,
      ],
      isXML: !0,
      contentType: "application/xml; charset=utf-8",
      mediaType: "xml",
      serializer: IQ,
    };
});
var lk = Z((ck) => {
  Object.defineProperty(ck, "__esModule", { value: !0 });
  ck.PageBlobImpl = void 0;
  var E4 = BQ(),
    MMA = E4.__importStar(oI()),
    vA = E4.__importStar(UC()),
    K = E4.__importStar(B0());
  class dk {
    client;
    constructor(A) {
      this.client = A;
    }
    create(A, Q, B) {
      return this.client.sendOperationRequest(
        { contentLength: A, blobContentLength: Q, options: B },
        LMA,
      );
    }
    uploadPages(A, Q, B) {
      return this.client.sendOperationRequest(
        { contentLength: A, body: Q, options: B },
        RMA,
      );
    }
    clearPages(A, Q) {
      return this.client.sendOperationRequest(
        { contentLength: A, options: Q },
        VMA,
      );
    }
    uploadPagesFromURL(A, Q, B, I, E) {
      return this.client.sendOperationRequest(
        {
          sourceUrl: A,
          sourceRange: Q,
          contentLength: B,
          range: I,
          options: E,
        },
        $MA,
      );
    }
    getPageRanges(A) {
      return this.client.sendOperationRequest({ options: A }, HMA);
    }
    getPageRangesDiff(A) {
      return this.client.sendOperationRequest({ options: A }, KMA);
    }
    resize(A, Q) {
      return this.client.sendOperationRequest(
        { blobContentLength: A, options: Q },
        zMA,
      );
    }
    updateSequenceNumber(A, Q) {
      return this.client.sendOperationRequest(
        { sequenceNumberAction: A, options: Q },
        TMA,
      );
    }
    copyIncremental(A, Q) {
      return this.client.sendOperationRequest(
        { copySource: A, options: Q },
        OMA,
      );
    }
  }
  ck.PageBlobImpl = dk;
  var TE = MMA.createSerializer(vA, !0),
    LMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: { headersMapper: vA.PageBlobCreateHeaders },
        default: {
          bodyMapper: vA.StorageError,
          headersMapper: vA.PageBlobCreateExceptionHeaders,
        },
      },
      queryParameters: [K.timeoutInSeconds],
      urlParameters: [K.url],
      headerParameters: [
        K.version,
        K.requestId,
        K.accept1,
        K.contentLength,
        K.metadata,
        K.leaseId,
        K.ifModifiedSince,
        K.ifUnmodifiedSince,
        K.encryptionKey,
        K.encryptionKeySha256,
        K.encryptionAlgorithm,
        K.ifMatch,
        K.ifNoneMatch,
        K.ifTags,
        K.blobCacheControl,
        K.blobContentType,
        K.blobContentMD5,
        K.blobContentEncoding,
        K.blobContentLanguage,
        K.blobContentDisposition,
        K.immutabilityPolicyExpiry,
        K.immutabilityPolicyMode,
        K.encryptionScope,
        K.tier,
        K.blobTagsString,
        K.legalHold1,
        K.blobType,
        K.blobContentLength,
        K.blobSequenceNumber,
      ],
      isXML: !0,
      serializer: TE,
    },
    RMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: { headersMapper: vA.PageBlobUploadPagesHeaders },
        default: {
          bodyMapper: vA.StorageError,
          headersMapper: vA.PageBlobUploadPagesExceptionHeaders,
        },
      },
      requestBody: K.body1,
      queryParameters: [K.timeoutInSeconds, K.comp19],
      urlParameters: [K.url],
      headerParameters: [
        K.version,
        K.requestId,
        K.contentLength,
        K.leaseId,
        K.ifModifiedSince,
        K.ifUnmodifiedSince,
        K.range,
        K.encryptionKey,
        K.encryptionKeySha256,
        K.encryptionAlgorithm,
        K.ifMatch,
        K.ifNoneMatch,
        K.ifTags,
        K.encryptionScope,
        K.transactionalContentMD5,
        K.transactionalContentCrc64,
        K.contentType1,
        K.accept2,
        K.pageWrite,
        K.ifSequenceNumberLessThanOrEqualTo,
        K.ifSequenceNumberLessThan,
        K.ifSequenceNumberEqualTo,
      ],
      isXML: !0,
      contentType: "application/xml; charset=utf-8",
      mediaType: "binary",
      serializer: TE,
    },
    VMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: { headersMapper: vA.PageBlobClearPagesHeaders },
        default: {
          bodyMapper: vA.StorageError,
          headersMapper: vA.PageBlobClearPagesExceptionHeaders,
        },
      },
      queryParameters: [K.timeoutInSeconds, K.comp19],
      urlParameters: [K.url],
      headerParameters: [
        K.version,
        K.requestId,
        K.accept1,
        K.contentLength,
        K.leaseId,
        K.ifModifiedSince,
        K.ifUnmodifiedSince,
        K.range,
        K.encryptionKey,
        K.encryptionKeySha256,
        K.encryptionAlgorithm,
        K.ifMatch,
        K.ifNoneMatch,
        K.ifTags,
        K.encryptionScope,
        K.ifSequenceNumberLessThanOrEqualTo,
        K.ifSequenceNumberLessThan,
        K.ifSequenceNumberEqualTo,
        K.pageWrite1,
      ],
      isXML: !0,
      serializer: TE,
    },
    $MA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: { headersMapper: vA.PageBlobUploadPagesFromURLHeaders },
        default: {
          bodyMapper: vA.StorageError,
          headersMapper: vA.PageBlobUploadPagesFromURLExceptionHeaders,
        },
      },
      queryParameters: [K.timeoutInSeconds, K.comp19],
      urlParameters: [K.url],
      headerParameters: [
        K.version,
        K.requestId,
        K.accept1,
        K.contentLength,
        K.leaseId,
        K.ifModifiedSince,
        K.ifUnmodifiedSince,
        K.encryptionKey,
        K.encryptionKeySha256,
        K.encryptionAlgorithm,
        K.ifMatch,
        K.ifNoneMatch,
        K.ifTags,
        K.encryptionScope,
        K.sourceIfModifiedSince,
        K.sourceIfUnmodifiedSince,
        K.sourceIfMatch,
        K.sourceIfNoneMatch,
        K.sourceContentMD5,
        K.copySourceAuthorization,
        K.fileRequestIntent,
        K.pageWrite,
        K.ifSequenceNumberLessThanOrEqualTo,
        K.ifSequenceNumberLessThan,
        K.ifSequenceNumberEqualTo,
        K.sourceUrl,
        K.sourceRange,
        K.sourceContentCrc64,
        K.range1,
      ],
      isXML: !0,
      serializer: TE,
    },
    HMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: vA.PageList,
          headersMapper: vA.PageBlobGetPageRangesHeaders,
        },
        default: {
          bodyMapper: vA.StorageError,
          headersMapper: vA.PageBlobGetPageRangesExceptionHeaders,
        },
      },
      queryParameters: [
        K.timeoutInSeconds,
        K.marker,
        K.maxPageSize,
        K.snapshot,
        K.comp20,
      ],
      urlParameters: [K.url],
      headerParameters: [
        K.version,
        K.requestId,
        K.accept1,
        K.leaseId,
        K.ifModifiedSince,
        K.ifUnmodifiedSince,
        K.range,
        K.ifMatch,
        K.ifNoneMatch,
        K.ifTags,
      ],
      isXML: !0,
      serializer: TE,
    },
    KMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: vA.PageList,
          headersMapper: vA.PageBlobGetPageRangesDiffHeaders,
        },
        default: {
          bodyMapper: vA.StorageError,
          headersMapper: vA.PageBlobGetPageRangesDiffExceptionHeaders,
        },
      },
      queryParameters: [
        K.timeoutInSeconds,
        K.marker,
        K.maxPageSize,
        K.snapshot,
        K.comp20,
        K.prevsnapshot,
      ],
      urlParameters: [K.url],
      headerParameters: [
        K.version,
        K.requestId,
        K.accept1,
        K.leaseId,
        K.ifModifiedSince,
        K.ifUnmodifiedSince,
        K.range,
        K.ifMatch,
        K.ifNoneMatch,
        K.ifTags,
        K.prevSnapshotUrl,
      ],
      isXML: !0,
      serializer: TE,
    },
    zMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: { headersMapper: vA.PageBlobResizeHeaders },
        default: {
          bodyMapper: vA.StorageError,
          headersMapper: vA.PageBlobResizeExceptionHeaders,
        },
      },
      queryParameters: [K.comp, K.timeoutInSeconds],
      urlParameters: [K.url],
      headerParameters: [
        K.version,
        K.requestId,
        K.accept1,
        K.leaseId,
        K.ifModifiedSince,
        K.ifUnmodifiedSince,
        K.encryptionKey,
        K.encryptionKeySha256,
        K.encryptionAlgorithm,
        K.ifMatch,
        K.ifNoneMatch,
        K.ifTags,
        K.encryptionScope,
        K.blobContentLength,
      ],
      isXML: !0,
      serializer: TE,
    },
    TMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: { headersMapper: vA.PageBlobUpdateSequenceNumberHeaders },
        default: {
          bodyMapper: vA.StorageError,
          headersMapper: vA.PageBlobUpdateSequenceNumberExceptionHeaders,
        },
      },
      queryParameters: [K.comp, K.timeoutInSeconds],
      urlParameters: [K.url],
      headerParameters: [
        K.version,
        K.requestId,
        K.accept1,
        K.leaseId,
        K.ifModifiedSince,
        K.ifUnmodifiedSince,
        K.ifMatch,
        K.ifNoneMatch,
        K.ifTags,
        K.blobSequenceNumber,
        K.sequenceNumberAction,
      ],
      isXML: !0,
      serializer: TE,
    },
    OMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        202: { headersMapper: vA.PageBlobCopyIncrementalHeaders },
        default: {
          bodyMapper: vA.StorageError,
          headersMapper: vA.PageBlobCopyIncrementalExceptionHeaders,
        },
      },
      queryParameters: [K.timeoutInSeconds, K.comp21],
      urlParameters: [K.url],
      headerParameters: [
        K.version,
        K.requestId,
        K.accept1,
        K.ifModifiedSince,
        K.ifUnmodifiedSince,
        K.ifMatch,
        K.ifNoneMatch,
        K.ifTags,
        K.copySource,
      ],
      isXML: !0,
      serializer: TE,
    };
});
var ak = Z((ik) => {
  Object.defineProperty(ik, "__esModule", { value: !0 });
  ik.AppendBlobImpl = void 0;
  var C4 = BQ(),
    qMA = C4.__importStar(oI()),
    iB = C4.__importStar(UC()),
    b = C4.__importStar(B0());
  class pk {
    client;
    constructor(A) {
      this.client = A;
    }
    create(A, Q) {
      return this.client.sendOperationRequest(
        { contentLength: A, options: Q },
        jMA,
      );
    }
    appendBlock(A, Q, B) {
      return this.client.sendOperationRequest(
        { contentLength: A, body: Q, options: B },
        fMA,
      );
    }
    appendBlockFromUrl(A, Q, B) {
      return this.client.sendOperationRequest(
        { sourceUrl: A, contentLength: Q, options: B },
        hMA,
      );
    }
    seal(A) {
      return this.client.sendOperationRequest({ options: A }, kMA);
    }
  }
  ik.AppendBlobImpl = pk;
  var zN = qMA.createSerializer(iB, !0),
    jMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: { headersMapper: iB.AppendBlobCreateHeaders },
        default: {
          bodyMapper: iB.StorageError,
          headersMapper: iB.AppendBlobCreateExceptionHeaders,
        },
      },
      queryParameters: [b.timeoutInSeconds],
      urlParameters: [b.url],
      headerParameters: [
        b.version,
        b.requestId,
        b.accept1,
        b.contentLength,
        b.metadata,
        b.leaseId,
        b.ifModifiedSince,
        b.ifUnmodifiedSince,
        b.encryptionKey,
        b.encryptionKeySha256,
        b.encryptionAlgorithm,
        b.ifMatch,
        b.ifNoneMatch,
        b.ifTags,
        b.blobCacheControl,
        b.blobContentType,
        b.blobContentMD5,
        b.blobContentEncoding,
        b.blobContentLanguage,
        b.blobContentDisposition,
        b.immutabilityPolicyExpiry,
        b.immutabilityPolicyMode,
        b.encryptionScope,
        b.blobTagsString,
        b.legalHold1,
        b.blobType1,
      ],
      isXML: !0,
      serializer: zN,
    },
    fMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: { headersMapper: iB.AppendBlobAppendBlockHeaders },
        default: {
          bodyMapper: iB.StorageError,
          headersMapper: iB.AppendBlobAppendBlockExceptionHeaders,
        },
      },
      requestBody: b.body1,
      queryParameters: [b.timeoutInSeconds, b.comp22],
      urlParameters: [b.url],
      headerParameters: [
        b.version,
        b.requestId,
        b.contentLength,
        b.leaseId,
        b.ifModifiedSince,
        b.ifUnmodifiedSince,
        b.encryptionKey,
        b.encryptionKeySha256,
        b.encryptionAlgorithm,
        b.ifMatch,
        b.ifNoneMatch,
        b.ifTags,
        b.encryptionScope,
        b.transactionalContentMD5,
        b.transactionalContentCrc64,
        b.contentType1,
        b.accept2,
        b.maxSize,
        b.appendPosition,
      ],
      isXML: !0,
      contentType: "application/xml; charset=utf-8",
      mediaType: "binary",
      serializer: zN,
    },
    hMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: { headersMapper: iB.AppendBlobAppendBlockFromUrlHeaders },
        default: {
          bodyMapper: iB.StorageError,
          headersMapper: iB.AppendBlobAppendBlockFromUrlExceptionHeaders,
        },
      },
      queryParameters: [b.timeoutInSeconds, b.comp22],
      urlParameters: [b.url],
      headerParameters: [
        b.version,
        b.requestId,
        b.accept1,
        b.contentLength,
        b.leaseId,
        b.ifModifiedSince,
        b.ifUnmodifiedSince,
        b.encryptionKey,
        b.encryptionKeySha256,
        b.encryptionAlgorithm,
        b.ifMatch,
        b.ifNoneMatch,
        b.ifTags,
        b.encryptionScope,
        b.sourceIfModifiedSince,
        b.sourceIfUnmodifiedSince,
        b.sourceIfMatch,
        b.sourceIfNoneMatch,
        b.sourceContentMD5,
        b.copySourceAuthorization,
        b.fileRequestIntent,
        b.transactionalContentMD5,
        b.sourceUrl,
        b.sourceContentCrc64,
        b.maxSize,
        b.appendPosition,
        b.sourceRange1,
      ],
      isXML: !0,
      serializer: zN,
    },
    kMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        200: { headersMapper: iB.AppendBlobSealHeaders },
        default: {
          bodyMapper: iB.StorageError,
          headersMapper: iB.AppendBlobSealExceptionHeaders,
        },
      },
      queryParameters: [b.timeoutInSeconds, b.comp23],
      urlParameters: [b.url],
      headerParameters: [
        b.version,
        b.requestId,
        b.accept1,
        b.leaseId,
        b.ifModifiedSince,
        b.ifUnmodifiedSince,
        b.ifMatch,
        b.ifNoneMatch,
        b.appendPosition,
      ],
      isXML: !0,
      serializer: zN,
    };
});
var tk = Z((sk) => {
  Object.defineProperty(sk, "__esModule", { value: !0 });
  sk.BlockBlobImpl = void 0;
  var g4 = BQ(),
    xMA = g4.__importStar(oI()),
    zQ = g4.__importStar(UC()),
    j = g4.__importStar(B0());
  class ok {
    client;
    constructor(A) {
      this.client = A;
    }
    upload(A, Q, B) {
      return this.client.sendOperationRequest(
        { contentLength: A, body: Q, options: B },
        vMA,
      );
    }
    putBlobFromUrl(A, Q, B) {
      return this.client.sendOperationRequest(
        { contentLength: A, copySource: Q, options: B },
        PMA,
      );
    }
    stageBlock(A, Q, B, I) {
      return this.client.sendOperationRequest(
        { blockId: A, contentLength: Q, body: B, options: I },
        _MA,
      );
    }
    stageBlockFromURL(A, Q, B, I) {
      return this.client.sendOperationRequest(
        { blockId: A, contentLength: Q, sourceUrl: B, options: I },
        yMA,
      );
    }
    commitBlockList(A, Q) {
      return this.client.sendOperationRequest({ blocks: A, options: Q }, SMA);
    }
    getBlockList(A, Q) {
      return this.client.sendOperationRequest({ listType: A, options: Q }, bMA);
    }
  }
  sk.BlockBlobImpl = ok;
  var Og = xMA.createSerializer(zQ, !0),
    vMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: { headersMapper: zQ.BlockBlobUploadHeaders },
        default: {
          bodyMapper: zQ.StorageError,
          headersMapper: zQ.BlockBlobUploadExceptionHeaders,
        },
      },
      requestBody: j.body1,
      queryParameters: [j.timeoutInSeconds],
      urlParameters: [j.url],
      headerParameters: [
        j.version,
        j.requestId,
        j.contentLength,
        j.metadata,
        j.leaseId,
        j.ifModifiedSince,
        j.ifUnmodifiedSince,
        j.encryptionKey,
        j.encryptionKeySha256,
        j.encryptionAlgorithm,
        j.ifMatch,
        j.ifNoneMatch,
        j.ifTags,
        j.blobCacheControl,
        j.blobContentType,
        j.blobContentMD5,
        j.blobContentEncoding,
        j.blobContentLanguage,
        j.blobContentDisposition,
        j.immutabilityPolicyExpiry,
        j.immutabilityPolicyMode,
        j.encryptionScope,
        j.tier,
        j.blobTagsString,
        j.legalHold1,
        j.transactionalContentMD5,
        j.transactionalContentCrc64,
        j.contentType1,
        j.accept2,
        j.blobType2,
      ],
      isXML: !0,
      contentType: "application/xml; charset=utf-8",
      mediaType: "binary",
      serializer: Og,
    },
    PMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: { headersMapper: zQ.BlockBlobPutBlobFromUrlHeaders },
        default: {
          bodyMapper: zQ.StorageError,
          headersMapper: zQ.BlockBlobPutBlobFromUrlExceptionHeaders,
        },
      },
      queryParameters: [j.timeoutInSeconds],
      urlParameters: [j.url],
      headerParameters: [
        j.version,
        j.requestId,
        j.accept1,
        j.contentLength,
        j.metadata,
        j.leaseId,
        j.ifModifiedSince,
        j.ifUnmodifiedSince,
        j.encryptionKey,
        j.encryptionKeySha256,
        j.encryptionAlgorithm,
        j.ifMatch,
        j.ifNoneMatch,
        j.ifTags,
        j.blobCacheControl,
        j.blobContentType,
        j.blobContentMD5,
        j.blobContentEncoding,
        j.blobContentLanguage,
        j.blobContentDisposition,
        j.encryptionScope,
        j.tier,
        j.sourceIfModifiedSince,
        j.sourceIfUnmodifiedSince,
        j.sourceIfMatch,
        j.sourceIfNoneMatch,
        j.sourceIfTags,
        j.copySource,
        j.blobTagsString,
        j.sourceContentMD5,
        j.copySourceAuthorization,
        j.copySourceTags,
        j.fileRequestIntent,
        j.transactionalContentMD5,
        j.blobType2,
        j.copySourceBlobProperties,
      ],
      isXML: !0,
      serializer: Og,
    },
    _MA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: { headersMapper: zQ.BlockBlobStageBlockHeaders },
        default: {
          bodyMapper: zQ.StorageError,
          headersMapper: zQ.BlockBlobStageBlockExceptionHeaders,
        },
      },
      requestBody: j.body1,
      queryParameters: [j.timeoutInSeconds, j.comp24, j.blockId],
      urlParameters: [j.url],
      headerParameters: [
        j.version,
        j.requestId,
        j.contentLength,
        j.leaseId,
        j.encryptionKey,
        j.encryptionKeySha256,
        j.encryptionAlgorithm,
        j.encryptionScope,
        j.transactionalContentMD5,
        j.transactionalContentCrc64,
        j.contentType1,
        j.accept2,
      ],
      isXML: !0,
      contentType: "application/xml; charset=utf-8",
      mediaType: "binary",
      serializer: Og,
    },
    yMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: { headersMapper: zQ.BlockBlobStageBlockFromURLHeaders },
        default: {
          bodyMapper: zQ.StorageError,
          headersMapper: zQ.BlockBlobStageBlockFromURLExceptionHeaders,
        },
      },
      queryParameters: [j.timeoutInSeconds, j.comp24, j.blockId],
      urlParameters: [j.url],
      headerParameters: [
        j.version,
        j.requestId,
        j.accept1,
        j.contentLength,
        j.leaseId,
        j.encryptionKey,
        j.encryptionKeySha256,
        j.encryptionAlgorithm,
        j.encryptionScope,
        j.sourceIfModifiedSince,
        j.sourceIfUnmodifiedSince,
        j.sourceIfMatch,
        j.sourceIfNoneMatch,
        j.sourceContentMD5,
        j.copySourceAuthorization,
        j.fileRequestIntent,
        j.sourceUrl,
        j.sourceContentCrc64,
        j.sourceRange1,
      ],
      isXML: !0,
      serializer: Og,
    },
    SMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "PUT",
      responses: {
        201: { headersMapper: zQ.BlockBlobCommitBlockListHeaders },
        default: {
          bodyMapper: zQ.StorageError,
          headersMapper: zQ.BlockBlobCommitBlockListExceptionHeaders,
        },
      },
      requestBody: j.blocks,
      queryParameters: [j.timeoutInSeconds, j.comp25],
      urlParameters: [j.url],
      headerParameters: [
        j.contentType,
        j.accept,
        j.version,
        j.requestId,
        j.metadata,
        j.leaseId,
        j.ifModifiedSince,
        j.ifUnmodifiedSince,
        j.encryptionKey,
        j.encryptionKeySha256,
        j.encryptionAlgorithm,
        j.ifMatch,
        j.ifNoneMatch,
        j.ifTags,
        j.blobCacheControl,
        j.blobContentType,
        j.blobContentMD5,
        j.blobContentEncoding,
        j.blobContentLanguage,
        j.blobContentDisposition,
        j.immutabilityPolicyExpiry,
        j.immutabilityPolicyMode,
        j.encryptionScope,
        j.tier,
        j.blobTagsString,
        j.legalHold1,
        j.transactionalContentMD5,
        j.transactionalContentCrc64,
      ],
      isXML: !0,
      contentType: "application/xml; charset=utf-8",
      mediaType: "xml",
      serializer: Og,
    },
    bMA = {
      path: "/{containerName}/{blob}",
      httpMethod: "GET",
      responses: {
        200: {
          bodyMapper: zQ.BlockList,
          headersMapper: zQ.BlockBlobGetBlockListHeaders,
        },
        default: {
          bodyMapper: zQ.StorageError,
          headersMapper: zQ.BlockBlobGetBlockListExceptionHeaders,
        },
      },
      queryParameters: [j.timeoutInSeconds, j.snapshot, j.comp25, j.listType],
      urlParameters: [j.url],
      headerParameters: [
        j.version,
        j.requestId,
        j.accept1,
        j.leaseId,
        j.ifTags,
      ],
      isXML: !0,
      serializer: Og,
    };
});
var ek = Z((ZC) => {
  Object.defineProperty(ZC, "__esModule", { value: !0 });
  var qg = BQ();
  qg.__exportStar(kk(), ZC);
  qg.__exportStar(_k(), ZC);
  qg.__exportStar(mk(), ZC);
  qg.__exportStar(lk(), ZC);
  qg.__exportStar(ak(), ZC);
  qg.__exportStar(tk(), ZC);
});
var Ix = Z((Qx) => {
  Object.defineProperty(Qx, "__esModule", { value: !0 });
  Qx.StorageClient = void 0;
  var mMA = BQ(),
    dMA = mMA.__importStar(WN()),
    jg = ek();
  class Ax extends dMA.ExtendedServiceClient {
    url;
    version;
    constructor(A, Q) {
      if (A === void 0) throw Error("'url' cannot be null");
      if (!Q) Q = {};
      let B = { requestContentType: "application/json; charset=utf-8" },
        I = "azsdk-js-azure-storage-blob/12.29.1",
        E =
          Q.userAgentOptions && Q.userAgentOptions.userAgentPrefix
            ? `${Q.userAgentOptions.userAgentPrefix} ${I}`
            : `${I}`,
        C = {
          ...B,
          ...Q,
          userAgentOptions: { userAgentPrefix: E },
          endpoint: Q.endpoint ?? Q.baseUri ?? "{url}",
        };
      super(C);
      (this.url = A),
        (this.version = Q.version || "2025-11-05"),
        (this.service = new jg.ServiceImpl(this)),
        (this.container = new jg.ContainerImpl(this)),
        (this.blob = new jg.BlobImpl(this)),
        (this.pageBlob = new jg.PageBlobImpl(this)),
        (this.appendBlob = new jg.AppendBlobImpl(this)),
        (this.blockBlob = new jg.BlockBlobImpl(this));
    }
    service;
    container;
    blob;
    pageBlob;
    appendBlob;
    blockBlob;
  }
  Qx.StorageClient = Ax;
});
var Cx = Z((Ex) => {
  Object.defineProperty(Ex, "__esModule", { value: !0 });
});
var Fx = Z((gx) => {
  Object.defineProperty(gx, "__esModule", { value: !0 });
});
var Yx = Z((Dx) => {
  Object.defineProperty(Dx, "__esModule", { value: !0 });
});
var Nx = Z((Jx) => {
  Object.defineProperty(Jx, "__esModule", { value: !0 });
});
var Ux = Z((Gx) => {
  Object.defineProperty(Gx, "__esModule", { value: !0 });
});
var Zx = Z((Wx) => {
  Object.defineProperty(Wx, "__esModule", { value: !0 });
});
var Xx = Z((XC) => {
  Object.defineProperty(XC, "__esModule", { value: !0 });
  var fg = BQ();
  fg.__exportStar(Cx(), XC);
  fg.__exportStar(Fx(), XC);
  fg.__exportStar(Yx(), XC);
  fg.__exportStar(Nx(), XC);
  fg.__exportStar(Ux(), XC);
  fg.__exportStar(Zx(), XC);
});
var Mx = Z((ZD) => {
  Object.defineProperty(ZD, "__esModule", { value: !0 });
  ZD.StorageClient = void 0;
  var wx = BQ();
  wx.__exportStar(Lk(), ZD);
  var cMA = Ix();
  Object.defineProperty(ZD, "StorageClient", {
    enumerable: !0,
    get: function () {
      return cMA.StorageClient;
    },
  });
  wx.__exportStar(Xx(), ZD);
});
var F4 = Z((Rx) => {
  Object.defineProperty(Rx, "__esModule", { value: !0 });
  Rx.StorageContextClient = void 0;
  var lMA = Mx();
  class Lx extends lMA.StorageClient {
    async sendOperationRequest(A, Q) {
      let B = { ...Q };
      if (B.path === "/{containerName}" || B.path === "/{containerName}/{blob}")
        B.path = "";
      return super.sendOperationRequest(A, B);
    }
  }
  Rx.StorageContextClient = Lx;
});
var ON = Z((Kx) => {
  Object.defineProperty(Kx, "__esModule", { value: !0 });
  Kx.StorageClient = void 0;
  var pMA = F4(),
    $x = GC(),
    TN = yQ();
  class Hx {
    url;
    accountName;
    pipeline;
    credential;
    storageClientContext;
    isHttps;
    constructor(A, Q) {
      (this.url = (0, TN.escapeURLPath)(A)),
        (this.accountName = (0, TN.getAccountNameFromUrl)(A)),
        (this.pipeline = Q),
        (this.storageClientContext = new pMA.StorageContextClient(
          this.url,
          (0, $x.getCoreClientOptions)(Q),
        )),
        (this.isHttps = (0, TN.iEqual)(
          (0, TN.getURLScheme)(this.url) || "",
          "https",
        )),
        (this.credential = (0, $x.getCredentialFromPipeline)(Q));
      let B = this.storageClientContext;
      B.requestContentType = void 0;
    }
  }
  Kx.StorageClient = Hx;
});
var I0 = Z((Tx) => {
  Object.defineProperty(Tx, "__esModule", { value: !0 });
  Tx.tracingClient = void 0;
  var iMA = k1(),
    nMA = KQ();
  Tx.tracingClient = (0, iMA.createTracingClient)({
    packageName: "@azure/storage-blob",
    packageVersion: nMA.SDK_VERSION,
    namespace: "Microsoft.Storage",
  });
});
var D4 = Z((qx) => {
  Object.defineProperty(qx, "__esModule", { value: !0 });
  qx.BlobSASPermissions = void 0;
  class qN {
    static parse(A) {
      let Q = new qN();
      for (let B of A)
        switch (B) {
          case "r":
            Q.read = !0;
            break;
          case "a":
            Q.add = !0;
            break;
          case "c":
            Q.create = !0;
            break;
          case "w":
            Q.write = !0;
            break;
          case "d":
            Q.delete = !0;
            break;
          case "x":
            Q.deleteVersion = !0;
            break;
          case "t":
            Q.tag = !0;
            break;
          case "m":
            Q.move = !0;
            break;
          case "e":
            Q.execute = !0;
            break;
          case "i":
            Q.setImmutabilityPolicy = !0;
            break;
          case "y":
            Q.permanentDelete = !0;
            break;
          default:
            throw RangeError(`Invalid permission: ${B}`);
        }
      return Q;
    }
    static from(A) {
      let Q = new qN();
      if (A.read) Q.read = !0;
      if (A.add) Q.add = !0;
      if (A.create) Q.create = !0;
      if (A.write) Q.write = !0;
      if (A.delete) Q.delete = !0;
      if (A.deleteVersion) Q.deleteVersion = !0;
      if (A.tag) Q.tag = !0;
      if (A.move) Q.move = !0;
      if (A.execute) Q.execute = !0;
      if (A.setImmutabilityPolicy) Q.setImmutabilityPolicy = !0;
      if (A.permanentDelete) Q.permanentDelete = !0;
      return Q;
    }
    read = !1;
    add = !1;
    create = !1;
    write = !1;
    delete = !1;
    deleteVersion = !1;
    tag = !1;
    move = !1;
    execute = !1;
    setImmutabilityPolicy = !1;
    permanentDelete = !1;
    toString() {
      let A = [];
      if (this.read) A.push("r");
      if (this.add) A.push("a");
      if (this.create) A.push("c");
      if (this.write) A.push("w");
      if (this.delete) A.push("d");
      if (this.deleteVersion) A.push("x");
      if (this.tag) A.push("t");
      if (this.move) A.push("m");
      if (this.execute) A.push("e");
      if (this.setImmutabilityPolicy) A.push("i");
      if (this.permanentDelete) A.push("y");
      return A.join("");
    }
  }
  qx.BlobSASPermissions = qN;
});
var Y4 = Z((fx) => {
  Object.defineProperty(fx, "__esModule", { value: !0 });
  fx.ContainerSASPermissions = void 0;
  class jN {
    static parse(A) {
      let Q = new jN();
      for (let B of A)
        switch (B) {
          case "r":
            Q.read = !0;
            break;
          case "a":
            Q.add = !0;
            break;
          case "c":
            Q.create = !0;
            break;
          case "w":
            Q.write = !0;
            break;
          case "d":
            Q.delete = !0;
            break;
          case "l":
            Q.list = !0;
            break;
          case "t":
            Q.tag = !0;
            break;
          case "x":
            Q.deleteVersion = !0;
            break;
          case "m":
            Q.move = !0;
            break;
          case "e":
            Q.execute = !0;
            break;
          case "i":
            Q.setImmutabilityPolicy = !0;
            break;
          case "y":
            Q.permanentDelete = !0;
            break;
          case "f":
            Q.filterByTags = !0;
            break;
          default:
            throw RangeError(`Invalid permission ${B}`);
        }
      return Q;
    }
    static from(A) {
      let Q = new jN();
      if (A.read) Q.read = !0;
      if (A.add) Q.add = !0;
      if (A.create) Q.create = !0;
      if (A.write) Q.write = !0;
      if (A.delete) Q.delete = !0;
      if (A.list) Q.list = !0;
      if (A.deleteVersion) Q.deleteVersion = !0;
      if (A.tag) Q.tag = !0;
      if (A.move) Q.move = !0;
      if (A.execute) Q.execute = !0;
      if (A.setImmutabilityPolicy) Q.setImmutabilityPolicy = !0;
      if (A.permanentDelete) Q.permanentDelete = !0;
      if (A.filterByTags) Q.filterByTags = !0;
      return Q;
    }
    read = !1;
    add = !1;
    create = !1;
    write = !1;
    delete = !1;
    deleteVersion = !1;
    list = !1;
    tag = !1;
    move = !1;
    execute = !1;
    setImmutabilityPolicy = !1;
    permanentDelete = !1;
    filterByTags = !1;
    toString() {
      let A = [];
      if (this.read) A.push("r");
      if (this.add) A.push("a");
      if (this.create) A.push("c");
      if (this.write) A.push("w");
      if (this.delete) A.push("d");
      if (this.deleteVersion) A.push("x");
      if (this.list) A.push("l");
      if (this.tag) A.push("t");
      if (this.move) A.push("m");
      if (this.execute) A.push("e");
      if (this.setImmutabilityPolicy) A.push("i");
      if (this.permanentDelete) A.push("y");
      if (this.filterByTags) A.push("f");
      return A.join("");
    }
  }
  fx.ContainerSASPermissions = jN;
});
var Px = Z((xx) => {
  Object.defineProperty(xx, "__esModule", { value: !0 });
  xx.UserDelegationKeyCredential = void 0;
  var aMA = $("node:crypto");
  class kx {
    accountName;
    userDelegationKey;
    key;
    constructor(A, Q) {
      (this.accountName = A),
        (this.userDelegationKey = Q),
        (this.key = Buffer.from(Q.value, "base64"));
    }
    computeHMACSHA256(A) {
      return (0, aMA.createHmac)("sha256", this.key)
        .update(A, "utf8")
        .digest("base64");
    }
  }
  xx.UserDelegationKeyCredential = kx;
});
var fN = Z((_x) => {
  Object.defineProperty(_x, "__esModule", { value: !0 });
  _x.ipRangeToString = oMA;
  function oMA(A) {
    return A.end ? `${A.start}-${A.end}` : A.start;
  }
});
var kN = Z((bx) => {
  Object.defineProperty(bx, "__esModule", { value: !0 });
  bx.SASQueryParameters = bx.SASProtocol = void 0;
  var rMA = fN(),
    hN = yQ(),
    yx;
  (function (A) {
    (A.Https = "https"), (A.HttpsAndHttp = "https,http");
  })(yx || (bx.SASProtocol = yx = {}));
  class Sx {
    version;
    protocol;
    startsOn;
    expiresOn;
    permissions;
    services;
    resourceTypes;
    identifier;
    encryptionScope;
    resource;
    signature;
    cacheControl;
    contentDisposition;
    contentEncoding;
    contentLanguage;
    contentType;
    ipRangeInner;
    signedOid;
    signedTenantId;
    signedStartsOn;
    signedExpiresOn;
    signedService;
    signedVersion;
    preauthorizedAgentObjectId;
    correlationId;
    get ipRange() {
      if (this.ipRangeInner)
        return { end: this.ipRangeInner.end, start: this.ipRangeInner.start };
      return;
    }
    constructor(A, Q, B, I, E, C, g, F, D, J, Y, N, W, X, M, L, H, q, O, f) {
      if (
        ((this.version = A),
        (this.signature = Q),
        B !== void 0 && typeof B !== "string")
      ) {
        if (
          ((this.permissions = B.permissions),
          (this.services = B.services),
          (this.resourceTypes = B.resourceTypes),
          (this.protocol = B.protocol),
          (this.startsOn = B.startsOn),
          (this.expiresOn = B.expiresOn),
          (this.ipRangeInner = B.ipRange),
          (this.identifier = B.identifier),
          (this.encryptionScope = B.encryptionScope),
          (this.resource = B.resource),
          (this.cacheControl = B.cacheControl),
          (this.contentDisposition = B.contentDisposition),
          (this.contentEncoding = B.contentEncoding),
          (this.contentLanguage = B.contentLanguage),
          (this.contentType = B.contentType),
          B.userDelegationKey)
        )
          (this.signedOid = B.userDelegationKey.signedObjectId),
            (this.signedTenantId = B.userDelegationKey.signedTenantId),
            (this.signedStartsOn = B.userDelegationKey.signedStartsOn),
            (this.signedExpiresOn = B.userDelegationKey.signedExpiresOn),
            (this.signedService = B.userDelegationKey.signedService),
            (this.signedVersion = B.userDelegationKey.signedVersion),
            (this.preauthorizedAgentObjectId = B.preauthorizedAgentObjectId),
            (this.correlationId = B.correlationId);
      } else if (
        ((this.services = I),
        (this.resourceTypes = E),
        (this.expiresOn = F),
        (this.permissions = B),
        (this.protocol = C),
        (this.startsOn = g),
        (this.ipRangeInner = D),
        (this.encryptionScope = f),
        (this.identifier = J),
        (this.resource = Y),
        (this.cacheControl = N),
        (this.contentDisposition = W),
        (this.contentEncoding = X),
        (this.contentLanguage = M),
        (this.contentType = L),
        H)
      )
        (this.signedOid = H.signedObjectId),
          (this.signedTenantId = H.signedTenantId),
          (this.signedStartsOn = H.signedStartsOn),
          (this.signedExpiresOn = H.signedExpiresOn),
          (this.signedService = H.signedService),
          (this.signedVersion = H.signedVersion),
          (this.preauthorizedAgentObjectId = q),
          (this.correlationId = O);
    }
    toString() {
      let A = [
          "sv",
          "ss",
          "srt",
          "spr",
          "st",
          "se",
          "sip",
          "si",
          "ses",
          "skoid",
          "sktid",
          "skt",
          "ske",
          "sks",
          "skv",
          "sr",
          "sp",
          "sig",
          "rscc",
          "rscd",
          "rsce",
          "rscl",
          "rsct",
          "saoid",
          "scid",
        ],
        Q = [];
      for (let B of A)
        switch (B) {
          case "sv":
            this.tryAppendQueryParameter(Q, B, this.version);
            break;
          case "ss":
            this.tryAppendQueryParameter(Q, B, this.services);
            break;
          case "srt":
            this.tryAppendQueryParameter(Q, B, this.resourceTypes);
            break;
          case "spr":
            this.tryAppendQueryParameter(Q, B, this.protocol);
            break;
          case "st":
            this.tryAppendQueryParameter(
              Q,
              B,
              this.startsOn
                ? (0, hN.truncatedISO8061Date)(this.startsOn, !1)
                : void 0,
            );
            break;
          case "se":
            this.tryAppendQueryParameter(
              Q,
              B,
              this.expiresOn
                ? (0, hN.truncatedISO8061Date)(this.expiresOn, !1)
                : void 0,
            );
            break;
          case "sip":
            this.tryAppendQueryParameter(
              Q,
              B,
              this.ipRange ? (0, rMA.ipRangeToString)(this.ipRange) : void 0,
            );
            break;
          case "si":
            this.tryAppendQueryParameter(Q, B, this.identifier);
            break;
          case "ses":
            this.tryAppendQueryParameter(Q, B, this.encryptionScope);
            break;
          case "skoid":
            this.tryAppendQueryParameter(Q, B, this.signedOid);
            break;
          case "sktid":
            this.tryAppendQueryParameter(Q, B, this.signedTenantId);
            break;
          case "skt":
            this.tryAppendQueryParameter(
              Q,
              B,
              this.signedStartsOn
                ? (0, hN.truncatedISO8061Date)(this.signedStartsOn, !1)
                : void 0,
            );
            break;
          case "ske":
            this.tryAppendQueryParameter(
              Q,
              B,
              this.signedExpiresOn
                ? (0, hN.truncatedISO8061Date)(this.signedExpiresOn, !1)
                : void 0,
            );
            break;
          case "sks":
            this.tryAppendQueryParameter(Q, B, this.signedService);
            break;
          case "skv":
            this.tryAppendQueryParameter(Q, B, this.signedVersion);
            break;
          case "sr":
            this.tryAppendQueryParameter(Q, B, this.resource);
            break;
          case "sp":
            this.tryAppendQueryParameter(Q, B, this.permissions);
            break;
          case "sig":
            this.tryAppendQueryParameter(Q, B, this.signature);
            break;
          case "rscc":
            this.tryAppendQueryParameter(Q, B, this.cacheControl);
            break;
          case "rscd":
            this.tryAppendQueryParameter(Q, B, this.contentDisposition);
            break;
          case "rsce":
            this.tryAppendQueryParameter(Q, B, this.contentEncoding);
            break;
          case "rscl":
            this.tryAppendQueryParameter(Q, B, this.contentLanguage);
            break;
          case "rsct":
            this.tryAppendQueryParameter(Q, B, this.contentType);
            break;
          case "saoid":
            this.tryAppendQueryParameter(Q, B, this.preauthorizedAgentObjectId);
            break;
          case "scid":
            this.tryAppendQueryParameter(Q, B, this.correlationId);
            break;
        }
      return Q.join("&");
    }
    tryAppendQueryParameter(A, Q, B) {
      if (!B) return;
      if (
        ((Q = encodeURIComponent(Q)),
        (B = encodeURIComponent(B)),
        Q.length > 0 && B.length > 0)
      )
        A.push(`${Q}=${B}`);
    }
  }
  bx.SASQueryParameters = Sx;
});
var xN = Z((ux) => {
  Object.defineProperty(ux, "__esModule", { value: !0 });
  ux.generateBlobSASQueryParameters = QLA;
  ux.generateBlobSASQueryParametersInternal = cx;
  var E0 = D4(),
    C0 = Y4(),
    eMA = FC(),
    ALA = Px(),
    g0 = fN(),
    F0 = kN(),
    dx = KQ(),
    WQ = yQ();
  function QLA(A, Q, B) {
    return cx(A, Q, B).sasQueryParameters;
  }
  function cx(A, Q, B) {
    let I = A.version ? A.version : dx.SERVICE_VERSION,
      E = Q instanceof eMA.StorageSharedKeyCredential ? Q : void 0,
      C;
    if (E === void 0 && B !== void 0)
      C = new ALA.UserDelegationKeyCredential(B, Q);
    if (E === void 0 && C === void 0)
      throw TypeError(
        "Invalid sharedKeyCredential, userDelegationKey or accountName.",
      );
    if (I >= "2020-12-06")
      if (E !== void 0) return ELA(A, E);
      else if (I >= "2025-07-05") return DLA(A, C);
      else return FLA(A, C);
    if (I >= "2018-11-09")
      if (E !== void 0) return ILA(A, E);
      else if (I >= "2020-02-10") return gLA(A, C);
      else return CLA(A, C);
    if (I >= "2015-04-05")
      if (E !== void 0) return BLA(A, E);
      else
        throw RangeError(
          "'version' must be >= '2018-11-09' when generating user delegation SAS using user delegation key.",
        );
    throw RangeError("'version' must be >= '2015-04-05'.");
  }
  function BLA(A, Q) {
    if (((A = Y0(A)), !A.identifier && !(A.permissions && A.expiresOn)))
      throw RangeError(
        "Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.",
      );
    let B = "c";
    if (A.blobName) B = "b";
    let I;
    if (A.permissions)
      if (A.blobName)
        I = E0.BlobSASPermissions.parse(A.permissions.toString()).toString();
      else
        I = C0.ContainerSASPermissions.parse(
          A.permissions.toString(),
        ).toString();
    let E = [
        I ? I : "",
        A.startsOn ? (0, WQ.truncatedISO8061Date)(A.startsOn, !1) : "",
        A.expiresOn ? (0, WQ.truncatedISO8061Date)(A.expiresOn, !1) : "",
        D0(Q.accountName, A.containerName, A.blobName),
        A.identifier,
        A.ipRange ? (0, g0.ipRangeToString)(A.ipRange) : "",
        A.protocol ? A.protocol : "",
        A.version,
        A.cacheControl ? A.cacheControl : "",
        A.contentDisposition ? A.contentDisposition : "",
        A.contentEncoding ? A.contentEncoding : "",
        A.contentLanguage ? A.contentLanguage : "",
        A.contentType ? A.contentType : "",
      ].join(`
`),
      C = Q.computeHMACSHA256(E);
    return {
      sasQueryParameters: new F0.SASQueryParameters(
        A.version,
        C,
        I,
        void 0,
        void 0,
        A.protocol,
        A.startsOn,
        A.expiresOn,
        A.ipRange,
        A.identifier,
        B,
        A.cacheControl,
        A.contentDisposition,
        A.contentEncoding,
        A.contentLanguage,
        A.contentType,
      ),
      stringToSign: E,
    };
  }
  function ILA(A, Q) {
    if (((A = Y0(A)), !A.identifier && !(A.permissions && A.expiresOn)))
      throw RangeError(
        "Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.",
      );
    let B = "c",
      I = A.snapshotTime;
    if (A.blobName) {
      if (((B = "b"), A.snapshotTime)) B = "bs";
      else if (A.versionId) (B = "bv"), (I = A.versionId);
    }
    let E;
    if (A.permissions)
      if (A.blobName)
        E = E0.BlobSASPermissions.parse(A.permissions.toString()).toString();
      else
        E = C0.ContainerSASPermissions.parse(
          A.permissions.toString(),
        ).toString();
    let C = [
        E ? E : "",
        A.startsOn ? (0, WQ.truncatedISO8061Date)(A.startsOn, !1) : "",
        A.expiresOn ? (0, WQ.truncatedISO8061Date)(A.expiresOn, !1) : "",
        D0(Q.accountName, A.containerName, A.blobName),
        A.identifier,
        A.ipRange ? (0, g0.ipRangeToString)(A.ipRange) : "",
        A.protocol ? A.protocol : "",
        A.version,
        B,
        I,
        A.cacheControl ? A.cacheControl : "",
        A.contentDisposition ? A.contentDisposition : "",
        A.contentEncoding ? A.contentEncoding : "",
        A.contentLanguage ? A.contentLanguage : "",
        A.contentType ? A.contentType : "",
      ].join(`
`),
      g = Q.computeHMACSHA256(C);
    return {
      sasQueryParameters: new F0.SASQueryParameters(
        A.version,
        g,
        E,
        void 0,
        void 0,
        A.protocol,
        A.startsOn,
        A.expiresOn,
        A.ipRange,
        A.identifier,
        B,
        A.cacheControl,
        A.contentDisposition,
        A.contentEncoding,
        A.contentLanguage,
        A.contentType,
      ),
      stringToSign: C,
    };
  }
  function ELA(A, Q) {
    if (((A = Y0(A)), !A.identifier && !(A.permissions && A.expiresOn)))
      throw RangeError(
        "Must provide 'permissions' and 'expiresOn' for Blob SAS generation when 'identifier' is not provided.",
      );
    let B = "c",
      I = A.snapshotTime;
    if (A.blobName) {
      if (((B = "b"), A.snapshotTime)) B = "bs";
      else if (A.versionId) (B = "bv"), (I = A.versionId);
    }
    let E;
    if (A.permissions)
      if (A.blobName)
        E = E0.BlobSASPermissions.parse(A.permissions.toString()).toString();
      else
        E = C0.ContainerSASPermissions.parse(
          A.permissions.toString(),
        ).toString();
    let C = [
        E ? E : "",
        A.startsOn ? (0, WQ.truncatedISO8061Date)(A.startsOn, !1) : "",
        A.expiresOn ? (0, WQ.truncatedISO8061Date)(A.expiresOn, !1) : "",
        D0(Q.accountName, A.containerName, A.blobName),
        A.identifier,
        A.ipRange ? (0, g0.ipRangeToString)(A.ipRange) : "",
        A.protocol ? A.protocol : "",
        A.version,
        B,
        I,
        A.encryptionScope,
        A.cacheControl ? A.cacheControl : "",
        A.contentDisposition ? A.contentDisposition : "",
        A.contentEncoding ? A.contentEncoding : "",
        A.contentLanguage ? A.contentLanguage : "",
        A.contentType ? A.contentType : "",
      ].join(`
`),
      g = Q.computeHMACSHA256(C);
    return {
      sasQueryParameters: new F0.SASQueryParameters(
        A.version,
        g,
        E,
        void 0,
        void 0,
        A.protocol,
        A.startsOn,
        A.expiresOn,
        A.ipRange,
        A.identifier,
        B,
        A.cacheControl,
        A.contentDisposition,
        A.contentEncoding,
        A.contentLanguage,
        A.contentType,
        void 0,
        void 0,
        void 0,
        A.encryptionScope,
      ),
      stringToSign: C,
    };
  }
  function CLA(A, Q) {
    if (((A = Y0(A)), !A.permissions || !A.expiresOn))
      throw RangeError(
        "Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.",
      );
    let B = "c",
      I = A.snapshotTime;
    if (A.blobName) {
      if (((B = "b"), A.snapshotTime)) B = "bs";
      else if (A.versionId) (B = "bv"), (I = A.versionId);
    }
    let E;
    if (A.permissions)
      if (A.blobName)
        E = E0.BlobSASPermissions.parse(A.permissions.toString()).toString();
      else
        E = C0.ContainerSASPermissions.parse(
          A.permissions.toString(),
        ).toString();
    let C = [
        E ? E : "",
        A.startsOn ? (0, WQ.truncatedISO8061Date)(A.startsOn, !1) : "",
        A.expiresOn ? (0, WQ.truncatedISO8061Date)(A.expiresOn, !1) : "",
        D0(Q.accountName, A.containerName, A.blobName),
        Q.userDelegationKey.signedObjectId,
        Q.userDelegationKey.signedTenantId,
        Q.userDelegationKey.signedStartsOn
          ? (0, WQ.truncatedISO8061Date)(Q.userDelegationKey.signedStartsOn, !1)
          : "",
        Q.userDelegationKey.signedExpiresOn
          ? (0, WQ.truncatedISO8061Date)(
              Q.userDelegationKey.signedExpiresOn,
              !1,
            )
          : "",
        Q.userDelegationKey.signedService,
        Q.userDelegationKey.signedVersion,
        A.ipRange ? (0, g0.ipRangeToString)(A.ipRange) : "",
        A.protocol ? A.protocol : "",
        A.version,
        B,
        I,
        A.cacheControl,
        A.contentDisposition,
        A.contentEncoding,
        A.contentLanguage,
        A.contentType,
      ].join(`
`),
      g = Q.computeHMACSHA256(C);
    return {
      sasQueryParameters: new F0.SASQueryParameters(
        A.version,
        g,
        E,
        void 0,
        void 0,
        A.protocol,
        A.startsOn,
        A.expiresOn,
        A.ipRange,
        A.identifier,
        B,
        A.cacheControl,
        A.contentDisposition,
        A.contentEncoding,
        A.contentLanguage,
        A.contentType,
        Q.userDelegationKey,
      ),
      stringToSign: C,
    };
  }
  function gLA(A, Q) {
    if (((A = Y0(A)), !A.permissions || !A.expiresOn))
      throw RangeError(
        "Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.",
      );
    let B = "c",
      I = A.snapshotTime;
    if (A.blobName) {
      if (((B = "b"), A.snapshotTime)) B = "bs";
      else if (A.versionId) (B = "bv"), (I = A.versionId);
    }
    let E;
    if (A.permissions)
      if (A.blobName)
        E = E0.BlobSASPermissions.parse(A.permissions.toString()).toString();
      else
        E = C0.ContainerSASPermissions.parse(
          A.permissions.toString(),
        ).toString();
    let C = [
        E ? E : "",
        A.startsOn ? (0, WQ.truncatedISO8061Date)(A.startsOn, !1) : "",
        A.expiresOn ? (0, WQ.truncatedISO8061Date)(A.expiresOn, !1) : "",
        D0(Q.accountName, A.containerName, A.blobName),
        Q.userDelegationKey.signedObjectId,
        Q.userDelegationKey.signedTenantId,
        Q.userDelegationKey.signedStartsOn
          ? (0, WQ.truncatedISO8061Date)(Q.userDelegationKey.signedStartsOn, !1)
          : "",
        Q.userDelegationKey.signedExpiresOn
          ? (0, WQ.truncatedISO8061Date)(
              Q.userDelegationKey.signedExpiresOn,
              !1,
            )
          : "",
        Q.userDelegationKey.signedService,
        Q.userDelegationKey.signedVersion,
        A.preauthorizedAgentObjectId,
        void 0,
        A.correlationId,
        A.ipRange ? (0, g0.ipRangeToString)(A.ipRange) : "",
        A.protocol ? A.protocol : "",
        A.version,
        B,
        I,
        A.cacheControl,
        A.contentDisposition,
        A.contentEncoding,
        A.contentLanguage,
        A.contentType,
      ].join(`
`),
      g = Q.computeHMACSHA256(C);
    return {
      sasQueryParameters: new F0.SASQueryParameters(
        A.version,
        g,
        E,
        void 0,
        void 0,
        A.protocol,
        A.startsOn,
        A.expiresOn,
        A.ipRange,
        A.identifier,
        B,
        A.cacheControl,
        A.contentDisposition,
        A.contentEncoding,
        A.contentLanguage,
        A.contentType,
        Q.userDelegationKey,
        A.preauthorizedAgentObjectId,
        A.correlationId,
      ),
      stringToSign: C,
    };
  }
  function FLA(A, Q) {
    if (((A = Y0(A)), !A.permissions || !A.expiresOn))
      throw RangeError(
        "Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.",
      );
    let B = "c",
      I = A.snapshotTime;
    if (A.blobName) {
      if (((B = "b"), A.snapshotTime)) B = "bs";
      else if (A.versionId) (B = "bv"), (I = A.versionId);
    }
    let E;
    if (A.permissions)
      if (A.blobName)
        E = E0.BlobSASPermissions.parse(A.permissions.toString()).toString();
      else
        E = C0.ContainerSASPermissions.parse(
          A.permissions.toString(),
        ).toString();
    let C = [
        E ? E : "",
        A.startsOn ? (0, WQ.truncatedISO8061Date)(A.startsOn, !1) : "",
        A.expiresOn ? (0, WQ.truncatedISO8061Date)(A.expiresOn, !1) : "",
        D0(Q.accountName, A.containerName, A.blobName),
        Q.userDelegationKey.signedObjectId,
        Q.userDelegationKey.signedTenantId,
        Q.userDelegationKey.signedStartsOn
          ? (0, WQ.truncatedISO8061Date)(Q.userDelegationKey.signedStartsOn, !1)
          : "",
        Q.userDelegationKey.signedExpiresOn
          ? (0, WQ.truncatedISO8061Date)(
              Q.userDelegationKey.signedExpiresOn,
              !1,
            )
          : "",
        Q.userDelegationKey.signedService,
        Q.userDelegationKey.signedVersion,
        A.preauthorizedAgentObjectId,
        void 0,
        A.correlationId,
        A.ipRange ? (0, g0.ipRangeToString)(A.ipRange) : "",
        A.protocol ? A.protocol : "",
        A.version,
        B,
        I,
        A.encryptionScope,
        A.cacheControl,
        A.contentDisposition,
        A.contentEncoding,
        A.contentLanguage,
        A.contentType,
      ].join(`
`),
      g = Q.computeHMACSHA256(C);
    return {
      sasQueryParameters: new F0.SASQueryParameters(
        A.version,
        g,
        E,
        void 0,
        void 0,
        A.protocol,
        A.startsOn,
        A.expiresOn,
        A.ipRange,
        A.identifier,
        B,
        A.cacheControl,
        A.contentDisposition,
        A.contentEncoding,
        A.contentLanguage,
        A.contentType,
        Q.userDelegationKey,
        A.preauthorizedAgentObjectId,
        A.correlationId,
        A.encryptionScope,
      ),
      stringToSign: C,
    };
  }
  function DLA(A, Q) {
    if (((A = Y0(A)), !A.permissions || !A.expiresOn))
      throw RangeError(
        "Must provide 'permissions' and 'expiresOn' for Blob SAS generation when generating user delegation SAS.",
      );
    let B = "c",
      I = A.snapshotTime;
    if (A.blobName) {
      if (((B = "b"), A.snapshotTime)) B = "bs";
      else if (A.versionId) (B = "bv"), (I = A.versionId);
    }
    let E;
    if (A.permissions)
      if (A.blobName)
        E = E0.BlobSASPermissions.parse(A.permissions.toString()).toString();
      else
        E = C0.ContainerSASPermissions.parse(
          A.permissions.toString(),
        ).toString();
    let C = [
        E ? E : "",
        A.startsOn ? (0, WQ.truncatedISO8061Date)(A.startsOn, !1) : "",
        A.expiresOn ? (0, WQ.truncatedISO8061Date)(A.expiresOn, !1) : "",
        D0(Q.accountName, A.containerName, A.blobName),
        Q.userDelegationKey.signedObjectId,
        Q.userDelegationKey.signedTenantId,
        Q.userDelegationKey.signedStartsOn
          ? (0, WQ.truncatedISO8061Date)(Q.userDelegationKey.signedStartsOn, !1)
          : "",
        Q.userDelegationKey.signedExpiresOn
          ? (0, WQ.truncatedISO8061Date)(
              Q.userDelegationKey.signedExpiresOn,
              !1,
            )
          : "",
        Q.userDelegationKey.signedService,
        Q.userDelegationKey.signedVersion,
        A.preauthorizedAgentObjectId,
        void 0,
        A.correlationId,
        void 0,
        void 0,
        A.ipRange ? (0, g0.ipRangeToString)(A.ipRange) : "",
        A.protocol ? A.protocol : "",
        A.version,
        B,
        I,
        A.encryptionScope,
        A.cacheControl,
        A.contentDisposition,
        A.contentEncoding,
        A.contentLanguage,
        A.contentType,
      ].join(`
`),
      g = Q.computeHMACSHA256(C);
    return {
      sasQueryParameters: new F0.SASQueryParameters(
        A.version,
        g,
        E,
        void 0,
        void 0,
        A.protocol,
        A.startsOn,
        A.expiresOn,
        A.ipRange,
        A.identifier,
        B,
        A.cacheControl,
        A.contentDisposition,
        A.contentEncoding,
        A.contentLanguage,
        A.contentType,
        Q.userDelegationKey,
        A.preauthorizedAgentObjectId,
        A.correlationId,
        A.encryptionScope,
      ),
      stringToSign: C,
    };
  }
  function D0(A, Q, B) {
    let I = [`/blob/${A}/${Q}`];
    if (B) I.push(`/${B}`);
    return I.join("");
  }
  function Y0(A) {
    let Q = A.version ? A.version : dx.SERVICE_VERSION;
    if (A.snapshotTime && Q < "2018-11-09")
      throw RangeError(
        "'version' must be >= '2018-11-09' when providing 'snapshotTime'.",
      );
    if (A.blobName === void 0 && A.snapshotTime)
      throw RangeError(
        "Must provide 'blobName' when providing 'snapshotTime'.",
      );
    if (A.versionId && Q < "2019-10-10")
      throw RangeError(
        "'version' must be >= '2019-10-10' when providing 'versionId'.",
      );
    if (A.blobName === void 0 && A.versionId)
      throw RangeError("Must provide 'blobName' when providing 'versionId'.");
    if (
      A.permissions &&
      A.permissions.setImmutabilityPolicy &&
      Q < "2020-08-04"
    )
      throw RangeError(
        "'version' must be >= '2020-08-04' when provided 'i' permission.",
      );
    if (A.permissions && A.permissions.deleteVersion && Q < "2019-10-10")
      throw RangeError(
        "'version' must be >= '2019-10-10' when providing 'x' permission.",
      );
    if (A.permissions && A.permissions.permanentDelete && Q < "2019-10-10")
      throw RangeError(
        "'version' must be >= '2019-10-10' when providing 'y' permission.",
      );
    if (A.permissions && A.permissions.tag && Q < "2019-12-12")
      throw RangeError(
        "'version' must be >= '2019-12-12' when providing 't' permission.",
      );
    if (
      Q < "2020-02-10" &&
      A.permissions &&
      (A.permissions.move || A.permissions.execute)
    )
      throw RangeError(
        "'version' must be >= '2020-02-10' when providing the 'm' or 'e' permission.",
      );
    if (Q < "2021-04-10" && A.permissions && A.permissions.filterByTags)
      throw RangeError(
        "'version' must be >= '2021-04-10' when providing the 'f' permission.",
      );
    if (Q < "2020-02-10" && (A.preauthorizedAgentObjectId || A.correlationId))
      throw RangeError(
        "'version' must be >= '2020-02-10' when providing 'preauthorizedAgentObjectId' or 'correlationId'.",
      );
    if (A.encryptionScope && Q < "2020-12-06")
      throw RangeError(
        "'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.",
      );
    return (A.version = Q), A;
  }
});
var PN = Z((px) => {
  Object.defineProperty(px, "__esModule", { value: !0 });
  px.BlobLeaseClient = void 0;
  var NLA = lA(),
    sI = KQ(),
    XD = I0(),
    vN = yQ();
  class lx {
    _leaseId;
    _url;
    _containerOrBlobOperation;
    _isContainer;
    get leaseId() {
      return this._leaseId;
    }
    get url() {
      return this._url;
    }
    constructor(A, Q) {
      let B = A.storageClientContext;
      if (((this._url = A.url), A.name === void 0))
        (this._isContainer = !0),
          (this._containerOrBlobOperation = B.container);
      else (this._isContainer = !1), (this._containerOrBlobOperation = B.blob);
      if (!Q) Q = (0, NLA.randomUUID)();
      this._leaseId = Q;
    }
    async acquireLease(A, Q = {}) {
      if (
        this._isContainer &&
        ((Q.conditions?.ifMatch && Q.conditions?.ifMatch !== sI.ETagNone) ||
          (Q.conditions?.ifNoneMatch &&
            Q.conditions?.ifNoneMatch !== sI.ETagNone) ||
          Q.conditions?.tagConditions)
      )
        throw RangeError(
          "The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.",
        );
      return XD.tracingClient.withSpan(
        "BlobLeaseClient-acquireLease",
        Q,
        async (B) => {
          return (0, vN.assertResponse)(
            await this._containerOrBlobOperation.acquireLease({
              abortSignal: Q.abortSignal,
              duration: A,
              modifiedAccessConditions: {
                ...Q.conditions,
                ifTags: Q.conditions?.tagConditions,
              },
              proposedLeaseId: this._leaseId,
              tracingOptions: B.tracingOptions,
            }),
          );
        },
      );
    }
    async changeLease(A, Q = {}) {
      if (
        this._isContainer &&
        ((Q.conditions?.ifMatch && Q.conditions?.ifMatch !== sI.ETagNone) ||
          (Q.conditions?.ifNoneMatch &&
            Q.conditions?.ifNoneMatch !== sI.ETagNone) ||
          Q.conditions?.tagConditions)
      )
        throw RangeError(
          "The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.",
        );
      return XD.tracingClient.withSpan(
        "BlobLeaseClient-changeLease",
        Q,
        async (B) => {
          let I = (0, vN.assertResponse)(
            await this._containerOrBlobOperation.changeLease(this._leaseId, A, {
              abortSignal: Q.abortSignal,
              modifiedAccessConditions: {
                ...Q.conditions,
                ifTags: Q.conditions?.tagConditions,
              },
              tracingOptions: B.tracingOptions,
            }),
          );
          return (this._leaseId = A), I;
        },
      );
    }
    async releaseLease(A = {}) {
      if (
        this._isContainer &&
        ((A.conditions?.ifMatch && A.conditions?.ifMatch !== sI.ETagNone) ||
          (A.conditions?.ifNoneMatch &&
            A.conditions?.ifNoneMatch !== sI.ETagNone) ||
          A.conditions?.tagConditions)
      )
        throw RangeError(
          "The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.",
        );
      return XD.tracingClient.withSpan(
        "BlobLeaseClient-releaseLease",
        A,
        async (Q) => {
          return (0, vN.assertResponse)(
            await this._containerOrBlobOperation.releaseLease(this._leaseId, {
              abortSignal: A.abortSignal,
              modifiedAccessConditions: {
                ...A.conditions,
                ifTags: A.conditions?.tagConditions,
              },
              tracingOptions: Q.tracingOptions,
            }),
          );
        },
      );
    }
    async renewLease(A = {}) {
      if (
        this._isContainer &&
        ((A.conditions?.ifMatch && A.conditions?.ifMatch !== sI.ETagNone) ||
          (A.conditions?.ifNoneMatch &&
            A.conditions?.ifNoneMatch !== sI.ETagNone) ||
          A.conditions?.tagConditions)
      )
        throw RangeError(
          "The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.",
        );
      return XD.tracingClient.withSpan(
        "BlobLeaseClient-renewLease",
        A,
        async (Q) => {
          return this._containerOrBlobOperation.renewLease(this._leaseId, {
            abortSignal: A.abortSignal,
            modifiedAccessConditions: {
              ...A.conditions,
              ifTags: A.conditions?.tagConditions,
            },
            tracingOptions: Q.tracingOptions,
          });
        },
      );
    }
    async breakLease(A, Q = {}) {
      if (
        this._isContainer &&
        ((Q.conditions?.ifMatch && Q.conditions?.ifMatch !== sI.ETagNone) ||
          (Q.conditions?.ifNoneMatch &&
            Q.conditions?.ifNoneMatch !== sI.ETagNone) ||
          Q.conditions?.tagConditions)
      )
        throw RangeError(
          "The IfMatch, IfNoneMatch and tags access conditions are ignored by the service. Values other than undefined or their default values are not acceptable.",
        );
      return XD.tracingClient.withSpan(
        "BlobLeaseClient-breakLease",
        Q,
        async (B) => {
          let I = {
            abortSignal: Q.abortSignal,
            breakPeriod: A,
            modifiedAccessConditions: {
              ...Q.conditions,
              ifTags: Q.conditions?.tagConditions,
            },
            tracingOptions: B.tracingOptions,
          };
          return (0, vN.assertResponse)(
            await this._containerOrBlobOperation.breakLease(I),
          );
        },
      );
    }
  }
  px.BlobLeaseClient = lx;
});
var sx = Z((ax) => {
  Object.defineProperty(ax, "__esModule", { value: !0 });
  ax.RetriableReadableStream = void 0;
  var GLA = YD(),
    ULA = $("node:stream");
  class nx extends ULA.Readable {
    start;
    offset;
    end;
    getter;
    source;
    retries = 0;
    maxRetryRequests;
    onProgress;
    options;
    constructor(A, Q, B, I, E = {}) {
      super({ highWaterMark: E.highWaterMark });
      (this.getter = Q),
        (this.source = A),
        (this.start = B),
        (this.offset = B),
        (this.end = B + I - 1),
        (this.maxRetryRequests =
          E.maxRetryRequests && E.maxRetryRequests >= 0
            ? E.maxRetryRequests
            : 0),
        (this.onProgress = E.onProgress),
        (this.options = E),
        this.setSourceEventHandlers();
    }
    _read() {
      this.source.resume();
    }
    setSourceEventHandlers() {
      this.source.on("data", this.sourceDataHandler),
        this.source.on("end", this.sourceErrorOrEndHandler),
        this.source.on("error", this.sourceErrorOrEndHandler),
        this.source.on("aborted", this.sourceAbortedHandler);
    }
    removeSourceEventHandlers() {
      this.source.removeListener("data", this.sourceDataHandler),
        this.source.removeListener("end", this.sourceErrorOrEndHandler),
        this.source.removeListener("error", this.sourceErrorOrEndHandler),
        this.source.removeListener("aborted", this.sourceAbortedHandler);
    }
    sourceDataHandler = (A) => {
      if (this.options.doInjectErrorOnce) {
        (this.options.doInjectErrorOnce = void 0),
          this.source.pause(),
          this.sourceErrorOrEndHandler(),
          this.source.destroy();
        return;
      }
      if (((this.offset += A.length), this.onProgress))
        this.onProgress({ loadedBytes: this.offset - this.start });
      if (!this.push(A)) this.source.pause();
    };
    sourceAbortedHandler = () => {
      let A = new GLA.AbortError("The operation was aborted.");
      this.destroy(A);
    };
    sourceErrorOrEndHandler = (A) => {
      if (A && A.name === "AbortError") {
        this.destroy(A);
        return;
      }
      if ((this.removeSourceEventHandlers(), this.offset - 1 === this.end))
        this.push(null);
      else if (this.offset <= this.end)
        if (this.retries < this.maxRetryRequests)
          (this.retries += 1),
            this.getter(this.offset)
              .then((Q) => {
                (this.source = Q), this.setSourceEventHandlers();
                return;
              })
              .catch((Q) => {
                this.destroy(Q);
              });
        else
          this.destroy(
            Error(
              `Data corruption failure: received less data than required and reached maxRetires limitation. Received data offset: ${this.offset - 1}, data needed offset: ${this.end}, retries: ${this.retries}, max retries: ${this.maxRetryRequests}`,
            ),
          );
      else
        this.destroy(
          Error(
            `Data corruption failure: Received more data than original request, data needed offset is ${this.end}, received offset: ${this.offset - 1}`,
          ),
        );
    };
    _destroy(A, Q) {
      this.removeSourceEventHandlers(),
        this.source.destroy(),
        Q(A === null ? void 0 : A);
    }
  }
  ax.RetriableReadableStream = nx;
});
var Av = Z((tx) => {
  Object.defineProperty(tx, "__esModule", { value: !0 });
  tx.BlobDownloadResponse = void 0;
  var WLA = lA(),
    ZLA = sx();
  class rx {
    get acceptRanges() {
      return this.originalResponse.acceptRanges;
    }
    get cacheControl() {
      return this.originalResponse.cacheControl;
    }
    get contentDisposition() {
      return this.originalResponse.contentDisposition;
    }
    get contentEncoding() {
      return this.originalResponse.contentEncoding;
    }
    get contentLanguage() {
      return this.originalResponse.contentLanguage;
    }
    get blobSequenceNumber() {
      return this.originalResponse.blobSequenceNumber;
    }
    get blobType() {
      return this.originalResponse.blobType;
    }
    get contentLength() {
      return this.originalResponse.contentLength;
    }
    get contentMD5() {
      return this.originalResponse.contentMD5;
    }
    get contentRange() {
      return this.originalResponse.contentRange;
    }
    get contentType() {
      return this.originalResponse.contentType;
    }
    get copyCompletedOn() {
      return this.originalResponse.copyCompletedOn;
    }
    get copyId() {
      return this.originalResponse.copyId;
    }
    get copyProgress() {
      return this.originalResponse.copyProgress;
    }
    get copySource() {
      return this.originalResponse.copySource;
    }
    get copyStatus() {
      return this.originalResponse.copyStatus;
    }
    get copyStatusDescription() {
      return this.originalResponse.copyStatusDescription;
    }
    get leaseDuration() {
      return this.originalResponse.leaseDuration;
    }
    get leaseState() {
      return this.originalResponse.leaseState;
    }
    get leaseStatus() {
      return this.originalResponse.leaseStatus;
    }
    get date() {
      return this.originalResponse.date;
    }
    get blobCommittedBlockCount() {
      return this.originalResponse.blobCommittedBlockCount;
    }
    get etag() {
      return this.originalResponse.etag;
    }
    get tagCount() {
      return this.originalResponse.tagCount;
    }
    get errorCode() {
      return this.originalResponse.errorCode;
    }
    get isServerEncrypted() {
      return this.originalResponse.isServerEncrypted;
    }
    get blobContentMD5() {
      return this.originalResponse.blobContentMD5;
    }
    get lastModified() {
      return this.originalResponse.lastModified;
    }
    get lastAccessed() {
      return this.originalResponse.lastAccessed;
    }
    get createdOn() {
      return this.originalResponse.createdOn;
    }
    get metadata() {
      return this.originalResponse.metadata;
    }
    get requestId() {
      return this.originalResponse.requestId;
    }
    get clientRequestId() {
      return this.originalResponse.clientRequestId;
    }
    get version() {
      return this.originalResponse.version;
    }
    get versionId() {
      return this.originalResponse.versionId;
    }
    get isCurrentVersion() {
      return this.originalResponse.isCurrentVersion;
    }
    get encryptionKeySha256() {
      return this.originalResponse.encryptionKeySha256;
    }
    get contentCrc64() {
      return this.originalResponse.contentCrc64;
    }
    get objectReplicationDestinationPolicyId() {
      return this.originalResponse.objectReplicationDestinationPolicyId;
    }
    get objectReplicationSourceProperties() {
      return this.originalResponse.objectReplicationSourceProperties;
    }
    get isSealed() {
      return this.originalResponse.isSealed;
    }
    get immutabilityPolicyExpiresOn() {
      return this.originalResponse.immutabilityPolicyExpiresOn;
    }
    get immutabilityPolicyMode() {
      return this.originalResponse.immutabilityPolicyMode;
    }
    get legalHold() {
      return this.originalResponse.legalHold;
    }
    get contentAsBlob() {
      return this.originalResponse.blobBody;
    }
    get readableStreamBody() {
      return WLA.isNodeLike ? this.blobDownloadStream : void 0;
    }
    get _response() {
      return this.originalResponse._response;
    }
    originalResponse;
    blobDownloadStream;
    constructor(A, Q, B, I, E = {}) {
      (this.originalResponse = A),
        (this.blobDownloadStream = new ZLA.RetriableReadableStream(
          this.originalResponse.readableStreamBody,
          Q,
          B,
          I,
          E,
        ));
    }
  }
  tx.BlobDownloadResponse = rx;
});
var Iv = Z((Qv) => {
  Object.defineProperty(Qv, "__esModule", { value: !0 });
  Qv.AVRO_SCHEMA_KEY =
    Qv.AVRO_CODEC_KEY =
    Qv.AVRO_INIT_BYTES =
    Qv.AVRO_SYNC_MARKER_SIZE =
      void 0;
  Qv.AVRO_SYNC_MARKER_SIZE = 16;
  Qv.AVRO_INIT_BYTES = new Uint8Array([79, 98, 106, 1]);
  Qv.AVRO_CODEC_KEY = "avro.codec";
  Qv.AVRO_SCHEMA_KEY = "avro.schema";
});
var Nv = Z((Yv) => {
  Object.defineProperty(Yv, "__esModule", { value: !0 });
  Yv.AvroType = Yv.AvroParser = void 0;
  class SA {
    static async readFixedBytes(A, Q, B = {}) {
      let I = await A.read(Q, { abortSignal: B.abortSignal });
      if (I.length !== Q) throw Error("Hit stream end.");
      return I;
    }
    static async readByte(A, Q = {}) {
      return (await SA.readFixedBytes(A, 1, Q))[0];
    }
    static async readZigZagLong(A, Q = {}) {
      let B = 0,
        I = 0,
        E,
        C,
        g;
      do
        (E = await SA.readByte(A, Q)),
          (C = E & 128),
          (B |= (E & 127) << I),
          (I += 7);
      while (C && I < 28);
      if (C) {
        (B = B), (g = 268435456);
        do (E = await SA.readByte(A, Q)), (B += (E & 127) * g), (g *= 128);
        while (E & 128);
        let F = (B % 2 ? -(B + 1) : B) / 2;
        if (F < Number.MIN_SAFE_INTEGER || F > Number.MAX_SAFE_INTEGER)
          throw Error("Integer overflow.");
        return F;
      }
      return (B >> 1) ^ -(B & 1);
    }
    static async readLong(A, Q = {}) {
      return SA.readZigZagLong(A, Q);
    }
    static async readInt(A, Q = {}) {
      return SA.readZigZagLong(A, Q);
    }
    static async readNull() {
      return null;
    }
    static async readBoolean(A, Q = {}) {
      let B = await SA.readByte(A, Q);
      if (B === 1) return !0;
      else if (B === 0) return !1;
      else throw Error("Byte was not a boolean.");
    }
    static async readFloat(A, Q = {}) {
      let B = await SA.readFixedBytes(A, 4, Q);
      return new DataView(B.buffer, B.byteOffset, B.byteLength).getFloat32(
        0,
        !0,
      );
    }
    static async readDouble(A, Q = {}) {
      let B = await SA.readFixedBytes(A, 8, Q);
      return new DataView(B.buffer, B.byteOffset, B.byteLength).getFloat64(
        0,
        !0,
      );
    }
    static async readBytes(A, Q = {}) {
      let B = await SA.readLong(A, Q);
      if (B < 0) throw Error("Bytes size was negative.");
      return A.read(B, { abortSignal: Q.abortSignal });
    }
    static async readString(A, Q = {}) {
      let B = await SA.readBytes(A, Q);
      return new TextDecoder().decode(B);
    }
    static async readMapPair(A, Q, B = {}) {
      let I = await SA.readString(A, B),
        E = await Q(A, B);
      return { key: I, value: E };
    }
    static async readMap(A, Q, B = {}) {
      let I = (g, F = {}) => {
          return SA.readMapPair(g, Q, F);
        },
        E = await SA.readArray(A, I, B),
        C = {};
      for (let g of E) C[g.key] = g.value;
      return C;
    }
    static async readArray(A, Q, B = {}) {
      let I = [];
      for (
        let E = await SA.readLong(A, B);
        E !== 0;
        E = await SA.readLong(A, B)
      ) {
        if (E < 0) await SA.readLong(A, B), (E = -E);
        while (E--) {
          let C = await Q(A, B);
          I.push(C);
        }
      }
      return I;
    }
  }
  Yv.AvroParser = SA;
  var J0;
  (function (A) {
    (A.RECORD = "record"),
      (A.ENUM = "enum"),
      (A.ARRAY = "array"),
      (A.MAP = "map"),
      (A.UNION = "union"),
      (A.FIXED = "fixed");
  })(J0 || (J0 = {}));
  var mQ;
  (function (A) {
    (A.NULL = "null"),
      (A.BOOLEAN = "boolean"),
      (A.INT = "int"),
      (A.LONG = "long"),
      (A.FLOAT = "float"),
      (A.DOUBLE = "double"),
      (A.BYTES = "bytes"),
      (A.STRING = "string");
  })(mQ || (mQ = {}));
  class xB {
    static fromSchema(A) {
      if (typeof A === "string") return xB.fromStringSchema(A);
      else if (Array.isArray(A)) return xB.fromArraySchema(A);
      else return xB.fromObjectSchema(A);
    }
    static fromStringSchema(A) {
      switch (A) {
        case mQ.NULL:
        case mQ.BOOLEAN:
        case mQ.INT:
        case mQ.LONG:
        case mQ.FLOAT:
        case mQ.DOUBLE:
        case mQ.BYTES:
        case mQ.STRING:
          return new Ev(A);
        default:
          throw Error(`Unexpected Avro type ${A}`);
      }
    }
    static fromArraySchema(A) {
      return new gv(A.map(xB.fromSchema));
    }
    static fromObjectSchema(A) {
      let Q = A.type;
      try {
        return xB.fromStringSchema(Q);
      } catch {}
      switch (Q) {
        case J0.RECORD:
          if (A.aliases)
            throw Error(`aliases currently is not supported, schema: ${A}`);
          if (!A.name)
            throw Error(
              `Required attribute 'name' doesn't exist on schema: ${A}`,
            );
          let B = {};
          if (!A.fields)
            throw Error(
              `Required attribute 'fields' doesn't exist on schema: ${A}`,
            );
          for (let I of A.fields) B[I.name] = xB.fromSchema(I.type);
          return new Dv(B, A.name);
        case J0.ENUM:
          if (A.aliases)
            throw Error(`aliases currently is not supported, schema: ${A}`);
          if (!A.symbols)
            throw Error(
              `Required attribute 'symbols' doesn't exist on schema: ${A}`,
            );
          return new Cv(A.symbols);
        case J0.MAP:
          if (!A.values)
            throw Error(
              `Required attribute 'values' doesn't exist on schema: ${A}`,
            );
          return new Fv(xB.fromSchema(A.values));
        case J0.ARRAY:
        case J0.FIXED:
        default:
          throw Error(`Unexpected Avro type ${Q} in ${A}`);
      }
    }
  }
  Yv.AvroType = xB;
  class Ev extends xB {
    _primitive;
    constructor(A) {
      super();
      this._primitive = A;
    }
    read(A, Q = {}) {
      switch (this._primitive) {
        case mQ.NULL:
          return SA.readNull();
        case mQ.BOOLEAN:
          return SA.readBoolean(A, Q);
        case mQ.INT:
          return SA.readInt(A, Q);
        case mQ.LONG:
          return SA.readLong(A, Q);
        case mQ.FLOAT:
          return SA.readFloat(A, Q);
        case mQ.DOUBLE:
          return SA.readDouble(A, Q);
        case mQ.BYTES:
          return SA.readBytes(A, Q);
        case mQ.STRING:
          return SA.readString(A, Q);
        default:
          throw Error("Unknown Avro Primitive");
      }
    }
  }
  class Cv extends xB {
    _symbols;
    constructor(A) {
      super();
      this._symbols = A;
    }
    async read(A, Q = {}) {
      let B = await SA.readInt(A, Q);
      return this._symbols[B];
    }
  }
  class gv extends xB {
    _types;
    constructor(A) {
      super();
      this._types = A;
    }
    async read(A, Q = {}) {
      let B = await SA.readInt(A, Q);
      return this._types[B].read(A, Q);
    }
  }
  class Fv extends xB {
    _itemType;
    constructor(A) {
      super();
      this._itemType = A;
    }
    read(A, Q = {}) {
      let B = (I, E) => {
        return this._itemType.read(I, E);
      };
      return SA.readMap(A, B, Q);
    }
  }
  class Dv extends xB {
    _name;
    _fields;
    constructor(A, Q) {
      super();
      (this._fields = A), (this._name = Q);
    }
    async read(A, Q = {}) {
      let B = {};
      B.$schema = this._name;
      for (let I in this._fields)
        if (Object.prototype.hasOwnProperty.call(this._fields, I))
          B[I] = await this._fields[I].read(A, Q);
      return B;
    }
  }
});
var Uv = Z((Gv) => {
  Object.defineProperty(Gv, "__esModule", { value: !0 });
  Gv.arraysEqual = RLA;
  function RLA(A, Q) {
    if (A === Q) return !0;
    if (A == null || Q == null) return !1;
    if (A.length !== Q.length) return !1;
    for (let B = 0; B < A.length; ++B) if (A[B] !== Q[B]) return !1;
    return !0;
  }
});
var Mv = Z((Xv) => {
  Object.defineProperty(Xv, "__esModule", { value: !0 });
  Xv.AvroReader = void 0;
  var hg = Iv(),
    rI = Nv(),
    Wv = Uv();
  class Zv {
    _dataStream;
    _headerStream;
    _syncMarker;
    _metadata;
    _itemType;
    _itemsRemainingInBlock;
    _initialBlockOffset;
    _blockOffset;
    get blockOffset() {
      return this._blockOffset;
    }
    _objectIndex;
    get objectIndex() {
      return this._objectIndex;
    }
    _initialized;
    constructor(A, Q, B, I) {
      (this._dataStream = A),
        (this._headerStream = Q || A),
        (this._initialized = !1),
        (this._blockOffset = B || 0),
        (this._objectIndex = I || 0),
        (this._initialBlockOffset = B || 0);
    }
    async initialize(A = {}) {
      let Q = await rI.AvroParser.readFixedBytes(
        this._headerStream,
        hg.AVRO_INIT_BYTES.length,
        { abortSignal: A.abortSignal },
      );
      if (!(0, Wv.arraysEqual)(Q, hg.AVRO_INIT_BYTES))
        throw Error("Stream is not an Avro file.");
      this._metadata = await rI.AvroParser.readMap(
        this._headerStream,
        rI.AvroParser.readString,
        { abortSignal: A.abortSignal },
      );
      let B = this._metadata[hg.AVRO_CODEC_KEY];
      if (!(B === void 0 || B === null || B === "null"))
        throw Error("Codecs are not supported");
      this._syncMarker = await rI.AvroParser.readFixedBytes(
        this._headerStream,
        hg.AVRO_SYNC_MARKER_SIZE,
        { abortSignal: A.abortSignal },
      );
      let I = JSON.parse(this._metadata[hg.AVRO_SCHEMA_KEY]);
      if (
        ((this._itemType = rI.AvroType.fromSchema(I)), this._blockOffset === 0)
      )
        this._blockOffset =
          this._initialBlockOffset + this._dataStream.position;
      if (
        ((this._itemsRemainingInBlock = await rI.AvroParser.readLong(
          this._dataStream,
          { abortSignal: A.abortSignal },
        )),
        await rI.AvroParser.readLong(this._dataStream, {
          abortSignal: A.abortSignal,
        }),
        (this._initialized = !0),
        this._objectIndex && this._objectIndex > 0)
      )
        for (let E = 0; E < this._objectIndex; E++)
          await this._itemType.read(this._dataStream, {
            abortSignal: A.abortSignal,
          }),
            this._itemsRemainingInBlock--;
    }
    hasNext() {
      return !this._initialized || this._itemsRemainingInBlock > 0;
    }
    async *parseObjects(A = {}) {
      if (!this._initialized) await this.initialize(A);
      while (this.hasNext()) {
        let Q = await this._itemType.read(this._dataStream, {
          abortSignal: A.abortSignal,
        });
        if (
          (this._itemsRemainingInBlock--,
          this._objectIndex++,
          this._itemsRemainingInBlock === 0)
        ) {
          let B = await rI.AvroParser.readFixedBytes(
            this._dataStream,
            hg.AVRO_SYNC_MARKER_SIZE,
            { abortSignal: A.abortSignal },
          );
          if (
            ((this._blockOffset =
              this._initialBlockOffset + this._dataStream.position),
            (this._objectIndex = 0),
            !(0, Wv.arraysEqual)(this._syncMarker, B))
          )
            throw Error("Stream is not a valid Avro file.");
          try {
            this._itemsRemainingInBlock = await rI.AvroParser.readLong(
              this._dataStream,
              { abortSignal: A.abortSignal },
            );
          } catch {
            this._itemsRemainingInBlock = 0;
          }
          if (this._itemsRemainingInBlock > 0)
            await rI.AvroParser.readLong(this._dataStream, {
              abortSignal: A.abortSignal,
            });
        }
        yield Q;
      }
    }
  }
  Xv.AvroReader = Zv;
});
var J4 = Z((Rv) => {
  Object.defineProperty(Rv, "__esModule", { value: !0 });
  Rv.AvroReadable = void 0;
  class Lv {}
  Rv.AvroReadable = Lv;
});
var Tv = Z((Kv) => {
  Object.defineProperty(Kv, "__esModule", { value: !0 });
  Kv.AvroReadableFromStream = void 0;
  var $LA = J4(),
    HLA = YD(),
    KLA = $("buffer"),
    $v = new HLA.AbortError("Reading from the avro stream was aborted.");
  class Hv extends $LA.AvroReadable {
    _position;
    _readable;
    toUint8Array(A) {
      if (typeof A === "string") return KLA.Buffer.from(A);
      return A;
    }
    constructor(A) {
      super();
      (this._readable = A), (this._position = 0);
    }
    get position() {
      return this._position;
    }
    async read(A, Q = {}) {
      if (Q.abortSignal?.aborted) throw $v;
      if (A < 0) throw Error(`size parameter should be positive: ${A}`);
      if (A === 0) return new Uint8Array();
      if (!this._readable.readable) throw Error("Stream no longer readable.");
      let B = this._readable.read(A);
      if (B) return (this._position += B.length), this.toUint8Array(B);
      else
        return new Promise((I, E) => {
          let C = () => {
              if (
                (this._readable.removeListener("readable", g),
                this._readable.removeListener("error", F),
                this._readable.removeListener("end", F),
                this._readable.removeListener("close", F),
                Q.abortSignal)
              )
                Q.abortSignal.removeEventListener("abort", D);
            },
            g = () => {
              let J = this._readable.read(A);
              if (J) (this._position += J.length), C(), I(this.toUint8Array(J));
            },
            F = () => {
              C(), E();
            },
            D = () => {
              C(), E($v);
            };
          if (
            (this._readable.on("readable", g),
            this._readable.once("error", F),
            this._readable.once("end", F),
            this._readable.once("close", F),
            Q.abortSignal)
          )
            Q.abortSignal.addEventListener("abort", D);
        });
    }
  }
  Kv.AvroReadableFromStream = Hv;
});
var Ov = Z((wD) => {
  Object.defineProperty(wD, "__esModule", { value: !0 });
  wD.AvroReadableFromStream = wD.AvroReadable = wD.AvroReader = void 0;
  var zLA = Mv();
  Object.defineProperty(wD, "AvroReader", {
    enumerable: !0,
    get: function () {
      return zLA.AvroReader;
    },
  });
  var TLA = J4();
  Object.defineProperty(wD, "AvroReadable", {
    enumerable: !0,
    get: function () {
      return TLA.AvroReadable;
    },
  });
  var OLA = Tv();
  Object.defineProperty(wD, "AvroReadableFromStream", {
    enumerable: !0,
    get: function () {
      return OLA.AvroReadableFromStream;
    },
  });
});
var kv = Z((fv) => {
  Object.defineProperty(fv, "__esModule", { value: !0 });
  fv.BlobQuickQueryStream = void 0;
  var jLA = $("node:stream"),
    qv = Ov();
  class jv extends jLA.Readable {
    source;
    avroReader;
    avroIter;
    avroPaused = !0;
    onProgress;
    onError;
    constructor(A, Q = {}) {
      super();
      (this.source = A),
        (this.onProgress = Q.onProgress),
        (this.onError = Q.onError),
        (this.avroReader = new qv.AvroReader(
          new qv.AvroReadableFromStream(this.source),
        )),
        (this.avroIter = this.avroReader.parseObjects({
          abortSignal: Q.abortSignal,
        }));
    }
    _read() {
      if (this.avroPaused)
        this.readInternal().catch((A) => {
          this.emit("error", A);
        });
    }
    async readInternal() {
      this.avroPaused = !1;
      let A;
      do {
        if (((A = await this.avroIter.next()), A.done)) break;
        let Q = A.value,
          B = Q.$schema;
        if (typeof B !== "string")
          throw Error("Missing schema in avro record.");
        switch (B) {
          case "com.microsoft.azure.storage.queryBlobContents.resultData":
            {
              let I = Q.data;
              if (I instanceof Uint8Array === !1)
                throw Error("Invalid data in avro result record.");
              if (!this.push(Buffer.from(I))) this.avroPaused = !0;
            }
            break;
          case "com.microsoft.azure.storage.queryBlobContents.progress":
            {
              let I = Q.bytesScanned;
              if (typeof I !== "number")
                throw Error("Invalid bytesScanned in avro progress record.");
              if (this.onProgress) this.onProgress({ loadedBytes: I });
            }
            break;
          case "com.microsoft.azure.storage.queryBlobContents.end":
            if (this.onProgress) {
              let I = Q.totalBytes;
              if (typeof I !== "number")
                throw Error("Invalid totalBytes in avro end record.");
              this.onProgress({ loadedBytes: I });
            }
            this.push(null);
            break;
          case "com.microsoft.azure.storage.queryBlobContents.error":
            if (this.onError) {
              let I = Q.fatal;
              if (typeof I !== "boolean")
                throw Error("Invalid fatal in avro error record.");
              let E = Q.name;
              if (typeof E !== "string")
                throw Error("Invalid name in avro error record.");
              let C = Q.description;
              if (typeof C !== "string")
                throw Error("Invalid description in avro error record.");
              let g = Q.position;
              if (typeof g !== "number")
                throw Error("Invalid position in avro error record.");
              this.onError({
                position: g,
                name: E,
                isFatal: I,
                description: C,
              });
            }
            break;
          default:
            throw Error(`Unknown schema ${B} in avro progress record.`);
        }
      } while (!A.done && !this.avroPaused);
    }
  }
  fv.BlobQuickQueryStream = jv;
});
var _v = Z((vv) => {
  Object.defineProperty(vv, "__esModule", { value: !0 });
  vv.BlobQueryResponse = void 0;
  var fLA = lA(),
    hLA = kv();
  class xv {
    get acceptRanges() {
      return this.originalResponse.acceptRanges;
    }
    get cacheControl() {
      return this.originalResponse.cacheControl;
    }
    get contentDisposition() {
      return this.originalResponse.contentDisposition;
    }
    get contentEncoding() {
      return this.originalResponse.contentEncoding;
    }
    get contentLanguage() {
      return this.originalResponse.contentLanguage;
    }
    get blobSequenceNumber() {
      return this.originalResponse.blobSequenceNumber;
    }
    get blobType() {
      return this.originalResponse.blobType;
    }
    get contentLength() {
      return this.originalResponse.contentLength;
    }
    get contentMD5() {
      return this.originalResponse.contentMD5;
    }
    get contentRange() {
      return this.originalResponse.contentRange;
    }
    get contentType() {
      return this.originalResponse.contentType;
    }
    get copyCompletedOn() {
      return;
    }
    get copyId() {
      return this.originalResponse.copyId;
    }
    get copyProgress() {
      return this.originalResponse.copyProgress;
    }
    get copySource() {
      return this.originalResponse.copySource;
    }
    get copyStatus() {
      return this.originalResponse.copyStatus;
    }
    get copyStatusDescription() {
      return this.originalResponse.copyStatusDescription;
    }
    get leaseDuration() {
      return this.originalResponse.leaseDuration;
    }
    get leaseState() {
      return this.originalResponse.leaseState;
    }
    get leaseStatus() {
      return this.originalResponse.leaseStatus;
    }
    get date() {
      return this.originalResponse.date;
    }
    get blobCommittedBlockCount() {
      return this.originalResponse.blobCommittedBlockCount;
    }
    get etag() {
      return this.originalResponse.etag;
    }
    get errorCode() {
      return this.originalResponse.errorCode;
    }
    get isServerEncrypted() {
      return this.originalResponse.isServerEncrypted;
    }
    get blobContentMD5() {
      return this.originalResponse.blobContentMD5;
    }
    get lastModified() {
      return this.originalResponse.lastModified;
    }
    get metadata() {
      return this.originalResponse.metadata;
    }
    get requestId() {
      return this.originalResponse.requestId;
    }
    get clientRequestId() {
      return this.originalResponse.clientRequestId;
    }
    get version() {
      return this.originalResponse.version;
    }
    get encryptionKeySha256() {
      return this.originalResponse.encryptionKeySha256;
    }
    get contentCrc64() {
      return this.originalResponse.contentCrc64;
    }
    get blobBody() {
      return;
    }
    get readableStreamBody() {
      return fLA.isNodeLike ? this.blobDownloadStream : void 0;
    }
    get _response() {
      return this.originalResponse._response;
    }
    originalResponse;
    blobDownloadStream;
    constructor(A, Q = {}) {
      (this.originalResponse = A),
        (this.blobDownloadStream = new hLA.BlobQuickQueryStream(
          this.originalResponse.readableStreamBody,
          Q,
        ));
    }
  }
  vv.BlobQueryResponse = xv;
});
var N4 = Z((mv) => {
  Object.defineProperty(mv, "__esModule", { value: !0 });
  mv.StorageBlobAudience = mv.PremiumPageBlobTier = mv.BlockBlobTier = void 0;
  mv.toAccessTier = xLA;
  mv.ensureCpkIfSpecified = vLA;
  mv.getBlobServiceAccountAudience = PLA;
  var kLA = KQ(),
    yv;
  (function (A) {
    (A.Hot = "Hot"),
      (A.Cool = "Cool"),
      (A.Cold = "Cold"),
      (A.Archive = "Archive");
  })(yv || (mv.BlockBlobTier = yv = {}));
  var Sv;
  (function (A) {
    (A.P4 = "P4"),
      (A.P6 = "P6"),
      (A.P10 = "P10"),
      (A.P15 = "P15"),
      (A.P20 = "P20"),
      (A.P30 = "P30"),
      (A.P40 = "P40"),
      (A.P50 = "P50"),
      (A.P60 = "P60"),
      (A.P70 = "P70"),
      (A.P80 = "P80");
  })(Sv || (mv.PremiumPageBlobTier = Sv = {}));
  function xLA(A) {
    if (A === void 0) return;
    return A;
  }
  function vLA(A, Q) {
    if (A && !Q)
      throw RangeError(
        "Customer-provided encryption key must be used over HTTPS.",
      );
    if (A && !A.encryptionAlgorithm)
      A.encryptionAlgorithm = kLA.EncryptionAlgorithmAES25;
  }
  var bv;
  (function (A) {
    (A.StorageOAuthScopes = "https://storage.azure.com/.default"),
      (A.DiskComputeOAuthScopes = "https://disk.compute.azure.com/.default");
  })(bv || (mv.StorageBlobAudience = bv = {}));
  function PLA(A) {
    return `https://${A}.blob.core.windows.net/.default`;
  }
});
var uv = Z((cv) => {
  Object.defineProperty(cv, "__esModule", { value: !0 });
  cv.rangeResponseFromModel = dLA;
  function dLA(A) {
    let Q = (A._response.parsedBody.pageRange || []).map((I) => ({
        offset: I.start,
        count: I.end - I.start,
      })),
      B = (A._response.parsedBody.clearRange || []).map((I) => ({
        offset: I.start,
        count: I.end - I.start,
      }));
    return {
      ...A,
      pageRange: Q,
      clearRange: B,
      _response: {
        ...A._response,
        parsedBody: { pageRange: Q, clearRange: B },
      },
    };
  }
});
var _N = Z((lv) => {
  Object.defineProperty(lv, "__esModule", { value: !0 });
  lv.logger = void 0;
  var uLA = eC();
  lv.logger = (0, uLA.createClientLogger)("core-lro");
});
var yN = Z((iv) => {
  Object.defineProperty(iv, "__esModule", { value: !0 });
  iv.terminalStates = iv.POLL_INTERVAL_IN_MS = void 0;
  iv.POLL_INTERVAL_IN_MS = 2000;
  iv.terminalStates = ["succeeded", "canceled", "failed"];
});
var SN = Z((rv) => {
  Object.defineProperty(rv, "__esModule", { value: !0 });
  rv.pollOperation = rv.initOperation = rv.deserializeState = void 0;
  var G4 = _N(),
    ov = yN();
  function pLA(A) {
    try {
      return JSON.parse(A).state;
    } catch (Q) {
      throw Error(`Unable to deserialize input state: ${A}`);
    }
  }
  rv.deserializeState = pLA;
  function av(A) {
    let { state: Q, stateProxy: B, isOperationError: I } = A;
    return (E) => {
      if (I(E)) B.setError(Q, E), B.setFailed(Q);
      throw E;
    };
  }
  function iLA(A, Q) {
    let B = A;
    if (B.slice(-1) !== ".") B = B + ".";
    return B + " " + Q;
  }
  function nLA(A) {
    let { message: Q, code: B } = A,
      I = A;
    while (I.innererror)
      (I = I.innererror), (B = I.code), (Q = iLA(Q, I.message));
    return { code: B, message: Q };
  }
  function sv(A) {
    let {
      state: Q,
      stateProxy: B,
      status: I,
      isDone: E,
      processResult: C,
      getError: g,
      response: F,
      setErrorAsResult: D,
    } = A;
    switch (I) {
      case "succeeded": {
        B.setSucceeded(Q);
        break;
      }
      case "failed": {
        let J = g === null || g === void 0 ? void 0 : g(F),
          Y = "";
        if (J) {
          let { code: W, message: X } = nLA(J);
          Y = `. ${W}. ${X}`;
        }
        let N = `The long-running operation has failed${Y}`;
        B.setError(Q, Error(N)), B.setFailed(Q), G4.logger.warning(N);
        break;
      }
      case "canceled": {
        B.setCanceled(Q);
        break;
      }
    }
    if (
      (E === null || E === void 0 ? void 0 : E(F, Q)) ||
      (E === void 0 &&
        ["succeeded", "canceled"].concat(D ? [] : ["failed"]).includes(I))
    )
      B.setResult(Q, aLA({ response: F, state: Q, processResult: C }));
  }
  function aLA(A) {
    let { processResult: Q, response: B, state: I } = A;
    return Q ? Q(B, I) : B;
  }
  async function oLA(A) {
    let {
        init: Q,
        stateProxy: B,
        processResult: I,
        getOperationStatus: E,
        withOperationLocation: C,
        setErrorAsResult: g,
      } = A,
      {
        operationLocation: F,
        resourceLocation: D,
        metadata: J,
        response: Y,
      } = await Q();
    if (F) C === null || C === void 0 || C(F, !1);
    let N = { metadata: J, operationLocation: F, resourceLocation: D };
    G4.logger.verbose("LRO: Operation description:", N);
    let W = B.initState(N),
      X = E({ response: Y, state: W, operationLocation: F });
    return (
      sv({
        state: W,
        status: X,
        stateProxy: B,
        response: Y,
        setErrorAsResult: g,
        processResult: I,
      }),
      W
    );
  }
  rv.initOperation = oLA;
  async function sLA(A) {
    let {
        poll: Q,
        state: B,
        stateProxy: I,
        operationLocation: E,
        getOperationStatus: C,
        getResourceLocation: g,
        isOperationError: F,
        options: D,
      } = A,
      J = await Q(E, D).catch(
        av({ state: B, stateProxy: I, isOperationError: F }),
      ),
      Y = C(J, B);
    if (
      (G4.logger.verbose(`LRO: Status:
	Polling from: ${B.config.operationLocation}
	Operation status: ${Y}
	Polling status: ${ov.terminalStates.includes(Y) ? "Stopped" : "Running"}`),
      Y === "succeeded")
    ) {
      let N = g(J, B);
      if (N !== void 0)
        return {
          response: await Q(N).catch(
            av({ state: B, stateProxy: I, isOperationError: F }),
          ),
          status: Y,
        };
    }
    return { response: J, status: Y };
  }
  async function rLA(A) {
    let {
        poll: Q,
        state: B,
        stateProxy: I,
        options: E,
        getOperationStatus: C,
        getResourceLocation: g,
        getOperationLocation: F,
        isOperationError: D,
        withOperationLocation: J,
        getPollingInterval: Y,
        processResult: N,
        getError: W,
        updateState: X,
        setDelay: M,
        isDone: L,
        setErrorAsResult: H,
      } = A,
      { operationLocation: q } = B.config;
    if (q !== void 0) {
      let { response: O, status: f } = await sLA({
        poll: Q,
        getOperationStatus: C,
        state: B,
        stateProxy: I,
        operationLocation: q,
        getResourceLocation: g,
        isOperationError: D,
        options: E,
      });
      if (
        (sv({
          status: f,
          response: O,
          state: B,
          stateProxy: I,
          isDone: L,
          processResult: N,
          getError: W,
          setErrorAsResult: H,
        }),
        !ov.terminalStates.includes(f))
      ) {
        let S = Y === null || Y === void 0 ? void 0 : Y(O);
        if (S) M(S);
        let r = F === null || F === void 0 ? void 0 : F(O, B);
        if (r !== void 0) {
          let t = q !== r;
          (B.config.operationLocation = r),
            J === null || J === void 0 || J(r, t);
        } else J === null || J === void 0 || J(q, !1);
      }
      X === null || X === void 0 || X(B, O);
    }
  }
  rv.pollOperation = rLA;
});
var X4 = Z((UP) => {
  Object.defineProperty(UP, "__esModule", { value: !0 });
  UP.pollHttpOperation =
    UP.isOperationError =
    UP.getResourceLocation =
    UP.getOperationStatus =
    UP.getOperationLocation =
    UP.initHttpOperation =
    UP.getStatusFromInitialResponse =
    UP.getErrorFromResponse =
    UP.parseRetryAfter =
    UP.inferLroMode =
      void 0;
  var ev = SN(),
    U4 = _N();
  function AP(A) {
    let { azureAsyncOperation: Q, operationLocation: B } = A;
    return B !== null && B !== void 0 ? B : Q;
  }
  function QP(A) {
    return A.headers.location;
  }
  function BP(A) {
    return A.headers["operation-location"];
  }
  function IP(A) {
    return A.headers["azure-asyncoperation"];
  }
  function A6A(A) {
    var Q;
    let {
      location: B,
      requestMethod: I,
      requestPath: E,
      resourceLocationConfig: C,
    } = A;
    switch (I) {
      case "PUT":
        return E;
      case "DELETE":
        return;
      case "PATCH":
        return (Q = g()) !== null && Q !== void 0 ? Q : E;
      default:
        return g();
    }
    function g() {
      switch (C) {
        case "azure-async-operation":
          return;
        case "original-uri":
          return E;
        case "location":
        default:
          return B;
      }
    }
  }
  function EP(A) {
    let {
        rawResponse: Q,
        requestMethod: B,
        requestPath: I,
        resourceLocationConfig: E,
      } = A,
      C = BP(Q),
      g = IP(Q),
      F = AP({ operationLocation: C, azureAsyncOperation: g }),
      D = QP(Q),
      J = B === null || B === void 0 ? void 0 : B.toLocaleUpperCase();
    if (F !== void 0)
      return {
        mode: "OperationLocation",
        operationLocation: F,
        resourceLocation: A6A({
          requestMethod: J,
          location: D,
          requestPath: I,
          resourceLocationConfig: E,
        }),
      };
    else if (D !== void 0)
      return { mode: "ResourceLocation", operationLocation: D };
    else if (J === "PUT" && I) return { mode: "Body", operationLocation: I };
    else return;
  }
  UP.inferLroMode = EP;
  function CP(A) {
    let { status: Q, statusCode: B } = A;
    if (typeof Q !== "string" && Q !== void 0)
      throw Error(
        `Polling was unsuccessful. Expected status to have a string value or no value but it has instead: ${Q}. This doesn't necessarily indicate the operation has failed. Check your Azure subscription or resource status for more information.`,
      );
    switch (Q === null || Q === void 0 ? void 0 : Q.toLocaleLowerCase()) {
      case void 0:
        return W4(B);
      case "succeeded":
        return "succeeded";
      case "failed":
        return "failed";
      case "running":
      case "accepted":
      case "started":
      case "canceling":
      case "cancelling":
        return "running";
      case "canceled":
      case "cancelled":
        return "canceled";
      default:
        return U4.logger.verbose(`LRO: unrecognized operation status: ${Q}`), Q;
    }
  }
  function Q6A(A) {
    var Q;
    let { status: B } = (Q = A.body) !== null && Q !== void 0 ? Q : {};
    return CP({ status: B, statusCode: A.statusCode });
  }
  function B6A(A) {
    var Q, B;
    let { properties: I, provisioningState: E } =
        (Q = A.body) !== null && Q !== void 0 ? Q : {},
      C =
        (B = I === null || I === void 0 ? void 0 : I.provisioningState) !==
          null && B !== void 0
          ? B
          : E;
    return CP({ status: C, statusCode: A.statusCode });
  }
  function W4(A) {
    if (A === 202) return "running";
    else if (A < 300) return "succeeded";
    else return "failed";
  }
  function gP({ rawResponse: A }) {
    let Q = A.headers["retry-after"];
    if (Q !== void 0) {
      let B = parseInt(Q);
      return isNaN(B) ? I6A(new Date(Q)) : B * 1000;
    }
    return;
  }
  UP.parseRetryAfter = gP;
  function FP(A) {
    let Q = JP(A, "error");
    if (!Q) {
      U4.logger.warning(
        "The long-running operation failed but there is no error property in the response's body",
      );
      return;
    }
    if (!Q.code || !Q.message) {
      U4.logger.warning(
        "The long-running operation failed but the error property in the response's body doesn't contain code or message",
      );
      return;
    }
    return Q;
  }
  UP.getErrorFromResponse = FP;
  function I6A(A) {
    let Q = Math.floor(new Date().getTime()),
      B = A.getTime();
    if (Q < B) return B - Q;
    return;
  }
  function DP(A) {
    let { response: Q, state: B, operationLocation: I } = A;
    function E() {
      var g;
      switch (
        (g = B.config.metadata) === null || g === void 0 ? void 0 : g.mode
      ) {
        case void 0:
          return W4(Q.rawResponse.statusCode);
        case "Body":
          return Z4(Q, B);
        default:
          return "running";
      }
    }
    let C = E();
    return C === "running" && I === void 0 ? "succeeded" : C;
  }
  UP.getStatusFromInitialResponse = DP;
  async function E6A(A) {
    let {
      stateProxy: Q,
      resourceLocationConfig: B,
      processResult: I,
      lro: E,
      setErrorAsResult: C,
    } = A;
    return (0, ev.initOperation)({
      init: async () => {
        let g = await E.sendInitialRequest(),
          F = EP({
            rawResponse: g.rawResponse,
            requestPath: E.requestPath,
            requestMethod: E.requestMethod,
            resourceLocationConfig: B,
          });
        return Object.assign(
          {
            response: g,
            operationLocation:
              F === null || F === void 0 ? void 0 : F.operationLocation,
            resourceLocation:
              F === null || F === void 0 ? void 0 : F.resourceLocation,
          },
          (F === null || F === void 0 ? void 0 : F.mode)
            ? { metadata: { mode: F.mode } }
            : {},
        );
      },
      stateProxy: Q,
      processResult: I
        ? ({ flatResponse: g }, F) => I(g, F)
        : ({ flatResponse: g }) => g,
      getOperationStatus: DP,
      setErrorAsResult: C,
    });
  }
  UP.initHttpOperation = E6A;
  function YP({ rawResponse: A }, Q) {
    var B;
    switch (
      (B = Q.config.metadata) === null || B === void 0 ? void 0 : B.mode
    ) {
      case "OperationLocation":
        return AP({ operationLocation: BP(A), azureAsyncOperation: IP(A) });
      case "ResourceLocation":
        return QP(A);
      case "Body":
      default:
        return;
    }
  }
  UP.getOperationLocation = YP;
  function Z4({ rawResponse: A }, Q) {
    var B;
    let I = (B = Q.config.metadata) === null || B === void 0 ? void 0 : B.mode;
    switch (I) {
      case "OperationLocation":
        return Q6A(A);
      case "ResourceLocation":
        return W4(A.statusCode);
      case "Body":
        return B6A(A);
      default:
        throw Error(`Internal error: Unexpected operation mode: ${I}`);
    }
  }
  UP.getOperationStatus = Z4;
  function JP({ flatResponse: A, rawResponse: Q }, B) {
    var I, E;
    return (I = A === null || A === void 0 ? void 0 : A[B]) !== null &&
      I !== void 0
      ? I
      : (E = Q.body) === null || E === void 0
        ? void 0
        : E[B];
  }
  function NP(A, Q) {
    let B = JP(A, "resourceLocation");
    if (B && typeof B === "string") Q.config.resourceLocation = B;
    return Q.config.resourceLocation;
  }
  UP.getResourceLocation = NP;
  function GP(A) {
    return A.name === "RestError";
  }
  UP.isOperationError = GP;
  async function C6A(A) {
    let {
      lro: Q,
      stateProxy: B,
      options: I,
      processResult: E,
      updateState: C,
      setDelay: g,
      state: F,
      setErrorAsResult: D,
    } = A;
    return (0, ev.pollOperation)({
      state: F,
      stateProxy: B,
      setDelay: g,
      processResult: E
        ? ({ flatResponse: J }, Y) => E(J, Y)
        : ({ flatResponse: J }) => J,
      getError: FP,
      updateState: C,
      getPollingInterval: gP,
      getOperationLocation: YP,
      getOperationStatus: Z4,
      isOperationError: GP,
      getResourceLocation: NP,
      options: I,
      poll: async (J, Y) => Q.sendPollRequest(J, Y),
      setErrorAsResult: D,
    });
  }
  UP.pollHttpOperation = C6A;
});
var wP = Z((ZP) => {
  Object.defineProperty(ZP, "__esModule", { value: !0 });
  ZP.buildCreatePoller = void 0;
  var w4 = SN(),
    Z6A = yN(),
    X6A = lA(),
    w6A = () => ({
      initState: (A) => ({ status: "running", config: A }),
      setCanceled: (A) => (A.status = "canceled"),
      setError: (A, Q) => (A.error = Q),
      setResult: (A, Q) => (A.result = Q),
      setRunning: (A) => (A.status = "running"),
      setSucceeded: (A) => (A.status = "succeeded"),
      setFailed: (A) => (A.status = "failed"),
      getError: (A) => A.error,
      getResult: (A) => A.result,
      isCanceled: (A) => A.status === "canceled",
      isFailed: (A) => A.status === "failed",
      isRunning: (A) => A.status === "running",
      isSucceeded: (A) => A.status === "succeeded",
    });
  function M6A(A) {
    let {
      getOperationLocation: Q,
      getStatusFromInitialResponse: B,
      getStatusFromPollResponse: I,
      isOperationError: E,
      getResourceLocation: C,
      getPollingInterval: g,
      getError: F,
      resolveOnUnsuccessful: D,
    } = A;
    return async ({ init: J, poll: Y }, N) => {
      let {
          processResult: W,
          updateState: X,
          withOperationLocation: M,
          intervalInMs: L = Z6A.POLL_INTERVAL_IN_MS,
          restoreFrom: H,
        } = N || {},
        q = w6A(),
        O = M
          ? (() => {
              let LA = !1;
              return (EA, RA) => {
                if (RA) M(EA);
                else if (!LA) M(EA);
                LA = !0;
              };
            })()
          : void 0,
        f = H
          ? (0, w4.deserializeState)(H)
          : await (0, w4.initOperation)({
              init: J,
              stateProxy: q,
              processResult: W,
              getOperationStatus: B,
              withOperationLocation: O,
              setErrorAsResult: !D,
            }),
        S,
        r = new AbortController(),
        t = new Map(),
        IA = async () => t.forEach((LA) => LA(f)),
        zA = "Operation was canceled",
        DA = L,
        MA = {
          getOperationState: () => f,
          getResult: () => f.result,
          isDone: () => ["succeeded", "failed", "canceled"].includes(f.status),
          isStopped: () => S === void 0,
          stopPolling: () => {
            r.abort();
          },
          toString: () => JSON.stringify({ state: f }),
          onProgress: (LA) => {
            let EA = Symbol();
            return t.set(EA, LA), () => t.delete(EA);
          },
          pollUntilDone: (LA) =>
            S !== null && S !== void 0
              ? S
              : (S = (async () => {
                  let { abortSignal: EA } = LA || {};
                  function RA() {
                    r.abort();
                  }
                  let CQ = r.signal;
                  if (EA === null || EA === void 0 ? void 0 : EA.aborted)
                    r.abort();
                  else if (!CQ.aborted)
                    EA === null ||
                      EA === void 0 ||
                      EA.addEventListener("abort", RA, { once: !0 });
                  try {
                    if (!MA.isDone()) {
                      await MA.poll({ abortSignal: CQ });
                      while (!MA.isDone())
                        await (0, X6A.delay)(DA, { abortSignal: CQ }),
                          await MA.poll({ abortSignal: CQ });
                    }
                  } finally {
                    EA === null ||
                      EA === void 0 ||
                      EA.removeEventListener("abort", RA);
                  }
                  if (D) return MA.getResult();
                  else
                    switch (f.status) {
                      case "succeeded":
                        return MA.getResult();
                      case "canceled":
                        throw Error("Operation was canceled");
                      case "failed":
                        throw f.error;
                      case "notStarted":
                      case "running":
                        throw Error(
                          "Polling completed without succeeding or failing",
                        );
                    }
                })().finally(() => {
                  S = void 0;
                })),
          async poll(LA) {
            if (D) {
              if (MA.isDone()) return;
            } else
              switch (f.status) {
                case "succeeded":
                  return;
                case "canceled":
                  throw Error("Operation was canceled");
                case "failed":
                  throw f.error;
              }
            if (
              (await (0, w4.pollOperation)({
                poll: Y,
                state: f,
                stateProxy: q,
                getOperationLocation: Q,
                isOperationError: E,
                withOperationLocation: O,
                getPollingInterval: g,
                getOperationStatus: I,
                getResourceLocation: C,
                processResult: W,
                getError: F,
                updateState: X,
                options: LA,
                setDelay: (EA) => {
                  DA = EA;
                },
                setErrorAsResult: !D,
              }),
              await IA(),
              !D)
            )
              switch (f.status) {
                case "canceled":
                  throw Error("Operation was canceled");
                case "failed":
                  throw f.error;
              }
          },
        };
      return MA;
    };
  }
  ZP.buildCreatePoller = M6A;
});
var RP = Z((MP) => {
  Object.defineProperty(MP, "__esModule", { value: !0 });
  MP.createHttpPoller = void 0;
  var wC = X4(),
    L6A = wP();
  async function R6A(A, Q) {
    let {
      resourceLocationConfig: B,
      intervalInMs: I,
      processResult: E,
      restoreFrom: C,
      updateState: g,
      withOperationLocation: F,
      resolveOnUnsuccessful: D = !1,
    } = Q || {};
    return (0, L6A.buildCreatePoller)({
      getStatusFromInitialResponse: wC.getStatusFromInitialResponse,
      getStatusFromPollResponse: wC.getOperationStatus,
      isOperationError: wC.isOperationError,
      getOperationLocation: wC.getOperationLocation,
      getResourceLocation: wC.getResourceLocation,
      getPollingInterval: wC.parseRetryAfter,
      getError: wC.getErrorFromResponse,
      resolveOnUnsuccessful: D,
    })(
      {
        init: async () => {
          let J = await A.sendInitialRequest(),
            Y = (0, wC.inferLroMode)({
              rawResponse: J.rawResponse,
              requestPath: A.requestPath,
              requestMethod: A.requestMethod,
              resourceLocationConfig: B,
            });
          return Object.assign(
            {
              response: J,
              operationLocation:
                Y === null || Y === void 0 ? void 0 : Y.operationLocation,
              resourceLocation:
                Y === null || Y === void 0 ? void 0 : Y.resourceLocation,
            },
            (Y === null || Y === void 0 ? void 0 : Y.mode)
              ? { metadata: { mode: Y.mode } }
              : {},
          );
        },
        poll: A.sendPollRequest,
      },
      {
        intervalInMs: I,
        withOperationLocation: F,
        restoreFrom: C,
        updateState: g,
        processResult: E
          ? ({ flatResponse: J }, Y) => E(J, Y)
          : ({ flatResponse: J }) => J,
      },
    );
  }
  MP.createHttpPoller = R6A;
});
var zP = Z((HP) => {
  Object.defineProperty(HP, "__esModule", { value: !0 });
  HP.GenericPollOperation = void 0;
  var VP = X4(),
    V6A = _N(),
    $6A = () => ({
      initState: (A) => ({ config: A, isStarted: !0 }),
      setCanceled: (A) => (A.isCancelled = !0),
      setError: (A, Q) => (A.error = Q),
      setResult: (A, Q) => (A.result = Q),
      setRunning: (A) => (A.isStarted = !0),
      setSucceeded: (A) => (A.isCompleted = !0),
      setFailed: () => {},
      getError: (A) => A.error,
      getResult: (A) => A.result,
      isCanceled: (A) => !!A.isCancelled,
      isFailed: (A) => !!A.error,
      isRunning: (A) => !!A.isStarted,
      isSucceeded: (A) => Boolean(A.isCompleted && !A.isCancelled && !A.error),
    });
  class $P {
    constructor(A, Q, B, I, E, C, g) {
      (this.state = A),
        (this.lro = Q),
        (this.setErrorAsResult = B),
        (this.lroResourceLocationConfig = I),
        (this.processResult = E),
        (this.updateState = C),
        (this.isDone = g);
    }
    setPollerConfig(A) {
      this.pollerConfig = A;
    }
    async update(A) {
      var Q;
      let B = $6A();
      if (!this.state.isStarted)
        this.state = Object.assign(
          Object.assign({}, this.state),
          await (0, VP.initHttpOperation)({
            lro: this.lro,
            stateProxy: B,
            resourceLocationConfig: this.lroResourceLocationConfig,
            processResult: this.processResult,
            setErrorAsResult: this.setErrorAsResult,
          }),
        );
      let I = this.updateState,
        E = this.isDone;
      if (!this.state.isCompleted && this.state.error === void 0)
        await (0, VP.pollHttpOperation)({
          lro: this.lro,
          state: this.state,
          stateProxy: B,
          processResult: this.processResult,
          updateState: I ? (C, { rawResponse: g }) => I(C, g) : void 0,
          isDone: E ? ({ flatResponse: C }, g) => E(C, g) : void 0,
          options: A,
          setDelay: (C) => {
            this.pollerConfig.intervalInMs = C;
          },
          setErrorAsResult: this.setErrorAsResult,
        });
      return (
        (Q = A === null || A === void 0 ? void 0 : A.fireProgress) === null ||
          Q === void 0 ||
          Q.call(A, this.state),
        this
      );
    }
    async cancel() {
      return (
        V6A.logger.error(
          "`cancelOperation` is deprecated because it wasn't implemented",
        ),
        this
      );
    }
    toString() {
      return JSON.stringify({ state: this.state });
    }
  }
  HP.GenericPollOperation = $P;
});
var M4 = Z((OP) => {
  Object.defineProperty(OP, "__esModule", { value: !0 });
  OP.Poller = OP.PollerCancelledError = OP.PollerStoppedError = void 0;
  class bN extends Error {
    constructor(A) {
      super(A);
      (this.name = "PollerStoppedError"),
        Object.setPrototypeOf(this, bN.prototype);
    }
  }
  OP.PollerStoppedError = bN;
  class mN extends Error {
    constructor(A) {
      super(A);
      (this.name = "PollerCancelledError"),
        Object.setPrototypeOf(this, mN.prototype);
    }
  }
  OP.PollerCancelledError = mN;
  class TP {
    constructor(A) {
      (this.resolveOnUnsuccessful = !1),
        (this.stopped = !0),
        (this.pollProgressCallbacks = []),
        (this.operation = A),
        (this.promise = new Promise((Q, B) => {
          (this.resolve = Q), (this.reject = B);
        })),
        this.promise.catch(() => {});
    }
    async startPolling(A = {}) {
      if (this.stopped) this.stopped = !1;
      while (!this.isStopped() && !this.isDone())
        await this.poll(A), await this.delay();
    }
    async pollOnce(A = {}) {
      if (!this.isDone())
        this.operation = await this.operation.update({
          abortSignal: A.abortSignal,
          fireProgress: this.fireProgress.bind(this),
        });
      this.processUpdatedState();
    }
    fireProgress(A) {
      for (let Q of this.pollProgressCallbacks) Q(A);
    }
    async cancelOnce(A = {}) {
      this.operation = await this.operation.cancel(A);
    }
    poll(A = {}) {
      if (!this.pollOncePromise) {
        this.pollOncePromise = this.pollOnce(A);
        let Q = () => {
          this.pollOncePromise = void 0;
        };
        this.pollOncePromise.then(Q, Q).catch(this.reject);
      }
      return this.pollOncePromise;
    }
    processUpdatedState() {
      if (this.operation.state.error) {
        if (((this.stopped = !0), !this.resolveOnUnsuccessful))
          throw (
            (this.reject(this.operation.state.error),
            this.operation.state.error)
          );
      }
      if (this.operation.state.isCancelled) {
        if (((this.stopped = !0), !this.resolveOnUnsuccessful)) {
          let A = new mN("Operation was canceled");
          throw (this.reject(A), A);
        }
      }
      if (this.isDone() && this.resolve) this.resolve(this.getResult());
    }
    async pollUntilDone(A = {}) {
      if (this.stopped) this.startPolling(A).catch(this.reject);
      return this.processUpdatedState(), this.promise;
    }
    onProgress(A) {
      return (
        this.pollProgressCallbacks.push(A),
        () => {
          this.pollProgressCallbacks = this.pollProgressCallbacks.filter(
            (Q) => Q !== A,
          );
        }
      );
    }
    isDone() {
      let A = this.operation.state;
      return Boolean(A.isCompleted || A.isCancelled || A.error);
    }
    stopPolling() {
      if (!this.stopped) {
        if (((this.stopped = !0), this.reject))
          this.reject(new bN("This poller is already stopped"));
      }
    }
    isStopped() {
      return this.stopped;
    }
    cancelOperation(A = {}) {
      if (!this.cancelPromise) this.cancelPromise = this.cancelOnce(A);
      else if (A.abortSignal)
        throw Error("A cancel request is currently pending");
      return this.cancelPromise;
    }
    getOperationState() {
      return this.operation.state;
    }
    getResult() {
      return this.operation.state.result;
    }
    toString() {
      return this.operation.toString();
    }
  }
  OP.Poller = TP;
});
var kP = Z((fP) => {
  Object.defineProperty(fP, "__esModule", { value: !0 });
  fP.LroEngine = void 0;
  var z6A = zP(),
    T6A = yN(),
    O6A = M4(),
    q6A = SN();
  class jP extends O6A.Poller {
    constructor(A, Q) {
      let {
          intervalInMs: B = T6A.POLL_INTERVAL_IN_MS,
          resumeFrom: I,
          resolveOnUnsuccessful: E = !1,
          isDone: C,
          lroResourceLocationConfig: g,
          processResult: F,
          updateState: D,
        } = Q || {},
        J = I ? (0, q6A.deserializeState)(I) : {},
        Y = new z6A.GenericPollOperation(J, A, !E, g, F, D, C);
      super(Y);
      (this.resolveOnUnsuccessful = E),
        (this.config = { intervalInMs: B }),
        Y.setPollerConfig(this.config);
    }
    delay() {
      return new Promise((A) =>
        setTimeout(() => A(), this.config.intervalInMs),
      );
    }
  }
  fP.LroEngine = jP;
});
var xP = Z((L4) => {
  Object.defineProperty(L4, "__esModule", { value: !0 });
  L4.LroEngine = void 0;
  var j6A = kP();
  Object.defineProperty(L4, "LroEngine", {
    enumerable: !0,
    get: function () {
      return j6A.LroEngine;
    },
  });
});
var PP = Z((vP) => {
  Object.defineProperty(vP, "__esModule", { value: !0 });
});
var _P = Z((kg) => {
  Object.defineProperty(kg, "__esModule", { value: !0 });
  kg.createHttpPoller = void 0;
  var R4 = BQ(),
    h6A = RP();
  Object.defineProperty(kg, "createHttpPoller", {
    enumerable: !0,
    get: function () {
      return h6A.createHttpPoller;
    },
  });
  R4.__exportStar(xP(), kg);
  R4.__exportStar(M4(), kg);
  R4.__exportStar(PP(), kg);
});
var mP = Z((SP) => {
  Object.defineProperty(SP, "__esModule", { value: !0 });
  SP.BlobBeginCopyFromUrlPoller = void 0;
  var x6A = lA(),
    v6A = _P();
  class yP extends v6A.Poller {
    intervalInMs;
    constructor(A) {
      let {
          blobClient: Q,
          copySource: B,
          intervalInMs: I = 15000,
          onProgress: E,
          resumeFrom: C,
          startCopyFromURLOptions: g,
        } = A,
        F;
      if (C) F = JSON.parse(C).state;
      let D = MD({
        ...F,
        blobClient: Q,
        copySource: B,
        startCopyFromURLOptions: g,
      });
      super(D);
      if (typeof E === "function") this.onProgress(E);
      this.intervalInMs = I;
    }
    delay() {
      return (0, x6A.delay)(this.intervalInMs);
    }
  }
  SP.BlobBeginCopyFromUrlPoller = yP;
  var P6A = async function (Q = {}) {
      let B = this.state,
        { copyId: I } = B;
      if (B.isCompleted) return MD(B);
      if (!I) return (B.isCancelled = !0), MD(B);
      return (
        await B.blobClient.abortCopyFromURL(I, { abortSignal: Q.abortSignal }),
        (B.isCancelled = !0),
        MD(B)
      );
    },
    _6A = async function (Q = {}) {
      let B = this.state,
        { blobClient: I, copySource: E, startCopyFromURLOptions: C } = B;
      if (!B.isStarted) {
        B.isStarted = !0;
        let g = await I.startCopyFromURL(E, C);
        if (((B.copyId = g.copyId), g.copyStatus === "success"))
          (B.result = g), (B.isCompleted = !0);
      } else if (!B.isCompleted)
        try {
          let g = await B.blobClient.getProperties({
              abortSignal: Q.abortSignal,
            }),
            { copyStatus: F, copyProgress: D } = g,
            J = B.copyProgress;
          if (D) B.copyProgress = D;
          if (
            F === "pending" &&
            D !== J &&
            typeof Q.fireProgress === "function"
          )
            Q.fireProgress(B);
          else if (F === "success") (B.result = g), (B.isCompleted = !0);
          else if (F === "failed")
            (B.error = Error(
              `Blob copy failed with reason: "${g.copyStatusDescription || "unknown"}"`,
            )),
              (B.isCompleted = !0);
        } catch (g) {
          (B.error = g), (B.isCompleted = !0);
        }
      return MD(B);
    },
    y6A = function () {
      return JSON.stringify({ state: this.state }, (Q, B) => {
        if (Q === "blobClient") return;
        return B;
      });
    };
  function MD(A) {
    return { state: { ...A }, cancel: P6A, toString: y6A, update: _6A };
  }
});
var cP = Z((dP) => {
  Object.defineProperty(dP, "__esModule", { value: !0 });
  dP.rangeToString = S6A;
  function S6A(A) {
    if (A.offset < 0)
      throw RangeError("Range.offset cannot be smaller than 0.");
    if (A.count && A.count <= 0)
      throw RangeError(
        "Range.count must be larger than 0. Leave it undefined if you want a range from offset to the end.",
      );
    return A.count
      ? `bytes=${A.offset}-${A.offset + A.count - 1}`
      : `bytes=${A.offset}-`;
  }
});
var iP = Z((lP) => {
  Object.defineProperty(lP, "__esModule", { value: !0 });
  lP.Batch = void 0;
  var m6A = $("events"),
    LD;
  (function (A) {
    (A[(A.Good = 0)] = "Good"), (A[(A.Error = 1)] = "Error");
  })(LD || (LD = {}));
  class uP {
    concurrency;
    actives = 0;
    completed = 0;
    offset = 0;
    operations = [];
    state = LD.Good;
    emitter;
    constructor(A = 5) {
      if (A < 1) throw RangeError("concurrency must be larger than 0");
      (this.concurrency = A), (this.emitter = new m6A.EventEmitter());
    }
    addOperation(A) {
      this.operations.push(async () => {
        try {
          this.actives++,
            await A(),
            this.actives--,
            this.completed++,
            this.parallelExecute();
        } catch (Q) {
          this.emitter.emit("error", Q);
        }
      });
    }
    async do() {
      if (this.operations.length === 0) return Promise.resolve();
      return (
        this.parallelExecute(),
        new Promise((A, Q) => {
          this.emitter.on("finish", A),
            this.emitter.on("error", (B) => {
              (this.state = LD.Error), Q(B);
            });
        })
      );
    }
    nextOperation() {
      if (this.offset < this.operations.length)
        return this.operations[this.offset++];
      return null;
    }
    parallelExecute() {
      if (this.state === LD.Error) return;
      if (this.completed >= this.operations.length) {
        this.emitter.emit("finish");
        return;
      }
      while (this.actives < this.concurrency) {
        let A = this.nextOperation();
        if (A) A();
        else return;
      }
    }
  }
  lP.Batch = uP;
});
var $4 = Z((aP) => {
  Object.defineProperty(aP, "__esModule", { value: !0 });
  aP.fsCreateReadStream = aP.fsStat = void 0;
  aP.streamToBuffer = u6A;
  aP.streamToBuffer2 = l6A;
  aP.streamToBuffer3 = p6A;
  aP.readStreamToLocalFile = i6A;
  var nP = BQ(),
    V4 = nP.__importDefault($("node:fs")),
    d6A = nP.__importDefault($("node:util")),
    c6A = KQ();
  async function u6A(A, Q, B, I, E) {
    let C = 0,
      g = I - B;
    return new Promise((F, D) => {
      let J = setTimeout(
        () => D(Error("The operation cannot be completed in timeout.")),
        c6A.REQUEST_TIMEOUT,
      );
      A.on("readable", () => {
        if (C >= g) {
          clearTimeout(J), F();
          return;
        }
        let Y = A.read();
        if (!Y) return;
        if (typeof Y === "string") Y = Buffer.from(Y, E);
        let N = C + Y.length > g ? g - C : Y.length;
        Q.fill(Y.slice(0, N), B + C, B + C + N), (C += N);
      }),
        A.on("end", () => {
          if ((clearTimeout(J), C < g))
            D(
              Error(
                `Stream drains before getting enough data needed. Data read: ${C}, data need: ${g}`,
              ),
            );
          F();
        }),
        A.on("error", (Y) => {
          clearTimeout(J), D(Y);
        });
    });
  }
  async function l6A(A, Q, B) {
    let I = 0,
      E = Q.length;
    return new Promise((C, g) => {
      A.on("readable", () => {
        let F = A.read();
        if (!F) return;
        if (typeof F === "string") F = Buffer.from(F, B);
        if (I + F.length > E) {
          g(Error(`Stream exceeds buffer size. Buffer size: ${E}`));
          return;
        }
        Q.fill(F, I, I + F.length), (I += F.length);
      }),
        A.on("end", () => {
          C(I);
        }),
        A.on("error", g);
    });
  }
  async function p6A(A, Q) {
    return new Promise((B, I) => {
      let E = [];
      A.on("data", (C) => {
        E.push(typeof C === "string" ? Buffer.from(C, Q) : C);
      }),
        A.on("end", () => {
          B(Buffer.concat(E));
        }),
        A.on("error", I);
    });
  }
  async function i6A(A, Q) {
    return new Promise((B, I) => {
      let E = V4.default.createWriteStream(Q);
      A.on("error", (C) => {
        I(C);
      }),
        E.on("error", (C) => {
          I(C);
        }),
        E.on("close", B),
        A.pipe(E);
    });
  }
  aP.fsStat = d6A.default.promisify(V4.default.stat);
  aP.fsCreateReadStream = V4.default.createReadStream;
});
var aN = Z((tP) => {
  Object.defineProperty(tP, "__esModule", { value: !0 });
  tP.PageBlobClient =
    tP.BlockBlobClient =
    tP.AppendBlobClient =
    tP.BlobClient =
      void 0;
  var uN = HQ(),
    lN = Rg(),
    WI = lA(),
    sP = lA(),
    t6A = Av(),
    e6A = _v(),
    ZI = DC(),
    tI = FC(),
    tA = N4(),
    H4 = uv(),
    TQ = GC(),
    A7A = mP(),
    nB = cP(),
    Q7A = ON(),
    rP = iP(),
    B7A = bX(),
    nA = KQ(),
    BA = I0(),
    y = yQ(),
    cN = $4(),
    dN = xN(),
    I7A = PN();
  class N0 extends Q7A.StorageClient {
    blobContext;
    _name;
    _containerName;
    _versionId;
    _snapshot;
    get name() {
      return this._name;
    }
    get containerName() {
      return this._containerName;
    }
    constructor(A, Q, B, I) {
      I = I || {};
      let E, C;
      if ((0, TQ.isPipelineLike)(Q)) (C = A), (E = Q);
      else if (
        (WI.isNodeLike && Q instanceof tI.StorageSharedKeyCredential) ||
        Q instanceof ZI.AnonymousCredential ||
        (0, lN.isTokenCredential)(Q)
      )
        (C = A), (I = B), (E = (0, TQ.newPipeline)(Q, I));
      else if (!Q && typeof Q !== "string") {
        if (((C = A), B && typeof B !== "string")) I = B;
        E = (0, TQ.newPipeline)(new ZI.AnonymousCredential(), I);
      } else if (Q && typeof Q === "string" && B && typeof B === "string") {
        let g = Q,
          F = B,
          D = (0, y.extractConnectionStringParts)(A);
        if (D.kind === "AccountConnString")
          if (WI.isNodeLike) {
            let J = new tI.StorageSharedKeyCredential(
              D.accountName,
              D.accountKey,
            );
            if (
              ((C = (0, y.appendToURLPath)(
                (0, y.appendToURLPath)(D.url, encodeURIComponent(g)),
                encodeURIComponent(F),
              )),
              !I.proxyOptions)
            )
              I.proxyOptions = (0, uN.getDefaultProxySettings)(D.proxyUri);
            E = (0, TQ.newPipeline)(J, I);
          } else
            throw Error(
              "Account connection string is only supported in Node.js environment",
            );
        else if (D.kind === "SASConnString")
          (C =
            (0, y.appendToURLPath)(
              (0, y.appendToURLPath)(D.url, encodeURIComponent(g)),
              encodeURIComponent(F),
            ) +
            "?" +
            D.accountSas),
            (E = (0, TQ.newPipeline)(new ZI.AnonymousCredential(), I));
        else
          throw Error(
            "Connection string must be either an Account connection string or a SAS connection string",
          );
      } else
        throw Error(
          "Expecting non-empty strings for containerName and blobName parameters",
        );
      super(C, E);
      ({ blobName: this._name, containerName: this._containerName } =
        this.getBlobAndContainerNamesFromUrl()),
        (this.blobContext = this.storageClientContext.blob),
        (this._snapshot = (0, y.getURLParameter)(
          this.url,
          nA.URLConstants.Parameters.SNAPSHOT,
        )),
        (this._versionId = (0, y.getURLParameter)(
          this.url,
          nA.URLConstants.Parameters.VERSIONID,
        ));
    }
    withSnapshot(A) {
      return new N0(
        (0, y.setURLParameter)(
          this.url,
          nA.URLConstants.Parameters.SNAPSHOT,
          A.length === 0 ? void 0 : A,
        ),
        this.pipeline,
      );
    }
    withVersion(A) {
      return new N0(
        (0, y.setURLParameter)(
          this.url,
          nA.URLConstants.Parameters.VERSIONID,
          A.length === 0 ? void 0 : A,
        ),
        this.pipeline,
      );
    }
    getAppendBlobClient() {
      return new pN(this.url, this.pipeline);
    }
    getBlockBlobClient() {
      return new iN(this.url, this.pipeline);
    }
    getPageBlobClient() {
      return new nN(this.url, this.pipeline);
    }
    async download(A = 0, Q, B = {}) {
      return (
        (B.conditions = B.conditions || {}),
        (B.conditions = B.conditions || {}),
        (0, tA.ensureCpkIfSpecified)(B.customerProvidedKey, this.isHttps),
        BA.tracingClient.withSpan("BlobClient-download", B, async (I) => {
          let E = (0, y.assertResponse)(
              await this.blobContext.download({
                abortSignal: B.abortSignal,
                leaseAccessConditions: B.conditions,
                modifiedAccessConditions: {
                  ...B.conditions,
                  ifTags: B.conditions?.tagConditions,
                },
                requestOptions: {
                  onDownloadProgress: WI.isNodeLike ? void 0 : B.onProgress,
                },
                range:
                  A === 0 && !Q
                    ? void 0
                    : (0, nB.rangeToString)({ offset: A, count: Q }),
                rangeGetContentMD5: B.rangeGetContentMD5,
                rangeGetContentCRC64: B.rangeGetContentCrc64,
                snapshot: B.snapshot,
                cpkInfo: B.customerProvidedKey,
                tracingOptions: I.tracingOptions,
              }),
            ),
            C = {
              ...E,
              _response: E._response,
              objectReplicationDestinationPolicyId: E.objectReplicationPolicyId,
              objectReplicationSourceProperties: (0,
              y.parseObjectReplicationRecord)(E.objectReplicationRules),
            };
          if (!WI.isNodeLike) return C;
          if (B.maxRetryRequests === void 0 || B.maxRetryRequests < 0)
            B.maxRetryRequests = nA.DEFAULT_MAX_DOWNLOAD_RETRY_REQUESTS;
          if (E.contentLength === void 0)
            throw RangeError(
              "File download response doesn't contain valid content length header",
            );
          if (!E.etag)
            throw RangeError(
              "File download response doesn't contain valid etag header",
            );
          return new t6A.BlobDownloadResponse(
            C,
            async (g) => {
              let F = {
                leaseAccessConditions: B.conditions,
                modifiedAccessConditions: {
                  ifMatch: B.conditions.ifMatch || E.etag,
                  ifModifiedSince: B.conditions.ifModifiedSince,
                  ifNoneMatch: B.conditions.ifNoneMatch,
                  ifUnmodifiedSince: B.conditions.ifUnmodifiedSince,
                  ifTags: B.conditions?.tagConditions,
                },
                range: (0, nB.rangeToString)({
                  count: A + E.contentLength - g,
                  offset: g,
                }),
                rangeGetContentMD5: B.rangeGetContentMD5,
                rangeGetContentCRC64: B.rangeGetContentCrc64,
                snapshot: B.snapshot,
                cpkInfo: B.customerProvidedKey,
              };
              return (
                await this.blobContext.download({
                  abortSignal: B.abortSignal,
                  ...F,
                })
              ).readableStreamBody;
            },
            A,
            E.contentLength,
            { maxRetryRequests: B.maxRetryRequests, onProgress: B.onProgress },
          );
        })
      );
    }
    async exists(A = {}) {
      return BA.tracingClient.withSpan("BlobClient-exists", A, async (Q) => {
        try {
          return (
            (0, tA.ensureCpkIfSpecified)(A.customerProvidedKey, this.isHttps),
            await this.getProperties({
              abortSignal: A.abortSignal,
              customerProvidedKey: A.customerProvidedKey,
              conditions: A.conditions,
              tracingOptions: Q.tracingOptions,
            }),
            !0
          );
        } catch (B) {
          if (B.statusCode === 404) return !1;
          else if (
            B.statusCode === 409 &&
            (B.details.errorCode ===
              nA.BlobUsesCustomerSpecifiedEncryptionMsg ||
              B.details.errorCode ===
                nA.BlobDoesNotUseCustomerSpecifiedEncryption)
          )
            return !0;
          throw B;
        }
      });
    }
    async getProperties(A = {}) {
      return (
        (A.conditions = A.conditions || {}),
        (0, tA.ensureCpkIfSpecified)(A.customerProvidedKey, this.isHttps),
        BA.tracingClient.withSpan("BlobClient-getProperties", A, async (Q) => {
          let B = (0, y.assertResponse)(
            await this.blobContext.getProperties({
              abortSignal: A.abortSignal,
              leaseAccessConditions: A.conditions,
              modifiedAccessConditions: {
                ...A.conditions,
                ifTags: A.conditions?.tagConditions,
              },
              cpkInfo: A.customerProvidedKey,
              tracingOptions: Q.tracingOptions,
            }),
          );
          return {
            ...B,
            _response: B._response,
            objectReplicationDestinationPolicyId: B.objectReplicationPolicyId,
            objectReplicationSourceProperties: (0,
            y.parseObjectReplicationRecord)(B.objectReplicationRules),
          };
        })
      );
    }
    async delete(A = {}) {
      return (
        (A.conditions = A.conditions || {}),
        BA.tracingClient.withSpan("BlobClient-delete", A, async (Q) => {
          return (0, y.assertResponse)(
            await this.blobContext.delete({
              abortSignal: A.abortSignal,
              deleteSnapshots: A.deleteSnapshots,
              leaseAccessConditions: A.conditions,
              modifiedAccessConditions: {
                ...A.conditions,
                ifTags: A.conditions?.tagConditions,
              },
              tracingOptions: Q.tracingOptions,
            }),
          );
        })
      );
    }
    async deleteIfExists(A = {}) {
      return BA.tracingClient.withSpan(
        "BlobClient-deleteIfExists",
        A,
        async (Q) => {
          try {
            let B = (0, y.assertResponse)(await this.delete(Q));
            return { succeeded: !0, ...B, _response: B._response };
          } catch (B) {
            if (B.details?.errorCode === "BlobNotFound")
              return {
                succeeded: !1,
                ...B.response?.parsedHeaders,
                _response: B.response,
              };
            throw B;
          }
        },
      );
    }
    async undelete(A = {}) {
      return BA.tracingClient.withSpan("BlobClient-undelete", A, async (Q) => {
        return (0, y.assertResponse)(
          await this.blobContext.undelete({
            abortSignal: A.abortSignal,
            tracingOptions: Q.tracingOptions,
          }),
        );
      });
    }
    async setHTTPHeaders(A, Q = {}) {
      return (
        (Q.conditions = Q.conditions || {}),
        (0, tA.ensureCpkIfSpecified)(Q.customerProvidedKey, this.isHttps),
        BA.tracingClient.withSpan("BlobClient-setHTTPHeaders", Q, async (B) => {
          return (0, y.assertResponse)(
            await this.blobContext.setHttpHeaders({
              abortSignal: Q.abortSignal,
              blobHttpHeaders: A,
              leaseAccessConditions: Q.conditions,
              modifiedAccessConditions: {
                ...Q.conditions,
                ifTags: Q.conditions?.tagConditions,
              },
              tracingOptions: B.tracingOptions,
            }),
          );
        })
      );
    }
    async setMetadata(A, Q = {}) {
      return (
        (Q.conditions = Q.conditions || {}),
        (0, tA.ensureCpkIfSpecified)(Q.customerProvidedKey, this.isHttps),
        BA.tracingClient.withSpan("BlobClient-setMetadata", Q, async (B) => {
          return (0, y.assertResponse)(
            await this.blobContext.setMetadata({
              abortSignal: Q.abortSignal,
              leaseAccessConditions: Q.conditions,
              metadata: A,
              modifiedAccessConditions: {
                ...Q.conditions,
                ifTags: Q.conditions?.tagConditions,
              },
              cpkInfo: Q.customerProvidedKey,
              encryptionScope: Q.encryptionScope,
              tracingOptions: B.tracingOptions,
            }),
          );
        })
      );
    }
    async setTags(A, Q = {}) {
      return BA.tracingClient.withSpan("BlobClient-setTags", Q, async (B) => {
        return (0, y.assertResponse)(
          await this.blobContext.setTags({
            abortSignal: Q.abortSignal,
            leaseAccessConditions: Q.conditions,
            modifiedAccessConditions: {
              ...Q.conditions,
              ifTags: Q.conditions?.tagConditions,
            },
            tracingOptions: B.tracingOptions,
            tags: (0, y.toBlobTags)(A),
          }),
        );
      });
    }
    async getTags(A = {}) {
      return BA.tracingClient.withSpan("BlobClient-getTags", A, async (Q) => {
        let B = (0, y.assertResponse)(
          await this.blobContext.getTags({
            abortSignal: A.abortSignal,
            leaseAccessConditions: A.conditions,
            modifiedAccessConditions: {
              ...A.conditions,
              ifTags: A.conditions?.tagConditions,
            },
            tracingOptions: Q.tracingOptions,
          }),
        );
        return {
          ...B,
          _response: B._response,
          tags: (0, y.toTags)({ blobTagSet: B.blobTagSet }) || {},
        };
      });
    }
    getBlobLeaseClient(A) {
      return new I7A.BlobLeaseClient(this, A);
    }
    async createSnapshot(A = {}) {
      return (
        (A.conditions = A.conditions || {}),
        (0, tA.ensureCpkIfSpecified)(A.customerProvidedKey, this.isHttps),
        BA.tracingClient.withSpan("BlobClient-createSnapshot", A, async (Q) => {
          return (0, y.assertResponse)(
            await this.blobContext.createSnapshot({
              abortSignal: A.abortSignal,
              leaseAccessConditions: A.conditions,
              metadata: A.metadata,
              modifiedAccessConditions: {
                ...A.conditions,
                ifTags: A.conditions?.tagConditions,
              },
              cpkInfo: A.customerProvidedKey,
              encryptionScope: A.encryptionScope,
              tracingOptions: Q.tracingOptions,
            }),
          );
        })
      );
    }
    async beginCopyFromURL(A, Q = {}) {
      let B = {
          abortCopyFromURL: (...E) => this.abortCopyFromURL(...E),
          getProperties: (...E) => this.getProperties(...E),
          startCopyFromURL: (...E) => this.startCopyFromURL(...E),
        },
        I = new A7A.BlobBeginCopyFromUrlPoller({
          blobClient: B,
          copySource: A,
          intervalInMs: Q.intervalInMs,
          onProgress: Q.onProgress,
          resumeFrom: Q.resumeFrom,
          startCopyFromURLOptions: Q,
        });
      return await I.poll(), I;
    }
    async abortCopyFromURL(A, Q = {}) {
      return BA.tracingClient.withSpan(
        "BlobClient-abortCopyFromURL",
        Q,
        async (B) => {
          return (0, y.assertResponse)(
            await this.blobContext.abortCopyFromURL(A, {
              abortSignal: Q.abortSignal,
              leaseAccessConditions: Q.conditions,
              tracingOptions: B.tracingOptions,
            }),
          );
        },
      );
    }
    async syncCopyFromURL(A, Q = {}) {
      return (
        (Q.conditions = Q.conditions || {}),
        (Q.sourceConditions = Q.sourceConditions || {}),
        BA.tracingClient.withSpan(
          "BlobClient-syncCopyFromURL",
          Q,
          async (B) => {
            return (0, y.assertResponse)(
              await this.blobContext.copyFromURL(A, {
                abortSignal: Q.abortSignal,
                metadata: Q.metadata,
                leaseAccessConditions: Q.conditions,
                modifiedAccessConditions: {
                  ...Q.conditions,
                  ifTags: Q.conditions?.tagConditions,
                },
                sourceModifiedAccessConditions: {
                  sourceIfMatch: Q.sourceConditions?.ifMatch,
                  sourceIfModifiedSince: Q.sourceConditions?.ifModifiedSince,
                  sourceIfNoneMatch: Q.sourceConditions?.ifNoneMatch,
                  sourceIfUnmodifiedSince:
                    Q.sourceConditions?.ifUnmodifiedSince,
                },
                sourceContentMD5: Q.sourceContentMD5,
                copySourceAuthorization: (0, y.httpAuthorizationToString)(
                  Q.sourceAuthorization,
                ),
                tier: (0, tA.toAccessTier)(Q.tier),
                blobTagsString: (0, y.toBlobTagsString)(Q.tags),
                immutabilityPolicyExpiry: Q.immutabilityPolicy?.expiriesOn,
                immutabilityPolicyMode: Q.immutabilityPolicy?.policyMode,
                legalHold: Q.legalHold,
                encryptionScope: Q.encryptionScope,
                copySourceTags: Q.copySourceTags,
                fileRequestIntent: Q.sourceShareTokenIntent,
                tracingOptions: B.tracingOptions,
              }),
            );
          },
        )
      );
    }
    async setAccessTier(A, Q = {}) {
      return BA.tracingClient.withSpan(
        "BlobClient-setAccessTier",
        Q,
        async (B) => {
          return (0, y.assertResponse)(
            await this.blobContext.setTier((0, tA.toAccessTier)(A), {
              abortSignal: Q.abortSignal,
              leaseAccessConditions: Q.conditions,
              modifiedAccessConditions: {
                ...Q.conditions,
                ifTags: Q.conditions?.tagConditions,
              },
              rehydratePriority: Q.rehydratePriority,
              tracingOptions: B.tracingOptions,
            }),
          );
        },
      );
    }
    async downloadToBuffer(A, Q, B, I = {}) {
      let E,
        C = 0,
        g = 0,
        F = I;
      if (A instanceof Buffer)
        (E = A), (C = Q || 0), (g = typeof B === "number" ? B : 0);
      else
        (C = typeof A === "number" ? A : 0),
          (g = typeof Q === "number" ? Q : 0),
          (F = B || {});
      let D = F.blockSize ?? 0;
      if (D < 0) throw RangeError("blockSize option must be >= 0");
      if (D === 0) D = nA.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;
      if (C < 0) throw RangeError("offset option must be >= 0");
      if (g && g <= 0) throw RangeError("count option must be greater than 0");
      if (!F.conditions) F.conditions = {};
      return BA.tracingClient.withSpan(
        "BlobClient-downloadToBuffer",
        F,
        async (J) => {
          if (!g) {
            let W = await this.getProperties({
              ...F,
              tracingOptions: J.tracingOptions,
            });
            if (((g = W.contentLength - C), g < 0))
              throw RangeError(
                `offset ${C} shouldn't be larger than blob size ${W.contentLength}`,
              );
          }
          if (!E)
            try {
              E = Buffer.alloc(g);
            } catch (W) {
              throw Error(
                `Unable to allocate the buffer of size: ${g}(in bytes). Please try passing your own buffer to the "downloadToBuffer" method or try using other methods like "download" or "downloadToFile".	 ${W.message}`,
              );
            }
          if (E.length < g)
            throw RangeError(
              `The buffer's size should be equal to or larger than the request count of bytes: ${g}`,
            );
          let Y = 0,
            N = new rP.Batch(F.concurrency);
          for (let W = C; W < C + g; W = W + D)
            N.addOperation(async () => {
              let X = C + g;
              if (W + D < X) X = W + D;
              let L = (
                await this.download(W, X - W, {
                  abortSignal: F.abortSignal,
                  conditions: F.conditions,
                  maxRetryRequests: F.maxRetryRequestsPerBlock,
                  customerProvidedKey: F.customerProvidedKey,
                  tracingOptions: J.tracingOptions,
                })
              ).readableStreamBody;
              if (
                (await (0, cN.streamToBuffer)(L, E, W - C, X - C),
                (Y += X - W),
                F.onProgress)
              )
                F.onProgress({ loadedBytes: Y });
            });
          return await N.do(), E;
        },
      );
    }
    async downloadToFile(A, Q = 0, B, I = {}) {
      return BA.tracingClient.withSpan(
        "BlobClient-downloadToFile",
        I,
        async (E) => {
          let C = await this.download(Q, B, {
            ...I,
            tracingOptions: E.tracingOptions,
          });
          if (C.readableStreamBody)
            await (0, cN.readStreamToLocalFile)(C.readableStreamBody, A);
          return (C.blobDownloadStream = void 0), C;
        },
      );
    }
    getBlobAndContainerNamesFromUrl() {
      let A, Q;
      try {
        let B = new URL(this.url);
        if (B.host.split(".")[1] === "blob") {
          let I = B.pathname.match("/([^/]*)(/(.*))?");
          (A = I[1]), (Q = I[3]);
        } else if ((0, y.isIpEndpointStyle)(B)) {
          let I = B.pathname.match("/([^/]*)/([^/]*)(/(.*))?");
          (A = I[2]), (Q = I[4]);
        } else {
          let I = B.pathname.match("/([^/]*)(/(.*))?");
          (A = I[1]), (Q = I[3]);
        }
        if (
          ((A = decodeURIComponent(A)),
          (Q = decodeURIComponent(Q)),
          (Q = Q.replace(/\\/g, "/")),
          !A)
        )
          throw Error("Provided containerName is invalid.");
        return { blobName: Q, containerName: A };
      } catch (B) {
        throw Error(
          "Unable to extract blobName and containerName with provided information.",
        );
      }
    }
    async startCopyFromURL(A, Q = {}) {
      return BA.tracingClient.withSpan(
        "BlobClient-startCopyFromURL",
        Q,
        async (B) => {
          return (
            (Q.conditions = Q.conditions || {}),
            (Q.sourceConditions = Q.sourceConditions || {}),
            (0, y.assertResponse)(
              await this.blobContext.startCopyFromURL(A, {
                abortSignal: Q.abortSignal,
                leaseAccessConditions: Q.conditions,
                metadata: Q.metadata,
                modifiedAccessConditions: {
                  ...Q.conditions,
                  ifTags: Q.conditions?.tagConditions,
                },
                sourceModifiedAccessConditions: {
                  sourceIfMatch: Q.sourceConditions.ifMatch,
                  sourceIfModifiedSince: Q.sourceConditions.ifModifiedSince,
                  sourceIfNoneMatch: Q.sourceConditions.ifNoneMatch,
                  sourceIfUnmodifiedSince: Q.sourceConditions.ifUnmodifiedSince,
                  sourceIfTags: Q.sourceConditions.tagConditions,
                },
                immutabilityPolicyExpiry: Q.immutabilityPolicy?.expiriesOn,
                immutabilityPolicyMode: Q.immutabilityPolicy?.policyMode,
                legalHold: Q.legalHold,
                rehydratePriority: Q.rehydratePriority,
                tier: (0, tA.toAccessTier)(Q.tier),
                blobTagsString: (0, y.toBlobTagsString)(Q.tags),
                sealBlob: Q.sealBlob,
                tracingOptions: B.tracingOptions,
              }),
            )
          );
        },
      );
    }
    generateSasUrl(A) {
      return new Promise((Q) => {
        if (!(this.credential instanceof tI.StorageSharedKeyCredential))
          throw RangeError(
            "Can only generate the SAS when the client is initialized with a shared key credential",
          );
        let B = (0, dN.generateBlobSASQueryParameters)(
          {
            containerName: this._containerName,
            blobName: this._name,
            snapshotTime: this._snapshot,
            versionId: this._versionId,
            ...A,
          },
          this.credential,
        ).toString();
        Q((0, y.appendToURLQuery)(this.url, B));
      });
    }
    generateSasStringToSign(A) {
      if (!(this.credential instanceof tI.StorageSharedKeyCredential))
        throw RangeError(
          "Can only generate the SAS when the client is initialized with a shared key credential",
        );
      return (0, dN.generateBlobSASQueryParametersInternal)(
        {
          containerName: this._containerName,
          blobName: this._name,
          snapshotTime: this._snapshot,
          versionId: this._versionId,
          ...A,
        },
        this.credential,
      ).stringToSign;
    }
    generateUserDelegationSasUrl(A, Q) {
      return new Promise((B) => {
        let I = (0, dN.generateBlobSASQueryParameters)(
          {
            containerName: this._containerName,
            blobName: this._name,
            snapshotTime: this._snapshot,
            versionId: this._versionId,
            ...A,
          },
          Q,
          this.accountName,
        ).toString();
        B((0, y.appendToURLQuery)(this.url, I));
      });
    }
    generateUserDelegationSasStringToSign(A, Q) {
      return (0, dN.generateBlobSASQueryParametersInternal)(
        {
          containerName: this._containerName,
          blobName: this._name,
          snapshotTime: this._snapshot,
          versionId: this._versionId,
          ...A,
        },
        Q,
        this.accountName,
      ).stringToSign;
    }
    async deleteImmutabilityPolicy(A = {}) {
      return BA.tracingClient.withSpan(
        "BlobClient-deleteImmutabilityPolicy",
        A,
        async (Q) => {
          return (0, y.assertResponse)(
            await this.blobContext.deleteImmutabilityPolicy({
              tracingOptions: Q.tracingOptions,
            }),
          );
        },
      );
    }
    async setImmutabilityPolicy(A, Q = {}) {
      return BA.tracingClient.withSpan(
        "BlobClient-setImmutabilityPolicy",
        Q,
        async (B) => {
          return (0, y.assertResponse)(
            await this.blobContext.setImmutabilityPolicy({
              immutabilityPolicyExpiry: A.expiriesOn,
              immutabilityPolicyMode: A.policyMode,
              tracingOptions: B.tracingOptions,
            }),
          );
        },
      );
    }
    async setLegalHold(A, Q = {}) {
      return BA.tracingClient.withSpan(
        "BlobClient-setLegalHold",
        Q,
        async (B) => {
          return (0, y.assertResponse)(
            await this.blobContext.setLegalHold(A, {
              tracingOptions: B.tracingOptions,
            }),
          );
        },
      );
    }
    async getAccountInfo(A = {}) {
      return BA.tracingClient.withSpan(
        "BlobClient-getAccountInfo",
        A,
        async (Q) => {
          return (0, y.assertResponse)(
            await this.blobContext.getAccountInfo({
              abortSignal: A.abortSignal,
              tracingOptions: Q.tracingOptions,
            }),
          );
        },
      );
    }
  }
  tP.BlobClient = N0;
  class pN extends N0 {
    appendBlobContext;
    constructor(A, Q, B, I) {
      let E, C;
      if (((I = I || {}), (0, TQ.isPipelineLike)(Q))) (C = A), (E = Q);
      else if (
        (WI.isNodeLike && Q instanceof tI.StorageSharedKeyCredential) ||
        Q instanceof ZI.AnonymousCredential ||
        (0, lN.isTokenCredential)(Q)
      )
        (C = A), (I = B), (E = (0, TQ.newPipeline)(Q, I));
      else if (!Q && typeof Q !== "string")
        (C = A), (E = (0, TQ.newPipeline)(new ZI.AnonymousCredential(), I));
      else if (Q && typeof Q === "string" && B && typeof B === "string") {
        let g = Q,
          F = B,
          D = (0, y.extractConnectionStringParts)(A);
        if (D.kind === "AccountConnString")
          if (WI.isNodeLike) {
            let J = new tI.StorageSharedKeyCredential(
              D.accountName,
              D.accountKey,
            );
            if (
              ((C = (0, y.appendToURLPath)(
                (0, y.appendToURLPath)(D.url, encodeURIComponent(g)),
                encodeURIComponent(F),
              )),
              !I.proxyOptions)
            )
              I.proxyOptions = (0, uN.getDefaultProxySettings)(D.proxyUri);
            E = (0, TQ.newPipeline)(J, I);
          } else
            throw Error(
              "Account connection string is only supported in Node.js environment",
            );
        else if (D.kind === "SASConnString")
          (C =
            (0, y.appendToURLPath)(
              (0, y.appendToURLPath)(D.url, encodeURIComponent(g)),
              encodeURIComponent(F),
            ) +
            "?" +
            D.accountSas),
            (E = (0, TQ.newPipeline)(new ZI.AnonymousCredential(), I));
        else
          throw Error(
            "Connection string must be either an Account connection string or a SAS connection string",
          );
      } else
        throw Error(
          "Expecting non-empty strings for containerName and blobName parameters",
        );
      super(C, E);
      this.appendBlobContext = this.storageClientContext.appendBlob;
    }
    withSnapshot(A) {
      return new pN(
        (0, y.setURLParameter)(
          this.url,
          nA.URLConstants.Parameters.SNAPSHOT,
          A.length === 0 ? void 0 : A,
        ),
        this.pipeline,
      );
    }
    async create(A = {}) {
      return (
        (A.conditions = A.conditions || {}),
        (0, tA.ensureCpkIfSpecified)(A.customerProvidedKey, this.isHttps),
        BA.tracingClient.withSpan("AppendBlobClient-create", A, async (Q) => {
          return (0, y.assertResponse)(
            await this.appendBlobContext.create(0, {
              abortSignal: A.abortSignal,
              blobHttpHeaders: A.blobHTTPHeaders,
              leaseAccessConditions: A.conditions,
              metadata: A.metadata,
              modifiedAccessConditions: {
                ...A.conditions,
                ifTags: A.conditions?.tagConditions,
              },
              cpkInfo: A.customerProvidedKey,
              encryptionScope: A.encryptionScope,
              immutabilityPolicyExpiry: A.immutabilityPolicy?.expiriesOn,
              immutabilityPolicyMode: A.immutabilityPolicy?.policyMode,
              legalHold: A.legalHold,
              blobTagsString: (0, y.toBlobTagsString)(A.tags),
              tracingOptions: Q.tracingOptions,
            }),
          );
        })
      );
    }
    async createIfNotExists(A = {}) {
      let Q = { ifNoneMatch: nA.ETagAny };
      return BA.tracingClient.withSpan(
        "AppendBlobClient-createIfNotExists",
        A,
        async (B) => {
          try {
            let I = (0, y.assertResponse)(
              await this.create({ ...B, conditions: Q }),
            );
            return { succeeded: !0, ...I, _response: I._response };
          } catch (I) {
            if (I.details?.errorCode === "BlobAlreadyExists")
              return {
                succeeded: !1,
                ...I.response?.parsedHeaders,
                _response: I.response,
              };
            throw I;
          }
        },
      );
    }
    async seal(A = {}) {
      return (
        (A.conditions = A.conditions || {}),
        BA.tracingClient.withSpan("AppendBlobClient-seal", A, async (Q) => {
          return (0, y.assertResponse)(
            await this.appendBlobContext.seal({
              abortSignal: A.abortSignal,
              appendPositionAccessConditions: A.conditions,
              leaseAccessConditions: A.conditions,
              modifiedAccessConditions: {
                ...A.conditions,
                ifTags: A.conditions?.tagConditions,
              },
              tracingOptions: Q.tracingOptions,
            }),
          );
        })
      );
    }
    async appendBlock(A, Q, B = {}) {
      return (
        (B.conditions = B.conditions || {}),
        (0, tA.ensureCpkIfSpecified)(B.customerProvidedKey, this.isHttps),
        BA.tracingClient.withSpan(
          "AppendBlobClient-appendBlock",
          B,
          async (I) => {
            return (0, y.assertResponse)(
              await this.appendBlobContext.appendBlock(Q, A, {
                abortSignal: B.abortSignal,
                appendPositionAccessConditions: B.conditions,
                leaseAccessConditions: B.conditions,
                modifiedAccessConditions: {
                  ...B.conditions,
                  ifTags: B.conditions?.tagConditions,
                },
                requestOptions: { onUploadProgress: B.onProgress },
                transactionalContentMD5: B.transactionalContentMD5,
                transactionalContentCrc64: B.transactionalContentCrc64,
                cpkInfo: B.customerProvidedKey,
                encryptionScope: B.encryptionScope,
                tracingOptions: I.tracingOptions,
              }),
            );
          },
        )
      );
    }
    async appendBlockFromURL(A, Q, B, I = {}) {
      return (
        (I.conditions = I.conditions || {}),
        (I.sourceConditions = I.sourceConditions || {}),
        (0, tA.ensureCpkIfSpecified)(I.customerProvidedKey, this.isHttps),
        BA.tracingClient.withSpan(
          "AppendBlobClient-appendBlockFromURL",
          I,
          async (E) => {
            return (0, y.assertResponse)(
              await this.appendBlobContext.appendBlockFromUrl(A, 0, {
                abortSignal: I.abortSignal,
                sourceRange: (0, nB.rangeToString)({ offset: Q, count: B }),
                sourceContentMD5: I.sourceContentMD5,
                sourceContentCrc64: I.sourceContentCrc64,
                leaseAccessConditions: I.conditions,
                appendPositionAccessConditions: I.conditions,
                modifiedAccessConditions: {
                  ...I.conditions,
                  ifTags: I.conditions?.tagConditions,
                },
                sourceModifiedAccessConditions: {
                  sourceIfMatch: I.sourceConditions?.ifMatch,
                  sourceIfModifiedSince: I.sourceConditions?.ifModifiedSince,
                  sourceIfNoneMatch: I.sourceConditions?.ifNoneMatch,
                  sourceIfUnmodifiedSince:
                    I.sourceConditions?.ifUnmodifiedSince,
                },
                copySourceAuthorization: (0, y.httpAuthorizationToString)(
                  I.sourceAuthorization,
                ),
                cpkInfo: I.customerProvidedKey,
                encryptionScope: I.encryptionScope,
                fileRequestIntent: I.sourceShareTokenIntent,
                tracingOptions: E.tracingOptions,
              }),
            );
          },
        )
      );
    }
  }
  tP.AppendBlobClient = pN;
  class iN extends N0 {
    _blobContext;
    blockBlobContext;
    constructor(A, Q, B, I) {
      let E, C;
      if (((I = I || {}), (0, TQ.isPipelineLike)(Q))) (C = A), (E = Q);
      else if (
        (WI.isNodeLike && Q instanceof tI.StorageSharedKeyCredential) ||
        Q instanceof ZI.AnonymousCredential ||
        (0, lN.isTokenCredential)(Q)
      )
        (C = A), (I = B), (E = (0, TQ.newPipeline)(Q, I));
      else if (!Q && typeof Q !== "string") {
        if (((C = A), B && typeof B !== "string")) I = B;
        E = (0, TQ.newPipeline)(new ZI.AnonymousCredential(), I);
      } else if (Q && typeof Q === "string" && B && typeof B === "string") {
        let g = Q,
          F = B,
          D = (0, y.extractConnectionStringParts)(A);
        if (D.kind === "AccountConnString")
          if (WI.isNodeLike) {
            let J = new tI.StorageSharedKeyCredential(
              D.accountName,
              D.accountKey,
            );
            if (
              ((C = (0, y.appendToURLPath)(
                (0, y.appendToURLPath)(D.url, encodeURIComponent(g)),
                encodeURIComponent(F),
              )),
              !I.proxyOptions)
            )
              I.proxyOptions = (0, uN.getDefaultProxySettings)(D.proxyUri);
            E = (0, TQ.newPipeline)(J, I);
          } else
            throw Error(
              "Account connection string is only supported in Node.js environment",
            );
        else if (D.kind === "SASConnString")
          (C =
            (0, y.appendToURLPath)(
              (0, y.appendToURLPath)(D.url, encodeURIComponent(g)),
              encodeURIComponent(F),
            ) +
            "?" +
            D.accountSas),
            (E = (0, TQ.newPipeline)(new ZI.AnonymousCredential(), I));
        else
          throw Error(
            "Connection string must be either an Account connection string or a SAS connection string",
          );
      } else
        throw Error(
          "Expecting non-empty strings for containerName and blobName parameters",
        );
      super(C, E);
      (this.blockBlobContext = this.storageClientContext.blockBlob),
        (this._blobContext = this.storageClientContext.blob);
    }
    withSnapshot(A) {
      return new iN(
        (0, y.setURLParameter)(
          this.url,
          nA.URLConstants.Parameters.SNAPSHOT,
          A.length === 0 ? void 0 : A,
        ),
        this.pipeline,
      );
    }
    async query(A, Q = {}) {
      if (
        ((0, tA.ensureCpkIfSpecified)(Q.customerProvidedKey, this.isHttps),
        !WI.isNodeLike)
      )
        throw Error("This operation currently is only supported in Node.js.");
      return BA.tracingClient.withSpan(
        "BlockBlobClient-query",
        Q,
        async (B) => {
          let I = (0, y.assertResponse)(
            await this._blobContext.query({
              abortSignal: Q.abortSignal,
              queryRequest: {
                queryType: "SQL",
                expression: A,
                inputSerialization: (0, y.toQuerySerialization)(
                  Q.inputTextConfiguration,
                ),
                outputSerialization: (0, y.toQuerySerialization)(
                  Q.outputTextConfiguration,
                ),
              },
              leaseAccessConditions: Q.conditions,
              modifiedAccessConditions: {
                ...Q.conditions,
                ifTags: Q.conditions?.tagConditions,
              },
              cpkInfo: Q.customerProvidedKey,
              tracingOptions: B.tracingOptions,
            }),
          );
          return new e6A.BlobQueryResponse(I, {
            abortSignal: Q.abortSignal,
            onProgress: Q.onProgress,
            onError: Q.onError,
          });
        },
      );
    }
    async upload(A, Q, B = {}) {
      return (
        (B.conditions = B.conditions || {}),
        (0, tA.ensureCpkIfSpecified)(B.customerProvidedKey, this.isHttps),
        BA.tracingClient.withSpan("BlockBlobClient-upload", B, async (I) => {
          return (0, y.assertResponse)(
            await this.blockBlobContext.upload(Q, A, {
              abortSignal: B.abortSignal,
              blobHttpHeaders: B.blobHTTPHeaders,
              leaseAccessConditions: B.conditions,
              metadata: B.metadata,
              modifiedAccessConditions: {
                ...B.conditions,
                ifTags: B.conditions?.tagConditions,
              },
              requestOptions: { onUploadProgress: B.onProgress },
              cpkInfo: B.customerProvidedKey,
              encryptionScope: B.encryptionScope,
              immutabilityPolicyExpiry: B.immutabilityPolicy?.expiriesOn,
              immutabilityPolicyMode: B.immutabilityPolicy?.policyMode,
              legalHold: B.legalHold,
              tier: (0, tA.toAccessTier)(B.tier),
              blobTagsString: (0, y.toBlobTagsString)(B.tags),
              tracingOptions: I.tracingOptions,
            }),
          );
        })
      );
    }
    async syncUploadFromURL(A, Q = {}) {
      return (
        (Q.conditions = Q.conditions || {}),
        (0, tA.ensureCpkIfSpecified)(Q.customerProvidedKey, this.isHttps),
        BA.tracingClient.withSpan(
          "BlockBlobClient-syncUploadFromURL",
          Q,
          async (B) => {
            return (0, y.assertResponse)(
              await this.blockBlobContext.putBlobFromUrl(0, A, {
                ...Q,
                blobHttpHeaders: Q.blobHTTPHeaders,
                leaseAccessConditions: Q.conditions,
                modifiedAccessConditions: {
                  ...Q.conditions,
                  ifTags: Q.conditions?.tagConditions,
                },
                sourceModifiedAccessConditions: {
                  sourceIfMatch: Q.sourceConditions?.ifMatch,
                  sourceIfModifiedSince: Q.sourceConditions?.ifModifiedSince,
                  sourceIfNoneMatch: Q.sourceConditions?.ifNoneMatch,
                  sourceIfUnmodifiedSince:
                    Q.sourceConditions?.ifUnmodifiedSince,
                  sourceIfTags: Q.sourceConditions?.tagConditions,
                },
                cpkInfo: Q.customerProvidedKey,
                copySourceAuthorization: (0, y.httpAuthorizationToString)(
                  Q.sourceAuthorization,
                ),
                tier: (0, tA.toAccessTier)(Q.tier),
                blobTagsString: (0, y.toBlobTagsString)(Q.tags),
                copySourceTags: Q.copySourceTags,
                fileRequestIntent: Q.sourceShareTokenIntent,
                tracingOptions: B.tracingOptions,
              }),
            );
          },
        )
      );
    }
    async stageBlock(A, Q, B, I = {}) {
      return (
        (0, tA.ensureCpkIfSpecified)(I.customerProvidedKey, this.isHttps),
        BA.tracingClient.withSpan(
          "BlockBlobClient-stageBlock",
          I,
          async (E) => {
            return (0, y.assertResponse)(
              await this.blockBlobContext.stageBlock(A, B, Q, {
                abortSignal: I.abortSignal,
                leaseAccessConditions: I.conditions,
                requestOptions: { onUploadProgress: I.onProgress },
                transactionalContentMD5: I.transactionalContentMD5,
                transactionalContentCrc64: I.transactionalContentCrc64,
                cpkInfo: I.customerProvidedKey,
                encryptionScope: I.encryptionScope,
                tracingOptions: E.tracingOptions,
              }),
            );
          },
        )
      );
    }
    async stageBlockFromURL(A, Q, B = 0, I, E = {}) {
      return (
        (0, tA.ensureCpkIfSpecified)(E.customerProvidedKey, this.isHttps),
        BA.tracingClient.withSpan(
          "BlockBlobClient-stageBlockFromURL",
          E,
          async (C) => {
            return (0, y.assertResponse)(
              await this.blockBlobContext.stageBlockFromURL(A, 0, Q, {
                abortSignal: E.abortSignal,
                leaseAccessConditions: E.conditions,
                sourceContentMD5: E.sourceContentMD5,
                sourceContentCrc64: E.sourceContentCrc64,
                sourceRange:
                  B === 0 && !I
                    ? void 0
                    : (0, nB.rangeToString)({ offset: B, count: I }),
                cpkInfo: E.customerProvidedKey,
                encryptionScope: E.encryptionScope,
                copySourceAuthorization: (0, y.httpAuthorizationToString)(
                  E.sourceAuthorization,
                ),
                fileRequestIntent: E.sourceShareTokenIntent,
                tracingOptions: C.tracingOptions,
              }),
            );
          },
        )
      );
    }
    async commitBlockList(A, Q = {}) {
      return (
        (Q.conditions = Q.conditions || {}),
        (0, tA.ensureCpkIfSpecified)(Q.customerProvidedKey, this.isHttps),
        BA.tracingClient.withSpan(
          "BlockBlobClient-commitBlockList",
          Q,
          async (B) => {
            return (0, y.assertResponse)(
              await this.blockBlobContext.commitBlockList(
                { latest: A },
                {
                  abortSignal: Q.abortSignal,
                  blobHttpHeaders: Q.blobHTTPHeaders,
                  leaseAccessConditions: Q.conditions,
                  metadata: Q.metadata,
                  modifiedAccessConditions: {
                    ...Q.conditions,
                    ifTags: Q.conditions?.tagConditions,
                  },
                  cpkInfo: Q.customerProvidedKey,
                  encryptionScope: Q.encryptionScope,
                  immutabilityPolicyExpiry: Q.immutabilityPolicy?.expiriesOn,
                  immutabilityPolicyMode: Q.immutabilityPolicy?.policyMode,
                  legalHold: Q.legalHold,
                  tier: (0, tA.toAccessTier)(Q.tier),
                  blobTagsString: (0, y.toBlobTagsString)(Q.tags),
                  tracingOptions: B.tracingOptions,
                },
              ),
            );
          },
        )
      );
    }
    async getBlockList(A, Q = {}) {
      return BA.tracingClient.withSpan(
        "BlockBlobClient-getBlockList",
        Q,
        async (B) => {
          let I = (0, y.assertResponse)(
            await this.blockBlobContext.getBlockList(A, {
              abortSignal: Q.abortSignal,
              leaseAccessConditions: Q.conditions,
              modifiedAccessConditions: {
                ...Q.conditions,
                ifTags: Q.conditions?.tagConditions,
              },
              tracingOptions: B.tracingOptions,
            }),
          );
          if (!I.committedBlocks) I.committedBlocks = [];
          if (!I.uncommittedBlocks) I.uncommittedBlocks = [];
          return I;
        },
      );
    }
    async uploadData(A, Q = {}) {
      return BA.tracingClient.withSpan(
        "BlockBlobClient-uploadData",
        Q,
        async (B) => {
          if (WI.isNodeLike) {
            let I;
            if (A instanceof Buffer) I = A;
            else if (A instanceof ArrayBuffer) I = Buffer.from(A);
            else
              (A = A), (I = Buffer.from(A.buffer, A.byteOffset, A.byteLength));
            return this.uploadSeekableInternal(
              (E, C) => I.slice(E, E + C),
              I.byteLength,
              B,
            );
          } else {
            let I = new Blob([A]);
            return this.uploadSeekableInternal(
              (E, C) => I.slice(E, E + C),
              I.size,
              B,
            );
          }
        },
      );
    }
    async uploadBrowserData(A, Q = {}) {
      return BA.tracingClient.withSpan(
        "BlockBlobClient-uploadBrowserData",
        Q,
        async (B) => {
          let I = new Blob([A]);
          return this.uploadSeekableInternal(
            (E, C) => I.slice(E, E + C),
            I.size,
            B,
          );
        },
      );
    }
    async uploadSeekableInternal(A, Q, B = {}) {
      let I = B.blockSize ?? 0;
      if (I < 0 || I > nA.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES)
        throw RangeError(
          `blockSize option must be >= 0 and <= ${nA.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES}`,
        );
      let E = B.maxSingleShotSize ?? nA.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES;
      if (E < 0 || E > nA.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES)
        throw RangeError(
          `maxSingleShotSize option must be >= 0 and <= ${nA.BLOCK_BLOB_MAX_UPLOAD_BLOB_BYTES}`,
        );
      if (I === 0) {
        if (Q > nA.BLOCK_BLOB_MAX_STAGE_BLOCK_BYTES * nA.BLOCK_BLOB_MAX_BLOCKS)
          throw RangeError(`${Q} is too larger to upload to a block blob.`);
        if (Q > E) {
          if (
            ((I = Math.ceil(Q / nA.BLOCK_BLOB_MAX_BLOCKS)),
            I < nA.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES)
          )
            I = nA.DEFAULT_BLOB_DOWNLOAD_BLOCK_BYTES;
        }
      }
      if (!B.blobHTTPHeaders) B.blobHTTPHeaders = {};
      if (!B.conditions) B.conditions = {};
      return BA.tracingClient.withSpan(
        "BlockBlobClient-uploadSeekableInternal",
        B,
        async (C) => {
          if (Q <= E)
            return (0, y.assertResponse)(await this.upload(A(0, Q), Q, C));
          let g = Math.floor((Q - 1) / I) + 1;
          if (g > nA.BLOCK_BLOB_MAX_BLOCKS)
            throw RangeError(
              `The buffer's size is too big or the BlockSize is too small;the number of blocks must be <= ${nA.BLOCK_BLOB_MAX_BLOCKS}`,
            );
          let F = [],
            D = (0, sP.randomUUID)(),
            J = 0,
            Y = new rP.Batch(B.concurrency);
          for (let N = 0; N < g; N++)
            Y.addOperation(async () => {
              let W = (0, y.generateBlockID)(D, N),
                X = I * N,
                L = (N === g - 1 ? Q : X + I) - X;
              if (
                (F.push(W),
                await this.stageBlock(W, A(X, L), L, {
                  abortSignal: B.abortSignal,
                  conditions: B.conditions,
                  encryptionScope: B.encryptionScope,
                  tracingOptions: C.tracingOptions,
                }),
                (J += L),
                B.onProgress)
              )
                B.onProgress({ loadedBytes: J });
            });
          return await Y.do(), this.commitBlockList(F, C);
        },
      );
    }
    async uploadFile(A, Q = {}) {
      return BA.tracingClient.withSpan(
        "BlockBlobClient-uploadFile",
        Q,
        async (B) => {
          let I = (await (0, cN.fsStat)(A)).size;
          return this.uploadSeekableInternal(
            (E, C) => {
              return () =>
                (0, cN.fsCreateReadStream)(A, {
                  autoClose: !0,
                  end: C ? E + C - 1 : 1 / 0,
                  start: E,
                });
            },
            I,
            { ...Q, tracingOptions: B.tracingOptions },
          );
        },
      );
    }
    async uploadStream(
      A,
      Q = nA.DEFAULT_BLOCK_BUFFER_SIZE_BYTES,
      B = 5,
      I = {},
    ) {
      if (!I.blobHTTPHeaders) I.blobHTTPHeaders = {};
      if (!I.conditions) I.conditions = {};
      return BA.tracingClient.withSpan(
        "BlockBlobClient-uploadStream",
        I,
        async (E) => {
          let C = 0,
            g = (0, sP.randomUUID)(),
            F = 0,
            D = [];
          return (
            await new B7A.BufferScheduler(
              A,
              Q,
              B,
              async (Y, N) => {
                let W = (0, y.generateBlockID)(g, C);
                if (
                  (D.push(W),
                  C++,
                  await this.stageBlock(W, Y, N, {
                    customerProvidedKey: I.customerProvidedKey,
                    conditions: I.conditions,
                    encryptionScope: I.encryptionScope,
                    tracingOptions: E.tracingOptions,
                  }),
                  (F += N),
                  I.onProgress)
                )
                  I.onProgress({ loadedBytes: F });
              },
              Math.ceil((B / 4) * 3),
            ).do(),
            (0, y.assertResponse)(
              await this.commitBlockList(D, {
                ...I,
                tracingOptions: E.tracingOptions,
              }),
            )
          );
        },
      );
    }
  }
  tP.BlockBlobClient = iN;
  class nN extends N0 {
    pageBlobContext;
    constructor(A, Q, B, I) {
      let E, C;
      if (((I = I || {}), (0, TQ.isPipelineLike)(Q))) (C = A), (E = Q);
      else if (
        (WI.isNodeLike && Q instanceof tI.StorageSharedKeyCredential) ||
        Q instanceof ZI.AnonymousCredential ||
        (0, lN.isTokenCredential)(Q)
      )
        (C = A), (I = B), (E = (0, TQ.newPipeline)(Q, I));
      else if (!Q && typeof Q !== "string")
        (C = A), (E = (0, TQ.newPipeline)(new ZI.AnonymousCredential(), I));
      else if (Q && typeof Q === "string" && B && typeof B === "string") {
        let g = Q,
          F = B,
          D = (0, y.extractConnectionStringParts)(A);
        if (D.kind === "AccountConnString")
          if (WI.isNodeLike) {
            let J = new tI.StorageSharedKeyCredential(
              D.accountName,
              D.accountKey,
            );
            if (
              ((C = (0, y.appendToURLPath)(
                (0, y.appendToURLPath)(D.url, encodeURIComponent(g)),
                encodeURIComponent(F),
              )),
              !I.proxyOptions)
            )
              I.proxyOptions = (0, uN.getDefaultProxySettings)(D.proxyUri);
            E = (0, TQ.newPipeline)(J, I);
          } else
            throw Error(
              "Account connection string is only supported in Node.js environment",
            );
        else if (D.kind === "SASConnString")
          (C =
            (0, y.appendToURLPath)(
              (0, y.appendToURLPath)(D.url, encodeURIComponent(g)),
              encodeURIComponent(F),
            ) +
            "?" +
            D.accountSas),
            (E = (0, TQ.newPipeline)(new ZI.AnonymousCredential(), I));
        else
          throw Error(
            "Connection string must be either an Account connection string or a SAS connection string",
          );
      } else
        throw Error(
          "Expecting non-empty strings for containerName and blobName parameters",
        );
      super(C, E);
      this.pageBlobContext = this.storageClientContext.pageBlob;
    }
    withSnapshot(A) {
      return new nN(
        (0, y.setURLParameter)(
          this.url,
          nA.URLConstants.Parameters.SNAPSHOT,
          A.length === 0 ? void 0 : A,
        ),
        this.pipeline,
      );
    }
    async create(A, Q = {}) {
      return (
        (Q.conditions = Q.conditions || {}),
        (0, tA.ensureCpkIfSpecified)(Q.customerProvidedKey, this.isHttps),
        BA.tracingClient.withSpan("PageBlobClient-create", Q, async (B) => {
          return (0, y.assertResponse)(
            await this.pageBlobContext.create(0, A, {
              abortSignal: Q.abortSignal,
              blobHttpHeaders: Q.blobHTTPHeaders,
              blobSequenceNumber: Q.blobSequenceNumber,
              leaseAccessConditions: Q.conditions,
              metadata: Q.metadata,
              modifiedAccessConditions: {
                ...Q.conditions,
                ifTags: Q.conditions?.tagConditions,
              },
              cpkInfo: Q.customerProvidedKey,
              encryptionScope: Q.encryptionScope,
              immutabilityPolicyExpiry: Q.immutabilityPolicy?.expiriesOn,
              immutabilityPolicyMode: Q.immutabilityPolicy?.policyMode,
              legalHold: Q.legalHold,
              tier: (0, tA.toAccessTier)(Q.tier),
              blobTagsString: (0, y.toBlobTagsString)(Q.tags),
              tracingOptions: B.tracingOptions,
            }),
          );
        })
      );
    }
    async createIfNotExists(A, Q = {}) {
      return BA.tracingClient.withSpan(
        "PageBlobClient-createIfNotExists",
        Q,
        async (B) => {
          try {
            let I = { ifNoneMatch: nA.ETagAny },
              E = (0, y.assertResponse)(
                await this.create(A, {
                  ...Q,
                  conditions: I,
                  tracingOptions: B.tracingOptions,
                }),
              );
            return { succeeded: !0, ...E, _response: E._response };
          } catch (I) {
            if (I.details?.errorCode === "BlobAlreadyExists")
              return {
                succeeded: !1,
                ...I.response?.parsedHeaders,
                _response: I.response,
              };
            throw I;
          }
        },
      );
    }
    async uploadPages(A, Q, B, I = {}) {
      return (
        (I.conditions = I.conditions || {}),
        (0, tA.ensureCpkIfSpecified)(I.customerProvidedKey, this.isHttps),
        BA.tracingClient.withSpan(
          "PageBlobClient-uploadPages",
          I,
          async (E) => {
            return (0, y.assertResponse)(
              await this.pageBlobContext.uploadPages(B, A, {
                abortSignal: I.abortSignal,
                leaseAccessConditions: I.conditions,
                modifiedAccessConditions: {
                  ...I.conditions,
                  ifTags: I.conditions?.tagConditions,
                },
                requestOptions: { onUploadProgress: I.onProgress },
                range: (0, nB.rangeToString)({ offset: Q, count: B }),
                sequenceNumberAccessConditions: I.conditions,
                transactionalContentMD5: I.transactionalContentMD5,
                transactionalContentCrc64: I.transactionalContentCrc64,
                cpkInfo: I.customerProvidedKey,
                encryptionScope: I.encryptionScope,
                tracingOptions: E.tracingOptions,
              }),
            );
          },
        )
      );
    }
    async uploadPagesFromURL(A, Q, B, I, E = {}) {
      return (
        (E.conditions = E.conditions || {}),
        (E.sourceConditions = E.sourceConditions || {}),
        (0, tA.ensureCpkIfSpecified)(E.customerProvidedKey, this.isHttps),
        BA.tracingClient.withSpan(
          "PageBlobClient-uploadPagesFromURL",
          E,
          async (C) => {
            return (0, y.assertResponse)(
              await this.pageBlobContext.uploadPagesFromURL(
                A,
                (0, nB.rangeToString)({ offset: Q, count: I }),
                0,
                (0, nB.rangeToString)({ offset: B, count: I }),
                {
                  abortSignal: E.abortSignal,
                  sourceContentMD5: E.sourceContentMD5,
                  sourceContentCrc64: E.sourceContentCrc64,
                  leaseAccessConditions: E.conditions,
                  sequenceNumberAccessConditions: E.conditions,
                  modifiedAccessConditions: {
                    ...E.conditions,
                    ifTags: E.conditions?.tagConditions,
                  },
                  sourceModifiedAccessConditions: {
                    sourceIfMatch: E.sourceConditions?.ifMatch,
                    sourceIfModifiedSince: E.sourceConditions?.ifModifiedSince,
                    sourceIfNoneMatch: E.sourceConditions?.ifNoneMatch,
                    sourceIfUnmodifiedSince:
                      E.sourceConditions?.ifUnmodifiedSince,
                  },
                  cpkInfo: E.customerProvidedKey,
                  encryptionScope: E.encryptionScope,
                  copySourceAuthorization: (0, y.httpAuthorizationToString)(
                    E.sourceAuthorization,
                  ),
                  fileRequestIntent: E.sourceShareTokenIntent,
                  tracingOptions: C.tracingOptions,
                },
              ),
            );
          },
        )
      );
    }
    async clearPages(A = 0, Q, B = {}) {
      return (
        (B.conditions = B.conditions || {}),
        BA.tracingClient.withSpan("PageBlobClient-clearPages", B, async (I) => {
          return (0, y.assertResponse)(
            await this.pageBlobContext.clearPages(0, {
              abortSignal: B.abortSignal,
              leaseAccessConditions: B.conditions,
              modifiedAccessConditions: {
                ...B.conditions,
                ifTags: B.conditions?.tagConditions,
              },
              range: (0, nB.rangeToString)({ offset: A, count: Q }),
              sequenceNumberAccessConditions: B.conditions,
              cpkInfo: B.customerProvidedKey,
              encryptionScope: B.encryptionScope,
              tracingOptions: I.tracingOptions,
            }),
          );
        })
      );
    }
    async getPageRanges(A = 0, Q, B = {}) {
      return (
        (B.conditions = B.conditions || {}),
        BA.tracingClient.withSpan(
          "PageBlobClient-getPageRanges",
          B,
          async (I) => {
            let E = (0, y.assertResponse)(
              await this.pageBlobContext.getPageRanges({
                abortSignal: B.abortSignal,
                leaseAccessConditions: B.conditions,
                modifiedAccessConditions: {
                  ...B.conditions,
                  ifTags: B.conditions?.tagConditions,
                },
                range: (0, nB.rangeToString)({ offset: A, count: Q }),
                tracingOptions: I.tracingOptions,
              }),
            );
            return (0, H4.rangeResponseFromModel)(E);
          },
        )
      );
    }
    async listPageRangesSegment(A = 0, Q, B, I = {}) {
      return BA.tracingClient.withSpan(
        "PageBlobClient-getPageRangesSegment",
        I,
        async (E) => {
          return (0, y.assertResponse)(
            await this.pageBlobContext.getPageRanges({
              abortSignal: I.abortSignal,
              leaseAccessConditions: I.conditions,
              modifiedAccessConditions: {
                ...I.conditions,
                ifTags: I.conditions?.tagConditions,
              },
              range: (0, nB.rangeToString)({ offset: A, count: Q }),
              marker: B,
              maxPageSize: I.maxPageSize,
              tracingOptions: E.tracingOptions,
            }),
          );
        },
      );
    }
    async *listPageRangeItemSegments(A = 0, Q, B, I = {}) {
      let E;
      if (!!B || B === void 0)
        do
          (E = await this.listPageRangesSegment(A, Q, B, I)),
            (B = E.continuationToken),
            yield await E;
        while (B);
    }
    async *listPageRangeItems(A = 0, Q, B = {}) {
      let I;
      for await (let E of this.listPageRangeItemSegments(A, Q, I, B))
        yield* (0, y.ExtractPageRangeInfoItems)(E);
    }
    listPageRanges(A = 0, Q, B = {}) {
      B.conditions = B.conditions || {};
      let I = this.listPageRangeItems(A, Q, B);
      return {
        next() {
          return I.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (E = {}) => {
          return this.listPageRangeItemSegments(A, Q, E.continuationToken, {
            maxPageSize: E.maxPageSize,
            ...B,
          });
        },
      };
    }
    async getPageRangesDiff(A, Q, B, I = {}) {
      return (
        (I.conditions = I.conditions || {}),
        BA.tracingClient.withSpan(
          "PageBlobClient-getPageRangesDiff",
          I,
          async (E) => {
            let C = (0, y.assertResponse)(
              await this.pageBlobContext.getPageRangesDiff({
                abortSignal: I.abortSignal,
                leaseAccessConditions: I.conditions,
                modifiedAccessConditions: {
                  ...I.conditions,
                  ifTags: I.conditions?.tagConditions,
                },
                prevsnapshot: B,
                range: (0, nB.rangeToString)({ offset: A, count: Q }),
                tracingOptions: E.tracingOptions,
              }),
            );
            return (0, H4.rangeResponseFromModel)(C);
          },
        )
      );
    }
    async listPageRangesDiffSegment(A, Q, B, I, E = {}) {
      return BA.tracingClient.withSpan(
        "PageBlobClient-getPageRangesDiffSegment",
        E,
        async (C) => {
          return (0, y.assertResponse)(
            await this.pageBlobContext.getPageRangesDiff({
              abortSignal: E?.abortSignal,
              leaseAccessConditions: E?.conditions,
              modifiedAccessConditions: {
                ...E?.conditions,
                ifTags: E?.conditions?.tagConditions,
              },
              prevsnapshot: B,
              range: (0, nB.rangeToString)({ offset: A, count: Q }),
              marker: I,
              maxPageSize: E?.maxPageSize,
              tracingOptions: C.tracingOptions,
            }),
          );
        },
      );
    }
    async *listPageRangeDiffItemSegments(A, Q, B, I, E) {
      let C;
      if (!!I || I === void 0)
        do
          (C = await this.listPageRangesDiffSegment(A, Q, B, I, E)),
            (I = C.continuationToken),
            yield await C;
        while (I);
    }
    async *listPageRangeDiffItems(A, Q, B, I) {
      let E;
      for await (let C of this.listPageRangeDiffItemSegments(A, Q, B, E, I))
        yield* (0, y.ExtractPageRangeInfoItems)(C);
    }
    listPageRangesDiff(A, Q, B, I = {}) {
      I.conditions = I.conditions || {};
      let E = this.listPageRangeDiffItems(A, Q, B, { ...I });
      return {
        next() {
          return E.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (C = {}) => {
          return this.listPageRangeDiffItemSegments(
            A,
            Q,
            B,
            C.continuationToken,
            { maxPageSize: C.maxPageSize, ...I },
          );
        },
      };
    }
    async getPageRangesDiffForManagedDisks(A, Q, B, I = {}) {
      return (
        (I.conditions = I.conditions || {}),
        BA.tracingClient.withSpan(
          "PageBlobClient-GetPageRangesDiffForManagedDisks",
          I,
          async (E) => {
            let C = (0, y.assertResponse)(
              await this.pageBlobContext.getPageRangesDiff({
                abortSignal: I.abortSignal,
                leaseAccessConditions: I.conditions,
                modifiedAccessConditions: {
                  ...I.conditions,
                  ifTags: I.conditions?.tagConditions,
                },
                prevSnapshotUrl: B,
                range: (0, nB.rangeToString)({ offset: A, count: Q }),
                tracingOptions: E.tracingOptions,
              }),
            );
            return (0, H4.rangeResponseFromModel)(C);
          },
        )
      );
    }
    async resize(A, Q = {}) {
      return (
        (Q.conditions = Q.conditions || {}),
        BA.tracingClient.withSpan("PageBlobClient-resize", Q, async (B) => {
          return (0, y.assertResponse)(
            await this.pageBlobContext.resize(A, {
              abortSignal: Q.abortSignal,
              leaseAccessConditions: Q.conditions,
              modifiedAccessConditions: {
                ...Q.conditions,
                ifTags: Q.conditions?.tagConditions,
              },
              encryptionScope: Q.encryptionScope,
              tracingOptions: B.tracingOptions,
            }),
          );
        })
      );
    }
    async updateSequenceNumber(A, Q, B = {}) {
      return (
        (B.conditions = B.conditions || {}),
        BA.tracingClient.withSpan(
          "PageBlobClient-updateSequenceNumber",
          B,
          async (I) => {
            return (0, y.assertResponse)(
              await this.pageBlobContext.updateSequenceNumber(A, {
                abortSignal: B.abortSignal,
                blobSequenceNumber: Q,
                leaseAccessConditions: B.conditions,
                modifiedAccessConditions: {
                  ...B.conditions,
                  ifTags: B.conditions?.tagConditions,
                },
                tracingOptions: I.tracingOptions,
              }),
            );
          },
        )
      );
    }
    async startCopyIncremental(A, Q = {}) {
      return BA.tracingClient.withSpan(
        "PageBlobClient-startCopyIncremental",
        Q,
        async (B) => {
          return (0, y.assertResponse)(
            await this.pageBlobContext.copyIncremental(A, {
              abortSignal: Q.abortSignal,
              modifiedAccessConditions: {
                ...Q.conditions,
                ifTags: Q.conditions?.tagConditions,
              },
              tracingOptions: B.tracingOptions,
            }),
          );
        },
      );
    }
  }
  tP.PageBlobClient = nN;
});
var K4 = Z((A_) => {
  Object.defineProperty(A_, "__esModule", { value: !0 });
  A_.getBodyAsText = Y7A;
  A_.utf8ByteLength = J7A;
  var F7A = $4(),
    D7A = KQ();
  async function Y7A(A) {
    let Q = Buffer.alloc(D7A.BATCH_MAX_PAYLOAD_IN_BYTES),
      B = await (0, F7A.streamToBuffer2)(A.readableStreamBody, Q);
    return (Q = Q.slice(0, B)), Q.toString();
  }
  function J7A(A) {
    return Buffer.byteLength(A);
  }
});
var g_ = Z((E_) => {
  Object.defineProperty(E_, "__esModule", { value: !0 });
  E_.BatchResponseParser = void 0;
  var U7A = HQ(),
    W7A = WN(),
    xg = KQ(),
    Z7A = K4(),
    X7A = $g(),
    oN = ": ",
    Q_ = " ",
    B_ = -1;
  class I_ {
    batchResponse;
    responseBatchBoundary;
    perResponsePrefix;
    batchResponseEnding;
    subRequests;
    constructor(A, Q) {
      if (!A || !A.contentType)
        throw RangeError(
          "batchResponse is malformed or doesn't contain valid content-type.",
        );
      if (!Q || Q.size === 0)
        throw RangeError(
          "Invalid state: subRequests is not provided or size is 0.",
        );
      (this.batchResponse = A),
        (this.subRequests = Q),
        (this.responseBatchBoundary =
          this.batchResponse.contentType.split("=")[1]),
        (this.perResponsePrefix = `--${this.responseBatchBoundary}${xg.HTTP_LINE_ENDING}`),
        (this.batchResponseEnding = `--${this.responseBatchBoundary}--`);
    }
    async parseBatchResponse() {
      if (
        this.batchResponse._response.status !==
        xg.HTTPURLConnection.HTTP_ACCEPTED
      )
        throw Error(
          `Invalid state: batch request failed with status: '${this.batchResponse._response.status}'.`,
        );
      let Q = (await (0, Z7A.getBodyAsText)(this.batchResponse))
          .split(this.batchResponseEnding)[0]
          .split(this.perResponsePrefix)
          .slice(1),
        B = Q.length;
      if (B !== this.subRequests.size && B !== 1)
        throw Error(
          "Invalid state: sub responses' count is not equal to sub requests' count.",
        );
      let I = Array(B),
        E = 0,
        C = 0;
      for (let g = 0; g < B; g++) {
        let F = Q[g],
          D = {};
        D.headers = (0, W7A.toHttpHeadersLike)((0, U7A.createHttpHeaders)());
        let J = F.split(`${xg.HTTP_LINE_ENDING}`),
          Y = !1,
          N = !1,
          W = !1,
          X = B_;
        for (let M of J) {
          if (!Y) {
            if (M.startsWith(xg.HeaderConstants.CONTENT_ID))
              X = parseInt(M.split(oN)[1]);
            if (M.startsWith(xg.HTTP_VERSION_1_1)) {
              Y = !0;
              let L = M.split(Q_);
              (D.status = parseInt(L[1])),
                (D.statusMessage = L.slice(2).join(Q_));
            }
            continue;
          }
          if (M.trim() === "") {
            if (!N) N = !0;
            continue;
          }
          if (!N) {
            if (M.indexOf(oN) === -1)
              throw Error(
                `Invalid state: find non-empty line '${M}' without HTTP header delimiter '${oN}'.`,
              );
            let L = M.split(oN);
            if (
              (D.headers.set(L[0], L[1]),
              L[0] === xg.HeaderConstants.X_MS_ERROR_CODE)
            )
              (D.errorCode = L[1]), (W = !0);
          } else {
            if (!D.bodyAsText) D.bodyAsText = "";
            D.bodyAsText += M;
          }
        }
        if (
          X !== B_ &&
          Number.isInteger(X) &&
          X >= 0 &&
          X < this.subRequests.size &&
          I[X] === void 0
        )
          (D._request = this.subRequests.get(X)), (I[X] = D);
        else
          X7A.logger.error(
            `subResponses[${g}] is dropped as the Content-ID is not found or invalid, Content-ID: ${X}`,
          );
        if (W) C++;
        else E++;
      }
      return {
        subResponses: I,
        subResponsesSucceededCount: E,
        subResponsesFailedCount: C,
      };
    }
  }
  E_.BatchResponseParser = I_;
});
var J_ = Z((D_) => {
  Object.defineProperty(D_, "__esModule", { value: !0 });
  D_.Mutex = void 0;
  var vg;
  (function (A) {
    (A[(A.LOCKED = 0)] = "LOCKED"), (A[(A.UNLOCKED = 1)] = "UNLOCKED");
  })(vg || (vg = {}));
  class F_ {
    static async lock(A) {
      return new Promise((Q) => {
        if (this.keys[A] === void 0 || this.keys[A] === vg.UNLOCKED)
          (this.keys[A] = vg.LOCKED), Q();
        else
          this.onUnlockEvent(A, () => {
            (this.keys[A] = vg.LOCKED), Q();
          });
      });
    }
    static async unlock(A) {
      return new Promise((Q) => {
        if (this.keys[A] === vg.LOCKED) this.emitUnlockEvent(A);
        delete this.keys[A], Q();
      });
    }
    static keys = {};
    static listeners = {};
    static onUnlockEvent(A, Q) {
      if (this.listeners[A] === void 0) this.listeners[A] = [Q];
      else this.listeners[A].push(Q);
    }
    static emitUnlockEvent(A) {
      if (this.listeners[A] !== void 0 && this.listeners[A].length > 0) {
        let Q = this.listeners[A].shift();
        setImmediate(() => {
          Q.call(this);
        });
      }
    }
  }
  D_.Mutex = F_;
});
var j4 = Z((M_) => {
  Object.defineProperty(M_, "__esModule", { value: !0 });
  M_.BlobBatch = void 0;
  var w7A = lA(),
    z4 = Rg(),
    T4 = HQ(),
    N_ = lA(),
    G_ = DC(),
    sN = aN(),
    U_ = J_(),
    M7A = GC(),
    O4 = yQ(),
    L7A = DX(),
    UB = KQ(),
    q4 = FC(),
    W_ = I0(),
    Z_ = oI(),
    R7A = iX();
  class X_ {
    batchRequest;
    batch = "batch";
    batchType;
    constructor() {
      this.batchRequest = new w_();
    }
    getMultiPartContentType() {
      return this.batchRequest.getMultipartContentType();
    }
    getHttpRequestBody() {
      return this.batchRequest.getHttpRequestBody();
    }
    getSubRequests() {
      return this.batchRequest.getSubRequests();
    }
    async addSubRequestInternal(A, Q) {
      await U_.Mutex.lock(this.batch);
      try {
        this.batchRequest.preAddSubRequest(A),
          await Q(),
          this.batchRequest.postAddSubRequest(A);
      } finally {
        await U_.Mutex.unlock(this.batch);
      }
    }
    setBatchType(A) {
      if (!this.batchType) this.batchType = A;
      if (this.batchType !== A)
        throw RangeError(
          `BlobBatch only supports one operation type per batch and it already is being used for ${this.batchType} operations.`,
        );
    }
    async deleteBlob(A, Q, B) {
      let I, E;
      if (
        typeof A === "string" &&
        ((N_.isNodeLike && Q instanceof q4.StorageSharedKeyCredential) ||
          Q instanceof G_.AnonymousCredential ||
          (0, z4.isTokenCredential)(Q))
      )
        (I = A), (E = Q);
      else if (A instanceof sN.BlobClient)
        (I = A.url), (E = A.credential), (B = Q);
      else
        throw RangeError(
          "Invalid arguments. Either url and credential, or BlobClient need be provided.",
        );
      if (!B) B = {};
      return W_.tracingClient.withSpan(
        "BatchDeleteRequest-addSubRequest",
        B,
        async (C) => {
          this.setBatchType("delete"),
            await this.addSubRequestInternal(
              { url: I, credential: E },
              async () => {
                await new sN.BlobClient(
                  I,
                  this.batchRequest.createPipeline(E),
                ).delete(C);
              },
            );
        },
      );
    }
    async setBlobAccessTier(A, Q, B, I) {
      let E, C, g;
      if (
        typeof A === "string" &&
        ((N_.isNodeLike && Q instanceof q4.StorageSharedKeyCredential) ||
          Q instanceof G_.AnonymousCredential ||
          (0, z4.isTokenCredential)(Q))
      )
        (E = A), (C = Q), (g = B);
      else if (A instanceof sN.BlobClient)
        (E = A.url), (C = A.credential), (g = Q), (I = B);
      else
        throw RangeError(
          "Invalid arguments. Either url and credential, or BlobClient need be provided.",
        );
      if (!I) I = {};
      return W_.tracingClient.withSpan(
        "BatchSetTierRequest-addSubRequest",
        I,
        async (F) => {
          this.setBatchType("setAccessTier"),
            await this.addSubRequestInternal(
              { url: E, credential: C },
              async () => {
                await new sN.BlobClient(
                  E,
                  this.batchRequest.createPipeline(C),
                ).setAccessTier(g, F);
              },
            );
        },
      );
    }
  }
  M_.BlobBatch = X_;
  class w_ {
    operationCount;
    body;
    subRequests;
    boundary;
    subRequestPrefix;
    multipartContentType;
    batchRequestEnding;
    constructor() {
      (this.operationCount = 0), (this.body = "");
      let A = (0, w7A.randomUUID)();
      (this.boundary = `batch_${A}`),
        (this.subRequestPrefix = `--${this.boundary}${UB.HTTP_LINE_ENDING}${UB.HeaderConstants.CONTENT_TYPE}: application/http${UB.HTTP_LINE_ENDING}${UB.HeaderConstants.CONTENT_TRANSFER_ENCODING}: binary`),
        (this.multipartContentType = `multipart/mixed; boundary=${this.boundary}`),
        (this.batchRequestEnding = `--${this.boundary}--`),
        (this.subRequests = new Map());
    }
    createPipeline(A) {
      let Q = (0, T4.createEmptyPipeline)();
      if (
        (Q.addPolicy(
          (0, Z_.serializationPolicy)({
            stringifyXML: L7A.stringifyXML,
            serializerOptions: { xml: { xmlCharKey: "#" } },
          }),
          { phase: "Serialize" },
        ),
        Q.addPolicy($7A()),
        Q.addPolicy(V7A(this), { afterPhase: "Sign" }),
        (0, z4.isTokenCredential)(A))
      )
        Q.addPolicy(
          (0, T4.bearerTokenAuthenticationPolicy)({
            credential: A,
            scopes: UB.StorageOAuthScopes,
            challengeCallbacks: {
              authorizeRequestOnChallenge: Z_.authorizeRequestOnTenantChallenge,
            },
          }),
          { phase: "Sign" },
        );
      else if (A instanceof q4.StorageSharedKeyCredential)
        Q.addPolicy(
          (0, R7A.storageSharedKeyCredentialPolicy)({
            accountName: A.accountName,
            accountKey: A.accountKey,
          }),
          { phase: "Sign" },
        );
      let B = new M7A.Pipeline([]);
      return (B._credential = A), (B._corePipeline = Q), B;
    }
    appendSubRequestToBody(A) {
      this.body += [
        this.subRequestPrefix,
        `${UB.HeaderConstants.CONTENT_ID}: ${this.operationCount}`,
        "",
        `${A.method.toString()} ${(0, O4.getURLPathAndQuery)(A.url)} ${UB.HTTP_VERSION_1_1}${UB.HTTP_LINE_ENDING}`,
      ].join(UB.HTTP_LINE_ENDING);
      for (let [Q, B] of A.headers)
        this.body += `${Q}: ${B}${UB.HTTP_LINE_ENDING}`;
      this.body += UB.HTTP_LINE_ENDING;
    }
    preAddSubRequest(A) {
      if (this.operationCount >= UB.BATCH_MAX_REQUEST)
        throw RangeError(
          `Cannot exceed ${UB.BATCH_MAX_REQUEST} sub requests in a single batch`,
        );
      let Q = (0, O4.getURLPath)(A.url);
      if (!Q || Q === "")
        throw RangeError(`Invalid url for sub request: '${A.url}'`);
    }
    postAddSubRequest(A) {
      this.subRequests.set(this.operationCount, A), this.operationCount++;
    }
    getHttpRequestBody() {
      return `${this.body}${this.batchRequestEnding}${UB.HTTP_LINE_ENDING}`;
    }
    getMultipartContentType() {
      return this.multipartContentType;
    }
    getSubRequests() {
      return this.subRequests;
    }
  }
  function V7A(A) {
    return {
      name: "batchRequestAssemblePolicy",
      async sendRequest(Q) {
        return (
          A.appendSubRequestToBody(Q),
          { request: Q, status: 200, headers: (0, T4.createHttpHeaders)() }
        );
      },
    };
  }
  function $7A() {
    return {
      name: "batchHeaderFilterPolicy",
      async sendRequest(A, Q) {
        let B = "";
        for (let [I] of A.headers)
          if ((0, O4.iEqual)(I, UB.HeaderConstants.X_MS_VERSION)) B = I;
        if (B !== "") A.headers.delete(B);
        return Q(A);
      },
    };
  }
});
var tN = Z(($_) => {
  Object.defineProperty($_, "__esModule", { value: !0 });
  $_.BlobBatchClient = void 0;
  var H7A = g_(),
    K7A = K4(),
    f4 = j4(),
    z7A = I0(),
    T7A = DC(),
    O7A = F4(),
    rN = GC(),
    R_ = yQ();
  class V_ {
    serviceOrContainerContext;
    constructor(A, Q, B) {
      let I;
      if ((0, rN.isPipelineLike)(Q)) I = Q;
      else if (!Q) I = (0, rN.newPipeline)(new T7A.AnonymousCredential(), B);
      else I = (0, rN.newPipeline)(Q, B);
      let E = new O7A.StorageContextClient(A, (0, rN.getCoreClientOptions)(I)),
        C = (0, R_.getURLPath)(A);
      if (C && C !== "/") this.serviceOrContainerContext = E.container;
      else this.serviceOrContainerContext = E.service;
    }
    createBatch() {
      return new f4.BlobBatch();
    }
    async deleteBlobs(A, Q, B) {
      let I = new f4.BlobBatch();
      for (let E of A)
        if (typeof E === "string") await I.deleteBlob(E, Q, B);
        else await I.deleteBlob(E, Q);
      return this.submitBatch(I);
    }
    async setBlobsAccessTier(A, Q, B, I) {
      let E = new f4.BlobBatch();
      for (let C of A)
        if (typeof C === "string") await E.setBlobAccessTier(C, Q, B, I);
        else await E.setBlobAccessTier(C, Q, B);
      return this.submitBatch(E);
    }
    async submitBatch(A, Q = {}) {
      if (!A || A.getSubRequests().size === 0)
        throw RangeError(
          "Batch request should contain one or more sub requests.",
        );
      return z7A.tracingClient.withSpan(
        "BlobBatchClient-submitBatch",
        Q,
        async (B) => {
          let I = A.getHttpRequestBody(),
            E = (0, R_.assertResponse)(
              await this.serviceOrContainerContext.submitBatch(
                (0, K7A.utf8ByteLength)(I),
                A.getMultiPartContentType(),
                I,
                { ...B },
              ),
            ),
            g = await new H7A.BatchResponseParser(
              E,
              A.getSubRequests(),
            ).parseBatchResponse();
          return {
            _response: E._response,
            contentType: E.contentType,
            errorCode: E.errorCode,
            requestId: E.requestId,
            clientRequestId: E.clientRequestId,
            version: E.version,
            subResponses: g.subResponses,
            subResponsesSucceededCount: g.subResponsesSucceededCount,
            subResponsesFailedCount: g.subResponsesFailedCount,
          };
        },
      );
    }
  }
  $_.BlobBatchClient = V_;
});
var k4 = Z((T_) => {
  Object.defineProperty(T_, "__esModule", { value: !0 });
  T_.ContainerClient = void 0;
  var q7A = HQ(),
    K_ = lA(),
    j7A = Rg(),
    h4 = DC(),
    eN = FC(),
    RD = GC(),
    f7A = ON(),
    WB = I0(),
    wA = yQ(),
    AG = xN(),
    h7A = PN(),
    QG = aN(),
    k7A = tN();
  class z_ extends f7A.StorageClient {
    containerContext;
    _containerName;
    get containerName() {
      return this._containerName;
    }
    constructor(A, Q, B) {
      let I, E;
      if (((B = B || {}), (0, RD.isPipelineLike)(Q))) (E = A), (I = Q);
      else if (
        (K_.isNodeLike && Q instanceof eN.StorageSharedKeyCredential) ||
        Q instanceof h4.AnonymousCredential ||
        (0, j7A.isTokenCredential)(Q)
      )
        (E = A), (I = (0, RD.newPipeline)(Q, B));
      else if (!Q && typeof Q !== "string")
        (E = A), (I = (0, RD.newPipeline)(new h4.AnonymousCredential(), B));
      else if (Q && typeof Q === "string") {
        let C = Q,
          g = (0, wA.extractConnectionStringParts)(A);
        if (g.kind === "AccountConnString")
          if (K_.isNodeLike) {
            let F = new eN.StorageSharedKeyCredential(
              g.accountName,
              g.accountKey,
            );
            if (
              ((E = (0, wA.appendToURLPath)(g.url, encodeURIComponent(C))),
              !B.proxyOptions)
            )
              B.proxyOptions = (0, q7A.getDefaultProxySettings)(g.proxyUri);
            I = (0, RD.newPipeline)(F, B);
          } else
            throw Error(
              "Account connection string is only supported in Node.js environment",
            );
        else if (g.kind === "SASConnString")
          (E =
            (0, wA.appendToURLPath)(g.url, encodeURIComponent(C)) +
            "?" +
            g.accountSas),
            (I = (0, RD.newPipeline)(new h4.AnonymousCredential(), B));
        else
          throw Error(
            "Connection string must be either an Account connection string or a SAS connection string",
          );
      } else
        throw Error("Expecting non-empty strings for containerName parameter");
      super(E, I);
      (this._containerName = this.getContainerNameFromUrl()),
        (this.containerContext = this.storageClientContext.container);
    }
    async create(A = {}) {
      return WB.tracingClient.withSpan(
        "ContainerClient-create",
        A,
        async (Q) => {
          return (0, wA.assertResponse)(await this.containerContext.create(Q));
        },
      );
    }
    async createIfNotExists(A = {}) {
      return WB.tracingClient.withSpan(
        "ContainerClient-createIfNotExists",
        A,
        async (Q) => {
          try {
            let B = await this.create(Q);
            return { succeeded: !0, ...B, _response: B._response };
          } catch (B) {
            if (B.details?.errorCode === "ContainerAlreadyExists")
              return {
                succeeded: !1,
                ...B.response?.parsedHeaders,
                _response: B.response,
              };
            else throw B;
          }
        },
      );
    }
    async exists(A = {}) {
      return WB.tracingClient.withSpan(
        "ContainerClient-exists",
        A,
        async (Q) => {
          try {
            return (
              await this.getProperties({
                abortSignal: A.abortSignal,
                tracingOptions: Q.tracingOptions,
              }),
              !0
            );
          } catch (B) {
            if (B.statusCode === 404) return !1;
            throw B;
          }
        },
      );
    }
    getBlobClient(A) {
      return new QG.BlobClient(
        (0, wA.appendToURLPath)(this.url, (0, wA.EscapePath)(A)),
        this.pipeline,
      );
    }
    getAppendBlobClient(A) {
      return new QG.AppendBlobClient(
        (0, wA.appendToURLPath)(this.url, (0, wA.EscapePath)(A)),
        this.pipeline,
      );
    }
    getBlockBlobClient(A) {
      return new QG.BlockBlobClient(
        (0, wA.appendToURLPath)(this.url, (0, wA.EscapePath)(A)),
        this.pipeline,
      );
    }
    getPageBlobClient(A) {
      return new QG.PageBlobClient(
        (0, wA.appendToURLPath)(this.url, (0, wA.EscapePath)(A)),
        this.pipeline,
      );
    }
    async getProperties(A = {}) {
      if (!A.conditions) A.conditions = {};
      return WB.tracingClient.withSpan(
        "ContainerClient-getProperties",
        A,
        async (Q) => {
          return (0, wA.assertResponse)(
            await this.containerContext.getProperties({
              abortSignal: A.abortSignal,
              ...A.conditions,
              tracingOptions: Q.tracingOptions,
            }),
          );
        },
      );
    }
    async delete(A = {}) {
      if (!A.conditions) A.conditions = {};
      return WB.tracingClient.withSpan(
        "ContainerClient-delete",
        A,
        async (Q) => {
          return (0, wA.assertResponse)(
            await this.containerContext.delete({
              abortSignal: A.abortSignal,
              leaseAccessConditions: A.conditions,
              modifiedAccessConditions: A.conditions,
              tracingOptions: Q.tracingOptions,
            }),
          );
        },
      );
    }
    async deleteIfExists(A = {}) {
      return WB.tracingClient.withSpan(
        "ContainerClient-deleteIfExists",
        A,
        async (Q) => {
          try {
            let B = await this.delete(Q);
            return { succeeded: !0, ...B, _response: B._response };
          } catch (B) {
            if (B.details?.errorCode === "ContainerNotFound")
              return {
                succeeded: !1,
                ...B.response?.parsedHeaders,
                _response: B.response,
              };
            throw B;
          }
        },
      );
    }
    async setMetadata(A, Q = {}) {
      if (!Q.conditions) Q.conditions = {};
      if (Q.conditions.ifUnmodifiedSince)
        throw RangeError(
          "the IfUnmodifiedSince must have their default values because they are ignored by the blob service",
        );
      return WB.tracingClient.withSpan(
        "ContainerClient-setMetadata",
        Q,
        async (B) => {
          return (0, wA.assertResponse)(
            await this.containerContext.setMetadata({
              abortSignal: Q.abortSignal,
              leaseAccessConditions: Q.conditions,
              metadata: A,
              modifiedAccessConditions: Q.conditions,
              tracingOptions: B.tracingOptions,
            }),
          );
        },
      );
    }
    async getAccessPolicy(A = {}) {
      if (!A.conditions) A.conditions = {};
      return WB.tracingClient.withSpan(
        "ContainerClient-getAccessPolicy",
        A,
        async (Q) => {
          let B = (0, wA.assertResponse)(
              await this.containerContext.getAccessPolicy({
                abortSignal: A.abortSignal,
                leaseAccessConditions: A.conditions,
                tracingOptions: Q.tracingOptions,
              }),
            ),
            I = {
              _response: B._response,
              blobPublicAccess: B.blobPublicAccess,
              date: B.date,
              etag: B.etag,
              errorCode: B.errorCode,
              lastModified: B.lastModified,
              requestId: B.requestId,
              clientRequestId: B.clientRequestId,
              signedIdentifiers: [],
              version: B.version,
            };
          for (let E of B) {
            let C = void 0;
            if (E.accessPolicy) {
              if (
                ((C = { permissions: E.accessPolicy.permissions }),
                E.accessPolicy.expiresOn)
              )
                C.expiresOn = new Date(E.accessPolicy.expiresOn);
              if (E.accessPolicy.startsOn)
                C.startsOn = new Date(E.accessPolicy.startsOn);
            }
            I.signedIdentifiers.push({ accessPolicy: C, id: E.id });
          }
          return I;
        },
      );
    }
    async setAccessPolicy(A, Q, B = {}) {
      return (
        (B.conditions = B.conditions || {}),
        WB.tracingClient.withSpan(
          "ContainerClient-setAccessPolicy",
          B,
          async (I) => {
            let E = [];
            for (let C of Q || [])
              E.push({
                accessPolicy: {
                  expiresOn: C.accessPolicy.expiresOn
                    ? (0, wA.truncatedISO8061Date)(C.accessPolicy.expiresOn)
                    : "",
                  permissions: C.accessPolicy.permissions,
                  startsOn: C.accessPolicy.startsOn
                    ? (0, wA.truncatedISO8061Date)(C.accessPolicy.startsOn)
                    : "",
                },
                id: C.id,
              });
            return (0, wA.assertResponse)(
              await this.containerContext.setAccessPolicy({
                abortSignal: B.abortSignal,
                access: A,
                containerAcl: E,
                leaseAccessConditions: B.conditions,
                modifiedAccessConditions: B.conditions,
                tracingOptions: I.tracingOptions,
              }),
            );
          },
        )
      );
    }
    getBlobLeaseClient(A) {
      return new h7A.BlobLeaseClient(this, A);
    }
    async uploadBlockBlob(A, Q, B, I = {}) {
      return WB.tracingClient.withSpan(
        "ContainerClient-uploadBlockBlob",
        I,
        async (E) => {
          let C = this.getBlockBlobClient(A),
            g = await C.upload(Q, B, E);
          return { blockBlobClient: C, response: g };
        },
      );
    }
    async deleteBlob(A, Q = {}) {
      return WB.tracingClient.withSpan(
        "ContainerClient-deleteBlob",
        Q,
        async (B) => {
          let I = this.getBlobClient(A);
          if (Q.versionId) I = I.withVersion(Q.versionId);
          return I.delete(B);
        },
      );
    }
    async listBlobFlatSegment(A, Q = {}) {
      return WB.tracingClient.withSpan(
        "ContainerClient-listBlobFlatSegment",
        Q,
        async (B) => {
          let I = (0, wA.assertResponse)(
            await this.containerContext.listBlobFlatSegment({
              marker: A,
              ...Q,
              tracingOptions: B.tracingOptions,
            }),
          );
          return {
            ...I,
            _response: {
              ...I._response,
              parsedBody: (0, wA.ConvertInternalResponseOfListBlobFlat)(
                I._response.parsedBody,
              ),
            },
            segment: {
              ...I.segment,
              blobItems: I.segment.blobItems.map((C) => {
                return {
                  ...C,
                  name: (0, wA.BlobNameToString)(C.name),
                  tags: (0, wA.toTags)(C.blobTags),
                  objectReplicationSourceProperties: (0,
                  wA.parseObjectReplicationRecord)(C.objectReplicationMetadata),
                };
              }),
            },
          };
        },
      );
    }
    async listBlobHierarchySegment(A, Q, B = {}) {
      return WB.tracingClient.withSpan(
        "ContainerClient-listBlobHierarchySegment",
        B,
        async (I) => {
          let E = (0, wA.assertResponse)(
            await this.containerContext.listBlobHierarchySegment(A, {
              marker: Q,
              ...B,
              tracingOptions: I.tracingOptions,
            }),
          );
          return {
            ...E,
            _response: {
              ...E._response,
              parsedBody: (0, wA.ConvertInternalResponseOfListBlobHierarchy)(
                E._response.parsedBody,
              ),
            },
            segment: {
              ...E.segment,
              blobItems: E.segment.blobItems.map((g) => {
                return {
                  ...g,
                  name: (0, wA.BlobNameToString)(g.name),
                  tags: (0, wA.toTags)(g.blobTags),
                  objectReplicationSourceProperties: (0,
                  wA.parseObjectReplicationRecord)(g.objectReplicationMetadata),
                };
              }),
              blobPrefixes: E.segment.blobPrefixes?.map((g) => {
                return { ...g, name: (0, wA.BlobNameToString)(g.name) };
              }),
            },
          };
        },
      );
    }
    async *listSegments(A, Q = {}) {
      let B;
      if (!!A || A === void 0)
        do
          (B = await this.listBlobFlatSegment(A, Q)),
            (A = B.continuationToken),
            yield await B;
        while (A);
    }
    async *listItems(A = {}) {
      let Q;
      for await (let B of this.listSegments(Q, A)) yield* B.segment.blobItems;
    }
    listBlobsFlat(A = {}) {
      let Q = [];
      if (A.includeCopy) Q.push("copy");
      if (A.includeDeleted) Q.push("deleted");
      if (A.includeMetadata) Q.push("metadata");
      if (A.includeSnapshots) Q.push("snapshots");
      if (A.includeVersions) Q.push("versions");
      if (A.includeUncommitedBlobs) Q.push("uncommittedblobs");
      if (A.includeTags) Q.push("tags");
      if (A.includeDeletedWithVersions) Q.push("deletedwithversions");
      if (A.includeImmutabilityPolicy) Q.push("immutabilitypolicy");
      if (A.includeLegalHold) Q.push("legalhold");
      if (A.prefix === "") A.prefix = void 0;
      let B = { ...A, ...(Q.length > 0 ? { include: Q } : {}) },
        I = this.listItems(B);
      return {
        next() {
          return I.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (E = {}) => {
          return this.listSegments(E.continuationToken, {
            maxPageSize: E.maxPageSize,
            ...B,
          });
        },
      };
    }
    async *listHierarchySegments(A, Q, B = {}) {
      let I;
      if (!!Q || Q === void 0)
        do
          (I = await this.listBlobHierarchySegment(A, Q, B)),
            (Q = I.continuationToken),
            yield await I;
        while (Q);
    }
    async *listItemsByHierarchy(A, Q = {}) {
      let B;
      for await (let I of this.listHierarchySegments(A, B, Q)) {
        let E = I.segment;
        if (E.blobPrefixes)
          for (let C of E.blobPrefixes) yield { kind: "prefix", ...C };
        for (let C of E.blobItems) yield { kind: "blob", ...C };
      }
    }
    listBlobsByHierarchy(A, Q = {}) {
      if (A === "")
        throw RangeError("delimiter should contain one or more characters");
      let B = [];
      if (Q.includeCopy) B.push("copy");
      if (Q.includeDeleted) B.push("deleted");
      if (Q.includeMetadata) B.push("metadata");
      if (Q.includeSnapshots) B.push("snapshots");
      if (Q.includeVersions) B.push("versions");
      if (Q.includeUncommitedBlobs) B.push("uncommittedblobs");
      if (Q.includeTags) B.push("tags");
      if (Q.includeDeletedWithVersions) B.push("deletedwithversions");
      if (Q.includeImmutabilityPolicy) B.push("immutabilitypolicy");
      if (Q.includeLegalHold) B.push("legalhold");
      if (Q.prefix === "") Q.prefix = void 0;
      let I = { ...Q, ...(B.length > 0 ? { include: B } : {}) },
        E = this.listItemsByHierarchy(A, I);
      return {
        async next() {
          return E.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (C = {}) => {
          return this.listHierarchySegments(A, C.continuationToken, {
            maxPageSize: C.maxPageSize,
            ...I,
          });
        },
      };
    }
    async findBlobsByTagsSegment(A, Q, B = {}) {
      return WB.tracingClient.withSpan(
        "ContainerClient-findBlobsByTagsSegment",
        B,
        async (I) => {
          let E = (0, wA.assertResponse)(
            await this.containerContext.filterBlobs({
              abortSignal: B.abortSignal,
              where: A,
              marker: Q,
              maxPageSize: B.maxPageSize,
              tracingOptions: I.tracingOptions,
            }),
          );
          return {
            ...E,
            _response: E._response,
            blobs: E.blobs.map((g) => {
              let F = "";
              if (g.tags?.blobTagSet.length === 1)
                F = g.tags.blobTagSet[0].value;
              return { ...g, tags: (0, wA.toTags)(g.tags), tagValue: F };
            }),
          };
        },
      );
    }
    async *findBlobsByTagsSegments(A, Q, B = {}) {
      let I;
      if (!!Q || Q === void 0)
        do
          (I = await this.findBlobsByTagsSegment(A, Q, B)),
            (I.blobs = I.blobs || []),
            (Q = I.continuationToken),
            yield I;
        while (Q);
    }
    async *findBlobsByTagsItems(A, Q = {}) {
      let B;
      for await (let I of this.findBlobsByTagsSegments(A, B, Q)) yield* I.blobs;
    }
    findBlobsByTags(A, Q = {}) {
      let B = { ...Q },
        I = this.findBlobsByTagsItems(A, B);
      return {
        next() {
          return I.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (E = {}) => {
          return this.findBlobsByTagsSegments(A, E.continuationToken, {
            maxPageSize: E.maxPageSize,
            ...B,
          });
        },
      };
    }
    async getAccountInfo(A = {}) {
      return WB.tracingClient.withSpan(
        "ContainerClient-getAccountInfo",
        A,
        async (Q) => {
          return (0, wA.assertResponse)(
            await this.containerContext.getAccountInfo({
              abortSignal: A.abortSignal,
              tracingOptions: Q.tracingOptions,
            }),
          );
        },
      );
    }
    getContainerNameFromUrl() {
      let A;
      try {
        let Q = new URL(this.url);
        if (Q.hostname.split(".")[1] === "blob") A = Q.pathname.split("/")[1];
        else if ((0, wA.isIpEndpointStyle)(Q)) A = Q.pathname.split("/")[2];
        else A = Q.pathname.split("/")[1];
        if (((A = decodeURIComponent(A)), !A))
          throw Error("Provided containerName is invalid.");
        return A;
      } catch (Q) {
        throw Error(
          "Unable to extract containerName with provided information.",
        );
      }
    }
    generateSasUrl(A) {
      return new Promise((Q) => {
        if (!(this.credential instanceof eN.StorageSharedKeyCredential))
          throw RangeError(
            "Can only generate the SAS when the client is initialized with a shared key credential",
          );
        let B = (0, AG.generateBlobSASQueryParameters)(
          { containerName: this._containerName, ...A },
          this.credential,
        ).toString();
        Q((0, wA.appendToURLQuery)(this.url, B));
      });
    }
    generateSasStringToSign(A) {
      if (!(this.credential instanceof eN.StorageSharedKeyCredential))
        throw RangeError(
          "Can only generate the SAS when the client is initialized with a shared key credential",
        );
      return (0, AG.generateBlobSASQueryParametersInternal)(
        { containerName: this._containerName, ...A },
        this.credential,
      ).stringToSign;
    }
    generateUserDelegationSasUrl(A, Q) {
      return new Promise((B) => {
        let I = (0, AG.generateBlobSASQueryParameters)(
          { containerName: this._containerName, ...A },
          Q,
          this.accountName,
        ).toString();
        B((0, wA.appendToURLQuery)(this.url, I));
      });
    }
    generateUserDelegationSasStringToSign(A, Q) {
      return (0, AG.generateBlobSASQueryParametersInternal)(
        { containerName: this._containerName, ...A },
        Q,
        this.accountName,
      ).stringToSign;
    }
    getBlobBatchClient() {
      return new k7A.BlobBatchClient(this.url, this.pipeline);
    }
  }
  T_.ContainerClient = z_;
});
var IG = Z((q_) => {
  Object.defineProperty(q_, "__esModule", { value: !0 });
  q_.AccountSASPermissions = void 0;
  class BG {
    static parse(A) {
      let Q = new BG();
      for (let B of A)
        switch (B) {
          case "r":
            Q.read = !0;
            break;
          case "w":
            Q.write = !0;
            break;
          case "d":
            Q.delete = !0;
            break;
          case "x":
            Q.deleteVersion = !0;
            break;
          case "l":
            Q.list = !0;
            break;
          case "a":
            Q.add = !0;
            break;
          case "c":
            Q.create = !0;
            break;
          case "u":
            Q.update = !0;
            break;
          case "p":
            Q.process = !0;
            break;
          case "t":
            Q.tag = !0;
            break;
          case "f":
            Q.filter = !0;
            break;
          case "i":
            Q.setImmutabilityPolicy = !0;
            break;
          case "y":
            Q.permanentDelete = !0;
            break;
          default:
            throw RangeError(`Invalid permission character: ${B}`);
        }
      return Q;
    }
    static from(A) {
      let Q = new BG();
      if (A.read) Q.read = !0;
      if (A.write) Q.write = !0;
      if (A.delete) Q.delete = !0;
      if (A.deleteVersion) Q.deleteVersion = !0;
      if (A.filter) Q.filter = !0;
      if (A.tag) Q.tag = !0;
      if (A.list) Q.list = !0;
      if (A.add) Q.add = !0;
      if (A.create) Q.create = !0;
      if (A.update) Q.update = !0;
      if (A.process) Q.process = !0;
      if (A.setImmutabilityPolicy) Q.setImmutabilityPolicy = !0;
      if (A.permanentDelete) Q.permanentDelete = !0;
      return Q;
    }
    read = !1;
    write = !1;
    delete = !1;
    deleteVersion = !1;
    list = !1;
    add = !1;
    create = !1;
    update = !1;
    process = !1;
    tag = !1;
    filter = !1;
    setImmutabilityPolicy = !1;
    permanentDelete = !1;
    toString() {
      let A = [];
      if (this.read) A.push("r");
      if (this.write) A.push("w");
      if (this.delete) A.push("d");
      if (this.deleteVersion) A.push("x");
      if (this.filter) A.push("f");
      if (this.tag) A.push("t");
      if (this.list) A.push("l");
      if (this.add) A.push("a");
      if (this.create) A.push("c");
      if (this.update) A.push("u");
      if (this.process) A.push("p");
      if (this.setImmutabilityPolicy) A.push("i");
      if (this.permanentDelete) A.push("y");
      return A.join("");
    }
  }
  q_.AccountSASPermissions = BG;
});
var v4 = Z((f_) => {
  Object.defineProperty(f_, "__esModule", { value: !0 });
  f_.AccountSASResourceTypes = void 0;
  class x4 {
    static parse(A) {
      let Q = new x4();
      for (let B of A)
        switch (B) {
          case "s":
            Q.service = !0;
            break;
          case "c":
            Q.container = !0;
            break;
          case "o":
            Q.object = !0;
            break;
          default:
            throw RangeError(`Invalid resource type: ${B}`);
        }
      return Q;
    }
    service = !1;
    container = !1;
    object = !1;
    toString() {
      let A = [];
      if (this.service) A.push("s");
      if (this.container) A.push("c");
      if (this.object) A.push("o");
      return A.join("");
    }
  }
  f_.AccountSASResourceTypes = x4;
});
var EG = Z((k_) => {
  Object.defineProperty(k_, "__esModule", { value: !0 });
  k_.AccountSASServices = void 0;
  class P4 {
    static parse(A) {
      let Q = new P4();
      for (let B of A)
        switch (B) {
          case "b":
            Q.blob = !0;
            break;
          case "f":
            Q.file = !0;
            break;
          case "q":
            Q.queue = !0;
            break;
          case "t":
            Q.table = !0;
            break;
          default:
            throw RangeError(`Invalid service character: ${B}`);
        }
      return Q;
    }
    blob = !1;
    file = !1;
    queue = !1;
    table = !1;
    toString() {
      let A = [];
      if (this.blob) A.push("b");
      if (this.table) A.push("t");
      if (this.queue) A.push("q");
      if (this.file) A.push("f");
      return A.join("");
    }
  }
  k_.AccountSASServices = P4;
});
var _4 = Z((__) => {
  Object.defineProperty(__, "__esModule", { value: !0 });
  __.generateAccountSASQueryParameters = S7A;
  __.generateAccountSASQueryParametersInternal = P_;
  var x7A = IG(),
    v7A = v4(),
    P7A = EG(),
    v_ = fN(),
    _7A = kN(),
    y7A = KQ(),
    CG = yQ();
  function S7A(A, Q) {
    return P_(A, Q).sasQueryParameters;
  }
  function P_(A, Q) {
    let B = A.version ? A.version : y7A.SERVICE_VERSION;
    if (
      A.permissions &&
      A.permissions.setImmutabilityPolicy &&
      B < "2020-08-04"
    )
      throw RangeError(
        "'version' must be >= '2020-08-04' when provided 'i' permission.",
      );
    if (A.permissions && A.permissions.deleteVersion && B < "2019-10-10")
      throw RangeError(
        "'version' must be >= '2019-10-10' when provided 'x' permission.",
      );
    if (A.permissions && A.permissions.permanentDelete && B < "2019-10-10")
      throw RangeError(
        "'version' must be >= '2019-10-10' when provided 'y' permission.",
      );
    if (A.permissions && A.permissions.tag && B < "2019-12-12")
      throw RangeError(
        "'version' must be >= '2019-12-12' when provided 't' permission.",
      );
    if (A.permissions && A.permissions.filter && B < "2019-12-12")
      throw RangeError(
        "'version' must be >= '2019-12-12' when provided 'f' permission.",
      );
    if (A.encryptionScope && B < "2020-12-06")
      throw RangeError(
        "'version' must be >= '2020-12-06' when provided 'encryptionScope' in SAS.",
      );
    let I = x7A.AccountSASPermissions.parse(A.permissions.toString()),
      E = P7A.AccountSASServices.parse(A.services).toString(),
      C = v7A.AccountSASResourceTypes.parse(A.resourceTypes).toString(),
      g;
    if (B >= "2020-12-06")
      g = [
        Q.accountName,
        I,
        E,
        C,
        A.startsOn ? (0, CG.truncatedISO8061Date)(A.startsOn, !1) : "",
        (0, CG.truncatedISO8061Date)(A.expiresOn, !1),
        A.ipRange ? (0, v_.ipRangeToString)(A.ipRange) : "",
        A.protocol ? A.protocol : "",
        B,
        A.encryptionScope ? A.encryptionScope : "",
        "",
      ].join(`
`);
    else
      g = [
        Q.accountName,
        I,
        E,
        C,
        A.startsOn ? (0, CG.truncatedISO8061Date)(A.startsOn, !1) : "",
        (0, CG.truncatedISO8061Date)(A.expiresOn, !1),
        A.ipRange ? (0, v_.ipRangeToString)(A.ipRange) : "",
        A.protocol ? A.protocol : "",
        B,
        "",
      ].join(`
`);
    let F = Q.computeHMACSHA256(g);
    return {
      sasQueryParameters: new _7A.SASQueryParameters(
        B,
        F,
        I.toString(),
        E,
        C,
        A.protocol,
        A.startsOn,
        A.expiresOn,
        A.ipRange,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        void 0,
        A.encryptionScope,
      ),
      stringToSign: g,
    };
  }
});
var u_ = Z((d_) => {
  Object.defineProperty(d_, "__esModule", { value: !0 });
  d_.BlobServiceClient = void 0;
  var d7A = Rg(),
    c7A = HQ(),
    y_ = lA(),
    VD = GC(),
    u7A = k4(),
    gG = yQ(),
    FG = FC(),
    y4 = DC(),
    eI = yQ(),
    AE = I0(),
    l7A = tN(),
    p7A = ON(),
    S_ = IG(),
    b_ = _4(),
    m_ = EG();
  class DG extends p7A.StorageClient {
    serviceContext;
    static fromConnectionString(A, Q) {
      Q = Q || {};
      let B = (0, gG.extractConnectionStringParts)(A);
      if (B.kind === "AccountConnString")
        if (y_.isNodeLike) {
          let I = new FG.StorageSharedKeyCredential(
            B.accountName,
            B.accountKey,
          );
          if (!Q.proxyOptions)
            Q.proxyOptions = (0, c7A.getDefaultProxySettings)(B.proxyUri);
          let E = (0, VD.newPipeline)(I, Q);
          return new DG(B.url, E);
        } else
          throw Error(
            "Account connection string is only supported in Node.js environment",
          );
      else if (B.kind === "SASConnString") {
        let I = (0, VD.newPipeline)(new y4.AnonymousCredential(), Q);
        return new DG(B.url + "?" + B.accountSas, I);
      } else
        throw Error(
          "Connection string must be either an Account connection string or a SAS connection string",
        );
    }
    constructor(A, Q, B) {
      let I;
      if ((0, VD.isPipelineLike)(Q)) I = Q;
      else if (
        (y_.isNodeLike && Q instanceof FG.StorageSharedKeyCredential) ||
        Q instanceof y4.AnonymousCredential ||
        (0, d7A.isTokenCredential)(Q)
      )
        I = (0, VD.newPipeline)(Q, B);
      else I = (0, VD.newPipeline)(new y4.AnonymousCredential(), B);
      super(A, I);
      this.serviceContext = this.storageClientContext.service;
    }
    getContainerClient(A) {
      return new u7A.ContainerClient(
        (0, gG.appendToURLPath)(this.url, encodeURIComponent(A)),
        this.pipeline,
      );
    }
    async createContainer(A, Q = {}) {
      return AE.tracingClient.withSpan(
        "BlobServiceClient-createContainer",
        Q,
        async (B) => {
          let I = this.getContainerClient(A),
            E = await I.create(B);
          return { containerClient: I, containerCreateResponse: E };
        },
      );
    }
    async deleteContainer(A, Q = {}) {
      return AE.tracingClient.withSpan(
        "BlobServiceClient-deleteContainer",
        Q,
        async (B) => {
          return this.getContainerClient(A).delete(B);
        },
      );
    }
    async undeleteContainer(A, Q, B = {}) {
      return AE.tracingClient.withSpan(
        "BlobServiceClient-undeleteContainer",
        B,
        async (I) => {
          let E = this.getContainerClient(B.destinationContainerName || A),
            C = E.storageClientContext.container,
            g = (0, eI.assertResponse)(
              await C.restore({
                deletedContainerName: A,
                deletedContainerVersion: Q,
                tracingOptions: I.tracingOptions,
              }),
            );
          return { containerClient: E, containerUndeleteResponse: g };
        },
      );
    }
    async getProperties(A = {}) {
      return AE.tracingClient.withSpan(
        "BlobServiceClient-getProperties",
        A,
        async (Q) => {
          return (0, eI.assertResponse)(
            await this.serviceContext.getProperties({
              abortSignal: A.abortSignal,
              tracingOptions: Q.tracingOptions,
            }),
          );
        },
      );
    }
    async setProperties(A, Q = {}) {
      return AE.tracingClient.withSpan(
        "BlobServiceClient-setProperties",
        Q,
        async (B) => {
          return (0, eI.assertResponse)(
            await this.serviceContext.setProperties(A, {
              abortSignal: Q.abortSignal,
              tracingOptions: B.tracingOptions,
            }),
          );
        },
      );
    }
    async getStatistics(A = {}) {
      return AE.tracingClient.withSpan(
        "BlobServiceClient-getStatistics",
        A,
        async (Q) => {
          return (0, eI.assertResponse)(
            await this.serviceContext.getStatistics({
              abortSignal: A.abortSignal,
              tracingOptions: Q.tracingOptions,
            }),
          );
        },
      );
    }
    async getAccountInfo(A = {}) {
      return AE.tracingClient.withSpan(
        "BlobServiceClient-getAccountInfo",
        A,
        async (Q) => {
          return (0, eI.assertResponse)(
            await this.serviceContext.getAccountInfo({
              abortSignal: A.abortSignal,
              tracingOptions: Q.tracingOptions,
            }),
          );
        },
      );
    }
    async listContainersSegment(A, Q = {}) {
      return AE.tracingClient.withSpan(
        "BlobServiceClient-listContainersSegment",
        Q,
        async (B) => {
          return (0, eI.assertResponse)(
            await this.serviceContext.listContainersSegment({
              abortSignal: Q.abortSignal,
              marker: A,
              ...Q,
              include: typeof Q.include === "string" ? [Q.include] : Q.include,
              tracingOptions: B.tracingOptions,
            }),
          );
        },
      );
    }
    async findBlobsByTagsSegment(A, Q, B = {}) {
      return AE.tracingClient.withSpan(
        "BlobServiceClient-findBlobsByTagsSegment",
        B,
        async (I) => {
          let E = (0, eI.assertResponse)(
            await this.serviceContext.filterBlobs({
              abortSignal: B.abortSignal,
              where: A,
              marker: Q,
              maxPageSize: B.maxPageSize,
              tracingOptions: I.tracingOptions,
            }),
          );
          return {
            ...E,
            _response: E._response,
            blobs: E.blobs.map((g) => {
              let F = "";
              if (g.tags?.blobTagSet.length === 1)
                F = g.tags.blobTagSet[0].value;
              return { ...g, tags: (0, gG.toTags)(g.tags), tagValue: F };
            }),
          };
        },
      );
    }
    async *findBlobsByTagsSegments(A, Q, B = {}) {
      let I;
      if (!!Q || Q === void 0)
        do
          (I = await this.findBlobsByTagsSegment(A, Q, B)),
            (I.blobs = I.blobs || []),
            (Q = I.continuationToken),
            yield I;
        while (Q);
    }
    async *findBlobsByTagsItems(A, Q = {}) {
      let B;
      for await (let I of this.findBlobsByTagsSegments(A, B, Q)) yield* I.blobs;
    }
    findBlobsByTags(A, Q = {}) {
      let B = { ...Q },
        I = this.findBlobsByTagsItems(A, B);
      return {
        next() {
          return I.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (E = {}) => {
          return this.findBlobsByTagsSegments(A, E.continuationToken, {
            maxPageSize: E.maxPageSize,
            ...B,
          });
        },
      };
    }
    async *listSegments(A, Q = {}) {
      let B;
      if (!!A || A === void 0)
        do
          (B = await this.listContainersSegment(A, Q)),
            (B.containerItems = B.containerItems || []),
            (A = B.continuationToken),
            yield await B;
        while (A);
    }
    async *listItems(A = {}) {
      let Q;
      for await (let B of this.listSegments(Q, A)) yield* B.containerItems;
    }
    listContainers(A = {}) {
      if (A.prefix === "") A.prefix = void 0;
      let Q = [];
      if (A.includeDeleted) Q.push("deleted");
      if (A.includeMetadata) Q.push("metadata");
      if (A.includeSystem) Q.push("system");
      let B = { ...A, ...(Q.length > 0 ? { include: Q } : {}) },
        I = this.listItems(B);
      return {
        next() {
          return I.next();
        },
        [Symbol.asyncIterator]() {
          return this;
        },
        byPage: (E = {}) => {
          return this.listSegments(E.continuationToken, {
            maxPageSize: E.maxPageSize,
            ...B,
          });
        },
      };
    }
    async getUserDelegationKey(A, Q, B = {}) {
      return AE.tracingClient.withSpan(
        "BlobServiceClient-getUserDelegationKey",
        B,
        async (I) => {
          let E = (0, eI.assertResponse)(
              await this.serviceContext.getUserDelegationKey(
                {
                  startsOn: (0, eI.truncatedISO8061Date)(A, !1),
                  expiresOn: (0, eI.truncatedISO8061Date)(Q, !1),
                },
                {
                  abortSignal: B.abortSignal,
                  tracingOptions: I.tracingOptions,
                },
              ),
            ),
            C = {
              signedObjectId: E.signedObjectId,
              signedTenantId: E.signedTenantId,
              signedStartsOn: new Date(E.signedStartsOn),
              signedExpiresOn: new Date(E.signedExpiresOn),
              signedService: E.signedService,
              signedVersion: E.signedVersion,
              value: E.value,
            };
          return {
            _response: E._response,
            requestId: E.requestId,
            clientRequestId: E.clientRequestId,
            version: E.version,
            date: E.date,
            errorCode: E.errorCode,
            ...C,
          };
        },
      );
    }
    getBlobBatchClient() {
      return new l7A.BlobBatchClient(this.url, this.pipeline);
    }
    generateAccountSasUrl(
      A,
      Q = S_.AccountSASPermissions.parse("r"),
      B = "sco",
      I = {},
    ) {
      if (!(this.credential instanceof FG.StorageSharedKeyCredential))
        throw RangeError(
          "Can only generate the account SAS when the client is initialized with a shared key credential",
        );
      if (A === void 0) A = new Date(new Date().getTime() + 3600000);
      let E = (0, b_.generateAccountSASQueryParameters)(
        {
          permissions: Q,
          expiresOn: A,
          resourceTypes: B,
          services: m_.AccountSASServices.parse("b").toString(),
          ...I,
        },
        this.credential,
      ).toString();
      return (0, gG.appendToURLQuery)(this.url, E);
    }
    generateSasStringToSign(
      A,
      Q = S_.AccountSASPermissions.parse("r"),
      B = "sco",
      I = {},
    ) {
      if (!(this.credential instanceof FG.StorageSharedKeyCredential))
        throw RangeError(
          "Can only generate the account SAS when the client is initialized with a shared key credential",
        );
      if (A === void 0) A = new Date(new Date().getTime() + 3600000);
      return (0, b_.generateAccountSASQueryParametersInternal)(
        {
          permissions: Q,
          expiresOn: A,
          resourceTypes: B,
          services: m_.AccountSASServices.parse("b").toString(),
          ...I,
        },
        this.credential,
      ).stringToSign;
    }
  }
  d_.BlobServiceClient = DG;
});
var p_ = Z((l_) => {
  Object.defineProperty(l_, "__esModule", { value: !0 });
});
var o_ = Z((n_) => {
  Object.defineProperty(n_, "__esModule", { value: !0 });
  n_.KnownEncryptionAlgorithmType = void 0;
  var i_;
  (function (A) {
    A.AES256 = "AES256";
  })(i_ || (n_.KnownEncryptionAlgorithmType = i_ = {}));
});
var s_ = Z((ZA) => {
  Object.defineProperty(ZA, "__esModule", { value: !0 });
  ZA.logger =
    ZA.RestError =
    ZA.BaseRequestPolicy =
    ZA.StorageOAuthScopes =
    ZA.newPipeline =
    ZA.isPipelineLike =
    ZA.Pipeline =
    ZA.getBlobServiceAccountAudience =
    ZA.StorageBlobAudience =
    ZA.PremiumPageBlobTier =
    ZA.BlockBlobTier =
    ZA.generateBlobSASQueryParameters =
    ZA.generateAccountSASQueryParameters =
      void 0;
  var DQ = BQ(),
    i7A = HQ();
  Object.defineProperty(ZA, "RestError", {
    enumerable: !0,
    get: function () {
      return i7A.RestError;
    },
  });
  DQ.__exportStar(u_(), ZA);
  DQ.__exportStar(aN(), ZA);
  DQ.__exportStar(k4(), ZA);
  DQ.__exportStar(PN(), ZA);
  DQ.__exportStar(IG(), ZA);
  DQ.__exportStar(v4(), ZA);
  DQ.__exportStar(EG(), ZA);
  var n7A = _4();
  Object.defineProperty(ZA, "generateAccountSASQueryParameters", {
    enumerable: !0,
    get: function () {
      return n7A.generateAccountSASQueryParameters;
    },
  });
  DQ.__exportStar(j4(), ZA);
  DQ.__exportStar(tN(), ZA);
  DQ.__exportStar(p_(), ZA);
  DQ.__exportStar(D4(), ZA);
  var a7A = xN();
  Object.defineProperty(ZA, "generateBlobSASQueryParameters", {
    enumerable: !0,
    get: function () {
      return a7A.generateBlobSASQueryParameters;
    },
  });
  DQ.__exportStar(oX(), ZA);
  DQ.__exportStar(Y4(), ZA);
  DQ.__exportStar(DC(), ZA);
  DQ.__exportStar(MN(), ZA);
  DQ.__exportStar(FC(), ZA);
  var YG = N4();
  Object.defineProperty(ZA, "BlockBlobTier", {
    enumerable: !0,
    get: function () {
      return YG.BlockBlobTier;
    },
  });
  Object.defineProperty(ZA, "PremiumPageBlobTier", {
    enumerable: !0,
    get: function () {
      return YG.PremiumPageBlobTier;
    },
  });
  Object.defineProperty(ZA, "StorageBlobAudience", {
    enumerable: !0,
    get: function () {
      return YG.StorageBlobAudience;
    },
  });
  Object.defineProperty(ZA, "getBlobServiceAccountAudience", {
    enumerable: !0,
    get: function () {
      return YG.getBlobServiceAccountAudience;
    },
  });
  var JG = GC();
  Object.defineProperty(ZA, "Pipeline", {
    enumerable: !0,
    get: function () {
      return JG.Pipeline;
    },
  });
  Object.defineProperty(ZA, "isPipelineLike", {
    enumerable: !0,
    get: function () {
      return JG.isPipelineLike;
    },
  });
  Object.defineProperty(ZA, "newPipeline", {
    enumerable: !0,
    get: function () {
      return JG.newPipeline;
    },
  });
  Object.defineProperty(ZA, "StorageOAuthScopes", {
    enumerable: !0,
    get: function () {
      return JG.StorageOAuthScopes;
    },
  });
  DQ.__exportStar(ND(), ZA);
  var o7A = JD();
  Object.defineProperty(ZA, "BaseRequestPolicy", {
    enumerable: !0,
    get: function () {
      return o7A.BaseRequestPolicy;
    },
  });
  DQ.__exportStar(XX(), ZA);
  DQ.__exportStar(wN(), ZA);
  DQ.__exportStar(ND(), ZA);
  DQ.__exportStar(ZX(), ZA);
  DQ.__exportStar(kN(), ZA);
  DQ.__exportStar(o_(), ZA);
  var s7A = $g();
  Object.defineProperty(ZA, "logger", {
    enumerable: !0,
    get: function () {
      return s7A.logger;
    },
  });
});
var b4 = Z((ZQ) => {
  var t7A =
      (ZQ && ZQ.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            var E = Object.getOwnPropertyDescriptor(Q, B);
            if (
              !E ||
              ("get" in E ? !Q.__esModule : E.writable || E.configurable)
            )
              E = {
                enumerable: !0,
                get: function () {
                  return Q[B];
                },
              };
            Object.defineProperty(A, I, E);
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    e7A =
      (ZQ && ZQ.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    ARA =
      (ZQ && ZQ.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.prototype.hasOwnProperty.call(A, B))
              t7A(Q, A, B);
        }
        return e7A(Q, A), Q;
      },
    GG =
      (ZQ && ZQ.__awaiter) ||
      function (A, Q, B, I) {
        function E(C) {
          return C instanceof B
            ? C
            : new B(function (g) {
                g(C);
              });
        }
        return new (B || (B = Promise))(function (C, g) {
          function F(Y) {
            try {
              J(I.next(Y));
            } catch (N) {
              g(N);
            }
          }
          function D(Y) {
            try {
              J(I.throw(Y));
            } catch (N) {
              g(N);
            }
          }
          function J(Y) {
            Y.done ? C(Y.value) : E(Y.value).then(F, D);
          }
          J((I = I.apply(A, Q || [])).next());
        });
      };
  Object.defineProperty(ZQ, "__esModule", { value: !0 });
  ZQ.retryHttpClientResponse =
    ZQ.retryTypedResponse =
    ZQ.retry =
    ZQ.isRetryableStatusCode =
    ZQ.isServerErrorStatusCode =
    ZQ.isSuccessStatusCode =
      void 0;
  var r_ = ARA($B()),
    NG = OF(),
    Pg = bF();
  function QRA(A) {
    if (!A) return !1;
    return A >= 200 && A < 300;
  }
  ZQ.isSuccessStatusCode = QRA;
  function t_(A) {
    if (!A) return !0;
    return A >= 500;
  }
  ZQ.isServerErrorStatusCode = t_;
  function e_(A) {
    if (!A) return !1;
    return [
      NG.HttpCodes.BadGateway,
      NG.HttpCodes.ServiceUnavailable,
      NG.HttpCodes.GatewayTimeout,
    ].includes(A);
  }
  ZQ.isRetryableStatusCode = e_;
  function BRA(A) {
    return GG(this, void 0, void 0, function* () {
      return new Promise((Q) => setTimeout(Q, A));
    });
  }
  function S4(
    A,
    Q,
    B,
    I = Pg.DefaultRetryAttempts,
    E = Pg.DefaultRetryDelay,
    C = void 0,
  ) {
    return GG(this, void 0, void 0, function* () {
      let g = "",
        F = 1;
      while (F <= I) {
        let D = void 0,
          J = void 0,
          Y = !1;
        try {
          D = yield Q();
        } catch (N) {
          if (C) D = C(N);
          (Y = !0), (g = N.message);
        }
        if (D) {
          if (((J = B(D)), !t_(J))) return D;
        }
        if (J) (Y = e_(J)), (g = `Cache service responded with ${J}`);
        if (
          (r_.debug(`${A} - Attempt ${F} of ${I} failed with error: ${g}`), !Y)
        ) {
          r_.debug(`${A} - Error is not retryable`);
          break;
        }
        yield BRA(E), F++;
      }
      throw Error(`${A} failed: ${g}`);
    });
  }
  ZQ.retry = S4;
  function IRA(A, Q, B = Pg.DefaultRetryAttempts, I = Pg.DefaultRetryDelay) {
    return GG(this, void 0, void 0, function* () {
      return yield S4(
        A,
        Q,
        (E) => E.statusCode,
        B,
        I,
        (E) => {
          if (E instanceof NG.HttpClientError)
            return {
              statusCode: E.statusCode,
              result: null,
              headers: {},
              error: E,
            };
          else return;
        },
      );
    });
  }
  ZQ.retryTypedResponse = IRA;
  function ERA(A, Q, B = Pg.DefaultRetryAttempts, I = Pg.DefaultRetryDelay) {
    return GG(this, void 0, void 0, function* () {
      return yield S4(A, Q, (E) => E.message.statusCode, B, I);
    });
  }
  ZQ.retryHttpClientResponse = ERA;
});
var Ey = Z((Iy) => {
  Object.defineProperty(Iy, "__esModule", { value: !0 });
  var _g = new WeakMap(),
    UG = new WeakMap();
  class $D {
    constructor() {
      (this.onabort = null), _g.set(this, []), UG.set(this, !1);
    }
    get aborted() {
      if (!UG.has(this))
        throw TypeError("Expected `this` to be an instance of AbortSignal.");
      return UG.get(this);
    }
    static get none() {
      return new $D();
    }
    addEventListener(A, Q) {
      if (!_g.has(this))
        throw TypeError("Expected `this` to be an instance of AbortSignal.");
      _g.get(this).push(Q);
    }
    removeEventListener(A, Q) {
      if (!_g.has(this))
        throw TypeError("Expected `this` to be an instance of AbortSignal.");
      let B = _g.get(this),
        I = B.indexOf(Q);
      if (I > -1) B.splice(I, 1);
    }
    dispatchEvent(A) {
      throw Error(
        "This is a stub dispatchEvent implementation that should not be used.  It only exists for type-checking purposes.",
      );
    }
  }
  function Ay(A) {
    if (A.aborted) return;
    if (A.onabort) A.onabort.call(A);
    let Q = _g.get(A);
    if (Q)
      Q.slice().forEach((B) => {
        B.call(A, { type: "abort" });
      });
    UG.set(A, !0);
  }
  class Qy extends Error {
    constructor(A) {
      super(A);
      this.name = "AbortError";
    }
  }
  class By {
    constructor(A) {
      if (((this._signal = new $D()), !A)) return;
      if (!Array.isArray(A)) A = arguments;
      for (let Q of A)
        if (Q.aborted) this.abort();
        else
          Q.addEventListener("abort", () => {
            this.abort();
          });
    }
    get signal() {
      return this._signal;
    }
    abort() {
      Ay(this._signal);
    }
    static timeout(A) {
      let Q = new $D(),
        B = setTimeout(Ay, A, Q);
      if (typeof B.unref === "function") B.unref();
      return Q;
    }
  }
  Iy.AbortController = By;
  Iy.AbortError = Qy;
  Iy.AbortSignal = $D;
});
var Yy = Z((dQ) => {
  var DRA =
      (dQ && dQ.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            var E = Object.getOwnPropertyDescriptor(Q, B);
            if (
              !E ||
              ("get" in E ? !Q.__esModule : E.writable || E.configurable)
            )
              E = {
                enumerable: !0,
                get: function () {
                  return Q[B];
                },
              };
            Object.defineProperty(A, I, E);
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    YRA =
      (dQ && dQ.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    yg =
      (dQ && dQ.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.prototype.hasOwnProperty.call(A, B))
              DRA(Q, A, B);
        }
        return YRA(Q, A), Q;
      },
    XI =
      (dQ && dQ.__awaiter) ||
      function (A, Q, B, I) {
        function E(C) {
          return C instanceof B
            ? C
            : new B(function (g) {
                g(C);
              });
        }
        return new (B || (B = Promise))(function (C, g) {
          function F(Y) {
            try {
              J(I.next(Y));
            } catch (N) {
              g(N);
            }
          }
          function D(Y) {
            try {
              J(I.throw(Y));
            } catch (N) {
              g(N);
            }
          }
          function J(Y) {
            Y.done ? C(Y.value) : E(Y.value).then(F, D);
          }
          J((I = I.apply(A, Q || [])).next());
        });
      };
  Object.defineProperty(dQ, "__esModule", { value: !0 });
  dQ.downloadCacheStorageSDK =
    dQ.downloadCacheHttpClientConcurrent =
    dQ.downloadCacheHttpClient =
    dQ.DownloadProgress =
      void 0;
  var KD = yg($B()),
    gy = OF(),
    JRA = s_(),
    NRA = yg($("buffer")),
    HD = yg($("fs")),
    GRA = yg($("stream")),
    URA = yg($("util")),
    WRA = yg(dF()),
    Cy = bF(),
    m4 = b4(),
    ZRA = Ey();
  function XRA(A, Q) {
    return XI(this, void 0, void 0, function* () {
      yield URA.promisify(GRA.pipeline)(A.message, Q);
    });
  }
  class WG {
    constructor(A) {
      (this.contentLength = A),
        (this.segmentIndex = 0),
        (this.segmentSize = 0),
        (this.segmentOffset = 0),
        (this.receivedBytes = 0),
        (this.displayedComplete = !1),
        (this.startTime = Date.now());
    }
    nextSegment(A) {
      (this.segmentOffset = this.segmentOffset + this.segmentSize),
        (this.segmentIndex = this.segmentIndex + 1),
        (this.segmentSize = A),
        (this.receivedBytes = 0),
        KD.debug(
          `Downloading segment at offset ${this.segmentOffset} with length ${this.segmentSize}...`,
        );
    }
    setReceivedBytes(A) {
      this.receivedBytes = A;
    }
    getTransferredBytes() {
      return this.segmentOffset + this.receivedBytes;
    }
    isDone() {
      return this.getTransferredBytes() === this.contentLength;
    }
    display() {
      if (this.displayedComplete) return;
      let A = this.segmentOffset + this.receivedBytes,
        Q = (100 * (A / this.contentLength)).toFixed(1),
        B = Date.now() - this.startTime,
        I = (A / 1048576 / (B / 1000)).toFixed(1);
      if (
        (KD.info(
          `Received ${A} of ${this.contentLength} (${Q}%), ${I} MBs/sec`,
        ),
        this.isDone())
      )
        this.displayedComplete = !0;
    }
    onProgress() {
      return (A) => {
        this.setReceivedBytes(A.loadedBytes);
      };
    }
    startDisplayTimer(A = 1000) {
      let Q = () => {
        if ((this.display(), !this.isDone()))
          this.timeoutHandle = setTimeout(Q, A);
      };
      this.timeoutHandle = setTimeout(Q, A);
    }
    stopDisplayTimer() {
      if (this.timeoutHandle)
        clearTimeout(this.timeoutHandle), (this.timeoutHandle = void 0);
      this.display();
    }
  }
  dQ.DownloadProgress = WG;
  function Fy(A, Q) {
    return XI(this, void 0, void 0, function* () {
      let B = HD.createWriteStream(Q),
        I = new gy.HttpClient("actions/cache"),
        E = yield (0, m4.retryHttpClientResponse)("downloadCache", () =>
          XI(this, void 0, void 0, function* () {
            return I.get(A);
          }),
        );
      E.message.socket.setTimeout(Cy.SocketTimeout, () => {
        E.message.destroy(),
          KD.debug(
            `Aborting download, socket timed out after ${Cy.SocketTimeout} ms`,
          );
      }),
        yield XRA(E, B);
      let C = E.message.headers["content-length"];
      if (C) {
        let g = parseInt(C),
          F = WRA.getArchiveFileSizeInBytes(Q);
        if (F !== g)
          throw Error(
            `Incomplete download. Expected file size: ${g}, actual file size: ${F}`,
          );
      } else KD.debug("Unable to validate download, no Content-Length header");
    });
  }
  dQ.downloadCacheHttpClient = Fy;
  function wRA(A, Q, B) {
    var I;
    return XI(this, void 0, void 0, function* () {
      let E = yield HD.promises.open(Q, "w"),
        C = new gy.HttpClient("actions/cache", void 0, {
          socketTimeout: B.timeoutInMs,
          keepAlive: !0,
        });
      try {
        let F = (yield (0, m4.retryHttpClientResponse)(
          "downloadCacheMetadata",
          () =>
            XI(this, void 0, void 0, function* () {
              return yield C.request("HEAD", A, null, {});
            }),
        )).message.headers["content-length"];
        if (F === void 0 || F === null)
          throw Error("Content-Length not found on blob response");
        let D = parseInt(F);
        if (Number.isNaN(D))
          throw Error(`Could not interpret Content-Length: ${D}`);
        let J = [],
          Y = 4194304;
        for (let O = 0; O < D; O += Y) {
          let f = Math.min(Y, D - O);
          J.push({
            offset: O,
            promiseGetter: () =>
              XI(this, void 0, void 0, function* () {
                return yield MRA(C, A, O, f);
              }),
          });
        }
        J.reverse();
        let N = 0,
          W = 0,
          X = new WG(D);
        X.startDisplayTimer();
        let M = X.onProgress(),
          L = [],
          H,
          q = () =>
            XI(this, void 0, void 0, function* () {
              let O = yield Promise.race(Object.values(L));
              yield E.write(O.buffer, 0, O.count, O.offset),
                N--,
                delete L[O.offset],
                (W += O.count),
                M({ loadedBytes: W });
            });
        while ((H = J.pop()))
          if (
            ((L[H.offset] = H.promiseGetter()),
            N++,
            N >=
              ((I = B.downloadConcurrency) !== null && I !== void 0 ? I : 10))
          )
            yield q();
        while (N > 0) yield q();
      } finally {
        C.dispose(), yield E.close();
      }
    });
  }
  dQ.downloadCacheHttpClientConcurrent = wRA;
  function MRA(A, Q, B, I) {
    return XI(this, void 0, void 0, function* () {
      let C = 0;
      while (!0)
        try {
          let F = yield Dy(30000, LRA(A, Q, B, I));
          if (typeof F === "string")
            throw Error("downloadSegmentRetry failed due to timeout");
          return F;
        } catch (g) {
          if (C >= 5) throw g;
          C++;
        }
    });
  }
  function LRA(A, Q, B, I) {
    return XI(this, void 0, void 0, function* () {
      let E = yield (0, m4.retryHttpClientResponse)("downloadCachePart", () =>
        XI(this, void 0, void 0, function* () {
          return yield A.get(Q, { Range: `bytes=${B}-${B + I - 1}` });
        }),
      );
      if (!E.readBodyBuffer)
        throw Error("Expected HttpClientResponse to implement readBodyBuffer");
      return { offset: B, count: I, buffer: yield E.readBodyBuffer() };
    });
  }
  function RRA(A, Q, B) {
    var I;
    return XI(this, void 0, void 0, function* () {
      let E = new JRA.BlockBlobClient(A, void 0, {
          retryOptions: { tryTimeoutInMs: B.timeoutInMs },
        }),
        g =
          (I = (yield E.getProperties()).contentLength) !== null && I !== void 0
            ? I
            : -1;
      if (g < 0)
        KD.debug(
          "Unable to determine content length, downloading file with http-client...",
        ),
          yield Fy(A, Q);
      else {
        let F = Math.min(134217728, NRA.constants.MAX_LENGTH),
          D = new WG(g),
          J = HD.openSync(Q, "w");
        try {
          D.startDisplayTimer();
          let Y = new ZRA.AbortController(),
            N = Y.signal;
          while (!D.isDone()) {
            let W = D.segmentOffset + D.segmentSize,
              X = Math.min(F, g - W);
            D.nextSegment(X);
            let M = yield Dy(
              B.segmentTimeoutInMs || 3600000,
              E.downloadToBuffer(W, X, {
                abortSignal: N,
                concurrency: B.downloadConcurrency,
                onProgress: D.onProgress(),
              }),
            );
            if (M === "timeout")
              throw (
                (Y.abort(),
                Error(
                  "Aborting cache download as the download time exceeded the timeout.",
                ))
              );
            else if (Buffer.isBuffer(M)) HD.writeFileSync(J, M);
          }
        } finally {
          D.stopDisplayTimer(), HD.closeSync(J);
        }
      }
    });
  }
  dQ.downloadCacheStorageSDK = RRA;
  var Dy = (A, Q) =>
    XI(void 0, void 0, void 0, function* () {
      let B,
        I = new Promise((E) => {
          B = setTimeout(() => E("timeout"), A);
        });
      return Promise.race([Q, I]).then((E) => {
        return clearTimeout(B), E;
      });
    });
});
var Jy = Z((wI) => {
  var VRA =
      (wI && wI.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            var E = Object.getOwnPropertyDescriptor(Q, B);
            if (
              !E ||
              ("get" in E ? !Q.__esModule : E.writable || E.configurable)
            )
              E = {
                enumerable: !0,
                get: function () {
                  return Q[B];
                },
              };
            Object.defineProperty(A, I, E);
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    $RA =
      (wI && wI.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    HRA =
      (wI && wI.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.prototype.hasOwnProperty.call(A, B))
              VRA(Q, A, B);
        }
        return $RA(Q, A), Q;
      };
  Object.defineProperty(wI, "__esModule", { value: !0 });
  wI.getDownloadOptions = wI.getUploadOptions = void 0;
  var MC = HRA($B());
  function KRA(A) {
    let Q = { uploadConcurrency: 4, uploadChunkSize: 33554432 };
    if (A) {
      if (typeof A.uploadConcurrency === "number")
        Q.uploadConcurrency = A.uploadConcurrency;
      if (typeof A.uploadChunkSize === "number")
        Q.uploadChunkSize = A.uploadChunkSize;
    }
    return (
      MC.debug(`Upload concurrency: ${Q.uploadConcurrency}`),
      MC.debug(`Upload chunk size: ${Q.uploadChunkSize}`),
      Q
    );
  }
  wI.getUploadOptions = KRA;
  function zRA(A) {
    let Q = {
      useAzureSdk: !1,
      concurrentBlobDownloads: !0,
      downloadConcurrency: 8,
      timeoutInMs: 30000,
      segmentTimeoutInMs: 600000,
      lookupOnly: !1,
    };
    if (A) {
      if (typeof A.useAzureSdk === "boolean") Q.useAzureSdk = A.useAzureSdk;
      if (typeof A.concurrentBlobDownloads === "boolean")
        Q.concurrentBlobDownloads = A.concurrentBlobDownloads;
      if (typeof A.downloadConcurrency === "number")
        Q.downloadConcurrency = A.downloadConcurrency;
      if (typeof A.timeoutInMs === "number") Q.timeoutInMs = A.timeoutInMs;
      if (typeof A.segmentTimeoutInMs === "number")
        Q.segmentTimeoutInMs = A.segmentTimeoutInMs;
      if (typeof A.lookupOnly === "boolean") Q.lookupOnly = A.lookupOnly;
    }
    let B = process.env.SEGMENT_DOWNLOAD_TIMEOUT_MINS;
    if (B && !isNaN(Number(B)) && isFinite(Number(B)))
      Q.segmentTimeoutInMs = Number(B) * 60 * 1000;
    return (
      MC.debug(`Use Azure SDK: ${Q.useAzureSdk}`),
      MC.debug(`Download concurrency: ${Q.downloadConcurrency}`),
      MC.debug(`Request timeout (ms): ${Q.timeoutInMs}`),
      MC.debug(
        `Cache segment download timeout mins env var: ${process.env.SEGMENT_DOWNLOAD_TIMEOUT_MINS}`,
      ),
      MC.debug(`Segment download timeout (ms): ${Q.segmentTimeoutInMs}`),
      MC.debug(`Lookup only: ${Q.lookupOnly}`),
      Q
    );
  }
  wI.getDownloadOptions = zRA;
});
var Uy = Z((OQ) => {
  var TRA =
      (OQ && OQ.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            var E = Object.getOwnPropertyDescriptor(Q, B);
            if (
              !E ||
              ("get" in E ? !Q.__esModule : E.writable || E.configurable)
            )
              E = {
                enumerable: !0,
                get: function () {
                  return Q[B];
                },
              };
            Object.defineProperty(A, I, E);
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    ORA =
      (OQ && OQ.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    wG =
      (OQ && OQ.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.prototype.hasOwnProperty.call(A, B))
              TRA(Q, A, B);
        }
        return ORA(Q, A), Q;
      },
    vB =
      (OQ && OQ.__awaiter) ||
      function (A, Q, B, I) {
        function E(C) {
          return C instanceof B
            ? C
            : new B(function (g) {
                g(C);
              });
        }
        return new (B || (B = Promise))(function (C, g) {
          function F(Y) {
            try {
              J(I.next(Y));
            } catch (N) {
              g(N);
            }
          }
          function D(Y) {
            try {
              J(I.throw(Y));
            } catch (N) {
              g(N);
            }
          }
          function J(Y) {
            Y.done ? C(Y.value) : E(Y.value).then(F, D);
          }
          J((I = I.apply(A, Q || [])).next());
        });
      };
  Object.defineProperty(OQ, "__esModule", { value: !0 });
  OQ.saveCache =
    OQ.reserveCache =
    OQ.downloadCache =
    OQ.getCacheEntry =
    OQ.getCacheVersion =
      void 0;
  var aB = wG($B()),
    qRA = OF(),
    jRA = XZ(),
    fRA = wG($("crypto")),
    d4 = wG($("fs")),
    hRA = $("url"),
    XG = wG(dF()),
    ZG = Yy(),
    Gy = Jy(),
    LC = b4(),
    kRA = "1.0";
  function zD(A) {
    let Q = process.env.ACTIONS_CACHE_URL || "";
    if (!Q)
      throw Error("Cache Service Url not found, unable to restore cache.");
    let B = `${Q}_apis/artifactcache/${A}`;
    return aB.debug(`Resource Url: ${B}`), B;
  }
  function xRA(A, Q) {
    return `${A};api-version=${Q}`;
  }
  function vRA() {
    return { headers: { Accept: xRA("application/json", "6.0-preview.1") } };
  }
  function c4() {
    let A = process.env.ACTIONS_RUNTIME_TOKEN || "",
      Q = new jRA.BearerCredentialHandler(A);
    return new qRA.HttpClient("actions/cache", [Q], vRA());
  }
  function u4(A, Q, B = !1) {
    let I = A.slice();
    if (Q) I.push(Q);
    if (process.platform === "win32" && !B) I.push("windows-only");
    return (
      I.push(kRA), fRA.createHash("sha256").update(I.join("|")).digest("hex")
    );
  }
  OQ.getCacheVersion = u4;
  function PRA(A, Q, B) {
    return vB(this, void 0, void 0, function* () {
      let I = c4(),
        E = u4(
          Q,
          B === null || B === void 0 ? void 0 : B.compressionMethod,
          B === null || B === void 0 ? void 0 : B.enableCrossOsArchive,
        ),
        C = `cache?keys=${encodeURIComponent(A.join(","))}&version=${E}`,
        g = yield (0, LC.retryTypedResponse)("getCacheEntry", () =>
          vB(this, void 0, void 0, function* () {
            return I.getJson(zD(C));
          }),
        );
      if (g.statusCode === 204) {
        if (aB.isDebug()) yield _RA(A[0], I, E);
        return null;
      }
      if (!(0, LC.isSuccessStatusCode)(g.statusCode))
        throw Error(`Cache service responded with ${g.statusCode}`);
      let F = g.result,
        D = F === null || F === void 0 ? void 0 : F.archiveLocation;
      if (!D) throw Error("Cache not found.");
      return (
        aB.setSecret(D),
        aB.debug("Cache Result:"),
        aB.debug(JSON.stringify(F)),
        F
      );
    });
  }
  OQ.getCacheEntry = PRA;
  function _RA(A, Q, B) {
    return vB(this, void 0, void 0, function* () {
      let I = `caches?key=${encodeURIComponent(A)}`,
        E = yield (0, LC.retryTypedResponse)("listCache", () =>
          vB(this, void 0, void 0, function* () {
            return Q.getJson(zD(I));
          }),
        );
      if (E.statusCode === 200) {
        let C = E.result,
          g = C === null || C === void 0 ? void 0 : C.totalCount;
        if (g && g > 0) {
          aB.debug(`No matching cache found for cache key '${A}', version '${B} and scope ${process.env.GITHUB_REF}. There exist one or more cache(s) with similar key but they have different version or scope. See more info on cache matching here: https://docs.github.com/en/actions/using-workflows/caching-dependencies-to-speed-up-workflows#matching-a-cache-key 
Other caches with similar key:`);
          for (let F of (C === null || C === void 0
            ? void 0
            : C.artifactCaches) || [])
            aB.debug(
              `Cache Key: ${F === null || F === void 0 ? void 0 : F.cacheKey}, Cache Version: ${F === null || F === void 0 ? void 0 : F.cacheVersion}, Cache Scope: ${F === null || F === void 0 ? void 0 : F.scope}, Cache Created: ${F === null || F === void 0 ? void 0 : F.creationTime}`,
            );
        }
      }
    });
  }
  function yRA(A, Q, B) {
    return vB(this, void 0, void 0, function* () {
      let I = new hRA.URL(A),
        E = (0, Gy.getDownloadOptions)(B);
      if (I.hostname.endsWith(".blob.core.windows.net"))
        if (E.useAzureSdk) yield (0, ZG.downloadCacheStorageSDK)(A, Q, E);
        else if (E.concurrentBlobDownloads)
          yield (0, ZG.downloadCacheHttpClientConcurrent)(A, Q, E);
        else yield (0, ZG.downloadCacheHttpClient)(A, Q);
      else yield (0, ZG.downloadCacheHttpClient)(A, Q);
    });
  }
  OQ.downloadCache = yRA;
  function SRA(A, Q, B) {
    return vB(this, void 0, void 0, function* () {
      let I = c4(),
        E = u4(
          Q,
          B === null || B === void 0 ? void 0 : B.compressionMethod,
          B === null || B === void 0 ? void 0 : B.enableCrossOsArchive,
        ),
        C = {
          key: A,
          version: E,
          cacheSize: B === null || B === void 0 ? void 0 : B.cacheSize,
        };
      return yield (0, LC.retryTypedResponse)("reserveCache", () =>
        vB(this, void 0, void 0, function* () {
          return I.postJson(zD("caches"), C);
        }),
      );
    });
  }
  OQ.reserveCache = SRA;
  function Ny(A, Q) {
    return `bytes ${A}-${Q}/*`;
  }
  function bRA(A, Q, B, I, E) {
    return vB(this, void 0, void 0, function* () {
      aB.debug(
        `Uploading chunk of size ${E - I + 1} bytes at offset ${I} with content range: ${Ny(I, E)}`,
      );
      let C = {
          "Content-Type": "application/octet-stream",
          "Content-Range": Ny(I, E),
        },
        g = yield (0, LC.retryHttpClientResponse)(
          `uploadChunk (start: ${I}, end: ${E})`,
          () =>
            vB(this, void 0, void 0, function* () {
              return A.sendStream("PATCH", Q, B(), C);
            }),
        );
      if (!(0, LC.isSuccessStatusCode)(g.message.statusCode))
        throw Error(
          `Cache service responded with ${g.message.statusCode} during upload chunk.`,
        );
    });
  }
  function mRA(A, Q, B, I) {
    return vB(this, void 0, void 0, function* () {
      let E = XG.getArchiveFileSizeInBytes(B),
        C = zD(`caches/${Q.toString()}`),
        g = d4.openSync(B, "r"),
        F = (0, Gy.getUploadOptions)(I),
        D = XG.assertDefined("uploadConcurrency", F.uploadConcurrency),
        J = XG.assertDefined("uploadChunkSize", F.uploadChunkSize),
        Y = [...Array(D).keys()];
      aB.debug("Awaiting all uploads");
      let N = 0;
      try {
        yield Promise.all(
          Y.map(() =>
            vB(this, void 0, void 0, function* () {
              while (N < E) {
                let W = Math.min(E - N, J),
                  X = N,
                  M = N + W - 1;
                (N += J),
                  yield bRA(
                    A,
                    C,
                    () =>
                      d4
                        .createReadStream(B, {
                          fd: g,
                          start: X,
                          end: M,
                          autoClose: !1,
                        })
                        .on("error", (L) => {
                          throw Error(
                            `Cache upload failed because file read failed with ${L.message}`,
                          );
                        }),
                    X,
                    M,
                  );
              }
            }),
          ),
        );
      } finally {
        d4.closeSync(g);
      }
      return;
    });
  }
  function dRA(A, Q, B) {
    return vB(this, void 0, void 0, function* () {
      let I = { size: B };
      return yield (0, LC.retryTypedResponse)("commitCache", () =>
        vB(this, void 0, void 0, function* () {
          return A.postJson(zD(`caches/${Q.toString()}`), I);
        }),
      );
    });
  }
  function cRA(A, Q, B) {
    return vB(this, void 0, void 0, function* () {
      let I = c4();
      aB.debug("Upload cache"),
        yield mRA(I, A, Q, B),
        aB.debug("Commiting cache");
      let E = XG.getArchiveFileSizeInBytes(Q);
      aB.info(`Cache Size: ~${Math.round(E / 1048576)} MB (${E} B)`);
      let C = yield dRA(I, A, E);
      if (!(0, LC.isSuccessStatusCode)(C.statusCode))
        throw Error(
          `Cache service responded with ${C.statusCode} during commit cache.`,
        );
      aB.info("Cache saved successfully");
    });
  }
  OQ.saveCache = cRA;
});
var Xy = Z((IB) => {
  var uRA =
      (IB && IB.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            var E = Object.getOwnPropertyDescriptor(Q, B);
            if (
              !E ||
              ("get" in E ? !Q.__esModule : E.writable || E.configurable)
            )
              E = {
                enumerable: !0,
                get: function () {
                  return Q[B];
                },
              };
            Object.defineProperty(A, I, E);
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    lRA =
      (IB && IB.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    l4 =
      (IB && IB.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.prototype.hasOwnProperty.call(A, B))
              uRA(Q, A, B);
        }
        return lRA(Q, A), Q;
      },
    OE =
      (IB && IB.__awaiter) ||
      function (A, Q, B, I) {
        function E(C) {
          return C instanceof B
            ? C
            : new B(function (g) {
                g(C);
              });
        }
        return new (B || (B = Promise))(function (C, g) {
          function F(Y) {
            try {
              J(I.next(Y));
            } catch (N) {
              g(N);
            }
          }
          function D(Y) {
            try {
              J(I.throw(Y));
            } catch (N) {
              g(N);
            }
          }
          function J(Y) {
            Y.done ? C(Y.value) : E(Y.value).then(F, D);
          }
          J((I = I.apply(A, Q || [])).next());
        });
      };
  Object.defineProperty(IB, "__esModule", { value: !0 });
  IB.createTar = IB.extractTar = IB.listTar = void 0;
  var pRA = Qg(),
    MG = l4(qF()),
    Wy = $("fs"),
    OI = l4($("path")),
    p4 = l4(dF()),
    eA = bF(),
    RC = process.platform === "win32";
  function iRA() {
    return OE(this, void 0, void 0, function* () {
      switch (process.platform) {
        case "win32": {
          let A = yield p4.getGnuTarPathOnWindows(),
            Q = eA.SystemTarPathOnWindows;
          if (A) return { path: A, type: eA.ArchiveToolType.GNU };
          else if ((0, Wy.existsSync)(Q))
            return { path: Q, type: eA.ArchiveToolType.BSD };
          break;
        }
        case "darwin": {
          let A = yield MG.which("gtar", !1);
          if (A) return { path: A, type: eA.ArchiveToolType.GNU };
          else
            return {
              path: yield MG.which("tar", !0),
              type: eA.ArchiveToolType.BSD,
            };
        }
        default:
          break;
      }
      return { path: yield MG.which("tar", !0), type: eA.ArchiveToolType.GNU };
    });
  }
  function nRA(A, Q, B, I = "") {
    return OE(this, void 0, void 0, function* () {
      let E = [`"${A.path}"`],
        C = p4.getCacheFileName(Q),
        g = "cache.tar",
        F = Zy(),
        D =
          A.type === eA.ArchiveToolType.BSD &&
          Q !== eA.CompressionMethod.Gzip &&
          RC;
      switch (B) {
        case "create":
          E.push(
            "--posix",
            "-cf",
            D ? "cache.tar" : C.replace(new RegExp(`\\${OI.sep}`, "g"), "/"),
            "--exclude",
            D ? "cache.tar" : C.replace(new RegExp(`\\${OI.sep}`, "g"), "/"),
            "-P",
            "-C",
            F.replace(new RegExp(`\\${OI.sep}`, "g"), "/"),
            "--files-from",
            eA.ManifestFilename,
          );
          break;
        case "extract":
          E.push(
            "-xf",
            D ? "cache.tar" : I.replace(new RegExp(`\\${OI.sep}`, "g"), "/"),
            "-P",
            "-C",
            F.replace(new RegExp(`\\${OI.sep}`, "g"), "/"),
          );
          break;
        case "list":
          E.push(
            "-tf",
            D ? "cache.tar" : I.replace(new RegExp(`\\${OI.sep}`, "g"), "/"),
            "-P",
          );
          break;
      }
      if (A.type === eA.ArchiveToolType.GNU)
        switch (process.platform) {
          case "win32":
            E.push("--force-local");
            break;
          case "darwin":
            E.push("--delay-directory-restore");
            break;
        }
      return E;
    });
  }
  function i4(A, Q, B = "") {
    return OE(this, void 0, void 0, function* () {
      let I,
        E = yield iRA(),
        C = yield nRA(E, A, Q, B),
        g = Q !== "create" ? yield aRA(E, A, B) : yield oRA(E, A),
        F =
          E.type === eA.ArchiveToolType.BSD &&
          A !== eA.CompressionMethod.Gzip &&
          RC;
      if (F && Q !== "create") I = [[...g].join(" "), [...C].join(" ")];
      else I = [[...C].join(" "), [...g].join(" ")];
      if (F) return I;
      return [I.join(" ")];
    });
  }
  function Zy() {
    var A;
    return (A = process.env.GITHUB_WORKSPACE) !== null && A !== void 0
      ? A
      : process.cwd();
  }
  function aRA(A, Q, B) {
    return OE(this, void 0, void 0, function* () {
      let I =
        A.type === eA.ArchiveToolType.BSD &&
        Q !== eA.CompressionMethod.Gzip &&
        RC;
      switch (Q) {
        case eA.CompressionMethod.Zstd:
          return I
            ? [
                "zstd -d --long=30 --force -o",
                eA.TarFilename,
                B.replace(new RegExp(`\\${OI.sep}`, "g"), "/"),
              ]
            : [
                "--use-compress-program",
                RC ? '"zstd -d --long=30"' : "unzstd --long=30",
              ];
        case eA.CompressionMethod.ZstdWithoutLong:
          return I
            ? [
                "zstd -d --force -o",
                eA.TarFilename,
                B.replace(new RegExp(`\\${OI.sep}`, "g"), "/"),
              ]
            : ["--use-compress-program", RC ? '"zstd -d"' : "unzstd"];
        default:
          return ["-z"];
      }
    });
  }
  function oRA(A, Q) {
    return OE(this, void 0, void 0, function* () {
      let B = p4.getCacheFileName(Q),
        I =
          A.type === eA.ArchiveToolType.BSD &&
          Q !== eA.CompressionMethod.Gzip &&
          RC;
      switch (Q) {
        case eA.CompressionMethod.Zstd:
          return I
            ? [
                "zstd -T0 --long=30 --force -o",
                B.replace(new RegExp(`\\${OI.sep}`, "g"), "/"),
                eA.TarFilename,
              ]
            : [
                "--use-compress-program",
                RC ? '"zstd -T0 --long=30"' : "zstdmt --long=30",
              ];
        case eA.CompressionMethod.ZstdWithoutLong:
          return I
            ? [
                "zstd -T0 --force -o",
                B.replace(new RegExp(`\\${OI.sep}`, "g"), "/"),
                eA.TarFilename,
              ]
            : ["--use-compress-program", RC ? '"zstd -T0"' : "zstdmt"];
        default:
          return ["-z"];
      }
    });
  }
  function n4(A, Q) {
    return OE(this, void 0, void 0, function* () {
      for (let B of A)
        try {
          yield (0, pRA.exec)(B, void 0, {
            cwd: Q,
            env: Object.assign(Object.assign({}, process.env), {
              MSYS: "winsymlinks:nativestrict",
            }),
          });
        } catch (I) {
          throw Error(
            `${B.split(" ")[0]} failed with error: ${I === null || I === void 0 ? void 0 : I.message}`,
          );
        }
    });
  }
  function sRA(A, Q) {
    return OE(this, void 0, void 0, function* () {
      let B = yield i4(Q, "list", A);
      yield n4(B);
    });
  }
  IB.listTar = sRA;
  function rRA(A, Q) {
    return OE(this, void 0, void 0, function* () {
      let B = Zy();
      yield MG.mkdirP(B);
      let I = yield i4(Q, "extract", A);
      yield n4(I);
    });
  }
  IB.extractTar = rRA;
  function tRA(A, Q, B) {
    return OE(this, void 0, void 0, function* () {
      (0, Wy.writeFileSync)(
        OI.join(A, eA.ManifestFilename),
        Q.join(`
`),
      );
      let I = yield i4(B, "create");
      yield n4(I, A);
    });
  }
  IB.createTar = tRA;
});
var Vy = Z((qQ) => {
  var eRA =
      (qQ && qQ.__createBinding) ||
      (Object.create
        ? function (A, Q, B, I) {
            if (I === void 0) I = B;
            var E = Object.getOwnPropertyDescriptor(Q, B);
            if (
              !E ||
              ("get" in E ? !Q.__esModule : E.writable || E.configurable)
            )
              E = {
                enumerable: !0,
                get: function () {
                  return Q[B];
                },
              };
            Object.defineProperty(A, I, E);
          }
        : function (A, Q, B, I) {
            if (I === void 0) I = B;
            A[I] = Q[B];
          }),
    AVA =
      (qQ && qQ.__setModuleDefault) ||
      (Object.create
        ? function (A, Q) {
            Object.defineProperty(A, "default", { enumerable: !0, value: Q });
          }
        : function (A, Q) {
            A.default = Q;
          }),
    VG =
      (qQ && qQ.__importStar) ||
      function (A) {
        if (A && A.__esModule) return A;
        var Q = {};
        if (A != null) {
          for (var B in A)
            if (B !== "default" && Object.prototype.hasOwnProperty.call(A, B))
              eRA(Q, A, B);
        }
        return AVA(Q, A), Q;
      },
    wy =
      (qQ && qQ.__awaiter) ||
      function (A, Q, B, I) {
        function E(C) {
          return C instanceof B
            ? C
            : new B(function (g) {
                g(C);
              });
        }
        return new (B || (B = Promise))(function (C, g) {
          function F(Y) {
            try {
              J(I.next(Y));
            } catch (N) {
              g(N);
            }
          }
          function D(Y) {
            try {
              J(I.throw(Y));
            } catch (N) {
              g(N);
            }
          }
          function J(Y) {
            Y.done ? C(Y.value) : E(Y.value).then(F, D);
          }
          J((I = I.apply(A, Q || [])).next());
        });
      };
  Object.defineProperty(qQ, "__esModule", { value: !0 });
  qQ.saveCache =
    qQ.restoreCache =
    qQ.isFeatureAvailable =
    qQ.ReserveCacheError =
    qQ.ValidationError =
      void 0;
  var xQ = VG($B()),
    My = VG($("path")),
    MI = VG(dF()),
    LG = VG(Uy()),
    RG = Xy();
  class qE extends Error {
    constructor(A) {
      super(A);
      (this.name = "ValidationError"),
        Object.setPrototypeOf(this, qE.prototype);
    }
  }
  qQ.ValidationError = qE;
  class TD extends Error {
    constructor(A) {
      super(A);
      (this.name = "ReserveCacheError"),
        Object.setPrototypeOf(this, TD.prototype);
    }
  }
  qQ.ReserveCacheError = TD;
  function Ly(A) {
    if (!A || A.length === 0)
      throw new qE(
        "Path Validation Error: At least one directory or file path is required",
      );
  }
  function Ry(A) {
    if (A.length > 512)
      throw new qE(
        `Key Validation Error: ${A} cannot be larger than 512 characters.`,
      );
    if (!/^[^,]*$/.test(A))
      throw new qE(`Key Validation Error: ${A} cannot contain commas.`);
  }
  function QVA() {
    return !!process.env.ACTIONS_CACHE_URL;
  }
  qQ.isFeatureAvailable = QVA;
  function BVA(A, Q, B, I, E = !1) {
    return wy(this, void 0, void 0, function* () {
      Ly(A), (B = B || []);
      let C = [Q, ...B];
      if (
        (xQ.debug("Resolved Keys:"), xQ.debug(JSON.stringify(C)), C.length > 10)
      )
        throw new qE(
          "Key Validation Error: Keys are limited to a maximum of 10.",
        );
      for (let D of C) Ry(D);
      let g = yield MI.getCompressionMethod(),
        F = "";
      try {
        let D = yield LG.getCacheEntry(C, A, {
          compressionMethod: g,
          enableCrossOsArchive: E,
        });
        if (!(D === null || D === void 0 ? void 0 : D.archiveLocation)) return;
        if (I === null || I === void 0 ? void 0 : I.lookupOnly)
          return xQ.info("Lookup only - skipping download"), D.cacheKey;
        if (
          ((F = My.join(
            yield MI.createTempDirectory(),
            MI.getCacheFileName(g),
          )),
          xQ.debug(`Archive Path: ${F}`),
          yield LG.downloadCache(D.archiveLocation, F, I),
          xQ.isDebug())
        )
          yield (0, RG.listTar)(F, g);
        let J = MI.getArchiveFileSizeInBytes(F);
        return (
          xQ.info(`Cache Size: ~${Math.round(J / 1048576)} MB (${J} B)`),
          yield (0, RG.extractTar)(F, g),
          xQ.info("Cache restored successfully"),
          D.cacheKey
        );
      } catch (D) {
        if (D.name === qE.name) throw D;
        else xQ.warning(`Failed to restore: ${D.message}`);
      } finally {
        try {
          yield MI.unlinkFile(F);
        } catch (D) {
          xQ.debug(`Failed to delete archive: ${D}`);
        }
      }
      return;
    });
  }
  qQ.restoreCache = BVA;
  function IVA(A, Q, B, I = !1) {
    var E, C, g, F, D;
    return wy(this, void 0, void 0, function* () {
      Ly(A), Ry(Q);
      let J = yield MI.getCompressionMethod(),
        Y = -1,
        N = yield MI.resolvePaths(A);
      if (
        (xQ.debug("Cache Paths:"),
        xQ.debug(`${JSON.stringify(N)}`),
        N.length === 0)
      )
        throw Error(
          "Path Validation Error: Path(s) specified in the action for caching do(es) not exist, hence no cache is being saved.",
        );
      let W = yield MI.createTempDirectory(),
        X = My.join(W, MI.getCacheFileName(J));
      xQ.debug(`Archive Path: ${X}`);
      try {
        if ((yield (0, RG.createTar)(W, N, J), xQ.isDebug()))
          yield (0, RG.listTar)(X, J);
        let M = 10737418240,
          L = MI.getArchiveFileSizeInBytes(X);
        if ((xQ.debug(`File Size: ${L}`), L > M && !MI.isGhes()))
          throw Error(
            `Cache size of ~${Math.round(L / 1048576)} MB (${L} B) is over the 10GB limit, not saving cache.`,
          );
        xQ.debug("Reserving Cache");
        let H = yield LG.reserveCache(Q, A, {
          compressionMethod: J,
          enableCrossOsArchive: I,
          cacheSize: L,
        });
        if (
          (E = H === null || H === void 0 ? void 0 : H.result) === null ||
          E === void 0
            ? void 0
            : E.cacheId
        )
          Y =
            (C = H === null || H === void 0 ? void 0 : H.result) === null ||
            C === void 0
              ? void 0
              : C.cacheId;
        else if ((H === null || H === void 0 ? void 0 : H.statusCode) === 400)
          throw Error(
            (F =
              (g = H === null || H === void 0 ? void 0 : H.error) === null ||
              g === void 0
                ? void 0
                : g.message) !== null && F !== void 0
              ? F
              : `Cache size of ~${Math.round(L / 1048576)} MB (${L} B) is over the data cap limit, not saving cache.`,
          );
        else
          throw new TD(
            `Unable to reserve cache with key ${Q}, another job may be creating this cache. More details: ${(D = H === null || H === void 0 ? void 0 : H.error) === null || D === void 0 ? void 0 : D.message}`,
          );
        xQ.debug(`Saving Cache (ID: ${Y})`), yield LG.saveCache(Y, X, B);
      } catch (M) {
        let L = M;
        if (L.name === qE.name) throw M;
        else if (L.name === TD.name) xQ.info(`Failed to save: ${L.message}`);
        else xQ.warning(`Failed to save: ${L.message}`);
      } finally {
        try {
          yield MI.unlinkFile(X);
        } catch (M) {
          xQ.debug(`Failed to delete archive: ${M}`);
        }
      }
      return Y;
    });
  }
  qQ.saveCache = IVA;
});
var EQ = xE($B(), 1);
var uC = xE($B(), 1),
  qZ = xE(Qg(), 1),
  jR = xE(qF(), 1);
import * as jZ from "path";
import * as fR from "os";
import { promises as hR } from "fs";
function kR() {
  return jZ.join(fR.homedir(), ".local", "bin");
}
function rE() {
  return jZ.join(kR(), "claude");
}
async function fr() {
  try {
    let A = rE();
    return await hR.access(A), !0;
  } catch {
    return !1;
  }
}
async function fZ() {
  if (!(await fr())) return null;
  try {
    let A = rE(),
      Q = "";
    await qZ.exec(A, ["--version"], {
      silent: !0,
      listeners: {
        stdout: (I) => {
          Q += I.toString();
        },
      },
    });
    let B = Q.match(/claude\s+(\d+\.\d+\.\d+)/);
    return B ? B[1] : null;
  } catch (A) {
    return uC.warning(`Failed to get Claude Code version: ${A}`), null;
  }
}
async function xR(A) {
  let { version: Q } = A;
  uC.info(`Installing Claude Code version: ${Q}`);
  let B = kR();
  await jR.mkdirP(B);
  let I = "curl -fsSL https://claude.ai/install.sh",
    E =
      Q === "stable" || Q === "latest"
        ? `${I} | bash -s ${Q}`
        : `${I} | bash -s ${Q}`;
  await qZ.exec("bash", ["-c", E]);
  let C = rE();
  try {
    await hR.access(C);
  } catch {
    throw Error("Claude Code installation failed: executable not found");
  }
  let g = await fZ();
  if (!g) throw Error("Failed to verify Claude Code installation");
  return (
    uC.info(`Successfully installed Claude Code ${g}`),
    uC.addPath(B),
    { version: g, claudePath: C }
  );
}
var jE = xE($B(), 1),
  $G = xE(Vy(), 1);
import * as a4 from "path";
import * as Sg from "os";
function $y(A) {
  let Q = Sg.platform(),
    B = Sg.arch();
  if (A === "latest") {
    let I = new Date().toISOString().split("T")[0];
    return `claude-code-v2-${Q}-${B}-latest-${I}`;
  }
  return `claude-code-v2-${Q}-${B}-${A}`;
}
function Hy() {
  let A = Sg.homedir();
  return [a4.join(A, ".local", "bin", "claude"), a4.join(A, ".claude")];
}
async function Ky(A) {
  let Q = Hy(),
    B = $y(A);
  jE.info(`Attempting to restore cache with key: ${B}`);
  try {
    let I = await $G.restoreCache(Q, B);
    if (I) return jE.info(`Cache restored successfully from key: ${I}`), !0;
    else return jE.info("Cache not found"), !1;
  } catch (I) {
    return jE.warning(`Cache restoration failed: ${I}`), !1;
  }
}
async function zy(A) {
  let Q = Hy(),
    B = $y(A);
  jE.info(`Saving cache with key: ${B}`);
  try {
    await $G.saveCache(Q, B), jE.info("Cache saved successfully");
  } catch (I) {
    jE.warning(`Failed to save cache: ${I}`);
  }
}
var oB = xE($B(), 1),
  OD = xE(Qg(), 1);
var CVA = /^[@a-zA-Z0-9_\-/.]+$/,
  gVA = 512,
  FVA = /\.\.\/|\/\.\.|\.\/|\/\.|(?:^|\/)\.\.$|(?:^|\/)\.$|\.\.(?![0-9])/;
function DVA(A) {
  let Q = A.normalize("NFC");
  if (Q.length > gVA) throw Error(`Name too long: ${Q.substring(0, 50)}...`);
  if (!CVA.test(Q)) throw Error(`Invalid name format: ${A}`);
  if (FVA.test(Q))
    throw Error(`Invalid name format (path traversal detected): ${A}`);
}
function Ty(A) {
  if (!A || A.trim() === "") return [];
  return A.split(/[,\n]/)
    .map((Q) => Q.trim())
    .filter((Q) => {
      if (Q.length === 0) return !1;
      return DVA(Q), !0;
    });
}
async function YVA(A) {
  if (!A) return;
  oB.info("Configuring git credentials for plugin repositories"),
    await OD.exec("git", [
      "config",
      "--global",
      "url.https://x-access-token:" + A + "@github.com/.insteadOf",
      "git@github.com:",
    ]),
    await OD.exec("git", [
      "config",
      "--global",
      "url.https://x-access-token:" + A + "@github.com/.insteadOf",
      "ssh://git@github.com/",
    ]);
}
async function Oy(A, Q) {
  let B = Ty(A);
  if (B.length === 0) return oB.info("No marketplaces to add"), 0;
  await YVA(Q);
  let I = rE(),
    E = 0;
  for (let C of B) {
    oB.info(`Adding marketplace: ${C}`);
    try {
      await OD.exec(I, ["marketplace", "add", C]),
        E++,
        oB.info(`Successfully added marketplace: ${C}`);
    } catch (g) {
      oB.warning(`Failed to add marketplace ${C}: ${g}`);
    }
  }
  return oB.info(`Added ${E} marketplace(s)`), E;
}
async function qy(A) {
  let Q = Ty(A);
  if (Q.length === 0) return oB.info("No plugins to install"), [];
  let B = rE(),
    I = [];
  for (let E of Q) {
    oB.info(`Installing plugin: ${E}`);
    try {
      await OD.exec(B, ["plugin", "install", E]),
        I.push(E),
        oB.info(`Successfully installed plugin: ${E}`);
    } catch (C) {
      oB.warning(`Failed to install plugin ${E}: ${C}`);
    }
  }
  return oB.info(`Installed ${I.length} plugin(s)`), I;
}
async function NVA() {
  try {
    let A = EQ.getInput("version") || "stable",
      Q = EQ.getInput("github_token") || "",
      B = EQ.getInput("marketplaces") || "",
      I = EQ.getInput("plugins") || "";
    EQ.info(`Setting up Claude Code version: ${A}`);
    let E = await Ky(A);
    EQ.setOutput("cache-hit", E);
    let C, g;
    if (E) {
      EQ.info("Claude Code restored from cache");
      let J = await fZ();
      if (!J)
        throw Error(
          "Cache restoration succeeded but Claude Code is not functional",
        );
      (C = J), (g = rE());
      let Y = g.substring(0, g.lastIndexOf("/"));
      EQ.addPath(Y);
    } else {
      let J = await xR({ version: A });
      (C = J.version), (g = J.claudePath), await zy(A);
    }
    EQ.setOutput("version", C), EQ.setOutput("claude-path", g);
    let F = 0;
    if (B) F = await Oy(B, Q);
    EQ.setOutput("marketplaces_added", F);
    let D = [];
    if (I) D = await qy(I);
    EQ.setOutput("plugins_installed", D.join(",")),
      EQ.info("✓ Claude Code setup completed successfully"),
      EQ.info(`  Version: ${C}`),
      EQ.info(`  Path: ${g}`),
      EQ.info(`  Marketplaces added: ${F}`),
      EQ.info(`  Plugins installed: ${D.length}`);
  } catch (A) {
    if (A instanceof Error) EQ.setFailed(A.message);
    else EQ.setFailed(String(A));
  }
}
NVA();

//# debugId=2D53D408C0ED644164756E2164756E21
