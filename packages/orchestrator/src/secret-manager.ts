import * as k8s from '@kubernetes/client-node';
import { OrchestratorConfig, OrchestratorError, ErrorCode } from './types';

export class SecretManager {
  private coreV1Api: k8s.CoreV1Api;
  private config: OrchestratorConfig;

  constructor(coreV1Api: k8s.CoreV1Api, config: OrchestratorConfig) {
    this.coreV1Api = coreV1Api;
    this.config = config;
  }

  /**
   * Get existing password from secret or create new user credentials
   */
  async getOrCreateUserCredentials(username: string, createPostgresUser: (username: string, password: string) => Promise<void>): Promise<string> {
    const secretName = `peerbot-user-secret-${username.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase()}`;
    
    try {
      // Try to read existing secret first
      const existingSecret = await this.coreV1Api.readNamespacedSecret(secretName, this.config.kubernetes.namespace);
      const existingPassword = Buffer.from(existingSecret.body.data?.['DB_PASSWORD'] || '', 'base64').toString();
      
      if (existingPassword) {
        console.log(`Found existing secret for user ${username}, using existing credentials`);
        return existingPassword;
      }
    } catch (error) {
      // Secret doesn't exist, will create new credentials
      console.log(`Secret ${secretName} does not exist, creating new credentials`);
    }
    
    // Generate new credentials - password generated by caller
    const chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
    let password = '';
    for (let i = 0; i < 32; i++) {
      password += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    
    console.log(`Creating new credentials for user ${username}`);
    await createPostgresUser(username, password);
    await this.createUserSecret(username, password);
    return password;
  }

  /**
   * Update existing Kubernetes secret with new PostgreSQL credentials
   */
  async updateUserSecret(secretName: string, username: string, password: string): Promise<void> {
    try {
      const secretData = {
        'DATABASE_URL': Buffer.from(`postgres://${username}:${password}@peerbot-postgresql:5432/peerbot`).toString('base64'),
        'DB_USERNAME': Buffer.from(username).toString('base64'),
        'DB_PASSWORD': Buffer.from(password).toString('base64')
      };

      const secretPatch = {
        data: secretData
      };

      await this.coreV1Api.patchNamespacedSecret(secretName, this.config.kubernetes.namespace, secretPatch);
      console.log(`✅ Updated secret: ${secretName}`);
    } catch (error) {
      throw new OrchestratorError(
        ErrorCode.DEPLOYMENT_CREATE_FAILED,
        `Failed to update user secret: ${error instanceof Error ? error.message : String(error)}`,
        { username, secretName, error },
        true
      );
    }
  }

  /**
   * Create Kubernetes secret with PostgreSQL credentials
   */
  async createUserSecret(username: string, password: string): Promise<void> {
    const secretName = `peerbot-user-secret-${username.replace(/[^a-zA-Z0-9]/g, '-').toLowerCase()}`;
    
    try {
      // Check if secret already exists
      try {
        await this.coreV1Api.readNamespacedSecret(secretName, this.config.kubernetes.namespace);
        console.log(`Secret ${secretName} already exists`);
        return;
      } catch (error) {
        // Secret doesn't exist, create it
      }

      const secretData = {
        'DATABASE_URL': Buffer.from(`postgres://${username}:${password}@peerbot-postgresql:5432/peerbot`).toString('base64'),
        'DB_USERNAME': Buffer.from(username).toString('base64'),
        'DB_PASSWORD': Buffer.from(password).toString('base64')
      };

      const secret = {
        apiVersion: 'v1',
        kind: 'Secret',
        metadata: {
          name: secretName,
          namespace: this.config.kubernetes.namespace,
          labels: {
            'app.kubernetes.io/name': 'peerbot',
            'app.kubernetes.io/component': 'worker',
            'peerbot/managed-by': 'orchestrator'
          }
        },
        type: 'Opaque',
        data: secretData
      };

      await this.coreV1Api.createNamespacedSecret(this.config.kubernetes.namespace, secret);
      console.log(`✅ Created secret: ${secretName}`);
    } catch (error) {
      throw new OrchestratorError(
        ErrorCode.DEPLOYMENT_CREATE_FAILED,
        `Failed to create user secret: ${error instanceof Error ? error.message : String(error)}`,
        { username, secretName, error },
        true
      );
    }
  }
}