#!/usr/bin/env bun

/**
 * Unified entry point for the Claude action.
 *
 * This combines the prepare and run phases into a single step,
 * passing data directly in-memory instead of via files and outputs.
 */

import * as core from "@actions/core";
import { setupGitHubToken } from "../github/token";
import { checkWritePermissions } from "../github/validation/permissions";
import { createOctokit } from "../github/api/client";
import { parseGitHubContext, isEntityContext } from "../github/context";
import { getMode } from "../modes/registry";
import { prepare } from "../prepare";
import { collectActionInputsPresence } from "./collect-inputs";
import {
  runClaudeWithSdk,
  setupClaudeCodeSettings,
  installPlugins,
  parseSdkOptions,
} from "../../base-action/src/lib";

async function run() {
  try {
    // ============================================
    // PHASE 1: PREPARE
    // ============================================

    collectActionInputsPresence();

    // Parse GitHub context first to enable mode detection
    const context = parseGitHubContext();

    // Auto-detect mode based on context
    const mode = getMode(context);

    // Setup GitHub token
    const githubToken = await setupGitHubToken();
    const octokit = createOctokit(githubToken);

    // Check write permissions (only for entity contexts)
    if (isEntityContext(context)) {
      const githubTokenProvided = !!process.env.OVERRIDE_GITHUB_TOKEN;
      const hasWritePermissions = await checkWritePermissions(
        octokit.rest,
        context,
        context.inputs.allowedNonWriteUsers,
        githubTokenProvided,
      );
      if (!hasWritePermissions) {
        throw new Error(
          "Actor does not have write permissions to the repository",
        );
      }
    }

    // Check trigger conditions
    const containsTrigger = mode.shouldTrigger(context);

    // Debug logging
    console.log(`Mode: ${mode.name}`);
    console.log(`Context prompt: ${context.inputs?.prompt || "NO PROMPT"}`);
    console.log(`Trigger result: ${containsTrigger}`);

    // Set output for action.yml to check
    core.setOutput("contains_trigger", containsTrigger.toString());

    if (!containsTrigger) {
      console.log("No trigger found, skipping remaining steps");
      core.setOutput("GITHUB_TOKEN", githubToken);
      return;
    }

    // Run mode.prepare() - returns prompt, commentId, branchInfo, etc.
    const prepareResult = await prepare({
      context,
      octokit,
      mode,
      githubToken,
    });

    // Set outputs that may be needed by subsequent steps
    core.setOutput("GITHUB_TOKEN", githubToken);
    if (prepareResult.commentId) {
      core.setOutput("claude_comment_id", prepareResult.commentId.toString());
    }
    core.setOutput(
      "CLAUDE_BRANCH",
      prepareResult.branchInfo.claudeBranch || "",
    );
    core.setOutput("BASE_BRANCH", prepareResult.branchInfo.baseBranch);

    // Get system prompt from mode if available
    let appendSystemPrompt: string | undefined;
    if (mode.getSystemPrompt) {
      const modeContext = mode.prepareContext(context, {
        commentId: prepareResult.commentId,
        baseBranch: prepareResult.branchInfo.baseBranch,
        claudeBranch: prepareResult.branchInfo.claudeBranch,
      });
      appendSystemPrompt = mode.getSystemPrompt(modeContext);
    }

    // ============================================
    // PHASE 2: SETUP
    // ============================================

    // Setup Claude Code settings
    await setupClaudeCodeSettings(
      process.env.INPUT_SETTINGS,
      undefined, // homeDir
    );

    // Install Claude Code plugins if specified
    await installPlugins(
      process.env.INPUT_PLUGIN_MARKETPLACES,
      process.env.INPUT_PLUGINS,
      process.env.INPUT_PATH_TO_CLAUDE_CODE_EXECUTABLE,
    );

    // ============================================
    // PHASE 3: EXECUTE
    // ============================================

    // Get prompt content from prepare result
    const promptContent = prepareResult.promptContent;
    if (!promptContent) {
      throw new Error("No prompt content generated by prepare phase");
    }

    console.log("===== PROMPT CONTENT =====");
    console.log(`Prompt length: ${promptContent.length} chars`);
    console.log("==========================");

    // Build SDK options from environment and prepare result
    const sdkOptions = parseSdkOptions({
      claudeArgs: process.env.INPUT_CLAUDE_ARGS,
      allowedTools:
        prepareResult.allowedTools || process.env.INPUT_ALLOWED_TOOLS,
      disallowedTools:
        prepareResult.disallowedTools || process.env.INPUT_DISALLOWED_TOOLS,
      maxTurns: process.env.INPUT_MAX_TURNS,
      mcpConfig: process.env.INPUT_MCP_CONFIG,
      systemPrompt: process.env.INPUT_SYSTEM_PROMPT,
      appendSystemPrompt:
        appendSystemPrompt || process.env.INPUT_APPEND_SYSTEM_PROMPT,
      claudeEnv: process.env.INPUT_CLAUDE_ENV,
      fallbackModel: process.env.INPUT_FALLBACK_MODEL,
      model: process.env.ANTHROPIC_MODEL,
      pathToClaudeCodeExecutable:
        process.env.INPUT_PATH_TO_CLAUDE_CODE_EXECUTABLE,
      showFullOutput: process.env.INPUT_SHOW_FULL_OUTPUT,
    });

    // Run Claude with prompt string directly
    const execResult = await runClaudeWithSdk(
      { type: "string", prompt: promptContent },
      sdkOptions,
      { setOutputs: true },
    );

    // Set additional outputs
    core.setOutput("execution_file", execResult.executionFile);
    core.setOutput("conclusion", execResult.conclusion);
    if (execResult.structuredOutput) {
      core.setOutput("structured_output", execResult.structuredOutput);
    }

    if (!execResult.success) {
      core.setFailed(`Claude execution failed: ${execResult.error}`);
      process.exit(1);
    }
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    core.setFailed(`Run step failed with error: ${errorMessage}`);
    core.setOutput("prepare_error", errorMessage);
    core.setOutput("conclusion", "failure");
    process.exit(1);
  }
}

if (import.meta.main) {
  run();
}
